(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
var jsflow = {};
jsflow.Monitor = require('../out/toplevel/chrome/monitor').ChromeMonitor;

var global = (function() { return this; })();

window.jsflow = new jsflow.Monitor(global);

},{"../out/toplevel/chrome/monitor":70}],2:[function(require,module,exports){
(function (global){
/*
  Copyright (C) 2012-2014 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2015 Ingvar Stepanyan <me@rreverser.com>
  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>
  Copyright (C) 2012-2013 Michael Ficarra <escodegen.copyright@michael.ficarra.me>
  Copyright (C) 2012-2013 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2013 Irakli Gozalishvili <rfobic@gmail.com>
  Copyright (C) 2012 Robert Gust-Bardon <donate@robert.gust-bardon.org>
  Copyright (C) 2012 John Freeman <jfreeman08@gmail.com>
  Copyright (C) 2011-2012 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*global exports:true, require:true, global:true*/
(function () {
    'use strict';

    var Syntax,
        Precedence,
        BinaryPrecedence,
        SourceNode,
        estraverse,
        esutils,
        base,
        indent,
        json,
        renumber,
        hexadecimal,
        quotes,
        escapeless,
        newline,
        space,
        parentheses,
        semicolons,
        safeConcatenation,
        directive,
        extra,
        parse,
        sourceMap,
        sourceCode,
        preserveBlankLines,
        FORMAT_MINIFY,
        FORMAT_DEFAULTS;

    estraverse = require('estraverse');
    esutils = require('esutils');

    Syntax = estraverse.Syntax;

    // Generation is done by generateExpression.
    function isExpression(node) {
        return CodeGenerator.Expression.hasOwnProperty(node.type);
    }

    // Generation is done by generateStatement.
    function isStatement(node) {
        return CodeGenerator.Statement.hasOwnProperty(node.type);
    }

    Precedence = {
        Sequence: 0,
        Yield: 1,
        Await: 1,
        Assignment: 1,
        Conditional: 2,
        ArrowFunction: 2,
        LogicalOR: 3,
        LogicalAND: 4,
        BitwiseOR: 5,
        BitwiseXOR: 6,
        BitwiseAND: 7,
        Equality: 8,
        Relational: 9,
        BitwiseSHIFT: 10,
        Additive: 11,
        Multiplicative: 12,
        Unary: 13,
        Postfix: 14,
        Call: 15,
        New: 16,
        TaggedTemplate: 17,
        Member: 18,
        Primary: 19
    };

    BinaryPrecedence = {
        '||': Precedence.LogicalOR,
        '&&': Precedence.LogicalAND,
        '|': Precedence.BitwiseOR,
        '^': Precedence.BitwiseXOR,
        '&': Precedence.BitwiseAND,
        '==': Precedence.Equality,
        '!=': Precedence.Equality,
        '===': Precedence.Equality,
        '!==': Precedence.Equality,
        'is': Precedence.Equality,
        'isnt': Precedence.Equality,
        '<': Precedence.Relational,
        '>': Precedence.Relational,
        '<=': Precedence.Relational,
        '>=': Precedence.Relational,
        'in': Precedence.Relational,
        'instanceof': Precedence.Relational,
        '<<': Precedence.BitwiseSHIFT,
        '>>': Precedence.BitwiseSHIFT,
        '>>>': Precedence.BitwiseSHIFT,
        '+': Precedence.Additive,
        '-': Precedence.Additive,
        '*': Precedence.Multiplicative,
        '%': Precedence.Multiplicative,
        '/': Precedence.Multiplicative
    };

    //Flags
    var F_ALLOW_IN = 1,
        F_ALLOW_CALL = 1 << 1,
        F_ALLOW_UNPARATH_NEW = 1 << 2,
        F_FUNC_BODY = 1 << 3,
        F_DIRECTIVE_CTX = 1 << 4,
        F_SEMICOLON_OPT = 1 << 5;

    //Expression flag sets
    //NOTE: Flag order:
    // F_ALLOW_IN
    // F_ALLOW_CALL
    // F_ALLOW_UNPARATH_NEW
    var E_FTT = F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW,
        E_TTF = F_ALLOW_IN | F_ALLOW_CALL,
        E_TTT = F_ALLOW_IN | F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW,
        E_TFF = F_ALLOW_IN,
        E_FFT = F_ALLOW_UNPARATH_NEW,
        E_TFT = F_ALLOW_IN | F_ALLOW_UNPARATH_NEW;

    //Statement flag sets
    //NOTE: Flag order:
    // F_ALLOW_IN
    // F_FUNC_BODY
    // F_DIRECTIVE_CTX
    // F_SEMICOLON_OPT
    var S_TFFF = F_ALLOW_IN,
        S_TFFT = F_ALLOW_IN | F_SEMICOLON_OPT,
        S_FFFF = 0x00,
        S_TFTF = F_ALLOW_IN | F_DIRECTIVE_CTX,
        S_TTFF = F_ALLOW_IN | F_FUNC_BODY;

    function getDefaultOptions() {
        // default options
        return {
            indent: null,
            base: null,
            parse: null,
            comment: false,
            format: {
                indent: {
                    style: '    ',
                    base: 0,
                    adjustMultilineComment: false
                },
                newline: '\n',
                space: ' ',
                json: false,
                renumber: false,
                hexadecimal: false,
                quotes: 'single',
                escapeless: false,
                compact: false,
                parentheses: true,
                semicolons: true,
                safeConcatenation: false,
                preserveBlankLines: false
            },
            moz: {
                comprehensionExpressionStartsWithAssignment: false,
                starlessGenerator: false
            },
            sourceMap: null,
            sourceMapRoot: null,
            sourceMapWithCode: false,
            directive: false,
            raw: true,
            verbatim: null,
            sourceCode: null
        };
    }

    function stringRepeat(str, num) {
        var result = '';

        for (num |= 0; num > 0; num >>>= 1, str += str) {
            if (num & 1) {
                result += str;
            }
        }

        return result;
    }

    function hasLineTerminator(str) {
        return (/[\r\n]/g).test(str);
    }

    function endsWithLineTerminator(str) {
        var len = str.length;
        return len && esutils.code.isLineTerminator(str.charCodeAt(len - 1));
    }

    function merge(target, override) {
        var key;
        for (key in override) {
            if (override.hasOwnProperty(key)) {
                target[key] = override[key];
            }
        }
        return target;
    }

    function updateDeeply(target, override) {
        var key, val;

        function isHashObject(target) {
            return typeof target === 'object' && target instanceof Object && !(target instanceof RegExp);
        }

        for (key in override) {
            if (override.hasOwnProperty(key)) {
                val = override[key];
                if (isHashObject(val)) {
                    if (isHashObject(target[key])) {
                        updateDeeply(target[key], val);
                    } else {
                        target[key] = updateDeeply({}, val);
                    }
                } else {
                    target[key] = val;
                }
            }
        }
        return target;
    }

    function generateNumber(value) {
        var result, point, temp, exponent, pos;

        if (value !== value) {
            throw new Error('Numeric literal whose value is NaN');
        }
        if (value < 0 || (value === 0 && 1 / value < 0)) {
            throw new Error('Numeric literal whose value is negative');
        }

        if (value === 1 / 0) {
            return json ? 'null' : renumber ? '1e400' : '1e+400';
        }

        result = '' + value;
        if (!renumber || result.length < 3) {
            return result;
        }

        point = result.indexOf('.');
        if (!json && result.charCodeAt(0) === 0x30  /* 0 */ && point === 1) {
            point = 0;
            result = result.slice(1);
        }
        temp = result;
        result = result.replace('e+', 'e');
        exponent = 0;
        if ((pos = temp.indexOf('e')) > 0) {
            exponent = +temp.slice(pos + 1);
            temp = temp.slice(0, pos);
        }
        if (point >= 0) {
            exponent -= temp.length - point - 1;
            temp = +(temp.slice(0, point) + temp.slice(point + 1)) + '';
        }
        pos = 0;
        while (temp.charCodeAt(temp.length + pos - 1) === 0x30  /* 0 */) {
            --pos;
        }
        if (pos !== 0) {
            exponent -= pos;
            temp = temp.slice(0, pos);
        }
        if (exponent !== 0) {
            temp += 'e' + exponent;
        }
        if ((temp.length < result.length ||
                    (hexadecimal && value > 1e12 && Math.floor(value) === value && (temp = '0x' + value.toString(16)).length < result.length)) &&
                +temp === value) {
            result = temp;
        }

        return result;
    }

    // Generate valid RegExp expression.
    // This function is based on https://github.com/Constellation/iv Engine

    function escapeRegExpCharacter(ch, previousIsBackslash) {
        // not handling '\' and handling \u2028 or \u2029 to unicode escape sequence
        if ((ch & ~1) === 0x2028) {
            return (previousIsBackslash ? 'u' : '\\u') + ((ch === 0x2028) ? '2028' : '2029');
        } else if (ch === 10 || ch === 13) {  // \n, \r
            return (previousIsBackslash ? '' : '\\') + ((ch === 10) ? 'n' : 'r');
        }
        return String.fromCharCode(ch);
    }

    function generateRegExp(reg) {
        var match, result, flags, i, iz, ch, characterInBrack, previousIsBackslash;

        result = reg.toString();

        if (reg.source) {
            // extract flag from toString result
            match = result.match(/\/([^/]*)$/);
            if (!match) {
                return result;
            }

            flags = match[1];
            result = '';

            characterInBrack = false;
            previousIsBackslash = false;
            for (i = 0, iz = reg.source.length; i < iz; ++i) {
                ch = reg.source.charCodeAt(i);

                if (!previousIsBackslash) {
                    if (characterInBrack) {
                        if (ch === 93) {  // ]
                            characterInBrack = false;
                        }
                    } else {
                        if (ch === 47) {  // /
                            result += '\\';
                        } else if (ch === 91) {  // [
                            characterInBrack = true;
                        }
                    }
                    result += escapeRegExpCharacter(ch, previousIsBackslash);
                    previousIsBackslash = ch === 92;  // \
                } else {
                    // if new RegExp("\\\n') is provided, create /\n/
                    result += escapeRegExpCharacter(ch, previousIsBackslash);
                    // prevent like /\\[/]/
                    previousIsBackslash = false;
                }
            }

            return '/' + result + '/' + flags;
        }

        return result;
    }

    function escapeAllowedCharacter(code, next) {
        var hex;

        if (code === 0x08  /* \b */) {
            return '\\b';
        }

        if (code === 0x0C  /* \f */) {
            return '\\f';
        }

        if (code === 0x09  /* \t */) {
            return '\\t';
        }

        hex = code.toString(16).toUpperCase();
        if (json || code > 0xFF) {
            return '\\u' + '0000'.slice(hex.length) + hex;
        } else if (code === 0x0000 && !esutils.code.isDecimalDigit(next)) {
            return '\\0';
        } else if (code === 0x000B  /* \v */) { // '\v'
            return '\\x0B';
        } else {
            return '\\x' + '00'.slice(hex.length) + hex;
        }
    }

    function escapeDisallowedCharacter(code) {
        if (code === 0x5C  /* \ */) {
            return '\\\\';
        }

        if (code === 0x0A  /* \n */) {
            return '\\n';
        }

        if (code === 0x0D  /* \r */) {
            return '\\r';
        }

        if (code === 0x2028) {
            return '\\u2028';
        }

        if (code === 0x2029) {
            return '\\u2029';
        }

        throw new Error('Incorrectly classified character');
    }

    function escapeDirective(str) {
        var i, iz, code, quote;

        quote = quotes === 'double' ? '"' : '\'';
        for (i = 0, iz = str.length; i < iz; ++i) {
            code = str.charCodeAt(i);
            if (code === 0x27  /* ' */) {
                quote = '"';
                break;
            } else if (code === 0x22  /* " */) {
                quote = '\'';
                break;
            } else if (code === 0x5C  /* \ */) {
                ++i;
            }
        }

        return quote + str + quote;
    }

    function escapeString(str) {
        var result = '', i, len, code, singleQuotes = 0, doubleQuotes = 0, single, quote;

        for (i = 0, len = str.length; i < len; ++i) {
            code = str.charCodeAt(i);
            if (code === 0x27  /* ' */) {
                ++singleQuotes;
            } else if (code === 0x22  /* " */) {
                ++doubleQuotes;
            } else if (code === 0x2F  /* / */ && json) {
                result += '\\';
            } else if (esutils.code.isLineTerminator(code) || code === 0x5C  /* \ */) {
                result += escapeDisallowedCharacter(code);
                continue;
            } else if (!esutils.code.isIdentifierPartES5(code) && (json && code < 0x20  /* SP */ || !json && !escapeless && (code < 0x20  /* SP */ || code > 0x7E  /* ~ */))) {
                result += escapeAllowedCharacter(code, str.charCodeAt(i + 1));
                continue;
            }
            result += String.fromCharCode(code);
        }

        single = !(quotes === 'double' || (quotes === 'auto' && doubleQuotes < singleQuotes));
        quote = single ? '\'' : '"';

        if (!(single ? singleQuotes : doubleQuotes)) {
            return quote + result + quote;
        }

        str = result;
        result = quote;

        for (i = 0, len = str.length; i < len; ++i) {
            code = str.charCodeAt(i);
            if ((code === 0x27  /* ' */ && single) || (code === 0x22  /* " */ && !single)) {
                result += '\\';
            }
            result += String.fromCharCode(code);
        }

        return result + quote;
    }

    /**
     * flatten an array to a string, where the array can contain
     * either strings or nested arrays
     */
    function flattenToString(arr) {
        var i, iz, elem, result = '';
        for (i = 0, iz = arr.length; i < iz; ++i) {
            elem = arr[i];
            result += Array.isArray(elem) ? flattenToString(elem) : elem;
        }
        return result;
    }

    /**
     * convert generated to a SourceNode when source maps are enabled.
     */
    function toSourceNodeWhenNeeded(generated, node) {
        if (!sourceMap) {
            // with no source maps, generated is either an
            // array or a string.  if an array, flatten it.
            // if a string, just return it
            if (Array.isArray(generated)) {
                return flattenToString(generated);
            } else {
                return generated;
            }
        }
        if (node == null) {
            if (generated instanceof SourceNode) {
                return generated;
            } else {
                node = {};
            }
        }
        if (node.loc == null) {
            return new SourceNode(null, null, sourceMap, generated, node.name || null);
        }
        return new SourceNode(node.loc.start.line, node.loc.start.column, (sourceMap === true ? node.loc.source || null : sourceMap), generated, node.name || null);
    }

    function noEmptySpace() {
        return (space) ? space : ' ';
    }

    function join(left, right) {
        var leftSource,
            rightSource,
            leftCharCode,
            rightCharCode;

        leftSource = toSourceNodeWhenNeeded(left).toString();
        if (leftSource.length === 0) {
            return [right];
        }

        rightSource = toSourceNodeWhenNeeded(right).toString();
        if (rightSource.length === 0) {
            return [left];
        }

        leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
        rightCharCode = rightSource.charCodeAt(0);

        if ((leftCharCode === 0x2B  /* + */ || leftCharCode === 0x2D  /* - */) && leftCharCode === rightCharCode ||
            esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode) ||
            leftCharCode === 0x2F  /* / */ && rightCharCode === 0x69  /* i */) { // infix word operators all start with `i`
            return [left, noEmptySpace(), right];
        } else if (esutils.code.isWhiteSpace(leftCharCode) || esutils.code.isLineTerminator(leftCharCode) ||
                esutils.code.isWhiteSpace(rightCharCode) || esutils.code.isLineTerminator(rightCharCode)) {
            return [left, right];
        }
        return [left, space, right];
    }

    function addIndent(stmt) {
        return [base, stmt];
    }

    function withIndent(fn) {
        var previousBase;
        previousBase = base;
        base += indent;
        fn(base);
        base = previousBase;
    }

    function calculateSpaces(str) {
        var i;
        for (i = str.length - 1; i >= 0; --i) {
            if (esutils.code.isLineTerminator(str.charCodeAt(i))) {
                break;
            }
        }
        return (str.length - 1) - i;
    }

    function adjustMultilineComment(value, specialBase) {
        var array, i, len, line, j, spaces, previousBase, sn;

        array = value.split(/\r\n|[\r\n]/);
        spaces = Number.MAX_VALUE;

        // first line doesn't have indentation
        for (i = 1, len = array.length; i < len; ++i) {
            line = array[i];
            j = 0;
            while (j < line.length && esutils.code.isWhiteSpace(line.charCodeAt(j))) {
                ++j;
            }
            if (spaces > j) {
                spaces = j;
            }
        }

        if (typeof specialBase !== 'undefined') {
            // pattern like
            // {
            //   var t = 20;  /*
            //                 * this is comment
            //                 */
            // }
            previousBase = base;
            if (array[1][spaces] === '*') {
                specialBase += ' ';
            }
            base = specialBase;
        } else {
            if (spaces & 1) {
                // /*
                //  *
                //  */
                // If spaces are odd number, above pattern is considered.
                // We waste 1 space.
                --spaces;
            }
            previousBase = base;
        }

        for (i = 1, len = array.length; i < len; ++i) {
            sn = toSourceNodeWhenNeeded(addIndent(array[i].slice(spaces)));
            array[i] = sourceMap ? sn.join('') : sn;
        }

        base = previousBase;

        return array.join('\n');
    }

    function generateComment(comment, specialBase) {
        if (comment.type === 'Line') {
            if (endsWithLineTerminator(comment.value)) {
                return '//' + comment.value;
            } else {
                // Always use LineTerminator
                var result = '//' + comment.value;
                if (!preserveBlankLines) {
                    result += '\n';
                }
                return result;
            }
        }
        if (extra.format.indent.adjustMultilineComment && /[\n\r]/.test(comment.value)) {
            return adjustMultilineComment('/*' + comment.value + '*/', specialBase);
        }
        return '/*' + comment.value + '*/';
    }

    function addComments(stmt, result) {
        var i, len, comment, save, tailingToStatement, specialBase, fragment,
            extRange, range, prevRange, prefix, infix, suffix, count;

        if (stmt.leadingComments && stmt.leadingComments.length > 0) {
            save = result;

            if (preserveBlankLines) {
                comment = stmt.leadingComments[0];
                result = [];

                extRange = comment.extendedRange;
                range = comment.range;

                prefix = sourceCode.substring(extRange[0], range[0]);
                count = (prefix.match(/\n/g) || []).length;
                if (count > 0) {
                    result.push(stringRepeat('\n', count));
                    result.push(addIndent(generateComment(comment)));
                } else {
                    result.push(prefix);
                    result.push(generateComment(comment));
                }

                prevRange = range;

                for (i = 1, len = stmt.leadingComments.length; i < len; i++) {
                    comment = stmt.leadingComments[i];
                    range = comment.range;

                    infix = sourceCode.substring(prevRange[1], range[0]);
                    count = (infix.match(/\n/g) || []).length;
                    result.push(stringRepeat('\n', count));
                    result.push(addIndent(generateComment(comment)));

                    prevRange = range;
                }

                suffix = sourceCode.substring(range[1], extRange[1]);
                count = (suffix.match(/\n/g) || []).length;
                result.push(stringRepeat('\n', count));
            } else {
                comment = stmt.leadingComments[0];
                result = [];
                if (safeConcatenation && stmt.type === Syntax.Program && stmt.body.length === 0) {
                    result.push('\n');
                }
                result.push(generateComment(comment));
                if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                    result.push('\n');
                }

                for (i = 1, len = stmt.leadingComments.length; i < len; ++i) {
                    comment = stmt.leadingComments[i];
                    fragment = [generateComment(comment)];
                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                        fragment.push('\n');
                    }
                    result.push(addIndent(fragment));
                }
            }

            result.push(addIndent(save));
        }

        if (stmt.trailingComments) {

            if (preserveBlankLines) {
                comment = stmt.trailingComments[0];
                extRange = comment.extendedRange;
                range = comment.range;

                prefix = sourceCode.substring(extRange[0], range[0]);
                count = (prefix.match(/\n/g) || []).length;

                if (count > 0) {
                    result.push(stringRepeat('\n', count));
                    result.push(addIndent(generateComment(comment)));
                } else {
                    result.push(prefix);
                    result.push(generateComment(comment));
                }
            } else {
                tailingToStatement = !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
                specialBase = stringRepeat(' ', calculateSpaces(toSourceNodeWhenNeeded([base, result, indent]).toString()));
                for (i = 0, len = stmt.trailingComments.length; i < len; ++i) {
                    comment = stmt.trailingComments[i];
                    if (tailingToStatement) {
                        // We assume target like following script
                        //
                        // var t = 20;  /**
                        //               * This is comment of t
                        //               */
                        if (i === 0) {
                            // first case
                            result = [result, indent];
                        } else {
                            result = [result, specialBase];
                        }
                        result.push(generateComment(comment, specialBase));
                    } else {
                        result = [result, addIndent(generateComment(comment))];
                    }
                    if (i !== len - 1 && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                        result = [result, '\n'];
                    }
                }
            }
        }

        return result;
    }

    function generateBlankLines(start, end, result) {
        var j, newlineCount = 0;

        for (j = start; j < end; j++) {
            if (sourceCode[j] === '\n') {
                newlineCount++;
            }
        }

        for (j = 1; j < newlineCount; j++) {
            result.push(newline);
        }
    }

    function parenthesize(text, current, should) {
        if (current < should) {
            return ['(', text, ')'];
        }
        return text;
    }

    function generateVerbatimString(string) {
        var i, iz, result;
        result = string.split(/\r\n|\n/);
        for (i = 1, iz = result.length; i < iz; i++) {
            result[i] = newline + base + result[i];
        }
        return result;
    }

    function generateVerbatim(expr, precedence) {
        var verbatim, result, prec;
        verbatim = expr[extra.verbatim];

        if (typeof verbatim === 'string') {
            result = parenthesize(generateVerbatimString(verbatim), Precedence.Sequence, precedence);
        } else {
            // verbatim is object
            result = generateVerbatimString(verbatim.content);
            prec = (verbatim.precedence != null) ? verbatim.precedence : Precedence.Sequence;
            result = parenthesize(result, prec, precedence);
        }

        return toSourceNodeWhenNeeded(result, expr);
    }

    function CodeGenerator() {
    }

    // Helpers.

    CodeGenerator.prototype.maybeBlock = function(stmt, flags) {
        var result, noLeadingComment, that = this;

        noLeadingComment = !extra.comment || !stmt.leadingComments;

        if (stmt.type === Syntax.BlockStatement && noLeadingComment) {
            return [space, this.generateStatement(stmt, flags)];
        }

        if (stmt.type === Syntax.EmptyStatement && noLeadingComment) {
            return ';';
        }

        withIndent(function () {
            result = [
                newline,
                addIndent(that.generateStatement(stmt, flags))
            ];
        });

        return result;
    };

    CodeGenerator.prototype.maybeBlockSuffix = function (stmt, result) {
        var ends = endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
        if (stmt.type === Syntax.BlockStatement && (!extra.comment || !stmt.leadingComments) && !ends) {
            return [result, space];
        }
        if (ends) {
            return [result, base];
        }
        return [result, newline, base];
    };

    function generateIdentifier(node) {
        return toSourceNodeWhenNeeded(node.name, node);
    }

    function generateAsyncPrefix(node, spaceRequired) {
        return node.async ? 'async' + (spaceRequired ? noEmptySpace() : space) : '';
    }

    function generateStarSuffix(node) {
        var isGenerator = node.generator && !extra.moz.starlessGenerator;
        return isGenerator ? '*' + space : '';
    }

    function generateMethodPrefix(prop) {
        var func = prop.value, prefix = '';
        if (func.async) {
            prefix += generateAsyncPrefix(func, !prop.computed);
        }
        if (func.generator) {
            // avoid space before method name
            prefix += generateStarSuffix(func) ? '*' : '';
        }
        return prefix;
    }

    CodeGenerator.prototype.generatePattern = function (node, precedence, flags) {
        if (node.type === Syntax.Identifier) {
            return generateIdentifier(node);
        }
        return this.generateExpression(node, precedence, flags);
    };

    CodeGenerator.prototype.generateFunctionParams = function (node) {
        var i, iz, result, hasDefault;

        hasDefault = false;

        if (node.type === Syntax.ArrowFunctionExpression &&
                !node.rest && (!node.defaults || node.defaults.length === 0) &&
                node.params.length === 1 && node.params[0].type === Syntax.Identifier) {
            // arg => { } case
            result = [generateAsyncPrefix(node, true), generateIdentifier(node.params[0])];
        } else {
            result = node.type === Syntax.ArrowFunctionExpression ? [generateAsyncPrefix(node, false)] : [];
            result.push('(');
            if (node.defaults) {
                hasDefault = true;
            }
            for (i = 0, iz = node.params.length; i < iz; ++i) {
                if (hasDefault && node.defaults[i]) {
                    // Handle default values.
                    result.push(this.generateAssignment(node.params[i], node.defaults[i], '=', Precedence.Assignment, E_TTT));
                } else {
                    result.push(this.generatePattern(node.params[i], Precedence.Assignment, E_TTT));
                }
                if (i + 1 < iz) {
                    result.push(',' + space);
                }
            }

            if (node.rest) {
                if (node.params.length) {
                    result.push(',' + space);
                }
                result.push('...');
                result.push(generateIdentifier(node.rest));
            }

            result.push(')');
        }

        return result;
    };

    CodeGenerator.prototype.generateFunctionBody = function (node) {
        var result, expr;

        result = this.generateFunctionParams(node);

        if (node.type === Syntax.ArrowFunctionExpression) {
            result.push(space);
            result.push('=>');
        }

        if (node.expression) {
            result.push(space);
            expr = this.generateExpression(node.body, Precedence.Assignment, E_TTT);
            if (expr.toString().charAt(0) === '{') {
                expr = ['(', expr, ')'];
            }
            result.push(expr);
        } else {
            result.push(this.maybeBlock(node.body, S_TTFF));
        }

        return result;
    };

    CodeGenerator.prototype.generateIterationForStatement = function (operator, stmt, flags) {
        var result = ['for' + space + (stmt.await ? 'await' + space : '') + '('], that = this;
        withIndent(function () {
            if (stmt.left.type === Syntax.VariableDeclaration) {
                withIndent(function () {
                    result.push(stmt.left.kind + noEmptySpace());
                    result.push(that.generateStatement(stmt.left.declarations[0], S_FFFF));
                });
            } else {
                result.push(that.generateExpression(stmt.left, Precedence.Call, E_TTT));
            }

            result = join(result, operator);
            result = [join(
                result,
                that.generateExpression(stmt.right, Precedence.Sequence, E_TTT)
            ), ')'];
        });
        result.push(this.maybeBlock(stmt.body, flags));
        return result;
    };

    CodeGenerator.prototype.generatePropertyKey = function (expr, computed) {
        var result = [];

        if (computed) {
            result.push('[');
        }

        result.push(this.generateExpression(expr, Precedence.Sequence, E_TTT));

        if (computed) {
            result.push(']');
        }

        return result;
    };

    CodeGenerator.prototype.generateAssignment = function (left, right, operator, precedence, flags) {
        if (Precedence.Assignment < precedence) {
            flags |= F_ALLOW_IN;
        }

        return parenthesize(
            [
                this.generateExpression(left, Precedence.Call, flags),
                space + operator + space,
                this.generateExpression(right, Precedence.Assignment, flags)
            ],
            Precedence.Assignment,
            precedence
        );
    };

    CodeGenerator.prototype.semicolon = function (flags) {
        if (!semicolons && flags & F_SEMICOLON_OPT) {
            return '';
        }
        return ';';
    };

    // Statements.

    CodeGenerator.Statement = {

        BlockStatement: function (stmt, flags) {
            var range, content, result = ['{', newline], that = this;

            withIndent(function () {
                // handle functions without any code
                if (stmt.body.length === 0 && preserveBlankLines) {
                    range = stmt.range;
                    if (range[1] - range[0] > 2) {
                        content = sourceCode.substring(range[0] + 1, range[1] - 1);
                        if (content[0] === '\n') {
                            result = ['{'];
                        }
                        result.push(content);
                    }
                }

                var i, iz, fragment, bodyFlags;
                bodyFlags = S_TFFF;
                if (flags & F_FUNC_BODY) {
                    bodyFlags |= F_DIRECTIVE_CTX;
                }

                for (i = 0, iz = stmt.body.length; i < iz; ++i) {
                    if (preserveBlankLines) {
                        // handle spaces before the first line
                        if (i === 0) {
                            if (stmt.body[0].leadingComments) {
                                range = stmt.body[0].leadingComments[0].extendedRange;
                                content = sourceCode.substring(range[0], range[1]);
                                if (content[0] === '\n') {
                                    result = ['{'];
                                }
                            }
                            if (!stmt.body[0].leadingComments) {
                                generateBlankLines(stmt.range[0], stmt.body[0].range[0], result);
                            }
                        }

                        // handle spaces between lines
                        if (i > 0) {
                            if (!stmt.body[i - 1].trailingComments  && !stmt.body[i].leadingComments) {
                                generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);
                            }
                        }
                    }

                    if (i === iz - 1) {
                        bodyFlags |= F_SEMICOLON_OPT;
                    }

                    if (stmt.body[i].leadingComments && preserveBlankLines) {
                        fragment = that.generateStatement(stmt.body[i], bodyFlags);
                    } else {
                        fragment = addIndent(that.generateStatement(stmt.body[i], bodyFlags));
                    }

                    result.push(fragment);
                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                        if (preserveBlankLines && i < iz - 1) {
                            // don't add a new line if there are leading coments
                            // in the next statement
                            if (!stmt.body[i + 1].leadingComments) {
                                result.push(newline);
                            }
                        } else {
                            result.push(newline);
                        }
                    }

                    if (preserveBlankLines) {
                        // handle spaces after the last line
                        if (i === iz - 1) {
                            if (!stmt.body[i].trailingComments) {
                                generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);
                            }
                        }
                    }
                }
            });

            result.push(addIndent('}'));
            return result;
        },

        BreakStatement: function (stmt, flags) {
            if (stmt.label) {
                return 'break ' + stmt.label.name + this.semicolon(flags);
            }
            return 'break' + this.semicolon(flags);
        },

        ContinueStatement: function (stmt, flags) {
            if (stmt.label) {
                return 'continue ' + stmt.label.name + this.semicolon(flags);
            }
            return 'continue' + this.semicolon(flags);
        },

        ClassBody: function (stmt, flags) {
            var result = [ '{', newline], that = this;

            withIndent(function (indent) {
                var i, iz;

                for (i = 0, iz = stmt.body.length; i < iz; ++i) {
                    result.push(indent);
                    result.push(that.generateExpression(stmt.body[i], Precedence.Sequence, E_TTT));
                    if (i + 1 < iz) {
                        result.push(newline);
                    }
                }
            });

            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push(newline);
            }
            result.push(base);
            result.push('}');
            return result;
        },

        ClassDeclaration: function (stmt, flags) {
            var result, fragment;
            result  = ['class'];
            if (stmt.id) {
                result = join(result, this.generateExpression(stmt.id, Precedence.Sequence, E_TTT));
            }
            if (stmt.superClass) {
                fragment = join('extends', this.generateExpression(stmt.superClass, Precedence.Assignment, E_TTT));
                result = join(result, fragment);
            }
            result.push(space);
            result.push(this.generateStatement(stmt.body, S_TFFT));
            return result;
        },

        DirectiveStatement: function (stmt, flags) {
            if (extra.raw && stmt.raw) {
                return stmt.raw + this.semicolon(flags);
            }
            return escapeDirective(stmt.directive) + this.semicolon(flags);
        },

        DoWhileStatement: function (stmt, flags) {
            // Because `do 42 while (cond)` is Syntax Error. We need semicolon.
            var result = join('do', this.maybeBlock(stmt.body, S_TFFF));
            result = this.maybeBlockSuffix(stmt.body, result);
            return join(result, [
                'while' + space + '(',
                this.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
                ')' + this.semicolon(flags)
            ]);
        },

        CatchClause: function (stmt, flags) {
            var result, that = this;
            withIndent(function () {
                var guard;

                result = [
                    'catch' + space + '(',
                    that.generateExpression(stmt.param, Precedence.Sequence, E_TTT),
                    ')'
                ];

                if (stmt.guard) {
                    guard = that.generateExpression(stmt.guard, Precedence.Sequence, E_TTT);
                    result.splice(2, 0, ' if ', guard);
                }
            });
            result.push(this.maybeBlock(stmt.body, S_TFFF));
            return result;
        },

        DebuggerStatement: function (stmt, flags) {
            return 'debugger' + this.semicolon(flags);
        },

        EmptyStatement: function (stmt, flags) {
            return ';';
        },

        ExportDefaultDeclaration: function (stmt, flags) {
            var result = [ 'export' ], bodyFlags;

            bodyFlags = (flags & F_SEMICOLON_OPT) ? S_TFFT : S_TFFF;

            // export default HoistableDeclaration[Default]
            // export default AssignmentExpression[In] ;
            result = join(result, 'default');
            if (isStatement(stmt.declaration)) {
                result = join(result, this.generateStatement(stmt.declaration, bodyFlags));
            } else {
                result = join(result, this.generateExpression(stmt.declaration, Precedence.Assignment, E_TTT) + this.semicolon(flags));
            }
            return result;
        },

        ExportNamedDeclaration: function (stmt, flags) {
            var result = [ 'export' ], bodyFlags, that = this;

            bodyFlags = (flags & F_SEMICOLON_OPT) ? S_TFFT : S_TFFF;

            // export VariableStatement
            // export Declaration[Default]
            if (stmt.declaration) {
                return join(result, this.generateStatement(stmt.declaration, bodyFlags));
            }

            // export ExportClause[NoReference] FromClause ;
            // export ExportClause ;
            if (stmt.specifiers) {
                if (stmt.specifiers.length === 0) {
                    result = join(result, '{' + space + '}');
                } else if (stmt.specifiers[0].type === Syntax.ExportBatchSpecifier) {
                    result = join(result, this.generateExpression(stmt.specifiers[0], Precedence.Sequence, E_TTT));
                } else {
                    result = join(result, '{');
                    withIndent(function (indent) {
                        var i, iz;
                        result.push(newline);
                        for (i = 0, iz = stmt.specifiers.length; i < iz; ++i) {
                            result.push(indent);
                            result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));
                            if (i + 1 < iz) {
                                result.push(',' + newline);
                            }
                        }
                    });
                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                        result.push(newline);
                    }
                    result.push(base + '}');
                }

                if (stmt.source) {
                    result = join(result, [
                        'from' + space,
                        // ModuleSpecifier
                        this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
                        this.semicolon(flags)
                    ]);
                } else {
                    result.push(this.semicolon(flags));
                }
            }
            return result;
        },

        ExportAllDeclaration: function (stmt, flags) {
            // export * FromClause ;
            return [
                'export' + space,
                '*' + space,
                'from' + space,
                // ModuleSpecifier
                this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
                this.semicolon(flags)
            ];
        },

        ExpressionStatement: function (stmt, flags) {
            var result, fragment;

            function isClassPrefixed(fragment) {
                var code;
                if (fragment.slice(0, 5) !== 'class') {
                    return false;
                }
                code = fragment.charCodeAt(5);
                return code === 0x7B  /* '{' */ || esutils.code.isWhiteSpace(code) || esutils.code.isLineTerminator(code);
            }

            function isFunctionPrefixed(fragment) {
                var code;
                if (fragment.slice(0, 8) !== 'function') {
                    return false;
                }
                code = fragment.charCodeAt(8);
                return code === 0x28 /* '(' */ || esutils.code.isWhiteSpace(code) || code === 0x2A  /* '*' */ || esutils.code.isLineTerminator(code);
            }

            function isAsyncPrefixed(fragment) {
                var code, i, iz;
                if (fragment.slice(0, 5) !== 'async') {
                    return false;
                }
                if (!esutils.code.isWhiteSpace(fragment.charCodeAt(5))) {
                    return false;
                }
                for (i = 6, iz = fragment.length; i < iz; ++i) {
                    if (!esutils.code.isWhiteSpace(fragment.charCodeAt(i))) {
                        break;
                    }
                }
                if (i === iz) {
                    return false;
                }
                if (fragment.slice(i, i + 8) !== 'function') {
                    return false;
                }
                code = fragment.charCodeAt(i + 8);
                return code === 0x28 /* '(' */ || esutils.code.isWhiteSpace(code) || code === 0x2A  /* '*' */ || esutils.code.isLineTerminator(code);
            }

            result = [this.generateExpression(stmt.expression, Precedence.Sequence, E_TTT)];
            // 12.4 '{', 'function', 'class' is not allowed in this position.
            // wrap expression with parentheses
            fragment = toSourceNodeWhenNeeded(result).toString();
            if (fragment.charCodeAt(0) === 0x7B  /* '{' */ ||  // ObjectExpression
                    isClassPrefixed(fragment) ||
                    isFunctionPrefixed(fragment) ||
                    isAsyncPrefixed(fragment) ||
                    (directive && (flags & F_DIRECTIVE_CTX) && stmt.expression.type === Syntax.Literal && typeof stmt.expression.value === 'string')) {
                result = ['(', result, ')' + this.semicolon(flags)];
            } else {
                result.push(this.semicolon(flags));
            }
            return result;
        },

        ImportDeclaration: function (stmt, flags) {
            // ES6: 15.2.1 valid import declarations:
            //     - import ImportClause FromClause ;
            //     - import ModuleSpecifier ;
            var result, cursor, that = this;

            // If no ImportClause is present,
            // this should be `import ModuleSpecifier` so skip `from`
            // ModuleSpecifier is StringLiteral.
            if (stmt.specifiers.length === 0) {
                // import ModuleSpecifier ;
                return [
                    'import',
                    space,
                    // ModuleSpecifier
                    this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
                    this.semicolon(flags)
                ];
            }

            // import ImportClause FromClause ;
            result = [
                'import'
            ];
            cursor = 0;

            // ImportedBinding
            if (stmt.specifiers[cursor].type === Syntax.ImportDefaultSpecifier) {
                result = join(result, [
                        this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)
                ]);
                ++cursor;
            }

            if (stmt.specifiers[cursor]) {
                if (cursor !== 0) {
                    result.push(',');
                }

                if (stmt.specifiers[cursor].type === Syntax.ImportNamespaceSpecifier) {
                    // NameSpaceImport
                    result = join(result, [
                            space,
                            this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)
                    ]);
                } else {
                    // NamedImports
                    result.push(space + '{');

                    if ((stmt.specifiers.length - cursor) === 1) {
                        // import { ... } from "...";
                        result.push(space);
                        result.push(this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT));
                        result.push(space + '}' + space);
                    } else {
                        // import {
                        //    ...,
                        //    ...,
                        // } from "...";
                        withIndent(function (indent) {
                            var i, iz;
                            result.push(newline);
                            for (i = cursor, iz = stmt.specifiers.length; i < iz; ++i) {
                                result.push(indent);
                                result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));
                                if (i + 1 < iz) {
                                    result.push(',' + newline);
                                }
                            }
                        });
                        if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                            result.push(newline);
                        }
                        result.push(base + '}' + space);
                    }
                }
            }

            result = join(result, [
                'from' + space,
                // ModuleSpecifier
                this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
                this.semicolon(flags)
            ]);
            return result;
        },

        VariableDeclarator: function (stmt, flags) {
            var itemFlags = (flags & F_ALLOW_IN) ? E_TTT : E_FTT;
            if (stmt.init) {
                return [
                    this.generateExpression(stmt.id, Precedence.Assignment, itemFlags),
                    space,
                    '=',
                    space,
                    this.generateExpression(stmt.init, Precedence.Assignment, itemFlags)
                ];
            }
            return this.generatePattern(stmt.id, Precedence.Assignment, itemFlags);
        },

        VariableDeclaration: function (stmt, flags) {
            // VariableDeclarator is typed as Statement,
            // but joined with comma (not LineTerminator).
            // So if comment is attached to target node, we should specialize.
            var result, i, iz, node, bodyFlags, that = this;

            result = [ stmt.kind ];

            bodyFlags = (flags & F_ALLOW_IN) ? S_TFFF : S_FFFF;

            function block() {
                node = stmt.declarations[0];
                if (extra.comment && node.leadingComments) {
                    result.push('\n');
                    result.push(addIndent(that.generateStatement(node, bodyFlags)));
                } else {
                    result.push(noEmptySpace());
                    result.push(that.generateStatement(node, bodyFlags));
                }

                for (i = 1, iz = stmt.declarations.length; i < iz; ++i) {
                    node = stmt.declarations[i];
                    if (extra.comment && node.leadingComments) {
                        result.push(',' + newline);
                        result.push(addIndent(that.generateStatement(node, bodyFlags)));
                    } else {
                        result.push(',' + space);
                        result.push(that.generateStatement(node, bodyFlags));
                    }
                }
            }

            if (stmt.declarations.length > 1) {
                withIndent(block);
            } else {
                block();
            }

            result.push(this.semicolon(flags));

            return result;
        },

        ThrowStatement: function (stmt, flags) {
            return [join(
                'throw',
                this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)
            ), this.semicolon(flags)];
        },

        TryStatement: function (stmt, flags) {
            var result, i, iz, guardedHandlers;

            result = ['try', this.maybeBlock(stmt.block, S_TFFF)];
            result = this.maybeBlockSuffix(stmt.block, result);

            if (stmt.handlers) {
                // old interface
                for (i = 0, iz = stmt.handlers.length; i < iz; ++i) {
                    result = join(result, this.generateStatement(stmt.handlers[i], S_TFFF));
                    if (stmt.finalizer || i + 1 !== iz) {
                        result = this.maybeBlockSuffix(stmt.handlers[i].body, result);
                    }
                }
            } else {
                guardedHandlers = stmt.guardedHandlers || [];

                for (i = 0, iz = guardedHandlers.length; i < iz; ++i) {
                    result = join(result, this.generateStatement(guardedHandlers[i], S_TFFF));
                    if (stmt.finalizer || i + 1 !== iz) {
                        result = this.maybeBlockSuffix(guardedHandlers[i].body, result);
                    }
                }

                // new interface
                if (stmt.handler) {
                    if (Array.isArray(stmt.handler)) {
                        for (i = 0, iz = stmt.handler.length; i < iz; ++i) {
                            result = join(result, this.generateStatement(stmt.handler[i], S_TFFF));
                            if (stmt.finalizer || i + 1 !== iz) {
                                result = this.maybeBlockSuffix(stmt.handler[i].body, result);
                            }
                        }
                    } else {
                        result = join(result, this.generateStatement(stmt.handler, S_TFFF));
                        if (stmt.finalizer) {
                            result = this.maybeBlockSuffix(stmt.handler.body, result);
                        }
                    }
                }
            }
            if (stmt.finalizer) {
                result = join(result, ['finally', this.maybeBlock(stmt.finalizer, S_TFFF)]);
            }
            return result;
        },

        SwitchStatement: function (stmt, flags) {
            var result, fragment, i, iz, bodyFlags, that = this;
            withIndent(function () {
                result = [
                    'switch' + space + '(',
                    that.generateExpression(stmt.discriminant, Precedence.Sequence, E_TTT),
                    ')' + space + '{' + newline
                ];
            });
            if (stmt.cases) {
                bodyFlags = S_TFFF;
                for (i = 0, iz = stmt.cases.length; i < iz; ++i) {
                    if (i === iz - 1) {
                        bodyFlags |= F_SEMICOLON_OPT;
                    }
                    fragment = addIndent(this.generateStatement(stmt.cases[i], bodyFlags));
                    result.push(fragment);
                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                        result.push(newline);
                    }
                }
            }
            result.push(addIndent('}'));
            return result;
        },

        SwitchCase: function (stmt, flags) {
            var result, fragment, i, iz, bodyFlags, that = this;
            withIndent(function () {
                if (stmt.test) {
                    result = [
                        join('case', that.generateExpression(stmt.test, Precedence.Sequence, E_TTT)),
                        ':'
                    ];
                } else {
                    result = ['default:'];
                }

                i = 0;
                iz = stmt.consequent.length;
                if (iz && stmt.consequent[0].type === Syntax.BlockStatement) {
                    fragment = that.maybeBlock(stmt.consequent[0], S_TFFF);
                    result.push(fragment);
                    i = 1;
                }

                if (i !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                    result.push(newline);
                }

                bodyFlags = S_TFFF;
                for (; i < iz; ++i) {
                    if (i === iz - 1 && flags & F_SEMICOLON_OPT) {
                        bodyFlags |= F_SEMICOLON_OPT;
                    }
                    fragment = addIndent(that.generateStatement(stmt.consequent[i], bodyFlags));
                    result.push(fragment);
                    if (i + 1 !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                        result.push(newline);
                    }
                }
            });
            return result;
        },

        IfStatement: function (stmt, flags) {
            var result, bodyFlags, semicolonOptional, that = this;
            withIndent(function () {
                result = [
                    'if' + space + '(',
                    that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
                    ')'
                ];
            });
            semicolonOptional = flags & F_SEMICOLON_OPT;
            bodyFlags = S_TFFF;
            if (semicolonOptional) {
                bodyFlags |= F_SEMICOLON_OPT;
            }
            if (stmt.alternate) {
                result.push(this.maybeBlock(stmt.consequent, S_TFFF));
                result = this.maybeBlockSuffix(stmt.consequent, result);
                if (stmt.alternate.type === Syntax.IfStatement) {
                    result = join(result, ['else ', this.generateStatement(stmt.alternate, bodyFlags)]);
                } else {
                    result = join(result, join('else', this.maybeBlock(stmt.alternate, bodyFlags)));
                }
            } else {
                result.push(this.maybeBlock(stmt.consequent, bodyFlags));
            }
            return result;
        },

        ForStatement: function (stmt, flags) {
            var result, that = this;
            withIndent(function () {
                result = ['for' + space + '('];
                if (stmt.init) {
                    if (stmt.init.type === Syntax.VariableDeclaration) {
                        result.push(that.generateStatement(stmt.init, S_FFFF));
                    } else {
                        // F_ALLOW_IN becomes false.
                        result.push(that.generateExpression(stmt.init, Precedence.Sequence, E_FTT));
                        result.push(';');
                    }
                } else {
                    result.push(';');
                }

                if (stmt.test) {
                    result.push(space);
                    result.push(that.generateExpression(stmt.test, Precedence.Sequence, E_TTT));
                    result.push(';');
                } else {
                    result.push(';');
                }

                if (stmt.update) {
                    result.push(space);
                    result.push(that.generateExpression(stmt.update, Precedence.Sequence, E_TTT));
                    result.push(')');
                } else {
                    result.push(')');
                }
            });

            result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
            return result;
        },

        ForInStatement: function (stmt, flags) {
            return this.generateIterationForStatement('in', stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);
        },

        ForOfStatement: function (stmt, flags) {
            return this.generateIterationForStatement('of', stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);
        },

        LabeledStatement: function (stmt, flags) {
            return [stmt.label.name + ':', this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF)];
        },

        Program: function (stmt, flags) {
            var result, fragment, i, iz, bodyFlags;
            iz = stmt.body.length;
            result = [safeConcatenation && iz > 0 ? '\n' : ''];
            bodyFlags = S_TFTF;
            for (i = 0; i < iz; ++i) {
                if (!safeConcatenation && i === iz - 1) {
                    bodyFlags |= F_SEMICOLON_OPT;
                }

                if (preserveBlankLines) {
                    // handle spaces before the first line
                    if (i === 0) {
                        if (!stmt.body[0].leadingComments) {
                            generateBlankLines(stmt.range[0], stmt.body[i].range[0], result);
                        }
                    }

                    // handle spaces between lines
                    if (i > 0) {
                        if (!stmt.body[i - 1].trailingComments && !stmt.body[i].leadingComments) {
                            generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);
                        }
                    }
                }

                fragment = addIndent(this.generateStatement(stmt.body[i], bodyFlags));
                result.push(fragment);
                if (i + 1 < iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                    if (preserveBlankLines) {
                        if (!stmt.body[i + 1].leadingComments) {
                            result.push(newline);
                        }
                    } else {
                        result.push(newline);
                    }
                }

                if (preserveBlankLines) {
                    // handle spaces after the last line
                    if (i === iz - 1) {
                        if (!stmt.body[i].trailingComments) {
                            generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);
                        }
                    }
                }
            }
            return result;
        },

        FunctionDeclaration: function (stmt, flags) {
            return [
                generateAsyncPrefix(stmt, true),
                'function',
                generateStarSuffix(stmt) || noEmptySpace(),
                stmt.id ? generateIdentifier(stmt.id) : '',
                this.generateFunctionBody(stmt)
            ];
        },

        ReturnStatement: function (stmt, flags) {
            if (stmt.argument) {
                return [join(
                    'return',
                    this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)
                ), this.semicolon(flags)];
            }
            return ['return' + this.semicolon(flags)];
        },

        WhileStatement: function (stmt, flags) {
            var result, that = this;
            withIndent(function () {
                result = [
                    'while' + space + '(',
                    that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
                    ')'
                ];
            });
            result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
            return result;
        },

        WithStatement: function (stmt, flags) {
            var result, that = this;
            withIndent(function () {
                result = [
                    'with' + space + '(',
                    that.generateExpression(stmt.object, Precedence.Sequence, E_TTT),
                    ')'
                ];
            });
            result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
            return result;
        }

    };

    merge(CodeGenerator.prototype, CodeGenerator.Statement);

    // Expressions.

    CodeGenerator.Expression = {

        SequenceExpression: function (expr, precedence, flags) {
            var result, i, iz;
            if (Precedence.Sequence < precedence) {
                flags |= F_ALLOW_IN;
            }
            result = [];
            for (i = 0, iz = expr.expressions.length; i < iz; ++i) {
                result.push(this.generateExpression(expr.expressions[i], Precedence.Assignment, flags));
                if (i + 1 < iz) {
                    result.push(',' + space);
                }
            }
            return parenthesize(result, Precedence.Sequence, precedence);
        },

        AssignmentExpression: function (expr, precedence, flags) {
            return this.generateAssignment(expr.left, expr.right, expr.operator, precedence, flags);
        },

        ArrowFunctionExpression: function (expr, precedence, flags) {
            return parenthesize(this.generateFunctionBody(expr), Precedence.ArrowFunction, precedence);
        },

        ConditionalExpression: function (expr, precedence, flags) {
            if (Precedence.Conditional < precedence) {
                flags |= F_ALLOW_IN;
            }
            return parenthesize(
                [
                    this.generateExpression(expr.test, Precedence.LogicalOR, flags),
                    space + '?' + space,
                    this.generateExpression(expr.consequent, Precedence.Assignment, flags),
                    space + ':' + space,
                    this.generateExpression(expr.alternate, Precedence.Assignment, flags)
                ],
                Precedence.Conditional,
                precedence
            );
        },

        LogicalExpression: function (expr, precedence, flags) {
            return this.BinaryExpression(expr, precedence, flags);
        },

        BinaryExpression: function (expr, precedence, flags) {
            var result, currentPrecedence, fragment, leftSource;
            currentPrecedence = BinaryPrecedence[expr.operator];

            if (currentPrecedence < precedence) {
                flags |= F_ALLOW_IN;
            }

            fragment = this.generateExpression(expr.left, currentPrecedence, flags);

            leftSource = fragment.toString();

            if (leftSource.charCodeAt(leftSource.length - 1) === 0x2F /* / */ && esutils.code.isIdentifierPartES5(expr.operator.charCodeAt(0))) {
                result = [fragment, noEmptySpace(), expr.operator];
            } else {
                result = join(fragment, expr.operator);
            }

            fragment = this.generateExpression(expr.right, currentPrecedence + 1, flags);

            if (expr.operator === '/' && fragment.toString().charAt(0) === '/' ||
            expr.operator.slice(-1) === '<' && fragment.toString().slice(0, 3) === '!--') {
                // If '/' concats with '/' or `<` concats with `!--`, it is interpreted as comment start
                result.push(noEmptySpace());
                result.push(fragment);
            } else {
                result = join(result, fragment);
            }

            if (expr.operator === 'in' && !(flags & F_ALLOW_IN)) {
                return ['(', result, ')'];
            }
            return parenthesize(result, currentPrecedence, precedence);
        },

        CallExpression: function (expr, precedence, flags) {
            var result, i, iz;
            // F_ALLOW_UNPARATH_NEW becomes false.
            result = [this.generateExpression(expr.callee, Precedence.Call, E_TTF)];
            result.push('(');
            for (i = 0, iz = expr['arguments'].length; i < iz; ++i) {
                result.push(this.generateExpression(expr['arguments'][i], Precedence.Assignment, E_TTT));
                if (i + 1 < iz) {
                    result.push(',' + space);
                }
            }
            result.push(')');

            if (!(flags & F_ALLOW_CALL)) {
                return ['(', result, ')'];
            }
            return parenthesize(result, Precedence.Call, precedence);
        },

        NewExpression: function (expr, precedence, flags) {
            var result, length, i, iz, itemFlags;
            length = expr['arguments'].length;

            // F_ALLOW_CALL becomes false.
            // F_ALLOW_UNPARATH_NEW may become false.
            itemFlags = (flags & F_ALLOW_UNPARATH_NEW && !parentheses && length === 0) ? E_TFT : E_TFF;

            result = join(
                'new',
                this.generateExpression(expr.callee, Precedence.New, itemFlags)
            );

            if (!(flags & F_ALLOW_UNPARATH_NEW) || parentheses || length > 0) {
                result.push('(');
                for (i = 0, iz = length; i < iz; ++i) {
                    result.push(this.generateExpression(expr['arguments'][i], Precedence.Assignment, E_TTT));
                    if (i + 1 < iz) {
                        result.push(',' + space);
                    }
                }
                result.push(')');
            }

            return parenthesize(result, Precedence.New, precedence);
        },

        MemberExpression: function (expr, precedence, flags) {
            var result, fragment;

            // F_ALLOW_UNPARATH_NEW becomes false.
            result = [this.generateExpression(expr.object, Precedence.Call, (flags & F_ALLOW_CALL) ? E_TTF : E_TFF)];

            if (expr.computed) {
                result.push('[');
                result.push(this.generateExpression(expr.property, Precedence.Sequence, flags & F_ALLOW_CALL ? E_TTT : E_TFT));
                result.push(']');
            } else {
                if (expr.object.type === Syntax.Literal && typeof expr.object.value === 'number') {
                    fragment = toSourceNodeWhenNeeded(result).toString();
                    // When the following conditions are all true,
                    //   1. No floating point
                    //   2. Don't have exponents
                    //   3. The last character is a decimal digit
                    //   4. Not hexadecimal OR octal number literal
                    // we should add a floating point.
                    if (
                            fragment.indexOf('.') < 0 &&
                            !/[eExX]/.test(fragment) &&
                            esutils.code.isDecimalDigit(fragment.charCodeAt(fragment.length - 1)) &&
                            !(fragment.length >= 2 && fragment.charCodeAt(0) === 48)  // '0'
                            ) {
                        result.push(' ');
                    }
                }
                result.push('.');
                result.push(generateIdentifier(expr.property));
            }

            return parenthesize(result, Precedence.Member, precedence);
        },

        MetaProperty: function (expr, precedence, flags) {
            var result;
            result = [];
            result.push(typeof expr.meta === "string" ? expr.meta : generateIdentifier(expr.meta));
            result.push('.');
            result.push(typeof expr.property === "string" ? expr.property : generateIdentifier(expr.property));
            return parenthesize(result, Precedence.Member, precedence);
        },

        UnaryExpression: function (expr, precedence, flags) {
            var result, fragment, rightCharCode, leftSource, leftCharCode;
            fragment = this.generateExpression(expr.argument, Precedence.Unary, E_TTT);

            if (space === '') {
                result = join(expr.operator, fragment);
            } else {
                result = [expr.operator];
                if (expr.operator.length > 2) {
                    // delete, void, typeof
                    // get `typeof []`, not `typeof[]`
                    result = join(result, fragment);
                } else {
                    // Prevent inserting spaces between operator and argument if it is unnecessary
                    // like, `!cond`
                    leftSource = toSourceNodeWhenNeeded(result).toString();
                    leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
                    rightCharCode = fragment.toString().charCodeAt(0);

                    if (((leftCharCode === 0x2B  /* + */ || leftCharCode === 0x2D  /* - */) && leftCharCode === rightCharCode) ||
                            (esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode))) {
                        result.push(noEmptySpace());
                        result.push(fragment);
                    } else {
                        result.push(fragment);
                    }
                }
            }
            return parenthesize(result, Precedence.Unary, precedence);
        },

        YieldExpression: function (expr, precedence, flags) {
            var result;
            if (expr.delegate) {
                result = 'yield*';
            } else {
                result = 'yield';
            }
            if (expr.argument) {
                result = join(
                    result,
                    this.generateExpression(expr.argument, Precedence.Yield, E_TTT)
                );
            }
            return parenthesize(result, Precedence.Yield, precedence);
        },

        AwaitExpression: function (expr, precedence, flags) {
            var result = join(
                expr.all ? 'await*' : 'await',
                this.generateExpression(expr.argument, Precedence.Await, E_TTT)
            );
            return parenthesize(result, Precedence.Await, precedence);
        },

        UpdateExpression: function (expr, precedence, flags) {
            if (expr.prefix) {
                return parenthesize(
                    [
                        expr.operator,
                        this.generateExpression(expr.argument, Precedence.Unary, E_TTT)
                    ],
                    Precedence.Unary,
                    precedence
                );
            }
            return parenthesize(
                [
                    this.generateExpression(expr.argument, Precedence.Postfix, E_TTT),
                    expr.operator
                ],
                Precedence.Postfix,
                precedence
            );
        },

        FunctionExpression: function (expr, precedence, flags) {
            var result = [
                generateAsyncPrefix(expr, true),
                'function'
            ];
            if (expr.id) {
                result.push(generateStarSuffix(expr) || noEmptySpace());
                result.push(generateIdentifier(expr.id));
            } else {
                result.push(generateStarSuffix(expr) || space);
            }
            result.push(this.generateFunctionBody(expr));
            return result;
        },

        ArrayPattern: function (expr, precedence, flags) {
            return this.ArrayExpression(expr, precedence, flags, true);
        },

        ArrayExpression: function (expr, precedence, flags, isPattern) {
            var result, multiline, that = this;
            if (!expr.elements.length) {
                return '[]';
            }
            multiline = isPattern ? false : expr.elements.length > 1;
            result = ['[', multiline ? newline : ''];
            withIndent(function (indent) {
                var i, iz;
                for (i = 0, iz = expr.elements.length; i < iz; ++i) {
                    if (!expr.elements[i]) {
                        if (multiline) {
                            result.push(indent);
                        }
                        if (i + 1 === iz) {
                            result.push(',');
                        }
                    } else {
                        result.push(multiline ? indent : '');
                        result.push(that.generateExpression(expr.elements[i], Precedence.Assignment, E_TTT));
                    }
                    if (i + 1 < iz) {
                        result.push(',' + (multiline ? newline : space));
                    }
                }
            });
            if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push(newline);
            }
            result.push(multiline ? base : '');
            result.push(']');
            return result;
        },

        RestElement: function(expr, precedence, flags) {
            return '...' + this.generatePattern(expr.argument);
        },

        ClassExpression: function (expr, precedence, flags) {
            var result, fragment;
            result = ['class'];
            if (expr.id) {
                result = join(result, this.generateExpression(expr.id, Precedence.Sequence, E_TTT));
            }
            if (expr.superClass) {
                fragment = join('extends', this.generateExpression(expr.superClass, Precedence.Assignment, E_TTT));
                result = join(result, fragment);
            }
            result.push(space);
            result.push(this.generateStatement(expr.body, S_TFFT));
            return result;
        },

        MethodDefinition: function (expr, precedence, flags) {
            var result, fragment;
            if (expr['static']) {
                result = ['static' + space];
            } else {
                result = [];
            }
            if (expr.kind === 'get' || expr.kind === 'set') {
                fragment = [
                    join(expr.kind, this.generatePropertyKey(expr.key, expr.computed)),
                    this.generateFunctionBody(expr.value)
                ];
            } else {
                fragment = [
                    generateMethodPrefix(expr),
                    this.generatePropertyKey(expr.key, expr.computed),
                    this.generateFunctionBody(expr.value)
                ];
            }
            return join(result, fragment);
        },

        Property: function (expr, precedence, flags) {
            if (expr.kind === 'get' || expr.kind === 'set') {
                return [
                    expr.kind, noEmptySpace(),
                    this.generatePropertyKey(expr.key, expr.computed),
                    this.generateFunctionBody(expr.value)
                ];
            }

            if (expr.shorthand) {
                if (expr.value.type === "AssignmentPattern") {
                    return this.AssignmentPattern(expr.value, Precedence.Sequence, E_TTT);
                }
                return this.generatePropertyKey(expr.key, expr.computed);
            }

            if (expr.method) {
                return [
                    generateMethodPrefix(expr),
                    this.generatePropertyKey(expr.key, expr.computed),
                    this.generateFunctionBody(expr.value)
                ];
            }

            return [
                this.generatePropertyKey(expr.key, expr.computed),
                ':' + space,
                this.generateExpression(expr.value, Precedence.Assignment, E_TTT)
            ];
        },

        ObjectExpression: function (expr, precedence, flags) {
            var multiline, result, fragment, that = this;

            if (!expr.properties.length) {
                return '{}';
            }
            multiline = expr.properties.length > 1;

            withIndent(function () {
                fragment = that.generateExpression(expr.properties[0], Precedence.Sequence, E_TTT);
            });

            if (!multiline) {
                // issues 4
                // Do not transform from
                //   dejavu.Class.declare({
                //       method2: function () {}
                //   });
                // to
                //   dejavu.Class.declare({method2: function () {
                //       }});
                if (!hasLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                    return [ '{', space, fragment, space, '}' ];
                }
            }

            withIndent(function (indent) {
                var i, iz;
                result = [ '{', newline, indent, fragment ];

                if (multiline) {
                    result.push(',' + newline);
                    for (i = 1, iz = expr.properties.length; i < iz; ++i) {
                        result.push(indent);
                        result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));
                        if (i + 1 < iz) {
                            result.push(',' + newline);
                        }
                    }
                }
            });

            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push(newline);
            }
            result.push(base);
            result.push('}');
            return result;
        },

        AssignmentPattern: function(expr, precedence, flags) {
            return this.generateAssignment(expr.left, expr.right, '=', precedence, flags);
        },

        ObjectPattern: function (expr, precedence, flags) {
            var result, i, iz, multiline, property, that = this;
            if (!expr.properties.length) {
                return '{}';
            }

            multiline = false;
            if (expr.properties.length === 1) {
                property = expr.properties[0];
                if (property.value.type !== Syntax.Identifier) {
                    multiline = true;
                }
            } else {
                for (i = 0, iz = expr.properties.length; i < iz; ++i) {
                    property = expr.properties[i];
                    if (!property.shorthand) {
                        multiline = true;
                        break;
                    }
                }
            }
            result = ['{', multiline ? newline : '' ];

            withIndent(function (indent) {
                var i, iz;
                for (i = 0, iz = expr.properties.length; i < iz; ++i) {
                    result.push(multiline ? indent : '');
                    result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));
                    if (i + 1 < iz) {
                        result.push(',' + (multiline ? newline : space));
                    }
                }
            });

            if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push(newline);
            }
            result.push(multiline ? base : '');
            result.push('}');
            return result;
        },

        ThisExpression: function (expr, precedence, flags) {
            return 'this';
        },

        Super: function (expr, precedence, flags) {
            return 'super';
        },

        Identifier: function (expr, precedence, flags) {
            return generateIdentifier(expr);
        },

        ImportDefaultSpecifier: function (expr, precedence, flags) {
            return generateIdentifier(expr.id || expr.local);
        },

        ImportNamespaceSpecifier: function (expr, precedence, flags) {
            var result = ['*'];
            var id = expr.id || expr.local;
            if (id) {
                result.push(space + 'as' + noEmptySpace() + generateIdentifier(id));
            }
            return result;
        },

        ImportSpecifier: function (expr, precedence, flags) {
            var imported = expr.imported;
            var result = [ imported.name ];
            var local = expr.local;
            if (local && local.name !== imported.name) {
                result.push(noEmptySpace() + 'as' + noEmptySpace() + generateIdentifier(local));
            }
            return result;
        },

        ExportSpecifier: function (expr, precedence, flags) {
            var local = expr.local;
            var result = [ local.name ];
            var exported = expr.exported;
            if (exported && exported.name !== local.name) {
                result.push(noEmptySpace() + 'as' + noEmptySpace() + generateIdentifier(exported));
            }
            return result;
        },

        Literal: function (expr, precedence, flags) {
            var raw;
            if (expr.hasOwnProperty('raw') && parse && extra.raw) {
                try {
                    raw = parse(expr.raw).body[0].expression;
                    if (raw.type === Syntax.Literal) {
                        if (raw.value === expr.value) {
                            return expr.raw;
                        }
                    }
                } catch (e) {
                    // not use raw property
                }
            }

            if (expr.value === null) {
                return 'null';
            }

            if (typeof expr.value === 'string') {
                return escapeString(expr.value);
            }

            if (typeof expr.value === 'number') {
                return generateNumber(expr.value);
            }

            if (typeof expr.value === 'boolean') {
                return expr.value ? 'true' : 'false';
            }

            if (expr.regex) {
              return '/' + expr.regex.pattern + '/' + expr.regex.flags;
            }
            return generateRegExp(expr.value);
        },

        GeneratorExpression: function (expr, precedence, flags) {
            return this.ComprehensionExpression(expr, precedence, flags);
        },

        ComprehensionExpression: function (expr, precedence, flags) {
            // GeneratorExpression should be parenthesized with (...), ComprehensionExpression with [...]
            // Due to https://bugzilla.mozilla.org/show_bug.cgi?id=883468 position of expr.body can differ in Spidermonkey and ES6

            var result, i, iz, fragment, that = this;
            result = (expr.type === Syntax.GeneratorExpression) ? ['('] : ['['];

            if (extra.moz.comprehensionExpressionStartsWithAssignment) {
                fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);
                result.push(fragment);
            }

            if (expr.blocks) {
                withIndent(function () {
                    for (i = 0, iz = expr.blocks.length; i < iz; ++i) {
                        fragment = that.generateExpression(expr.blocks[i], Precedence.Sequence, E_TTT);
                        if (i > 0 || extra.moz.comprehensionExpressionStartsWithAssignment) {
                            result = join(result, fragment);
                        } else {
                            result.push(fragment);
                        }
                    }
                });
            }

            if (expr.filter) {
                result = join(result, 'if' + space);
                fragment = this.generateExpression(expr.filter, Precedence.Sequence, E_TTT);
                result = join(result, [ '(', fragment, ')' ]);
            }

            if (!extra.moz.comprehensionExpressionStartsWithAssignment) {
                fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);

                result = join(result, fragment);
            }

            result.push((expr.type === Syntax.GeneratorExpression) ? ')' : ']');
            return result;
        },

        ComprehensionBlock: function (expr, precedence, flags) {
            var fragment;
            if (expr.left.type === Syntax.VariableDeclaration) {
                fragment = [
                    expr.left.kind, noEmptySpace(),
                    this.generateStatement(expr.left.declarations[0], S_FFFF)
                ];
            } else {
                fragment = this.generateExpression(expr.left, Precedence.Call, E_TTT);
            }

            fragment = join(fragment, expr.of ? 'of' : 'in');
            fragment = join(fragment, this.generateExpression(expr.right, Precedence.Sequence, E_TTT));

            return [ 'for' + space + '(', fragment, ')' ];
        },

        SpreadElement: function (expr, precedence, flags) {
            return [
                '...',
                this.generateExpression(expr.argument, Precedence.Assignment, E_TTT)
            ];
        },

        TaggedTemplateExpression: function (expr, precedence, flags) {
            var itemFlags = E_TTF;
            if (!(flags & F_ALLOW_CALL)) {
                itemFlags = E_TFF;
            }
            var result = [
                this.generateExpression(expr.tag, Precedence.Call, itemFlags),
                this.generateExpression(expr.quasi, Precedence.Primary, E_FFT)
            ];
            return parenthesize(result, Precedence.TaggedTemplate, precedence);
        },

        TemplateElement: function (expr, precedence, flags) {
            // Don't use "cooked". Since tagged template can use raw template
            // representation. So if we do so, it breaks the script semantics.
            return expr.value.raw;
        },

        TemplateLiteral: function (expr, precedence, flags) {
            var result, i, iz;
            result = [ '`' ];
            for (i = 0, iz = expr.quasis.length; i < iz; ++i) {
                result.push(this.generateExpression(expr.quasis[i], Precedence.Primary, E_TTT));
                if (i + 1 < iz) {
                    result.push('${' + space);
                    result.push(this.generateExpression(expr.expressions[i], Precedence.Sequence, E_TTT));
                    result.push(space + '}');
                }
            }
            result.push('`');
            return result;
        },

        ModuleSpecifier: function (expr, precedence, flags) {
            return this.Literal(expr, precedence, flags);
        }

    };

    merge(CodeGenerator.prototype, CodeGenerator.Expression);

    CodeGenerator.prototype.generateExpression = function (expr, precedence, flags) {
        var result, type;

        type = expr.type || Syntax.Property;

        if (extra.verbatim && expr.hasOwnProperty(extra.verbatim)) {
            return generateVerbatim(expr, precedence);
        }

        result = this[type](expr, precedence, flags);


        if (extra.comment) {
            result = addComments(expr, result);
        }
        return toSourceNodeWhenNeeded(result, expr);
    };

    CodeGenerator.prototype.generateStatement = function (stmt, flags) {
        var result,
            fragment;

        result = this[stmt.type](stmt, flags);

        // Attach comments

        if (extra.comment) {
            result = addComments(stmt, result);
        }

        fragment = toSourceNodeWhenNeeded(result).toString();
        if (stmt.type === Syntax.Program && !safeConcatenation && newline === '' &&  fragment.charAt(fragment.length - 1) === '\n') {
            result = sourceMap ? toSourceNodeWhenNeeded(result).replaceRight(/\s+$/, '') : fragment.replace(/\s+$/, '');
        }

        return toSourceNodeWhenNeeded(result, stmt);
    };

    function generateInternal(node) {
        var codegen;

        codegen = new CodeGenerator();
        if (isStatement(node)) {
            return codegen.generateStatement(node, S_TFFF);
        }

        if (isExpression(node)) {
            return codegen.generateExpression(node, Precedence.Sequence, E_TTT);
        }

        throw new Error('Unknown node type: ' + node.type);
    }

    function generate(node, options) {
        var defaultOptions = getDefaultOptions(), result, pair;

        if (options != null) {
            // Obsolete options
            //
            //   `options.indent`
            //   `options.base`
            //
            // Instead of them, we can use `option.format.indent`.
            if (typeof options.indent === 'string') {
                defaultOptions.format.indent.style = options.indent;
            }
            if (typeof options.base === 'number') {
                defaultOptions.format.indent.base = options.base;
            }
            options = updateDeeply(defaultOptions, options);
            indent = options.format.indent.style;
            if (typeof options.base === 'string') {
                base = options.base;
            } else {
                base = stringRepeat(indent, options.format.indent.base);
            }
        } else {
            options = defaultOptions;
            indent = options.format.indent.style;
            base = stringRepeat(indent, options.format.indent.base);
        }
        json = options.format.json;
        renumber = options.format.renumber;
        hexadecimal = json ? false : options.format.hexadecimal;
        quotes = json ? 'double' : options.format.quotes;
        escapeless = options.format.escapeless;
        newline = options.format.newline;
        space = options.format.space;
        if (options.format.compact) {
            newline = space = indent = base = '';
        }
        parentheses = options.format.parentheses;
        semicolons = options.format.semicolons;
        safeConcatenation = options.format.safeConcatenation;
        directive = options.directive;
        parse = json ? null : options.parse;
        sourceMap = options.sourceMap;
        sourceCode = options.sourceCode;
        preserveBlankLines = options.format.preserveBlankLines && sourceCode !== null;
        extra = options;

        if (sourceMap) {
            if (!exports.browser) {
                // We assume environment is node.js
                // And prevent from including source-map by browserify
                SourceNode = require('source-map').SourceNode;
            } else {
                SourceNode = global.sourceMap.SourceNode;
            }
        }

        result = generateInternal(node);

        if (!sourceMap) {
            pair = {code: result.toString(), map: null};
            return options.sourceMapWithCode ? pair : pair.code;
        }


        pair = result.toStringWithSourceMap({
            file: options.file,
            sourceRoot: options.sourceMapRoot
        });

        if (options.sourceContent) {
            pair.map.setSourceContent(options.sourceMap,
                                      options.sourceContent);
        }

        if (options.sourceMapWithCode) {
            return pair;
        }

        return pair.map.toString();
    }

    FORMAT_MINIFY = {
        indent: {
            style: '',
            base: 0
        },
        renumber: true,
        hexadecimal: true,
        quotes: 'auto',
        escapeless: true,
        compact: true,
        parentheses: false,
        semicolons: false
    };

    FORMAT_DEFAULTS = getDefaultOptions().format;

    exports.version = require('./package.json').version;
    exports.generate = generate;
    exports.attachComments = estraverse.attachComments;
    exports.Precedence = updateDeeply({}, Precedence);
    exports.browser = false;
    exports.FORMAT_MINIFY = FORMAT_MINIFY;
    exports.FORMAT_DEFAULTS = FORMAT_DEFAULTS;
}());
/* vim: set sw=4 ts=4 et tw=80 : */

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./package.json":18,"estraverse":20,"esutils":6,"source-map":17}],3:[function(require,module,exports){
/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    function isExpression(node) {
        if (node == null) { return false; }
        switch (node.type) {
            case 'ArrayExpression':
            case 'AssignmentExpression':
            case 'BinaryExpression':
            case 'CallExpression':
            case 'ConditionalExpression':
            case 'FunctionExpression':
            case 'Identifier':
            case 'Literal':
            case 'LogicalExpression':
            case 'MemberExpression':
            case 'NewExpression':
            case 'ObjectExpression':
            case 'SequenceExpression':
            case 'ThisExpression':
            case 'UnaryExpression':
            case 'UpdateExpression':
                return true;
        }
        return false;
    }

    function isIterationStatement(node) {
        if (node == null) { return false; }
        switch (node.type) {
            case 'DoWhileStatement':
            case 'ForInStatement':
            case 'ForStatement':
            case 'WhileStatement':
                return true;
        }
        return false;
    }

    function isStatement(node) {
        if (node == null) { return false; }
        switch (node.type) {
            case 'BlockStatement':
            case 'BreakStatement':
            case 'ContinueStatement':
            case 'DebuggerStatement':
            case 'DoWhileStatement':
            case 'EmptyStatement':
            case 'ExpressionStatement':
            case 'ForInStatement':
            case 'ForStatement':
            case 'IfStatement':
            case 'LabeledStatement':
            case 'ReturnStatement':
            case 'SwitchStatement':
            case 'ThrowStatement':
            case 'TryStatement':
            case 'VariableDeclaration':
            case 'WhileStatement':
            case 'WithStatement':
                return true;
        }
        return false;
    }

    function isSourceElement(node) {
      return isStatement(node) || node != null && node.type === 'FunctionDeclaration';
    }

    function trailingStatement(node) {
        switch (node.type) {
        case 'IfStatement':
            if (node.alternate != null) {
                return node.alternate;
            }
            return node.consequent;

        case 'LabeledStatement':
        case 'ForStatement':
        case 'ForInStatement':
        case 'WhileStatement':
        case 'WithStatement':
            return node.body;
        }
        return null;
    }

    function isProblematicIfStatement(node) {
        var current;

        if (node.type !== 'IfStatement') {
            return false;
        }
        if (node.alternate == null) {
            return false;
        }
        current = node.consequent;
        do {
            if (current.type === 'IfStatement') {
                if (current.alternate == null)  {
                    return true;
                }
            }
            current = trailingStatement(current);
        } while (current);

        return false;
    }

    module.exports = {
        isExpression: isExpression,
        isStatement: isStatement,
        isIterationStatement: isIterationStatement,
        isSourceElement: isSourceElement,
        isProblematicIfStatement: isProblematicIfStatement,

        trailingStatement: trailingStatement
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */

},{}],4:[function(require,module,exports){
/*
  Copyright (C) 2013-2014 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch;

    // See `tools/generate-identifier-regex.js`.
    ES5Regex = {
        // ECMAScript 5.1/Unicode v7.0.0 NonAsciiIdentifierStart:
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
        // ECMAScript 5.1/Unicode v7.0.0 NonAsciiIdentifierPart:
        NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
    };

    ES6Regex = {
        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierStart:
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/,
        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierPart:
        NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDD0-\uDDDA\uDE00-\uDE11\uDE13-\uDE37\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF01-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
    };

    function isDecimalDigit(ch) {
        return 0x30 <= ch && ch <= 0x39;  // 0..9
    }

    function isHexDigit(ch) {
        return 0x30 <= ch && ch <= 0x39 ||  // 0..9
            0x61 <= ch && ch <= 0x66 ||     // a..f
            0x41 <= ch && ch <= 0x46;       // A..F
    }

    function isOctalDigit(ch) {
        return ch >= 0x30 && ch <= 0x37;  // 0..7
    }

    // 7.2 White Space

    NON_ASCII_WHITESPACES = [
        0x1680, 0x180E,
        0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A,
        0x202F, 0x205F,
        0x3000,
        0xFEFF
    ];

    function isWhiteSpace(ch) {
        return ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 ||
            ch >= 0x1680 && NON_ASCII_WHITESPACES.indexOf(ch) >= 0;
    }

    // 7.3 Line Terminators

    function isLineTerminator(ch) {
        return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029;
    }

    // 7.6 Identifier Names and Identifiers

    function fromCodePoint(cp) {
        if (cp <= 0xFFFF) { return String.fromCharCode(cp); }
        var cu1 = String.fromCharCode(Math.floor((cp - 0x10000) / 0x400) + 0xD800);
        var cu2 = String.fromCharCode(((cp - 0x10000) % 0x400) + 0xDC00);
        return cu1 + cu2;
    }

    IDENTIFIER_START = new Array(0x80);
    for(ch = 0; ch < 0x80; ++ch) {
        IDENTIFIER_START[ch] =
            ch >= 0x61 && ch <= 0x7A ||  // a..z
            ch >= 0x41 && ch <= 0x5A ||  // A..Z
            ch === 0x24 || ch === 0x5F;  // $ (dollar) and _ (underscore)
    }

    IDENTIFIER_PART = new Array(0x80);
    for(ch = 0; ch < 0x80; ++ch) {
        IDENTIFIER_PART[ch] =
            ch >= 0x61 && ch <= 0x7A ||  // a..z
            ch >= 0x41 && ch <= 0x5A ||  // A..Z
            ch >= 0x30 && ch <= 0x39 ||  // 0..9
            ch === 0x24 || ch === 0x5F;  // $ (dollar) and _ (underscore)
    }

    function isIdentifierStartES5(ch) {
        return ch < 0x80 ? IDENTIFIER_START[ch] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
    }

    function isIdentifierPartES5(ch) {
        return ch < 0x80 ? IDENTIFIER_PART[ch] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
    }

    function isIdentifierStartES6(ch) {
        return ch < 0x80 ? IDENTIFIER_START[ch] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
    }

    function isIdentifierPartES6(ch) {
        return ch < 0x80 ? IDENTIFIER_PART[ch] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
    }

    module.exports = {
        isDecimalDigit: isDecimalDigit,
        isHexDigit: isHexDigit,
        isOctalDigit: isOctalDigit,
        isWhiteSpace: isWhiteSpace,
        isLineTerminator: isLineTerminator,
        isIdentifierStartES5: isIdentifierStartES5,
        isIdentifierPartES5: isIdentifierPartES5,
        isIdentifierStartES6: isIdentifierStartES6,
        isIdentifierPartES6: isIdentifierPartES6
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */

},{}],5:[function(require,module,exports){
/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    var code = require('./code');

    function isStrictModeReservedWordES6(id) {
        switch (id) {
        case 'implements':
        case 'interface':
        case 'package':
        case 'private':
        case 'protected':
        case 'public':
        case 'static':
        case 'let':
            return true;
        default:
            return false;
        }
    }

    function isKeywordES5(id, strict) {
        // yield should not be treated as keyword under non-strict mode.
        if (!strict && id === 'yield') {
            return false;
        }
        return isKeywordES6(id, strict);
    }

    function isKeywordES6(id, strict) {
        if (strict && isStrictModeReservedWordES6(id)) {
            return true;
        }

        switch (id.length) {
        case 2:
            return (id === 'if') || (id === 'in') || (id === 'do');
        case 3:
            return (id === 'var') || (id === 'for') || (id === 'new') || (id === 'try');
        case 4:
            return (id === 'this') || (id === 'else') || (id === 'case') ||
                (id === 'void') || (id === 'with') || (id === 'enum');
        case 5:
            return (id === 'while') || (id === 'break') || (id === 'catch') ||
                (id === 'throw') || (id === 'const') || (id === 'yield') ||
                (id === 'class') || (id === 'super');
        case 6:
            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
                (id === 'switch') || (id === 'export') || (id === 'import');
        case 7:
            return (id === 'default') || (id === 'finally') || (id === 'extends');
        case 8:
            return (id === 'function') || (id === 'continue') || (id === 'debugger');
        case 10:
            return (id === 'instanceof');
        default:
            return false;
        }
    }

    function isReservedWordES5(id, strict) {
        return id === 'null' || id === 'true' || id === 'false' || isKeywordES5(id, strict);
    }

    function isReservedWordES6(id, strict) {
        return id === 'null' || id === 'true' || id === 'false' || isKeywordES6(id, strict);
    }

    function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
    }

    function isIdentifierNameES5(id) {
        var i, iz, ch;

        if (id.length === 0) { return false; }

        ch = id.charCodeAt(0);
        if (!code.isIdentifierStartES5(ch)) {
            return false;
        }

        for (i = 1, iz = id.length; i < iz; ++i) {
            ch = id.charCodeAt(i);
            if (!code.isIdentifierPartES5(ch)) {
                return false;
            }
        }
        return true;
    }

    function decodeUtf16(lead, trail) {
        return (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
    }

    function isIdentifierNameES6(id) {
        var i, iz, ch, lowCh, check;

        if (id.length === 0) { return false; }

        check = code.isIdentifierStartES6;
        for (i = 0, iz = id.length; i < iz; ++i) {
            ch = id.charCodeAt(i);
            if (0xD800 <= ch && ch <= 0xDBFF) {
                ++i;
                if (i >= iz) { return false; }
                lowCh = id.charCodeAt(i);
                if (!(0xDC00 <= lowCh && lowCh <= 0xDFFF)) {
                    return false;
                }
                ch = decodeUtf16(ch, lowCh);
            }
            if (!check(ch)) {
                return false;
            }
            check = code.isIdentifierPartES6;
        }
        return true;
    }

    function isIdentifierES5(id, strict) {
        return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);
    }

    function isIdentifierES6(id, strict) {
        return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);
    }

    module.exports = {
        isKeywordES5: isKeywordES5,
        isKeywordES6: isKeywordES6,
        isReservedWordES5: isReservedWordES5,
        isReservedWordES6: isReservedWordES6,
        isRestrictedWord: isRestrictedWord,
        isIdentifierNameES5: isIdentifierNameES5,
        isIdentifierNameES6: isIdentifierNameES6,
        isIdentifierES5: isIdentifierES5,
        isIdentifierES6: isIdentifierES6
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */

},{"./code":4}],6:[function(require,module,exports){
/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


(function () {
    'use strict';

    exports.ast = require('./ast');
    exports.code = require('./code');
    exports.keyword = require('./keyword');
}());
/* vim: set sw=4 ts=4 et tw=80 : */

},{"./ast":3,"./code":4,"./keyword":5}],7:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = require('./util');
var has = Object.prototype.hasOwnProperty;
var hasNativeMap = typeof Map !== "undefined";

/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */
function ArraySet() {
  this._array = [];
  this._set = hasNativeMap ? new Map() : Object.create(null);
}

/**
 * Static method for creating ArraySet instances from an existing array.
 */
ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  var set = new ArraySet();
  for (var i = 0, len = aArray.length; i < len; i++) {
    set.add(aArray[i], aAllowDuplicates);
  }
  return set;
};

/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */
ArraySet.prototype.size = function ArraySet_size() {
  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};

/**
 * Add the given string to this set.
 *
 * @param String aStr
 */
ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
  var idx = this._array.length;
  if (!isDuplicate || aAllowDuplicates) {
    this._array.push(aStr);
  }
  if (!isDuplicate) {
    if (hasNativeMap) {
      this._set.set(aStr, idx);
    } else {
      this._set[sStr] = idx;
    }
  }
};

/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */
ArraySet.prototype.has = function ArraySet_has(aStr) {
  if (hasNativeMap) {
    return this._set.has(aStr);
  } else {
    var sStr = util.toSetString(aStr);
    return has.call(this._set, sStr);
  }
};

/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */
ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
  if (hasNativeMap) {
    var idx = this._set.get(aStr);
    if (idx >= 0) {
        return idx;
    }
  } else {
    var sStr = util.toSetString(aStr);
    if (has.call(this._set, sStr)) {
      return this._set[sStr];
    }
  }

  throw new Error('"' + aStr + '" is not in the set.');
};

/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */
ArraySet.prototype.at = function ArraySet_at(aIdx) {
  if (aIdx >= 0 && aIdx < this._array.length) {
    return this._array[aIdx];
  }
  throw new Error('No element indexed by ' + aIdx);
};

/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */
ArraySet.prototype.toArray = function ArraySet_toArray() {
  return this._array.slice();
};

exports.ArraySet = ArraySet;

},{"./util":16}],8:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var base64 = require('./base64');

// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011

var VLQ_BASE_SHIFT = 5;

// binary: 100000
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

// binary: 011111
var VLQ_BASE_MASK = VLQ_BASE - 1;

// binary: 100000
var VLQ_CONTINUATION_BIT = VLQ_BASE;

/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
function toVLQSigned(aValue) {
  return aValue < 0
    ? ((-aValue) << 1) + 1
    : (aValue << 1) + 0;
}

/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
function fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative
    ? -shifted
    : shifted;
}

/**
 * Returns the base 64 VLQ encoded value.
 */
exports.encode = function base64VLQ_encode(aValue) {
  var encoded = "";
  var digit;

  var vlq = toVLQSigned(aValue);

  do {
    digit = vlq & VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;
    if (vlq > 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= VLQ_CONTINUATION_BIT;
    }
    encoded += base64.encode(digit);
  } while (vlq > 0);

  return encoded;
};

/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */
exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;

  do {
    if (aIndex >= strLen) {
      throw new Error("Expected more digits in base 64 VLQ value.");
    }

    digit = base64.decode(aStr.charCodeAt(aIndex++));
    if (digit === -1) {
      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    }

    continuation = !!(digit & VLQ_CONTINUATION_BIT);
    digit &= VLQ_BASE_MASK;
    result = result + (digit << shift);
    shift += VLQ_BASE_SHIFT;
  } while (continuation);

  aOutParam.value = fromVLQSigned(result);
  aOutParam.rest = aIndex;
};

},{"./base64":9}],9:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
exports.encode = function (number) {
  if (0 <= number && number < intToCharMap.length) {
    return intToCharMap[number];
  }
  throw new TypeError("Must be between 0 and 63: " + number);
};

/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */
exports.decode = function (charCode) {
  var bigA = 65;     // 'A'
  var bigZ = 90;     // 'Z'

  var littleA = 97;  // 'a'
  var littleZ = 122; // 'z'

  var zero = 48;     // '0'
  var nine = 57;     // '9'

  var plus = 43;     // '+'
  var slash = 47;    // '/'

  var littleOffset = 26;
  var numberOffset = 52;

  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
  if (bigA <= charCode && charCode <= bigZ) {
    return (charCode - bigA);
  }

  // 26 - 51: abcdefghijklmnopqrstuvwxyz
  if (littleA <= charCode && charCode <= littleZ) {
    return (charCode - littleA + littleOffset);
  }

  // 52 - 61: 0123456789
  if (zero <= charCode && charCode <= nine) {
    return (charCode - zero + numberOffset);
  }

  // 62: +
  if (charCode == plus) {
    return 62;
  }

  // 63: /
  if (charCode == slash) {
    return 63;
  }

  // Invalid base64 digit.
  return -1;
};

},{}],10:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

exports.GREATEST_LOWER_BOUND = 1;
exports.LEAST_UPPER_BOUND = 2;

/**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 */
function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
  // This function terminates when one of the following is true:
  //
  //   1. We find the exact element we are looking for.
  //
  //   2. We did not find the exact element, but we can return the index of
  //      the next-closest element.
  //
  //   3. We did not find the exact element, and there is no next-closest
  //      element than the one we are searching for, so we return -1.
  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
  var cmp = aCompare(aNeedle, aHaystack[mid], true);
  if (cmp === 0) {
    // Found the element we are looking for.
    return mid;
  }
  else if (cmp > 0) {
    // Our needle is greater than aHaystack[mid].
    if (aHigh - mid > 1) {
      // The element is in the upper half.
      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
    }

    // The exact needle element was not found in this haystack. Determine if
    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return aHigh < aHaystack.length ? aHigh : -1;
    } else {
      return mid;
    }
  }
  else {
    // Our needle is less than aHaystack[mid].
    if (mid - aLow > 1) {
      // The element is in the lower half.
      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
    }

    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return mid;
    } else {
      return aLow < 0 ? -1 : aLow;
    }
  }
}

/**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *     array and returns -1, 0, or 1 depending on whether the needle is less
 *     than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */
exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
  if (aHaystack.length === 0) {
    return -1;
  }

  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);
  if (index < 0) {
    return -1;
  }

  // We have found either the exact element, or the next-closest element than
  // the one we are searching for. However, there may be more than one such
  // element. Make sure we always return the smallest of these.
  while (index - 1 >= 0) {
    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
      break;
    }
    --index;
  }

  return index;
};

},{}],11:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = require('./util');

/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA ||
         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}

/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
function MappingList() {
  this._array = [];
  this._sorted = true;
  // Serves as infimum
  this._last = {generatedLine: -1, generatedColumn: 0};
}

/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */
MappingList.prototype.unsortedForEach =
  function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };

/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */
MappingList.prototype.add = function MappingList_add(aMapping) {
  if (generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;
    this._array.push(aMapping);
  } else {
    this._sorted = false;
    this._array.push(aMapping);
  }
};

/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */
MappingList.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(util.compareByGeneratedPositionsInflated);
    this._sorted = true;
  }
  return this._array;
};

exports.MappingList = MappingList;

},{"./util":16}],12:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

// It turns out that some (most?) JavaScript engines don't self-host
// `Array.prototype.sort`. This makes sense because C++ will likely remain
// faster than JS when doing raw CPU-intensive sorting. However, when using a
// custom comparator function, calling back and forth between the VM's C++ and
// JIT'd JS is rather slow *and* loses JIT type information, resulting in
// worse generated code for the comparator function than would be optimal. In
// fact, when sorting with a comparator, these costs outweigh the benefits of
// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
// a ~3500ms mean speed-up in `bench/bench.html`.

/**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *        The array.
 * @param {Number} x
 *        The index of the first item.
 * @param {Number} y
 *        The index of the second item.
 */
function swap(ary, x, y) {
  var temp = ary[x];
  ary[x] = ary[y];
  ary[y] = temp;
}

/**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *        The lower bound on the range.
 * @param {Number} high
 *        The upper bound on the range.
 */
function randomIntInRange(low, high) {
  return Math.round(low + (Math.random() * (high - low)));
}

/**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 * @param {Number} p
 *        Start index of the array
 * @param {Number} r
 *        End index of the array
 */
function doQuickSort(ary, comparator, p, r) {
  // If our lower bound is less than our upper bound, we (1) partition the
  // array into two pieces and (2) recurse on each half. If it is not, this is
  // the empty array and our base case.

  if (p < r) {
    // (1) Partitioning.
    //
    // The partitioning chooses a pivot between `p` and `r` and moves all
    // elements that are less than or equal to the pivot to the before it, and
    // all the elements that are greater than it after it. The effect is that
    // once partition is done, the pivot is in the exact place it will be when
    // the array is put in sorted order, and it will not need to be moved
    // again. This runs in O(n) time.

    // Always choose a random pivot so that an input array which is reverse
    // sorted does not cause O(n^2) running time.
    var pivotIndex = randomIntInRange(p, r);
    var i = p - 1;

    swap(ary, pivotIndex, r);
    var pivot = ary[r];

    // Immediately after `j` is incremented in this loop, the following hold
    // true:
    //
    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
    //
    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
    for (var j = p; j < r; j++) {
      if (comparator(ary[j], pivot) <= 0) {
        i += 1;
        swap(ary, i, j);
      }
    }

    swap(ary, i + 1, j);
    var q = i + 1;

    // (2) Recurse on each half.

    doQuickSort(ary, comparator, p, q - 1);
    doQuickSort(ary, comparator, q + 1, r);
  }
}

/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */
exports.quickSort = function (ary, comparator) {
  doQuickSort(ary, comparator, 0, ary.length - 1);
};

},{}],13:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = require('./util');
var binarySearch = require('./binary-search');
var ArraySet = require('./array-set').ArraySet;
var base64VLQ = require('./base64-vlq');
var quickSort = require('./quick-sort').quickSort;

function SourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  return sourceMap.sections != null
    ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)
    : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
}

SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
}

/**
 * The version of the source mapping spec that we are consuming.
 */
SourceMapConsumer.prototype._version = 3;

// `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.

SourceMapConsumer.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
  configurable: true,
  enumerable: true,
  get: function () {
    if (!this.__generatedMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__generatedMappings;
  }
});

SourceMapConsumer.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
  configurable: true,
  enumerable: true,
  get: function () {
    if (!this.__originalMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__originalMappings;
  }
});

SourceMapConsumer.prototype._charIsMappingSeparator =
  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
SourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };

SourceMapConsumer.GENERATED_ORDER = 1;
SourceMapConsumer.ORIGINAL_ORDER = 2;

SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer.LEAST_UPPER_BOUND = 2;

/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */
SourceMapConsumer.prototype.eachMapping =
  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

    var mappings;
    switch (order) {
    case SourceMapConsumer.GENERATED_ORDER:
      mappings = this._generatedMappings;
      break;
    case SourceMapConsumer.ORIGINAL_ORDER:
      mappings = this._originalMappings;
      break;
    default:
      throw new Error("Unknown order of iteration.");
    }

    var sourceRoot = this.sourceRoot;
    mappings.map(function (mapping) {
      var source = mapping.source === null ? null : this._sources.at(mapping.source);
      source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
      return {
        source: source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context);
  };

/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number is 1-based.
 *   - column: Optional. the column number in the original source.
 *    The column number is 0-based.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *    line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *    The column number is 0-based.
 */
SourceMapConsumer.prototype.allGeneratedPositionsFor =
  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util.getArg(aArgs, 'line');

    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
    // returns the index of the closest mapping less than the needle. By
    // setting needle.originalColumn to 0, we thus find the last mapping for
    // the given line, provided such a mapping exists.
    var needle = {
      source: util.getArg(aArgs, 'source'),
      originalLine: line,
      originalColumn: util.getArg(aArgs, 'column', 0)
    };

    needle.source = this._findSourceIndex(needle.source);
    if (needle.source < 0) {
      return [];
    }

    var mappings = [];

    var index = this._findMapping(needle,
                                  this._originalMappings,
                                  "originalLine",
                                  "originalColumn",
                                  util.compareByOriginalPositions,
                                  binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (aArgs.column === undefined) {
        var originalLine = mapping.originalLine;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we found. Since
        // mappings are sorted, this is guaranteed to find all mappings for
        // the line we found.
        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      } else {
        var originalColumn = mapping.originalColumn;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we were searching for.
        // Since mappings are sorted, this is guaranteed to find all mappings for
        // the line we are searching for.
        while (mapping &&
               mapping.originalLine === line &&
               mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      }
    }

    return mappings;
  };

exports.SourceMapConsumer = SourceMapConsumer;

/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The first parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */
function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  var version = util.getArg(sourceMap, 'version');
  var sources = util.getArg(sourceMap, 'sources');
  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
  // requires the array) to play nice here.
  var names = util.getArg(sourceMap, 'names', []);
  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
  var mappings = util.getArg(sourceMap, 'mappings');
  var file = util.getArg(sourceMap, 'file', null);

  // Once again, Sass deviates from the spec and supplies the version as a
  // string rather than a number, so we use loose equality checking here.
  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  if (sourceRoot) {
    sourceRoot = util.normalize(sourceRoot);
  }

  sources = sources
    .map(String)
    // Some source maps produce relative source paths like "./foo.js" instead of
    // "foo.js".  Normalize these first so that future comparisons will succeed.
    // See bugzil.la/1090768.
    .map(util.normalize)
    // Always ensure that absolute sources are internally stored relative to
    // the source root, if the source root is absolute. Not doing this would
    // be particularly problematic when the source root is a prefix of the
    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
    .map(function (source) {
      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
        ? util.relative(sourceRoot, source)
        : source;
    });

  // Pass `true` below to allow duplicate names and sources. While source maps
  // are intended to be compressed and deduplicated, the TypeScript compiler
  // sometimes generates source maps with duplicates in them. See Github issue
  // #72 and bugzil.la/889492.
  this._names = ArraySet.fromArray(names.map(String), true);
  this._sources = ArraySet.fromArray(sources, true);

  this._absoluteSources = this._sources.toArray().map(function (s) {
    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
  });

  this.sourceRoot = sourceRoot;
  this.sourcesContent = sourcesContent;
  this._mappings = mappings;
  this._sourceMapURL = aSourceMapURL;
  this.file = file;
}

BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

/**
 * Utility function to find the index of a source.  Returns -1 if not
 * found.
 */
BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
  var relativeSource = aSource;
  if (this.sourceRoot != null) {
    relativeSource = util.relative(this.sourceRoot, relativeSource);
  }

  if (this._sources.has(relativeSource)) {
    return this._sources.indexOf(relativeSource);
  }

  // Maybe aSource is an absolute URL as returned by |sources|.  In
  // this case we can't simply undo the transform.
  var i;
  for (i = 0; i < this._absoluteSources.length; ++i) {
    if (this._absoluteSources[i] == aSource) {
      return i;
    }
  }

  return -1;
};

/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @param String aSourceMapURL
 *        The URL at which the source map can be found (optional)
 * @returns BasicSourceMapConsumer
 */
BasicSourceMapConsumer.fromSourceMap =
  function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);

    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                            smc.sourceRoot);
    smc.file = aSourceMap._file;
    smc._sourceMapURL = aSourceMapURL;
    smc._absoluteSources = smc._sources.toArray().map(function (s) {
      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
    });

    // Because we are modifying the entries (by converting string sources and
    // names to indices into the sources and names ArraySets), we have to make
    // a copy of the entry or else bad things happen. Shared mutable state
    // strikes again! See github issue #191.

    var generatedMappings = aSourceMap._mappings.toArray().slice();
    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];

    for (var i = 0, length = generatedMappings.length; i < length; i++) {
      var srcMapping = generatedMappings[i];
      var destMapping = new Mapping;
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;

      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;

        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }

        destOriginalMappings.push(destMapping);
      }

      destGeneratedMappings.push(destMapping);
    }

    quickSort(smc.__originalMappings, util.compareByOriginalPositions);

    return smc;
  };

/**
 * The version of the source mapping spec that we are consuming.
 */
BasicSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
  get: function () {
    return this._absoluteSources.slice();
  }
});

/**
 * Provide the JIT with a nice shape / hidden class.
 */
function Mapping() {
  this.generatedLine = 0;
  this.generatedColumn = 0;
  this.source = null;
  this.originalLine = null;
  this.originalColumn = null;
  this.name = null;
}

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
BasicSourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;

    while (index < length) {
      if (aStr.charAt(index) === ';') {
        generatedLine++;
        index++;
        previousGeneratedColumn = 0;
      }
      else if (aStr.charAt(index) === ',') {
        index++;
      }
      else {
        mapping = new Mapping();
        mapping.generatedLine = generatedLine;

        // Because each offset is encoded relative to the previous one,
        // many segments often have the same encoding. We can exploit this
        // fact by caching the parsed variable length fields of each segment,
        // allowing us to avoid a second parse if we encounter the same
        // segment again.
        for (end = index; end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }
        str = aStr.slice(index, end);

        segment = cachedSegments[str];
        if (segment) {
          index += str.length;
        } else {
          segment = [];
          while (index < end) {
            base64VLQ.decode(aStr, index, temp);
            value = temp.value;
            index = temp.rest;
            segment.push(value);
          }

          if (segment.length === 2) {
            throw new Error('Found a source, but no line and column');
          }

          if (segment.length === 3) {
            throw new Error('Found a source and line, but no column');
          }

          cachedSegments[str] = segment;
        }

        // Generated column.
        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;

        if (segment.length > 1) {
          // Original source.
          mapping.source = previousSource + segment[1];
          previousSource += segment[1];

          // Original line.
          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine;
          // Lines are stored 0-based
          mapping.originalLine += 1;

          // Original column.
          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;

          if (segment.length > 4) {
            // Original name.
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }

        generatedMappings.push(mapping);
        if (typeof mapping.originalLine === 'number') {
          originalMappings.push(mapping);
        }
      }
    }

    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = generatedMappings;

    quickSort(originalMappings, util.compareByOriginalPositions);
    this.__originalMappings = originalMappings;
  };

/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */
BasicSourceMapConsumer.prototype._findMapping =
  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                         aColumnName, aComparator, aBias) {
    // To return the position we are searching for, we must first find the
    // mapping for the given position and then return the opposite position it
    // points to. Because the mappings are sorted, we can use binary search to
    // find the best mapping.

    if (aNeedle[aLineName] <= 0) {
      throw new TypeError('Line must be greater than or equal to 1, got '
                          + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
      throw new TypeError('Column must be greater than or equal to 0, got '
                          + aNeedle[aColumnName]);
    }

    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  };

/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */
BasicSourceMapConsumer.prototype.computeColumnSpans =
  function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0; index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index];

      // Mappings do not contain a field for the last generated columnt. We
      // can come up with an optimistic estimate, however, by assuming that
      // mappings are contiguous (i.e. given two consecutive mappings, the
      // first mapping ends where the second one starts).
      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];

        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }

      // The last mapping for each line spans the entire line.
      mapping.lastGeneratedColumn = Infinity;
    }
  };

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */
BasicSourceMapConsumer.prototype.originalPositionFor =
  function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._generatedMappings,
      "generatedLine",
      "generatedColumn",
      util.compareByGeneratedPositionsDeflated,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._generatedMappings[index];

      if (mapping.generatedLine === needle.generatedLine) {
        var source = util.getArg(mapping, 'source', null);
        if (source !== null) {
          source = this._sources.at(source);
          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
        }
        var name = util.getArg(mapping, 'name', null);
        if (name !== null) {
          name = this._names.at(name);
        }
        return {
          source: source,
          line: util.getArg(mapping, 'originalLine', null),
          column: util.getArg(mapping, 'originalColumn', null),
          name: name
        };
      }
    }

    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
  function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }
    return this.sourcesContent.length >= this._sources.size() &&
      !this.sourcesContent.some(function (sc) { return sc == null; });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
BasicSourceMapConsumer.prototype.sourceContentFor =
  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }

    var index = this._findSourceIndex(aSource);
    if (index >= 0) {
      return this.sourcesContent[index];
    }

    var relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util.relative(this.sourceRoot, relativeSource);
    }

    var url;
    if (this.sourceRoot != null
        && (url = util.urlParse(this.sourceRoot))) {
      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
      // many users. We can help them out when they expect file:// URIs to
      // behave like it would if they were running a local HTTP server. See
      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
      var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
      if (url.scheme == "file"
          && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
      }

      if ((!url.path || url.path == "/")
          && this._sources.has("/" + relativeSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
      }
    }

    // This function is used recursively from
    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
    // don't want to throw if we can't find the source - we just want to
    // return null, so we provide a flag to exit gracefully.
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + relativeSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */
BasicSourceMapConsumer.prototype.generatedPositionFor =
  function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util.getArg(aArgs, 'source');
    source = this._findSourceIndex(source);
    if (source < 0) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }

    var needle = {
      source: source,
      originalLine: util.getArg(aArgs, 'line'),
      originalColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      util.compareByOriginalPositions,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (mapping.source === needle.source) {
        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        };
      }
    }

    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };

exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The first parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */
function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  var version = util.getArg(sourceMap, 'version');
  var sections = util.getArg(sourceMap, 'sections');

  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  this._sources = new ArraySet();
  this._names = new ArraySet();

  var lastOffset = {
    line: -1,
    column: 0
  };
  this._sections = sections.map(function (s) {
    if (s.url) {
      // The url field will require support for asynchronicity.
      // See https://github.com/mozilla/source-map/issues/16
      throw new Error('Support for url field in sections not implemented.');
    }
    var offset = util.getArg(s, 'offset');
    var offsetLine = util.getArg(offset, 'line');
    var offsetColumn = util.getArg(offset, 'column');

    if (offsetLine < lastOffset.line ||
        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
      throw new Error('Section offsets must be ordered and non-overlapping.');
    }
    lastOffset = offset;

    return {
      generatedOffset: {
        // The offset fields are 0-based, but we use 1-based indices when
        // encoding/decoding from VLQ.
        generatedLine: offsetLine + 1,
        generatedColumn: offsetColumn + 1
      },
      consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)
    }
  });
}

IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

/**
 * The version of the source mapping spec that we are consuming.
 */
IndexedSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
  get: function () {
    var sources = [];
    for (var i = 0; i < this._sections.length; i++) {
      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
        sources.push(this._sections[i].consumer.sources[j]);
      }
    }
    return sources;
  }
});

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */
IndexedSourceMapConsumer.prototype.originalPositionFor =
  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    // Find the section containing the generated position we're trying to map
    // to an original position.
    var sectionIndex = binarySearch.search(needle, this._sections,
      function(needle, section) {
        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
        if (cmp) {
          return cmp;
        }

        return (needle.generatedColumn -
                section.generatedOffset.generatedColumn);
      });
    var section = this._sections[sectionIndex];

    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }

    return section.consumer.originalPositionFor({
      line: needle.generatedLine -
        (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn -
        (section.generatedOffset.generatedLine === needle.generatedLine
         ? section.generatedOffset.generatedColumn - 1
         : 0),
      bias: aArgs.bias
    });
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function (s) {
      return s.consumer.hasContentsOfAllSources();
    });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
IndexedSourceMapConsumer.prototype.sourceContentFor =
  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      var content = section.consumer.sourceContentFor(aSource, true);
      if (content) {
        return content;
      }
    }
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based. 
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */
IndexedSourceMapConsumer.prototype.generatedPositionFor =
  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      // Only consider this section if the requested source is in the list of
      // sources of the consumer.
      if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
        continue;
      }
      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line +
            (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column +
            (section.generatedOffset.generatedLine === generatedPosition.line
             ? section.generatedOffset.generatedColumn - 1
             : 0)
        };
        return ret;
      }
    }

    return {
      line: null,
      column: null
    };
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
IndexedSourceMapConsumer.prototype._parseMappings =
  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;
      for (var j = 0; j < sectionMappings.length; j++) {
        var mapping = sectionMappings[j];

        var source = section.consumer._sources.at(mapping.source);
        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
        this._sources.add(source);
        source = this._sources.indexOf(source);

        var name = null;
        if (mapping.name) {
          name = section.consumer._names.at(mapping.name);
          this._names.add(name);
          name = this._names.indexOf(name);
        }

        // The mappings coming from the consumer for the section have
        // generated positions relative to the start of the section, so we
        // need to offset them to be relative to the start of the concatenated
        // generated file.
        var adjustedMapping = {
          source: source,
          generatedLine: mapping.generatedLine +
            (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn +
            (section.generatedOffset.generatedLine === mapping.generatedLine
            ? section.generatedOffset.generatedColumn - 1
            : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: name
        };

        this.__generatedMappings.push(adjustedMapping);
        if (typeof adjustedMapping.originalLine === 'number') {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }

    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort(this.__originalMappings, util.compareByOriginalPositions);
  };

exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;

},{"./array-set":7,"./base64-vlq":8,"./binary-search":10,"./quick-sort":12,"./util":16}],14:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var base64VLQ = require('./base64-vlq');
var util = require('./util');
var ArraySet = require('./array-set').ArraySet;
var MappingList = require('./mapping-list').MappingList;

/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
function SourceMapGenerator(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }
  this._file = util.getArg(aArgs, 'file', null);
  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
  this._sources = new ArraySet();
  this._names = new ArraySet();
  this._mappings = new MappingList();
  this._sourcesContents = null;
}

SourceMapGenerator.prototype._version = 3;

/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */
SourceMapGenerator.fromSourceMap =
  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot
    });
    aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };

      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }

        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };

        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }

      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var sourceRelative = sourceFile;
      if (sourceRoot !== null) {
        sourceRelative = util.relative(sourceRoot, sourceFile);
      }

      if (!generator._sources.has(sourceRelative)) {
        generator._sources.add(sourceRelative);
      }

      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };

/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */
SourceMapGenerator.prototype.addMapping =
  function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, 'generated');
    var original = util.getArg(aArgs, 'original', null);
    var source = util.getArg(aArgs, 'source', null);
    var name = util.getArg(aArgs, 'name', null);

    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }

    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }

    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }

    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name
    });
  };

/**
 * Set the source content for a source file.
 */
SourceMapGenerator.prototype.setSourceContent =
  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }

    if (aSourceContent != null) {
      // Add the source content to the _sourcesContents map.
      // Create a new _sourcesContents map if the property is null.
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      // Remove the source file from the _sourcesContents map.
      // If the _sourcesContents map is empty, set the property to null.
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };

/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */
SourceMapGenerator.prototype.applySourceMap =
  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    // If aSourceFile is omitted, we will use the file property of the SourceMap
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error(
          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
          'or the source map\'s "file" property. Both were omitted.'
        );
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    // Make "sourceFile" relative if an absolute Url is passed.
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    // Applying the SourceMap can add and remove items from the sources and
    // the names array.
    var newSources = new ArraySet();
    var newNames = new ArraySet();

    // Find mappings for the "sourceFile"
    this._mappings.unsortedForEach(function (mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        // Check if it can be mapped by the source map, then update the mapping.
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          // Copy mapping
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source)
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }

      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }

      var name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }

    }, this);
    this._sources = newSources;
    this._names = newNames;

    // Copy sourcesContents of applied map.
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile = util.join(aSourceMapPath, sourceFile);
        }
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        this.setSourceContent(sourceFile, content);
      }
    }, this);
  };

/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */
SourceMapGenerator.prototype._validateMapping =
  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                              aName) {
    // When aOriginal is truthy but has empty values for .line and .column,
    // it is most likely a programmer error. In this case we throw a very
    // specific error message to try to guide them the right way.
    // For example: https://github.com/Polymer/polymer-bundler/pull/519
    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
        throw new Error(
            'original.line and original.column are not numbers -- you probably meant to omit ' +
            'the original mapping entirely and only map the generated position. If so, pass ' +
            'null for the original mapping instead of an object with empty or null values.'
        );
    }

    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
        && aGenerated.line > 0 && aGenerated.column >= 0
        && !aOriginal && !aSource && !aName) {
      // Case 1.
      return;
    }
    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
             && aGenerated.line > 0 && aGenerated.column >= 0
             && aOriginal.line > 0 && aOriginal.column >= 0
             && aSource) {
      // Cases 2 and 3.
      return;
    }
    else {
      throw new Error('Invalid mapping: ' + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };

/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */
SourceMapGenerator.prototype._serializeMappings =
  function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = '';
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;

    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = ''

      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ';';
          previousGeneratedLine++;
        }
      }
      else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ',';
        }
      }

      next += base64VLQ.encode(mapping.generatedColumn
                                 - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;

      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;

        // lines are stored 0-based in SourceMap spec version 3
        next += base64VLQ.encode(mapping.originalLine - 1
                                   - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;

        next += base64VLQ.encode(mapping.originalColumn
                                   - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;

        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }

      result += next;
    }

    return result;
  };

SourceMapGenerator.prototype._generateSourcesContent =
  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function (source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
        ? this._sourcesContents[key]
        : null;
    }, this);
  };

/**
 * Externalize the source map.
 */
SourceMapGenerator.prototype.toJSON =
  function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }

    return map;
  };

/**
 * Render the source map being generated to a string.
 */
SourceMapGenerator.prototype.toString =
  function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };

exports.SourceMapGenerator = SourceMapGenerator;

},{"./array-set":7,"./base64-vlq":8,"./mapping-list":11,"./util":16}],15:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;
var util = require('./util');

// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).
var REGEX_NEWLINE = /(\r?\n)/;

// Newline character code for charCodeAt() comparisons
var NEWLINE_CODE = 10;

// Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!
var isSourceNode = "$$$isSourceNode$$$";

/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */
function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
  this.children = [];
  this.sourceContents = {};
  this.line = aLine == null ? null : aLine;
  this.column = aColumn == null ? null : aColumn;
  this.source = aSource == null ? null : aSource;
  this.name = aName == null ? null : aName;
  this[isSourceNode] = true;
  if (aChunks != null) this.add(aChunks);
}

/**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *        SourceMapConsumer should be relative to.
 */
SourceNode.fromStringWithSourceMap =
  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    // The SourceNode we want to fill with the generated code
    // and the SourceMap
    var node = new SourceNode();

    // All even indices of this array are one line of the generated code,
    // while all odd indices are the newlines between two adjacent lines
    // (since `REGEX_NEWLINE` captures its match).
    // Processed fragments are accessed by calling `shiftNextLine`.
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var remainingLinesIndex = 0;
    var shiftNextLine = function() {
      var lineContents = getNextLine();
      // The last line of a file might not have a newline.
      var newLine = getNextLine() || "";
      return lineContents + newLine;

      function getNextLine() {
        return remainingLinesIndex < remainingLines.length ?
            remainingLines[remainingLinesIndex++] : undefined;
      }
    };

    // We need to remember the position of "remainingLines"
    var lastGeneratedLine = 1, lastGeneratedColumn = 0;

    // The generate SourceNodes we need a code range.
    // To extract it current and last mapping is used.
    // Here we store the last mapping.
    var lastMapping = null;

    aSourceMapConsumer.eachMapping(function (mapping) {
      if (lastMapping !== null) {
        // We add the code from "lastMapping" to "mapping":
        // First check if there is a new line in between.
        if (lastGeneratedLine < mapping.generatedLine) {
          // Associate first line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
          // The remaining code is added without mapping
        } else {
          // There is no new line in between.
          // Associate the code between "lastGeneratedColumn" and
          // "mapping.generatedColumn" with "lastMapping"
          var nextLine = remainingLines[remainingLinesIndex] || '';
          var code = nextLine.substr(0, mapping.generatedColumn -
                                        lastGeneratedColumn);
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -
                                              lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code);
          // No more remaining code, continue
          lastMapping = mapping;
          return;
        }
      }
      // We add the generated code until the first mapping
      // to the SourceNode without any mapping.
      // Each line is added as separate string.
      while (lastGeneratedLine < mapping.generatedLine) {
        node.add(shiftNextLine());
        lastGeneratedLine++;
      }
      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[remainingLinesIndex] || '';
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }
      lastMapping = mapping;
    }, this);
    // We have processed all mappings.
    if (remainingLinesIndex < remainingLines.length) {
      if (lastMapping) {
        // Associate the remaining code in the current line with "lastMapping"
        addMappingWithCode(lastMapping, shiftNextLine());
      }
      // and add the remaining lines without any mapping
      node.add(remainingLines.splice(remainingLinesIndex).join(""));
    }

    // Copy sourcesContent into SourceNode
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util.join(aRelativePath, sourceFile);
        }
        node.setSourceContent(sourceFile, content);
      }
    });

    return node;

    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === undefined) {
        node.add(code);
      } else {
        var source = aRelativePath
          ? util.join(aRelativePath, mapping.source)
          : mapping.source;
        node.add(new SourceNode(mapping.originalLine,
                                mapping.originalColumn,
                                source,
                                code,
                                mapping.name));
      }
    }
  };

/**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.add = function SourceNode_add(aChunk) {
  if (Array.isArray(aChunk)) {
    aChunk.forEach(function (chunk) {
      this.add(chunk);
    }, this);
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    if (aChunk) {
      this.children.push(aChunk);
    }
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
  if (Array.isArray(aChunk)) {
    for (var i = aChunk.length-1; i >= 0; i--) {
      this.prepend(aChunk[i]);
    }
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    this.children.unshift(aChunk);
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walk = function SourceNode_walk(aFn) {
  var chunk;
  for (var i = 0, len = this.children.length; i < len; i++) {
    chunk = this.children[i];
    if (chunk[isSourceNode]) {
      chunk.walk(aFn);
    }
    else {
      if (chunk !== '') {
        aFn(chunk, { source: this.source,
                     line: this.line,
                     column: this.column,
                     name: this.name });
      }
    }
  }
};

/**
 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
 * each of `this.children`.
 *
 * @param aSep The separator.
 */
SourceNode.prototype.join = function SourceNode_join(aSep) {
  var newChildren;
  var i;
  var len = this.children.length;
  if (len > 0) {
    newChildren = [];
    for (i = 0; i < len-1; i++) {
      newChildren.push(this.children[i]);
      newChildren.push(aSep);
    }
    newChildren.push(this.children[i]);
    this.children = newChildren;
  }
  return this;
};

/**
 * Call String.prototype.replace on the very right-most source snippet. Useful
 * for trimming whitespace from the end of a source node, etc.
 *
 * @param aPattern The pattern to replace.
 * @param aReplacement The thing to replace the pattern with.
 */
SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
  var lastChild = this.children[this.children.length - 1];
  if (lastChild[isSourceNode]) {
    lastChild.replaceRight(aPattern, aReplacement);
  }
  else if (typeof lastChild === 'string') {
    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
  }
  else {
    this.children.push(''.replace(aPattern, aReplacement));
  }
  return this;
};

/**
 * Set the source content for a source file. This will be added to the SourceMapGenerator
 * in the sourcesContent field.
 *
 * @param aSourceFile The filename of the source file
 * @param aSourceContent The content of the source file
 */
SourceNode.prototype.setSourceContent =
  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  };

/**
 * Walk over the tree of SourceNodes. The walking function is called for each
 * source file content and is passed the filename and source content.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walkSourceContents =
  function SourceNode_walkSourceContents(aFn) {
    for (var i = 0, len = this.children.length; i < len; i++) {
      if (this.children[i][isSourceNode]) {
        this.children[i].walkSourceContents(aFn);
      }
    }

    var sources = Object.keys(this.sourceContents);
    for (var i = 0, len = sources.length; i < len; i++) {
      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  };

/**
 * Return the string representation of this source node. Walks over the tree
 * and concatenates all the various snippets together to one string.
 */
SourceNode.prototype.toString = function SourceNode_toString() {
  var str = "";
  this.walk(function (chunk) {
    str += chunk;
  });
  return str;
};

/**
 * Returns the string representation of this source node along with a source
 * map.
 */
SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
  var generated = {
    code: "",
    line: 1,
    column: 0
  };
  var map = new SourceMapGenerator(aArgs);
  var sourceMappingActive = false;
  var lastOriginalSource = null;
  var lastOriginalLine = null;
  var lastOriginalColumn = null;
  var lastOriginalName = null;
  this.walk(function (chunk, original) {
    generated.code += chunk;
    if (original.source !== null
        && original.line !== null
        && original.column !== null) {
      if(lastOriginalSource !== original.source
         || lastOriginalLine !== original.line
         || lastOriginalColumn !== original.column
         || lastOriginalName !== original.name) {
        map.addMapping({
          source: original.source,
          original: {
            line: original.line,
            column: original.column
          },
          generated: {
            line: generated.line,
            column: generated.column
          },
          name: original.name
        });
      }
      lastOriginalSource = original.source;
      lastOriginalLine = original.line;
      lastOriginalColumn = original.column;
      lastOriginalName = original.name;
      sourceMappingActive = true;
    } else if (sourceMappingActive) {
      map.addMapping({
        generated: {
          line: generated.line,
          column: generated.column
        }
      });
      lastOriginalSource = null;
      sourceMappingActive = false;
    }
    for (var idx = 0, length = chunk.length; idx < length; idx++) {
      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
        generated.line++;
        generated.column = 0;
        // Mappings end at eol
        if (idx + 1 === length) {
          lastOriginalSource = null;
          sourceMappingActive = false;
        } else if (sourceMappingActive) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
      } else {
        generated.column++;
      }
    }
  });
  this.walkSourceContents(function (sourceFile, sourceContent) {
    map.setSourceContent(sourceFile, sourceContent);
  });

  return { code: generated.code, map: map };
};

exports.SourceNode = SourceNode;

},{"./source-map-generator":14,"./util":16}],16:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */
function getArg(aArgs, aName, aDefaultValue) {
  if (aName in aArgs) {
    return aArgs[aName];
  } else if (arguments.length === 3) {
    return aDefaultValue;
  } else {
    throw new Error('"' + aName + '" is a required argument.');
  }
}
exports.getArg = getArg;

var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
var dataUrlRegexp = /^data:.+\,.+$/;

function urlParse(aUrl) {
  var match = aUrl.match(urlRegexp);
  if (!match) {
    return null;
  }
  return {
    scheme: match[1],
    auth: match[2],
    host: match[3],
    port: match[4],
    path: match[5]
  };
}
exports.urlParse = urlParse;

function urlGenerate(aParsedUrl) {
  var url = '';
  if (aParsedUrl.scheme) {
    url += aParsedUrl.scheme + ':';
  }
  url += '//';
  if (aParsedUrl.auth) {
    url += aParsedUrl.auth + '@';
  }
  if (aParsedUrl.host) {
    url += aParsedUrl.host;
  }
  if (aParsedUrl.port) {
    url += ":" + aParsedUrl.port
  }
  if (aParsedUrl.path) {
    url += aParsedUrl.path;
  }
  return url;
}
exports.urlGenerate = urlGenerate;

/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */
function normalize(aPath) {
  var path = aPath;
  var url = urlParse(aPath);
  if (url) {
    if (!url.path) {
      return aPath;
    }
    path = url.path;
  }
  var isAbsolute = exports.isAbsolute(path);

  var parts = path.split(/\/+/);
  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
    part = parts[i];
    if (part === '.') {
      parts.splice(i, 1);
    } else if (part === '..') {
      up++;
    } else if (up > 0) {
      if (part === '') {
        // The first part is blank if the path is absolute. Trying to go
        // above the root is a no-op. Therefore we can remove all '..' parts
        // directly after the root.
        parts.splice(i + 1, up);
        up = 0;
      } else {
        parts.splice(i, 2);
        up--;
      }
    }
  }
  path = parts.join('/');

  if (path === '') {
    path = isAbsolute ? '/' : '.';
  }

  if (url) {
    url.path = path;
    return urlGenerate(url);
  }
  return path;
}
exports.normalize = normalize;

/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */
function join(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }
  if (aPath === "") {
    aPath = ".";
  }
  var aPathUrl = urlParse(aPath);
  var aRootUrl = urlParse(aRoot);
  if (aRootUrl) {
    aRoot = aRootUrl.path || '/';
  }

  // `join(foo, '//www.example.org')`
  if (aPathUrl && !aPathUrl.scheme) {
    if (aRootUrl) {
      aPathUrl.scheme = aRootUrl.scheme;
    }
    return urlGenerate(aPathUrl);
  }

  if (aPathUrl || aPath.match(dataUrlRegexp)) {
    return aPath;
  }

  // `join('http://', 'www.example.com')`
  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
    aRootUrl.host = aPath;
    return urlGenerate(aRootUrl);
  }

  var joined = aPath.charAt(0) === '/'
    ? aPath
    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

  if (aRootUrl) {
    aRootUrl.path = joined;
    return urlGenerate(aRootUrl);
  }
  return joined;
}
exports.join = join;

exports.isAbsolute = function (aPath) {
  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
};

/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */
function relative(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }

  aRoot = aRoot.replace(/\/$/, '');

  // It is possible for the path to be above the root. In this case, simply
  // checking whether the root is a prefix of the path won't work. Instead, we
  // need to remove components from the root one by one, until either we find
  // a prefix that fits, or we run out of components to remove.
  var level = 0;
  while (aPath.indexOf(aRoot + '/') !== 0) {
    var index = aRoot.lastIndexOf("/");
    if (index < 0) {
      return aPath;
    }

    // If the only part of the root that is left is the scheme (i.e. http://,
    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
    // have exhausted all components, so the path is not relative to the root.
    aRoot = aRoot.slice(0, index);
    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
      return aPath;
    }

    ++level;
  }

  // Make sure we add a "../" for each component we removed from the root.
  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}
exports.relative = relative;

var supportsNullProto = (function () {
  var obj = Object.create(null);
  return !('__proto__' in obj);
}());

function identity (s) {
  return s;
}

/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */
function toSetString(aStr) {
  if (isProtoString(aStr)) {
    return '$' + aStr;
  }

  return aStr;
}
exports.toSetString = supportsNullProto ? identity : toSetString;

function fromSetString(aStr) {
  if (isProtoString(aStr)) {
    return aStr.slice(1);
  }

  return aStr;
}
exports.fromSetString = supportsNullProto ? identity : fromSetString;

function isProtoString(s) {
  if (!s) {
    return false;
  }

  var length = s.length;

  if (length < 9 /* "__proto__".length */) {
    return false;
  }

  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
      s.charCodeAt(length - 9) !== 95  /* '_' */) {
    return false;
  }

  for (var i = length - 10; i >= 0; i--) {
    if (s.charCodeAt(i) !== 36 /* '$' */) {
      return false;
    }
  }

  return true;
}

/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */
function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
  var cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0 || onlyCompareOriginal) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByOriginalPositions = compareByOriginalPositions;

/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */
function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0 || onlyCompareGenerated) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

function strcmp(aStr1, aStr2) {
  if (aStr1 === aStr2) {
    return 0;
  }

  if (aStr1 === null) {
    return 1; // aStr2 !== null
  }

  if (aStr2 === null) {
    return -1; // aStr1 !== null
  }

  if (aStr1 > aStr2) {
    return 1;
  }

  return -1;
}

/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */
function compareByGeneratedPositionsInflated(mappingA, mappingB) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

/**
 * Strip any JSON XSSI avoidance prefix from the string (as documented
 * in the source maps specification), and then parse the string as
 * JSON.
 */
function parseSourceMapInput(str) {
  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
}
exports.parseSourceMapInput = parseSourceMapInput;

/**
 * Compute the URL of a source given the the source root, the source's
 * URL, and the source map's URL.
 */
function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
  sourceURL = sourceURL || '';

  if (sourceRoot) {
    // This follows what Chrome does.
    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
      sourceRoot += '/';
    }
    // The spec says:
    //   Line 4: An optional source root, useful for relocating source
    //   files on a server or removing repeated values in the
    //   sources entry.  This value is prepended to the individual
    //   entries in the source field.
    sourceURL = sourceRoot + sourceURL;
  }

  // Historically, SourceMapConsumer did not take the sourceMapURL as
  // a parameter.  This mode is still somewhat supported, which is why
  // this code block is conditional.  However, it's preferable to pass
  // the source map URL to SourceMapConsumer, so that this function
  // can implement the source URL resolution algorithm as outlined in
  // the spec.  This block is basically the equivalent of:
  //    new URL(sourceURL, sourceMapURL).toString()
  // ... except it avoids using URL, which wasn't available in the
  // older releases of node still supported by this library.
  //
  // The spec says:
  //   If the sources are not absolute URLs after prepending of the
  //   sourceRoot, the sources are resolved relative to the
  //   SourceMap (like resolving script src in a html document).
  if (sourceMapURL) {
    var parsed = urlParse(sourceMapURL);
    if (!parsed) {
      throw new Error("sourceMapURL could not be parsed");
    }
    if (parsed.path) {
      // Strip the last path component, but keep the "/".
      var index = parsed.path.lastIndexOf('/');
      if (index >= 0) {
        parsed.path = parsed.path.substring(0, index + 1);
      }
    }
    sourceURL = join(urlGenerate(parsed), sourceURL);
  }

  return normalize(sourceURL);
}
exports.computeSourceURL = computeSourceURL;

},{}],17:[function(require,module,exports){
/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = require('./lib/source-map-generator').SourceMapGenerator;
exports.SourceMapConsumer = require('./lib/source-map-consumer').SourceMapConsumer;
exports.SourceNode = require('./lib/source-node').SourceNode;

},{"./lib/source-map-consumer":13,"./lib/source-map-generator":14,"./lib/source-node":15}],18:[function(require,module,exports){
module.exports={
  "_from": "escodegen@^1.8.x",
  "_id": "escodegen@1.11.0",
  "_inBundle": false,
  "_integrity": "sha512-IeMV45ReixHS53K/OmfKAIztN/igDHzTJUhZM3k1jMhIZWjk45SMwAtBsEXiJp3vSPmTcu6CXn7mDvFHRN66fw==",
  "_location": "/escodegen",
  "_phantomChildren": {},
  "_requested": {
    "type": "range",
    "registry": true,
    "raw": "escodegen@^1.8.x",
    "name": "escodegen",
    "escapedName": "escodegen",
    "rawSpec": "^1.8.x",
    "saveSpec": null,
    "fetchSpec": "^1.8.x"
  },
  "_requiredBy": [
    "#USER",
    "/",
    "/static-eval"
  ],
  "_resolved": "https://registry.npmjs.org/escodegen/-/escodegen-1.11.0.tgz",
  "_shasum": "b27a9389481d5bfd5bec76f7bb1eb3f8f4556589",
  "_spec": "escodegen@^1.8.x",
  "_where": "/data/chalmers/project/jsflow",
  "bin": {
    "esgenerate": "./bin/esgenerate.js",
    "escodegen": "./bin/escodegen.js"
  },
  "bugs": {
    "url": "https://github.com/estools/escodegen/issues"
  },
  "bundleDependencies": false,
  "dependencies": {
    "esprima": "^3.1.3",
    "estraverse": "^4.2.0",
    "esutils": "^2.0.2",
    "optionator": "^0.8.1",
    "source-map": "~0.6.1"
  },
  "deprecated": false,
  "description": "ECMAScript code generator",
  "devDependencies": {
    "acorn": "^4.0.4",
    "bluebird": "^3.4.7",
    "bower-registry-client": "^1.0.0",
    "chai": "^3.5.0",
    "commonjs-everywhere": "^0.9.7",
    "gulp": "^3.8.10",
    "gulp-eslint": "^3.0.1",
    "gulp-mocha": "^3.0.1",
    "semver": "^5.1.0"
  },
  "engines": {
    "node": ">=4.0"
  },
  "files": [
    "LICENSE.BSD",
    "README.md",
    "bin",
    "escodegen.js",
    "package.json"
  ],
  "homepage": "http://github.com/estools/escodegen",
  "license": "BSD-2-Clause",
  "main": "escodegen.js",
  "maintainers": [
    {
      "name": "Yusuke Suzuki",
      "email": "utatane.tea@gmail.com",
      "url": "http://github.com/Constellation"
    }
  ],
  "name": "escodegen",
  "optionalDependencies": {
    "source-map": "~0.6.1"
  },
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/estools/escodegen.git"
  },
  "scripts": {
    "build": "cjsify -a path: tools/entry-point.js > escodegen.browser.js",
    "build-min": "cjsify -ma path: tools/entry-point.js > escodegen.browser.min.js",
    "lint": "gulp lint",
    "release": "node tools/release.js",
    "test": "gulp travis",
    "unit-test": "gulp test"
  },
  "version": "1.11.0"
}

},{}],19:[function(require,module,exports){
/*
  Copyright (c) jQuery Foundation, Inc. and Contributors, All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function (root, factory) {
    'use strict';

    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
    // Rhino, and plain browser loading.

    /* istanbul ignore next */
    if (typeof define === 'function' && define.amd) {
        define(['exports'], factory);
    } else if (typeof exports !== 'undefined') {
        factory(exports);
    } else {
        factory((root.esprima = {}));
    }
}(this, function (exports) {
    'use strict';

    var Token,
        TokenName,
        FnExprTokens,
        Syntax,
        PlaceHolders,
        Messages,
        Regex,
        source,
        strict,
        index,
        lineNumber,
        lineStart,
        hasLineTerminator,
        lastIndex,
        lastLineNumber,
        lastLineStart,
        startIndex,
        startLineNumber,
        startLineStart,
        scanning,
        length,
        lookahead,
        state,
        extra,
        isBindingElement,
        isAssignmentTarget,
        firstCoverInitializedNameError;

    Token = {
        BooleanLiteral: 1,
        EOF: 2,
        Identifier: 3,
        Keyword: 4,
        NullLiteral: 5,
        NumericLiteral: 6,
        Punctuator: 7,
        StringLiteral: 8,
        RegularExpression: 9,
        Template: 10
    };

    TokenName = {};
    TokenName[Token.BooleanLiteral] = 'Boolean';
    TokenName[Token.EOF] = '<end>';
    TokenName[Token.Identifier] = 'Identifier';
    TokenName[Token.Keyword] = 'Keyword';
    TokenName[Token.NullLiteral] = 'Null';
    TokenName[Token.NumericLiteral] = 'Numeric';
    TokenName[Token.Punctuator] = 'Punctuator';
    TokenName[Token.StringLiteral] = 'String';
    TokenName[Token.RegularExpression] = 'RegularExpression';
    TokenName[Token.Template] = 'Template';

    // A function following one of those tokens is an expression.
    FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',
                    'return', 'case', 'delete', 'throw', 'void',
                    // assignment operators
                    '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=',
                    '&=', '|=', '^=', ',',
                    // binary/unary operators
                    '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&',
                    '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',
                    '<=', '<', '>', '!=', '!=='];

    Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        AssignmentPattern: 'AssignmentPattern',
        ArrayExpression: 'ArrayExpression',
        ArrayPattern: 'ArrayPattern',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ClassBody: 'ClassBody',
        ClassDeclaration: 'ClassDeclaration',
        ClassExpression: 'ClassExpression',
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DoWhileStatement: 'DoWhileStatement',
        DebuggerStatement: 'DebuggerStatement',
        EmptyStatement: 'EmptyStatement',
        ExportAllDeclaration: 'ExportAllDeclaration',
        ExportDefaultDeclaration: 'ExportDefaultDeclaration',
        ExportNamedDeclaration: 'ExportNamedDeclaration',
        ExportSpecifier: 'ExportSpecifier',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForOfStatement: 'ForOfStatement',
        ForInStatement: 'ForInStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        ImportDeclaration: 'ImportDeclaration',
        ImportDefaultSpecifier: 'ImportDefaultSpecifier',
        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
        ImportSpecifier: 'ImportSpecifier',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        MetaProperty: 'MetaProperty',
        MethodDefinition: 'MethodDefinition',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        ObjectPattern: 'ObjectPattern',
        Program: 'Program',
        Property: 'Property',
        RestElement: 'RestElement',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SpreadElement: 'SpreadElement',
        Super: 'Super',
        SwitchCase: 'SwitchCase',
        SwitchStatement: 'SwitchStatement',
        TaggedTemplateExpression: 'TaggedTemplateExpression',
        TemplateElement: 'TemplateElement',
        TemplateLiteral: 'TemplateLiteral',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement',
        YieldExpression: 'YieldExpression'
    };

    PlaceHolders = {
        ArrowParameterPlaceHolder: 'ArrowParameterPlaceHolder'
    };

    // Error messages should be identical to V8.
    Messages = {
        UnexpectedToken: 'Unexpected token %0',
        UnexpectedNumber: 'Unexpected number',
        UnexpectedString: 'Unexpected string',
        UnexpectedIdentifier: 'Unexpected identifier',
        UnexpectedReserved: 'Unexpected reserved word',
        UnexpectedTemplate: 'Unexpected quasi %0',
        UnexpectedEOS: 'Unexpected end of input',
        NewlineAfterThrow: 'Illegal newline after throw',
        InvalidRegExp: 'Invalid regular expression',
        UnterminatedRegExp: 'Invalid regular expression: missing /',
        InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
        InvalidLHSInForIn: 'Invalid left-hand side in for-in',
        InvalidLHSInForLoop: 'Invalid left-hand side in for-loop',
        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
        NoCatchOrFinally: 'Missing catch or finally after try',
        UnknownLabel: 'Undefined label \'%0\'',
        Redeclaration: '%0 \'%1\' has already been declared',
        IllegalContinue: 'Illegal continue statement',
        IllegalBreak: 'Illegal break statement',
        IllegalReturn: 'Illegal return statement',
        StrictModeWith: 'Strict mode code may not include a with statement',
        StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
        StrictVarName: 'Variable name may not be eval or arguments in strict mode',
        StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
        StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
        StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
        StrictDelete: 'Delete of an unqualified identifier in strict mode.',
        StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
        StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
        StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
        StrictReservedWord: 'Use of future reserved word in strict mode',
        TemplateOctalLiteral: 'Octal literals are not allowed in template strings.',
        ParameterAfterRestParameter: 'Rest parameter must be last formal parameter',
        DefaultRestParameter: 'Unexpected token =',
        ObjectPatternAsRestParameter: 'Unexpected token {',
        DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals',
        ConstructorSpecialMethod: 'Class constructor may not be an accessor',
        DuplicateConstructor: 'A class may only have one constructor',
        StaticPrototype: 'Classes may not have static property named prototype',
        MissingFromClause: 'Unexpected token',
        NoAsAfterImportNamespace: 'Unexpected token',
        InvalidModuleSpecifier: 'Unexpected token',
        IllegalImportDeclaration: 'Unexpected token',
        IllegalExportDeclaration: 'Unexpected token',
        DuplicateBinding: 'Duplicate binding %0'
    };

    // See also tools/generate-unicode-regex.js.
    Regex = {
        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierStart:
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/,

        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierPart:
        NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDD0-\uDDDA\uDE00-\uDE11\uDE13-\uDE37\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF01-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
    };

    // Ensure the condition is true, otherwise throw an error.
    // This is only to have a better contract semantic, i.e. another safety net
    // to catch a logic error. The condition shall be fulfilled in normal case.
    // Do NOT use this to enforce a certain condition on any user input.

    function assert(condition, message) {
        /* istanbul ignore if */
        if (!condition) {
            throw new Error('ASSERT: ' + message);
        }
    }

    function isDecimalDigit(ch) {
        return (ch >= 0x30 && ch <= 0x39);   // 0..9
    }

    function isHexDigit(ch) {
        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;
    }

    function isOctalDigit(ch) {
        return '01234567'.indexOf(ch) >= 0;
    }

    function octalToDecimal(ch) {
        // \0 is not octal escape sequence
        var octal = (ch !== '0'), code = '01234567'.indexOf(ch);

        if (index < length && isOctalDigit(source[index])) {
            octal = true;
            code = code * 8 + '01234567'.indexOf(source[index++]);

            // 3 digits are only allowed when string starts
            // with 0, 1, 2, 3
            if ('0123'.indexOf(ch) >= 0 &&
                    index < length &&
                    isOctalDigit(source[index])) {
                code = code * 8 + '01234567'.indexOf(source[index++]);
            }
        }

        return {
            code: code,
            octal: octal
        };
    }

    // ECMA-262 11.2 White Space

    function isWhiteSpace(ch) {
        return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||
            (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);
    }

    // ECMA-262 11.3 Line Terminators

    function isLineTerminator(ch) {
        return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);
    }

    // ECMA-262 11.6 Identifier Names and Identifiers

    function fromCodePoint(cp) {
        return (cp < 0x10000) ? String.fromCharCode(cp) :
            String.fromCharCode(0xD800 + ((cp - 0x10000) >> 10)) +
            String.fromCharCode(0xDC00 + ((cp - 0x10000) & 1023));
    }

    function isIdentifierStart(ch) {
        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)
            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z
            (ch >= 0x61 && ch <= 0x7A) ||         // a..z
            (ch === 0x5C) ||                      // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch)));
    }

    function isIdentifierPart(ch) {
        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)
            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z
            (ch >= 0x61 && ch <= 0x7A) ||         // a..z
            (ch >= 0x30 && ch <= 0x39) ||         // 0..9
            (ch === 0x5C) ||                      // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch)));
    }

    // ECMA-262 11.6.2.2 Future Reserved Words

    function isFutureReservedWord(id) {
        switch (id) {
        case 'enum':
        case 'export':
        case 'import':
        case 'super':
            return true;
        default:
            return false;
        }
    }

    function isStrictModeReservedWord(id) {
        switch (id) {
        case 'implements':
        case 'interface':
        case 'package':
        case 'private':
        case 'protected':
        case 'public':
        case 'static':
        case 'yield':
        case 'let':
            return true;
        default:
            return false;
        }
    }

    function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
    }

    // ECMA-262 11.6.2.1 Keywords

    function isKeyword(id) {
        switch (id.length) {
        case 2:
            return (id === 'if') || (id === 'in') || (id === 'do');
        case 3:
            return (id === 'var') || (id === 'for') || (id === 'new') ||
                (id === 'try') || (id === 'let');
        case 4:
            return (id === 'this') || (id === 'else') || (id === 'case') ||
                (id === 'void') || (id === 'with') || (id === 'enum');
        case 5:
            return (id === 'while') || (id === 'break') || (id === 'catch') ||
                (id === 'throw') || (id === 'const') || (id === 'yield') ||
                (id === 'class') || (id === 'super');
        case 6:
            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
                (id === 'switch') || (id === 'export') || (id === 'import');
        case 7:
            return (id === 'default') || (id === 'finally') || (id === 'extends');
        case 8:
            return (id === 'function') || (id === 'continue') || (id === 'debugger');
        case 10:
            return (id === 'instanceof');
        default:
            return false;
        }
    }

    // ECMA-262 11.4 Comments

    function addComment(type, value, start, end, loc) {
        var comment;

        assert(typeof start === 'number', 'Comment must have valid position');

        state.lastCommentStart = start;

        comment = {
            type: type,
            value: value
        };
        if (extra.range) {
            comment.range = [start, end];
        }
        if (extra.loc) {
            comment.loc = loc;
        }
        extra.comments.push(comment);
        if (extra.attachComment) {
            extra.leadingComments.push(comment);
            extra.trailingComments.push(comment);
        }
        if (extra.tokenize) {
            comment.type = comment.type + 'Comment';
            if (extra.delegate) {
                comment = extra.delegate(comment);
            }
            extra.tokens.push(comment);
        }
    }

    function skipSingleLineComment(offset) {
        var start, loc, ch, comment;

        start = index - offset;
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart - offset
            }
        };

        while (index < length) {
            ch = source.charCodeAt(index);
            ++index;
            if (isLineTerminator(ch)) {
                hasLineTerminator = true;
                if (extra.comments) {
                    comment = source.slice(start + offset, index - 1);
                    loc.end = {
                        line: lineNumber,
                        column: index - lineStart - 1
                    };
                    addComment('Line', comment, start, index - 1, loc);
                }
                if (ch === 13 && source.charCodeAt(index) === 10) {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
                return;
            }
        }

        if (extra.comments) {
            comment = source.slice(start + offset, index);
            loc.end = {
                line: lineNumber,
                column: index - lineStart
            };
            addComment('Line', comment, start, index, loc);
        }
    }

    function skipMultiLineComment() {
        var start, loc, ch, comment;

        if (extra.comments) {
            start = index - 2;
            loc = {
                start: {
                    line: lineNumber,
                    column: index - lineStart - 2
                }
            };
        }

        while (index < length) {
            ch = source.charCodeAt(index);
            if (isLineTerminator(ch)) {
                if (ch === 0x0D && source.charCodeAt(index + 1) === 0x0A) {
                    ++index;
                }
                hasLineTerminator = true;
                ++lineNumber;
                ++index;
                lineStart = index;
            } else if (ch === 0x2A) {
                // Block comment ends with '*/'.
                if (source.charCodeAt(index + 1) === 0x2F) {
                    ++index;
                    ++index;
                    if (extra.comments) {
                        comment = source.slice(start + 2, index - 2);
                        loc.end = {
                            line: lineNumber,
                            column: index - lineStart
                        };
                        addComment('Block', comment, start, index, loc);
                    }
                    return;
                }
                ++index;
            } else {
                ++index;
            }
        }

        // Ran off the end of the file - the whole thing is a comment
        if (extra.comments) {
            loc.end = {
                line: lineNumber,
                column: index - lineStart
            };
            comment = source.slice(start + 2, index);
            addComment('Block', comment, start, index, loc);
        }
        tolerateUnexpectedToken();
    }

    function skipComment() {
        var ch, start;
        hasLineTerminator = false;

        start = (index === 0);
        while (index < length) {
            ch = source.charCodeAt(index);

            if (isWhiteSpace(ch)) {
                ++index;
            } else if (isLineTerminator(ch)) {
                hasLineTerminator = true;
                ++index;
                if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
                start = true;
            } else if (ch === 0x2F) { // U+002F is '/'
                ch = source.charCodeAt(index + 1);
                if (ch === 0x2F) {
                    ++index;
                    ++index;
                    skipSingleLineComment(2);
                    start = true;
                } else if (ch === 0x2A) {  // U+002A is '*'
                    ++index;
                    ++index;
                    skipMultiLineComment();
                } else {
                    break;
                }
            } else if (start && ch === 0x2D) { // U+002D is '-'
                // U+003E is '>'
                if ((source.charCodeAt(index + 1) === 0x2D) && (source.charCodeAt(index + 2) === 0x3E)) {
                    // '-->' is a single-line comment
                    index += 3;
                    skipSingleLineComment(3);
                } else {
                    break;
                }
            } else if (ch === 0x3C) { // U+003C is '<'
                if (source.slice(index + 1, index + 4) === '!--') {
                    ++index; // `<`
                    ++index; // `!`
                    ++index; // `-`
                    ++index; // `-`
                    skipSingleLineComment(4);
                } else {
                    break;
                }
            } else {
                break;
            }
        }
    }

    function scanHexEscape(prefix) {
        var i, len, ch, code = 0;

        len = (prefix === 'u') ? 4 : 2;
        for (i = 0; i < len; ++i) {
            if (index < length && isHexDigit(source[index])) {
                ch = source[index++];
                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
            } else {
                return '';
            }
        }
        return String.fromCharCode(code);
    }

    function scanUnicodeCodePointEscape() {
        var ch, code;

        ch = source[index];
        code = 0;

        // At least, one hex digit is required.
        if (ch === '}') {
            throwUnexpectedToken();
        }

        while (index < length) {
            ch = source[index++];
            if (!isHexDigit(ch)) {
                break;
            }
            code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
        }

        if (code > 0x10FFFF || ch !== '}') {
            throwUnexpectedToken();
        }

        return fromCodePoint(code);
    }

    function codePointAt(i) {
        var cp, first, second;

        cp = source.charCodeAt(i);
        if (cp >= 0xD800 && cp <= 0xDBFF) {
            second = source.charCodeAt(i + 1);
            if (second >= 0xDC00 && second <= 0xDFFF) {
                first = cp;
                cp = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
            }
        }

        return cp;
    }

    function getComplexIdentifier() {
        var cp, ch, id;

        cp = codePointAt(index);
        id = fromCodePoint(cp);
        index += id.length;

        // '\u' (U+005C, U+0075) denotes an escaped character.
        if (cp === 0x5C) {
            if (source.charCodeAt(index) !== 0x75) {
                throwUnexpectedToken();
            }
            ++index;
            if (source[index] === '{') {
                ++index;
                ch = scanUnicodeCodePointEscape();
            } else {
                ch = scanHexEscape('u');
                cp = ch.charCodeAt(0);
                if (!ch || ch === '\\' || !isIdentifierStart(cp)) {
                    throwUnexpectedToken();
                }
            }
            id = ch;
        }

        while (index < length) {
            cp = codePointAt(index);
            if (!isIdentifierPart(cp)) {
                break;
            }
            ch = fromCodePoint(cp);
            id += ch;
            index += ch.length;

            // '\u' (U+005C, U+0075) denotes an escaped character.
            if (cp === 0x5C) {
                id = id.substr(0, id.length - 1);
                if (source.charCodeAt(index) !== 0x75) {
                    throwUnexpectedToken();
                }
                ++index;
                if (source[index] === '{') {
                    ++index;
                    ch = scanUnicodeCodePointEscape();
                } else {
                    ch = scanHexEscape('u');
                    cp = ch.charCodeAt(0);
                    if (!ch || ch === '\\' || !isIdentifierPart(cp)) {
                        throwUnexpectedToken();
                    }
                }
                id += ch;
            }
        }

        return id;
    }

    function getIdentifier() {
        var start, ch;

        start = index++;
        while (index < length) {
            ch = source.charCodeAt(index);
            if (ch === 0x5C) {
                // Blackslash (U+005C) marks Unicode escape sequence.
                index = start;
                return getComplexIdentifier();
            } else if (ch >= 0xD800 && ch < 0xDFFF) {
                // Need to handle surrogate pairs.
                index = start;
                return getComplexIdentifier();
            }
            if (isIdentifierPart(ch)) {
                ++index;
            } else {
                break;
            }
        }

        return source.slice(start, index);
    }

    function scanIdentifier() {
        var start, id, type;

        start = index;

        // Backslash (U+005C) starts an escaped character.
        id = (source.charCodeAt(index) === 0x5C) ? getComplexIdentifier() : getIdentifier();

        // There is no keyword or literal with only one character.
        // Thus, it must be an identifier.
        if (id.length === 1) {
            type = Token.Identifier;
        } else if (isKeyword(id)) {
            type = Token.Keyword;
        } else if (id === 'null') {
            type = Token.NullLiteral;
        } else if (id === 'true' || id === 'false') {
            type = Token.BooleanLiteral;
        } else {
            type = Token.Identifier;
        }

        return {
            type: type,
            value: id,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }


    // ECMA-262 11.7 Punctuators

    function scanPunctuator() {
        var token, str;

        token = {
            type: Token.Punctuator,
            value: '',
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: index,
            end: index
        };

        // Check for most common single-character punctuators.
        str = source[index];
        switch (str) {

        case '(':
            if (extra.tokenize) {
                extra.openParenToken = extra.tokenValues.length;
            }
            ++index;
            break;

        case '{':
            if (extra.tokenize) {
                extra.openCurlyToken = extra.tokenValues.length;
            }
            state.curlyStack.push('{');
            ++index;
            break;

        case '.':
            ++index;
            if (source[index] === '.' && source[index + 1] === '.') {
                // Spread operator: ...
                index += 2;
                str = '...';
            }
            break;

        case '}':
            ++index;
            state.curlyStack.pop();
            break;
        case ')':
        case ';':
        case ',':
        case '[':
        case ']':
        case ':':
        case '?':
        case '~':
            ++index;
            break;

        default:
            // 4-character punctuator.
            str = source.substr(index, 4);
            if (str === '>>>=') {
                index += 4;
            } else {

                // 3-character punctuators.
                str = str.substr(0, 3);
                if (str === '===' || str === '!==' || str === '>>>' ||
                    str === '<<=' || str === '>>=') {
                    index += 3;
                } else {

                    // 2-character punctuators.
                    str = str.substr(0, 2);
                    if (str === '&&' || str === '||' || str === '==' || str === '!=' ||
                        str === '+=' || str === '-=' || str === '*=' || str === '/=' ||
                        str === '++' || str === '--' || str === '<<' || str === '>>' ||
                        str === '&=' || str === '|=' || str === '^=' || str === '%=' ||
                        str === '<=' || str === '>=' || str === '=>') {
                        index += 2;
                    } else {

                        // 1-character punctuators.
                        str = source[index];
                        if ('<>=!+-*%&|^/'.indexOf(str) >= 0) {
                            ++index;
                        }
                    }
                }
            }
        }

        if (index === token.start) {
            throwUnexpectedToken();
        }

        token.end = index;
        token.value = str;
        return token;
    }

    // ECMA-262 11.8.3 Numeric Literals

    function scanHexLiteral(start) {
        var number = '';

        while (index < length) {
            if (!isHexDigit(source[index])) {
                break;
            }
            number += source[index++];
        }

        if (number.length === 0) {
            throwUnexpectedToken();
        }

        if (isIdentifierStart(source.charCodeAt(index))) {
            throwUnexpectedToken();
        }

        return {
            type: Token.NumericLiteral,
            value: parseInt('0x' + number, 16),
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    function scanBinaryLiteral(start) {
        var ch, number;

        number = '';

        while (index < length) {
            ch = source[index];
            if (ch !== '0' && ch !== '1') {
                break;
            }
            number += source[index++];
        }

        if (number.length === 0) {
            // only 0b or 0B
            throwUnexpectedToken();
        }

        if (index < length) {
            ch = source.charCodeAt(index);
            /* istanbul ignore else */
            if (isIdentifierStart(ch) || isDecimalDigit(ch)) {
                throwUnexpectedToken();
            }
        }

        return {
            type: Token.NumericLiteral,
            value: parseInt(number, 2),
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    function scanOctalLiteral(prefix, start) {
        var number, octal;

        if (isOctalDigit(prefix)) {
            octal = true;
            number = '0' + source[index++];
        } else {
            octal = false;
            ++index;
            number = '';
        }

        while (index < length) {
            if (!isOctalDigit(source[index])) {
                break;
            }
            number += source[index++];
        }

        if (!octal && number.length === 0) {
            // only 0o or 0O
            throwUnexpectedToken();
        }

        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {
            throwUnexpectedToken();
        }

        return {
            type: Token.NumericLiteral,
            value: parseInt(number, 8),
            octal: octal,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    function isImplicitOctalLiteral() {
        var i, ch;

        // Implicit octal, unless there is a non-octal digit.
        // (Annex B.1.1 on Numeric Literals)
        for (i = index + 1; i < length; ++i) {
            ch = source[i];
            if (ch === '8' || ch === '9') {
                return false;
            }
            if (!isOctalDigit(ch)) {
                return true;
            }
        }

        return true;
    }

    function scanNumericLiteral() {
        var number, start, ch;

        ch = source[index];
        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),
            'Numeric literal must start with a decimal digit or a decimal point');

        start = index;
        number = '';
        if (ch !== '.') {
            number = source[index++];
            ch = source[index];

            // Hex number starts with '0x'.
            // Octal number starts with '0'.
            // Octal number in ES6 starts with '0o'.
            // Binary number in ES6 starts with '0b'.
            if (number === '0') {
                if (ch === 'x' || ch === 'X') {
                    ++index;
                    return scanHexLiteral(start);
                }
                if (ch === 'b' || ch === 'B') {
                    ++index;
                    return scanBinaryLiteral(start);
                }
                if (ch === 'o' || ch === 'O') {
                    return scanOctalLiteral(ch, start);
                }

                if (isOctalDigit(ch)) {
                    if (isImplicitOctalLiteral()) {
                        return scanOctalLiteral(ch, start);
                    }
                }
            }

            while (isDecimalDigit(source.charCodeAt(index))) {
                number += source[index++];
            }
            ch = source[index];
        }

        if (ch === '.') {
            number += source[index++];
            while (isDecimalDigit(source.charCodeAt(index))) {
                number += source[index++];
            }
            ch = source[index];
        }

        if (ch === 'e' || ch === 'E') {
            number += source[index++];

            ch = source[index];
            if (ch === '+' || ch === '-') {
                number += source[index++];
            }
            if (isDecimalDigit(source.charCodeAt(index))) {
                while (isDecimalDigit(source.charCodeAt(index))) {
                    number += source[index++];
                }
            } else {
                throwUnexpectedToken();
            }
        }

        if (isIdentifierStart(source.charCodeAt(index))) {
            throwUnexpectedToken();
        }

        return {
            type: Token.NumericLiteral,
            value: parseFloat(number),
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    // ECMA-262 11.8.4 String Literals

    function scanStringLiteral() {
        var str = '', quote, start, ch, unescaped, octToDec, octal = false;

        quote = source[index];
        assert((quote === '\'' || quote === '"'),
            'String literal must starts with a quote');

        start = index;
        ++index;

        while (index < length) {
            ch = source[index++];

            if (ch === quote) {
                quote = '';
                break;
            } else if (ch === '\\') {
                ch = source[index++];
                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
                    switch (ch) {
                    case 'u':
                    case 'x':
                        if (source[index] === '{') {
                            ++index;
                            str += scanUnicodeCodePointEscape();
                        } else {
                            unescaped = scanHexEscape(ch);
                            if (!unescaped) {
                                throw throwUnexpectedToken();
                            }
                            str += unescaped;
                        }
                        break;
                    case 'n':
                        str += '\n';
                        break;
                    case 'r':
                        str += '\r';
                        break;
                    case 't':
                        str += '\t';
                        break;
                    case 'b':
                        str += '\b';
                        break;
                    case 'f':
                        str += '\f';
                        break;
                    case 'v':
                        str += '\x0B';
                        break;
                    case '8':
                    case '9':
                        str += ch;
                        tolerateUnexpectedToken();
                        break;

                    default:
                        if (isOctalDigit(ch)) {
                            octToDec = octalToDecimal(ch);

                            octal = octToDec.octal || octal;
                            str += String.fromCharCode(octToDec.code);
                        } else {
                            str += ch;
                        }
                        break;
                    }
                } else {
                    ++lineNumber;
                    if (ch === '\r' && source[index] === '\n') {
                        ++index;
                    }
                    lineStart = index;
                }
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                break;
            } else {
                str += ch;
            }
        }

        if (quote !== '') {
            index = start;
            throwUnexpectedToken();
        }

        return {
            type: Token.StringLiteral,
            value: str,
            octal: octal,
            lineNumber: startLineNumber,
            lineStart: startLineStart,
            start: start,
            end: index
        };
    }

    // ECMA-262 11.8.6 Template Literal Lexical Components

    function scanTemplate() {
        var cooked = '', ch, start, rawOffset, terminated, head, tail, restore, unescaped;

        terminated = false;
        tail = false;
        start = index;
        head = (source[index] === '`');
        rawOffset = 2;

        ++index;

        while (index < length) {
            ch = source[index++];
            if (ch === '`') {
                rawOffset = 1;
                tail = true;
                terminated = true;
                break;
            } else if (ch === '$') {
                if (source[index] === '{') {
                    state.curlyStack.push('${');
                    ++index;
                    terminated = true;
                    break;
                }
                cooked += ch;
            } else if (ch === '\\') {
                ch = source[index++];
                if (!isLineTerminator(ch.charCodeAt(0))) {
                    switch (ch) {
                    case 'n':
                        cooked += '\n';
                        break;
                    case 'r':
                        cooked += '\r';
                        break;
                    case 't':
                        cooked += '\t';
                        break;
                    case 'u':
                    case 'x':
                        if (source[index] === '{') {
                            ++index;
                            cooked += scanUnicodeCodePointEscape();
                        } else {
                            restore = index;
                            unescaped = scanHexEscape(ch);
                            if (unescaped) {
                                cooked += unescaped;
                            } else {
                                index = restore;
                                cooked += ch;
                            }
                        }
                        break;
                    case 'b':
                        cooked += '\b';
                        break;
                    case 'f':
                        cooked += '\f';
                        break;
                    case 'v':
                        cooked += '\v';
                        break;

                    default:
                        if (ch === '0') {
                            if (isDecimalDigit(source.charCodeAt(index))) {
                                // Illegal: \01 \02 and so on
                                throwError(Messages.TemplateOctalLiteral);
                            }
                            cooked += '\0';
                        } else if (isOctalDigit(ch)) {
                            // Illegal: \1 \2
                            throwError(Messages.TemplateOctalLiteral);
                        } else {
                            cooked += ch;
                        }
                        break;
                    }
                } else {
                    ++lineNumber;
                    if (ch === '\r' && source[index] === '\n') {
                        ++index;
                    }
                    lineStart = index;
                }
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                ++lineNumber;
                if (ch === '\r' && source[index] === '\n') {
                    ++index;
                }
                lineStart = index;
                cooked += '\n';
            } else {
                cooked += ch;
            }
        }

        if (!terminated) {
            throwUnexpectedToken();
        }

        if (!head) {
            state.curlyStack.pop();
        }

        return {
            type: Token.Template,
            value: {
                cooked: cooked,
                raw: source.slice(start + 1, index - rawOffset)
            },
            head: head,
            tail: tail,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    // ECMA-262 11.8.5 Regular Expression Literals

    function testRegExp(pattern, flags) {
        // The BMP character to use as a replacement for astral symbols when
        // translating an ES6 "u"-flagged pattern to an ES5-compatible
        // approximation.
        // Note: replacing with '\uFFFF' enables false positives in unlikely
        // scenarios. For example, `[\u{1044f}-\u{10440}]` is an invalid
        // pattern that would not be detected by this substitution.
        var astralSubstitute = '\uFFFF',
            tmp = pattern;

        if (flags.indexOf('u') >= 0) {
            tmp = tmp
                // Replace every Unicode escape sequence with the equivalent
                // BMP character or a constant ASCII code point in the case of
                // astral symbols. (See the above note on `astralSubstitute`
                // for more information.)
                .replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function ($0, $1, $2) {
                    var codePoint = parseInt($1 || $2, 16);
                    if (codePoint > 0x10FFFF) {
                        throwUnexpectedToken(null, Messages.InvalidRegExp);
                    }
                    if (codePoint <= 0xFFFF) {
                        return String.fromCharCode(codePoint);
                    }
                    return astralSubstitute;
                })
                // Replace each paired surrogate with a single ASCII symbol to
                // avoid throwing on regular expressions that are only valid in
                // combination with the "u" flag.
                .replace(
                    /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
                    astralSubstitute
                );
        }

        // First, detect invalid regular expressions.
        try {
            RegExp(tmp);
        } catch (e) {
            throwUnexpectedToken(null, Messages.InvalidRegExp);
        }

        // Return a regular expression object for this pattern-flag pair, or
        // `null` in case the current environment doesn't support the flags it
        // uses.
        try {
            return new RegExp(pattern, flags);
        } catch (exception) {
            /* istanbul ignore next */
            return null;
        }
    }

    function scanRegExpBody() {
        var ch, str, classMarker, terminated, body;

        ch = source[index];
        assert(ch === '/', 'Regular expression literal must start with a slash');
        str = source[index++];

        classMarker = false;
        terminated = false;
        while (index < length) {
            ch = source[index++];
            str += ch;
            if (ch === '\\') {
                ch = source[index++];
                // ECMA-262 7.8.5
                if (isLineTerminator(ch.charCodeAt(0))) {
                    throwUnexpectedToken(null, Messages.UnterminatedRegExp);
                }
                str += ch;
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                throwUnexpectedToken(null, Messages.UnterminatedRegExp);
            } else if (classMarker) {
                if (ch === ']') {
                    classMarker = false;
                }
            } else {
                if (ch === '/') {
                    terminated = true;
                    break;
                } else if (ch === '[') {
                    classMarker = true;
                }
            }
        }

        if (!terminated) {
            throwUnexpectedToken(null, Messages.UnterminatedRegExp);
        }

        // Exclude leading and trailing slash.
        body = str.substr(1, str.length - 2);
        return {
            value: body,
            literal: str
        };
    }

    function scanRegExpFlags() {
        var ch, str, flags, restore;

        str = '';
        flags = '';
        while (index < length) {
            ch = source[index];
            if (!isIdentifierPart(ch.charCodeAt(0))) {
                break;
            }

            ++index;
            if (ch === '\\' && index < length) {
                ch = source[index];
                if (ch === 'u') {
                    ++index;
                    restore = index;
                    ch = scanHexEscape('u');
                    if (ch) {
                        flags += ch;
                        for (str += '\\u'; restore < index; ++restore) {
                            str += source[restore];
                        }
                    } else {
                        index = restore;
                        flags += 'u';
                        str += '\\u';
                    }
                    tolerateUnexpectedToken();
                } else {
                    str += '\\';
                    tolerateUnexpectedToken();
                }
            } else {
                flags += ch;
                str += ch;
            }
        }

        return {
            value: flags,
            literal: str
        };
    }

    function scanRegExp() {
        var start, body, flags, value;
        scanning = true;

        lookahead = null;
        skipComment();
        start = index;

        body = scanRegExpBody();
        flags = scanRegExpFlags();
        value = testRegExp(body.value, flags.value);
        scanning = false;
        if (extra.tokenize) {
            return {
                type: Token.RegularExpression,
                value: value,
                regex: {
                    pattern: body.value,
                    flags: flags.value
                },
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }

        return {
            literal: body.literal + flags.literal,
            value: value,
            regex: {
                pattern: body.value,
                flags: flags.value
            },
            start: start,
            end: index
        };
    }

    function collectRegex() {
        var pos, loc, regex, token;

        skipComment();

        pos = index;
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart
            }
        };

        regex = scanRegExp();

        loc.end = {
            line: lineNumber,
            column: index - lineStart
        };

        /* istanbul ignore next */
        if (!extra.tokenize) {
            // Pop the previous token, which is likely '/' or '/='
            if (extra.tokens.length > 0) {
                token = extra.tokens[extra.tokens.length - 1];
                if (token.range[0] === pos && token.type === 'Punctuator') {
                    if (token.value === '/' || token.value === '/=') {
                        extra.tokens.pop();
                    }
                }
            }

            extra.tokens.push({
                type: 'RegularExpression',
                value: regex.literal,
                regex: regex.regex,
                range: [pos, index],
                loc: loc
            });
        }

        return regex;
    }

    function isIdentifierName(token) {
        return token.type === Token.Identifier ||
            token.type === Token.Keyword ||
            token.type === Token.BooleanLiteral ||
            token.type === Token.NullLiteral;
    }

    // Using the following algorithm:
    // https://github.com/mozilla/sweet.js/wiki/design

    function advanceSlash() {
        var regex, previous, check;

        function testKeyword(value) {
            return value && (value.length > 1) && (value[0] >= 'a') && (value[0] <= 'z');
        }

        previous = extra.tokenValues[extra.tokenValues.length - 1];
        regex = (previous !== null);

        switch (previous) {
        case 'this':
        case ']':
            regex = false;
            break;

        case ')':
            check = extra.tokenValues[extra.openParenToken - 1];
            regex = (check === 'if' || check === 'while' || check === 'for' || check === 'with');
            break;

        case '}':
            // Dividing a function by anything makes little sense,
            // but we have to check for that.
            regex = false;
            if (testKeyword(extra.tokenValues[extra.openCurlyToken - 3])) {
                // Anonymous function, e.g. function(){} /42
                check = extra.tokenValues[extra.openCurlyToken - 4];
                regex = check ? (FnExprTokens.indexOf(check) < 0) : false;
            } else if (testKeyword(extra.tokenValues[extra.openCurlyToken - 4])) {
                // Named function, e.g. function f(){} /42/
                check = extra.tokenValues[extra.openCurlyToken - 5];
                regex = check ? (FnExprTokens.indexOf(check) < 0) : true;
            }
        }

        return regex ? collectRegex() : scanPunctuator();
    }

    function advance() {
        var cp, token;

        if (index >= length) {
            return {
                type: Token.EOF,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: index,
                end: index
            };
        }

        cp = source.charCodeAt(index);

        if (isIdentifierStart(cp)) {
            token = scanIdentifier();
            if (strict && isStrictModeReservedWord(token.value)) {
                token.type = Token.Keyword;
            }
            return token;
        }

        // Very common: ( and ) and ;
        if (cp === 0x28 || cp === 0x29 || cp === 0x3B) {
            return scanPunctuator();
        }

        // String literal starts with single quote (U+0027) or double quote (U+0022).
        if (cp === 0x27 || cp === 0x22) {
            return scanStringLiteral();
        }

        // Dot (.) U+002E can also start a floating-point number, hence the need
        // to check the next character.
        if (cp === 0x2E) {
            if (isDecimalDigit(source.charCodeAt(index + 1))) {
                return scanNumericLiteral();
            }
            return scanPunctuator();
        }

        if (isDecimalDigit(cp)) {
            return scanNumericLiteral();
        }

        // Slash (/) U+002F can also start a regex.
        if (extra.tokenize && cp === 0x2F) {
            return advanceSlash();
        }

        // Template literals start with ` (U+0060) for template head
        // or } (U+007D) for template middle or template tail.
        if (cp === 0x60 || (cp === 0x7D && state.curlyStack[state.curlyStack.length - 1] === '${')) {
            return scanTemplate();
        }

        // Possible identifier start in a surrogate pair.
        if (cp >= 0xD800 && cp < 0xDFFF) {
            cp = codePointAt(index);
            if (isIdentifierStart(cp)) {
                return scanIdentifier();
            }
        }

        return scanPunctuator();
    }

    function collectToken() {
        var loc, token, value, entry;

        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart
            }
        };

        token = advance();
        loc.end = {
            line: lineNumber,
            column: index - lineStart
        };

        if (token.type !== Token.EOF) {
            value = source.slice(token.start, token.end);
            entry = {
                type: TokenName[token.type],
                value: value,
                range: [token.start, token.end],
                loc: loc
            };
            if (token.regex) {
                entry.regex = {
                    pattern: token.regex.pattern,
                    flags: token.regex.flags
                };
            }
            if (extra.tokenValues) {
                extra.tokenValues.push((entry.type === 'Punctuator' || entry.type === 'Keyword') ? entry.value : null);
            }
            if (extra.tokenize) {
                if (!extra.range) {
                    delete entry.range;
                }
                if (!extra.loc) {
                    delete entry.loc;
                }
                if (extra.delegate) {
                    entry = extra.delegate(entry);
                }
            }
            extra.tokens.push(entry);
        }

        return token;
    }

    function lex() {
        var token;
        scanning = true;

        lastIndex = index;
        lastLineNumber = lineNumber;
        lastLineStart = lineStart;

        skipComment();

        token = lookahead;

        startIndex = index;
        startLineNumber = lineNumber;
        startLineStart = lineStart;

        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();
        scanning = false;
        return token;
    }

    function peek() {
        scanning = true;

        skipComment();

        lastIndex = index;
        lastLineNumber = lineNumber;
        lastLineStart = lineStart;

        startIndex = index;
        startLineNumber = lineNumber;
        startLineStart = lineStart;

        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();
        scanning = false;
    }

    function Position() {
        this.line = startLineNumber;
        this.column = startIndex - startLineStart;
    }

    function SourceLocation() {
        this.start = new Position();
        this.end = null;
    }

    function WrappingSourceLocation(startToken) {
        this.start = {
            line: startToken.lineNumber,
            column: startToken.start - startToken.lineStart
        };
        this.end = null;
    }

    function Node() {
        if (extra.range) {
            this.range = [startIndex, 0];
        }
        if (extra.loc) {
            this.loc = new SourceLocation();
        }
    }

    function WrappingNode(startToken) {
        if (extra.range) {
            this.range = [startToken.start, 0];
        }
        if (extra.loc) {
            this.loc = new WrappingSourceLocation(startToken);
        }
    }

    WrappingNode.prototype = Node.prototype = {

        processComment: function () {
            var lastChild,
                innerComments,
                leadingComments,
                trailingComments,
                bottomRight = extra.bottomRightStack,
                i,
                comment,
                last = bottomRight[bottomRight.length - 1];

            if (this.type === Syntax.Program) {
                if (this.body.length > 0) {
                    return;
                }
            }
            /**
             * patch innnerComments for properties empty block
             * `function a() {/** comments **\/}`
             */

            if (this.type === Syntax.BlockStatement && this.body.length === 0) {
                innerComments = [];
                for (i = extra.leadingComments.length - 1; i >= 0; --i) {
                    comment = extra.leadingComments[i];
                    if (this.range[1] >= comment.range[1]) {
                        innerComments.unshift(comment);
                        extra.leadingComments.splice(i, 1);
                        extra.trailingComments.splice(i, 1);
                    }
                }
                if (innerComments.length) {
                    this.innerComments = innerComments;
                    //bottomRight.push(this);
                    return;
                }
            }

            if (extra.trailingComments.length > 0) {
                trailingComments = [];
                for (i = extra.trailingComments.length - 1; i >= 0; --i) {
                    comment = extra.trailingComments[i];
                    if (comment.range[0] >= this.range[1]) {
                        trailingComments.unshift(comment);
                        extra.trailingComments.splice(i, 1);
                    }
                }
                extra.trailingComments = [];
            } else {
                if (last && last.trailingComments && last.trailingComments[0].range[0] >= this.range[1]) {
                    trailingComments = last.trailingComments;
                    delete last.trailingComments;
                }
            }

            // Eating the stack.
            while (last && last.range[0] >= this.range[0]) {
                lastChild = bottomRight.pop();
                last = bottomRight[bottomRight.length - 1];
            }

            if (lastChild) {
                if (lastChild.leadingComments) {
                    leadingComments = [];
                    for (i = lastChild.leadingComments.length - 1; i >= 0; --i) {
                        comment = lastChild.leadingComments[i];
                        if (comment.range[1] <= this.range[0]) {
                            leadingComments.unshift(comment);
                            lastChild.leadingComments.splice(i, 1);
                        }
                    }

                    if (!lastChild.leadingComments.length) {
                        lastChild.leadingComments = undefined;
                    }
                }
            } else if (extra.leadingComments.length > 0) {
                leadingComments = [];
                for (i = extra.leadingComments.length - 1; i >= 0; --i) {
                    comment = extra.leadingComments[i];
                    if (comment.range[1] <= this.range[0]) {
                        leadingComments.unshift(comment);
                        extra.leadingComments.splice(i, 1);
                    }
                }
            }


            if (leadingComments && leadingComments.length > 0) {
                this.leadingComments = leadingComments;
            }
            if (trailingComments && trailingComments.length > 0) {
                this.trailingComments = trailingComments;
            }

            bottomRight.push(this);
        },

        finish: function () {
            if (extra.range) {
                this.range[1] = lastIndex;
            }
            if (extra.loc) {
                this.loc.end = {
                    line: lastLineNumber,
                    column: lastIndex - lastLineStart
                };
                if (extra.source) {
                    this.loc.source = extra.source;
                }
            }

            if (extra.attachComment) {
                this.processComment();
            }
        },

        finishArrayExpression: function (elements) {
            this.type = Syntax.ArrayExpression;
            this.elements = elements;
            this.finish();
            return this;
        },

        finishArrayPattern: function (elements) {
            this.type = Syntax.ArrayPattern;
            this.elements = elements;
            this.finish();
            return this;
        },

        finishArrowFunctionExpression: function (params, defaults, body, expression) {
            this.type = Syntax.ArrowFunctionExpression;
            this.id = null;
            this.params = params;
            this.defaults = defaults;
            this.body = body;
            this.generator = false;
            this.expression = expression;
            this.finish();
            return this;
        },

        finishAssignmentExpression: function (operator, left, right) {
            this.type = Syntax.AssignmentExpression;
            this.operator = operator;
            this.left = left;
            this.right = right;
            this.finish();
            return this;
        },

        finishAssignmentPattern: function (left, right) {
            this.type = Syntax.AssignmentPattern;
            this.left = left;
            this.right = right;
            this.finish();
            return this;
        },

        finishBinaryExpression: function (operator, left, right) {
            this.type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression : Syntax.BinaryExpression;
            this.operator = operator;
            this.left = left;
            this.right = right;
            this.finish();
            return this;
        },

        finishBlockStatement: function (body) {
            this.type = Syntax.BlockStatement;
            this.body = body;
            this.finish();
            return this;
        },

        finishBreakStatement: function (label) {
            this.type = Syntax.BreakStatement;
            this.label = label;
            this.finish();
            return this;
        },

        finishCallExpression: function (callee, args) {
            this.type = Syntax.CallExpression;
            this.callee = callee;
            this.arguments = args;
            this.finish();
            return this;
        },

        finishCatchClause: function (param, body) {
            this.type = Syntax.CatchClause;
            this.param = param;
            this.body = body;
            this.finish();
            return this;
        },

        finishClassBody: function (body) {
            this.type = Syntax.ClassBody;
            this.body = body;
            this.finish();
            return this;
        },

        finishClassDeclaration: function (id, superClass, body) {
            this.type = Syntax.ClassDeclaration;
            this.id = id;
            this.superClass = superClass;
            this.body = body;
            this.finish();
            return this;
        },

        finishClassExpression: function (id, superClass, body) {
            this.type = Syntax.ClassExpression;
            this.id = id;
            this.superClass = superClass;
            this.body = body;
            this.finish();
            return this;
        },

        finishConditionalExpression: function (test, consequent, alternate) {
            this.type = Syntax.ConditionalExpression;
            this.test = test;
            this.consequent = consequent;
            this.alternate = alternate;
            this.finish();
            return this;
        },

        finishContinueStatement: function (label) {
            this.type = Syntax.ContinueStatement;
            this.label = label;
            this.finish();
            return this;
        },

        finishDebuggerStatement: function () {
            this.type = Syntax.DebuggerStatement;
            this.finish();
            return this;
        },

        finishDoWhileStatement: function (body, test) {
            this.type = Syntax.DoWhileStatement;
            this.body = body;
            this.test = test;
            this.finish();
            return this;
        },

        finishEmptyStatement: function () {
            this.type = Syntax.EmptyStatement;
            this.finish();
            return this;
        },

        finishExpressionStatement: function (expression) {
            this.type = Syntax.ExpressionStatement;
            this.expression = expression;
            this.finish();
            return this;
        },

        finishForStatement: function (init, test, update, body) {
            this.type = Syntax.ForStatement;
            this.init = init;
            this.test = test;
            this.update = update;
            this.body = body;
            this.finish();
            return this;
        },

        finishForOfStatement: function (left, right, body) {
            this.type = Syntax.ForOfStatement;
            this.left = left;
            this.right = right;
            this.body = body;
            this.finish();
            return this;
        },

        finishForInStatement: function (left, right, body) {
            this.type = Syntax.ForInStatement;
            this.left = left;
            this.right = right;
            this.body = body;
            this.each = false;
            this.finish();
            return this;
        },

        finishFunctionDeclaration: function (id, params, defaults, body, generator) {
            this.type = Syntax.FunctionDeclaration;
            this.id = id;
            this.params = params;
            this.defaults = defaults;
            this.body = body;
            this.generator = generator;
            this.expression = false;
            this.finish();
            return this;
        },

        finishFunctionExpression: function (id, params, defaults, body, generator) {
            this.type = Syntax.FunctionExpression;
            this.id = id;
            this.params = params;
            this.defaults = defaults;
            this.body = body;
            this.generator = generator;
            this.expression = false;
            this.finish();
            return this;
        },

        finishIdentifier: function (name) {
            this.type = Syntax.Identifier;
            this.name = name;
            this.finish();
            return this;
        },

        finishIfStatement: function (test, consequent, alternate) {
            this.type = Syntax.IfStatement;
            this.test = test;
            this.consequent = consequent;
            this.alternate = alternate;
            this.finish();
            return this;
        },

        finishLabeledStatement: function (label, body) {
            this.type = Syntax.LabeledStatement;
            this.label = label;
            this.body = body;
            this.finish();
            return this;
        },

        finishLiteral: function (token) {
            this.type = Syntax.Literal;
            this.value = token.value;
            this.raw = source.slice(token.start, token.end);
            if (token.regex) {
                this.regex = token.regex;
            }
            this.finish();
            return this;
        },

        finishMemberExpression: function (accessor, object, property) {
            this.type = Syntax.MemberExpression;
            this.computed = accessor === '[';
            this.object = object;
            this.property = property;
            this.finish();
            return this;
        },

        finishMetaProperty: function (meta, property) {
            this.type = Syntax.MetaProperty;
            this.meta = meta;
            this.property = property;
            this.finish();
            return this;
        },

        finishNewExpression: function (callee, args) {
            this.type = Syntax.NewExpression;
            this.callee = callee;
            this.arguments = args;
            this.finish();
            return this;
        },

        finishObjectExpression: function (properties) {
            this.type = Syntax.ObjectExpression;
            this.properties = properties;
            this.finish();
            return this;
        },

        finishObjectPattern: function (properties) {
            this.type = Syntax.ObjectPattern;
            this.properties = properties;
            this.finish();
            return this;
        },

        finishPostfixExpression: function (operator, argument) {
            this.type = Syntax.UpdateExpression;
            this.operator = operator;
            this.argument = argument;
            this.prefix = false;
            this.finish();
            return this;
        },

        finishProgram: function (body, sourceType) {
            this.type = Syntax.Program;
            this.body = body;
            this.sourceType = sourceType;
            this.finish();
            return this;
        },

        finishProperty: function (kind, key, computed, value, method, shorthand) {
            this.type = Syntax.Property;
            this.key = key;
            this.computed = computed;
            this.value = value;
            this.kind = kind;
            this.method = method;
            this.shorthand = shorthand;
            this.finish();
            return this;
        },

        finishRestElement: function (argument) {
            this.type = Syntax.RestElement;
            this.argument = argument;
            this.finish();
            return this;
        },

        finishReturnStatement: function (argument) {
            this.type = Syntax.ReturnStatement;
            this.argument = argument;
            this.finish();
            return this;
        },

        finishSequenceExpression: function (expressions) {
            this.type = Syntax.SequenceExpression;
            this.expressions = expressions;
            this.finish();
            return this;
        },

        finishSpreadElement: function (argument) {
            this.type = Syntax.SpreadElement;
            this.argument = argument;
            this.finish();
            return this;
        },

        finishSwitchCase: function (test, consequent) {
            this.type = Syntax.SwitchCase;
            this.test = test;
            this.consequent = consequent;
            this.finish();
            return this;
        },

        finishSuper: function () {
            this.type = Syntax.Super;
            this.finish();
            return this;
        },

        finishSwitchStatement: function (discriminant, cases) {
            this.type = Syntax.SwitchStatement;
            this.discriminant = discriminant;
            this.cases = cases;
            this.finish();
            return this;
        },

        finishTaggedTemplateExpression: function (tag, quasi) {
            this.type = Syntax.TaggedTemplateExpression;
            this.tag = tag;
            this.quasi = quasi;
            this.finish();
            return this;
        },

        finishTemplateElement: function (value, tail) {
            this.type = Syntax.TemplateElement;
            this.value = value;
            this.tail = tail;
            this.finish();
            return this;
        },

        finishTemplateLiteral: function (quasis, expressions) {
            this.type = Syntax.TemplateLiteral;
            this.quasis = quasis;
            this.expressions = expressions;
            this.finish();
            return this;
        },

        finishThisExpression: function () {
            this.type = Syntax.ThisExpression;
            this.finish();
            return this;
        },

        finishThrowStatement: function (argument) {
            this.type = Syntax.ThrowStatement;
            this.argument = argument;
            this.finish();
            return this;
        },

        finishTryStatement: function (block, handler, finalizer) {
            this.type = Syntax.TryStatement;
            this.block = block;
            this.guardedHandlers = [];
            this.handlers = handler ? [handler] : [];
            this.handler = handler;
            this.finalizer = finalizer;
            this.finish();
            return this;
        },

        finishUnaryExpression: function (operator, argument) {
            this.type = (operator === '++' || operator === '--') ? Syntax.UpdateExpression : Syntax.UnaryExpression;
            this.operator = operator;
            this.argument = argument;
            this.prefix = true;
            this.finish();
            return this;
        },

        finishVariableDeclaration: function (declarations) {
            this.type = Syntax.VariableDeclaration;
            this.declarations = declarations;
            this.kind = 'var';
            this.finish();
            return this;
        },

        finishLexicalDeclaration: function (declarations, kind) {
            this.type = Syntax.VariableDeclaration;
            this.declarations = declarations;
            this.kind = kind;
            this.finish();
            return this;
        },

        finishVariableDeclarator: function (id, init) {
            this.type = Syntax.VariableDeclarator;
            this.id = id;
            this.init = init;
            this.finish();
            return this;
        },

        finishWhileStatement: function (test, body) {
            this.type = Syntax.WhileStatement;
            this.test = test;
            this.body = body;
            this.finish();
            return this;
        },

        finishWithStatement: function (object, body) {
            this.type = Syntax.WithStatement;
            this.object = object;
            this.body = body;
            this.finish();
            return this;
        },

        finishExportSpecifier: function (local, exported) {
            this.type = Syntax.ExportSpecifier;
            this.exported = exported || local;
            this.local = local;
            this.finish();
            return this;
        },

        finishImportDefaultSpecifier: function (local) {
            this.type = Syntax.ImportDefaultSpecifier;
            this.local = local;
            this.finish();
            return this;
        },

        finishImportNamespaceSpecifier: function (local) {
            this.type = Syntax.ImportNamespaceSpecifier;
            this.local = local;
            this.finish();
            return this;
        },

        finishExportNamedDeclaration: function (declaration, specifiers, src) {
            this.type = Syntax.ExportNamedDeclaration;
            this.declaration = declaration;
            this.specifiers = specifiers;
            this.source = src;
            this.finish();
            return this;
        },

        finishExportDefaultDeclaration: function (declaration) {
            this.type = Syntax.ExportDefaultDeclaration;
            this.declaration = declaration;
            this.finish();
            return this;
        },

        finishExportAllDeclaration: function (src) {
            this.type = Syntax.ExportAllDeclaration;
            this.source = src;
            this.finish();
            return this;
        },

        finishImportSpecifier: function (local, imported) {
            this.type = Syntax.ImportSpecifier;
            this.local = local || imported;
            this.imported = imported;
            this.finish();
            return this;
        },

        finishImportDeclaration: function (specifiers, src) {
            this.type = Syntax.ImportDeclaration;
            this.specifiers = specifiers;
            this.source = src;
            this.finish();
            return this;
        },

        finishYieldExpression: function (argument, delegate) {
            this.type = Syntax.YieldExpression;
            this.argument = argument;
            this.delegate = delegate;
            this.finish();
            return this;
        }
    };


    function recordError(error) {
        var e, existing;

        for (e = 0; e < extra.errors.length; e++) {
            existing = extra.errors[e];
            // Prevent duplicated error.
            /* istanbul ignore next */
            if (existing.index === error.index && existing.message === error.message) {
                return;
            }
        }

        extra.errors.push(error);
    }

    function constructError(msg, column) {
        var error = new Error(msg);
        try {
            throw error;
        } catch (base) {
            /* istanbul ignore else */
            if (Object.create && Object.defineProperty) {
                error = Object.create(base);
                Object.defineProperty(error, 'column', { value: column });
            }
        } finally {
            return error;
        }
    }

    function createError(line, pos, description) {
        var msg, column, error;

        msg = 'Line ' + line + ': ' + description;
        column = pos - (scanning ? lineStart : lastLineStart) + 1;
        error = constructError(msg, column);
        error.lineNumber = line;
        error.description = description;
        error.index = pos;
        return error;
    }

    // Throw an exception

    function throwError(messageFormat) {
        var args, msg;

        args = Array.prototype.slice.call(arguments, 1);
        msg = messageFormat.replace(/%(\d)/g,
            function (whole, idx) {
                assert(idx < args.length, 'Message reference must be in range');
                return args[idx];
            }
        );

        throw createError(lastLineNumber, lastIndex, msg);
    }

    function tolerateError(messageFormat) {
        var args, msg, error;

        args = Array.prototype.slice.call(arguments, 1);
        /* istanbul ignore next */
        msg = messageFormat.replace(/%(\d)/g,
            function (whole, idx) {
                assert(idx < args.length, 'Message reference must be in range');
                return args[idx];
            }
        );

        error = createError(lineNumber, lastIndex, msg);
        if (extra.errors) {
            recordError(error);
        } else {
            throw error;
        }
    }

    // Throw an exception because of the token.

    function unexpectedTokenError(token, message) {
        var value, msg = message || Messages.UnexpectedToken;

        if (token) {
            if (!message) {
                msg = (token.type === Token.EOF) ? Messages.UnexpectedEOS :
                    (token.type === Token.Identifier) ? Messages.UnexpectedIdentifier :
                    (token.type === Token.NumericLiteral) ? Messages.UnexpectedNumber :
                    (token.type === Token.StringLiteral) ? Messages.UnexpectedString :
                    (token.type === Token.Template) ? Messages.UnexpectedTemplate :
                    Messages.UnexpectedToken;

                if (token.type === Token.Keyword) {
                    if (isFutureReservedWord(token.value)) {
                        msg = Messages.UnexpectedReserved;
                    } else if (strict && isStrictModeReservedWord(token.value)) {
                        msg = Messages.StrictReservedWord;
                    }
                }
            }

            value = (token.type === Token.Template) ? token.value.raw : token.value;
        } else {
            value = 'ILLEGAL';
        }

        msg = msg.replace('%0', value);

        return (token && typeof token.lineNumber === 'number') ?
            createError(token.lineNumber, token.start, msg) :
            createError(scanning ? lineNumber : lastLineNumber, scanning ? index : lastIndex, msg);
    }

    function throwUnexpectedToken(token, message) {
        throw unexpectedTokenError(token, message);
    }

    function tolerateUnexpectedToken(token, message) {
        var error = unexpectedTokenError(token, message);
        if (extra.errors) {
            recordError(error);
        } else {
            throw error;
        }
    }

    // Expect the next token to match the specified punctuator.
    // If not, an exception will be thrown.

    function expect(value) {
        var token = lex();
        if (token.type !== Token.Punctuator || token.value !== value) {
            throwUnexpectedToken(token);
        }
    }

    /**
     * @name expectCommaSeparator
     * @description Quietly expect a comma when in tolerant mode, otherwise delegates
     * to <code>expect(value)</code>
     * @since 2.0
     */
    function expectCommaSeparator() {
        var token;

        if (extra.errors) {
            token = lookahead;
            if (token.type === Token.Punctuator && token.value === ',') {
                lex();
            } else if (token.type === Token.Punctuator && token.value === ';') {
                lex();
                tolerateUnexpectedToken(token);
            } else {
                tolerateUnexpectedToken(token, Messages.UnexpectedToken);
            }
        } else {
            expect(',');
        }
    }

    // Expect the next token to match the specified keyword.
    // If not, an exception will be thrown.

    function expectKeyword(keyword) {
        var token = lex();
        if (token.type !== Token.Keyword || token.value !== keyword) {
            throwUnexpectedToken(token);
        }
    }

    // Return true if the next token matches the specified punctuator.

    function match(value) {
        return lookahead.type === Token.Punctuator && lookahead.value === value;
    }

    // Return true if the next token matches the specified keyword

    function matchKeyword(keyword) {
        return lookahead.type === Token.Keyword && lookahead.value === keyword;
    }

    // Return true if the next token matches the specified contextual keyword
    // (where an identifier is sometimes a keyword depending on the context)

    function matchContextualKeyword(keyword) {
        return lookahead.type === Token.Identifier && lookahead.value === keyword;
    }

    // Return true if the next token is an assignment operator

    function matchAssign() {
        var op;

        if (lookahead.type !== Token.Punctuator) {
            return false;
        }
        op = lookahead.value;
        return op === '=' ||
            op === '*=' ||
            op === '/=' ||
            op === '%=' ||
            op === '+=' ||
            op === '-=' ||
            op === '<<=' ||
            op === '>>=' ||
            op === '>>>=' ||
            op === '&=' ||
            op === '^=' ||
            op === '|=';
    }

    function consumeSemicolon() {
        // Catch the very common case first: immediately a semicolon (U+003B).
        if (source.charCodeAt(startIndex) === 0x3B || match(';')) {
            lex();
            return;
        }

        if (hasLineTerminator) {
            return;
        }

        // FIXME(ikarienator): this is seemingly an issue in the previous location info convention.
        lastIndex = startIndex;
        lastLineNumber = startLineNumber;
        lastLineStart = startLineStart;

        if (lookahead.type !== Token.EOF && !match('}')) {
            throwUnexpectedToken(lookahead);
        }
    }

    // Cover grammar support.
    //
    // When an assignment expression position starts with an left parenthesis, the determination of the type
    // of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)
    // or the first comma. This situation also defers the determination of all the expressions nested in the pair.
    //
    // There are three productions that can be parsed in a parentheses pair that needs to be determined
    // after the outermost pair is closed. They are:
    //
    //   1. AssignmentExpression
    //   2. BindingElements
    //   3. AssignmentTargets
    //
    // In order to avoid exponential backtracking, we use two flags to denote if the production can be
    // binding element or assignment target.
    //
    // The three productions have the relationship:
    //
    //   BindingElements  AssignmentTargets  AssignmentExpression
    //
    // with a single exception that CoverInitializedName when used directly in an Expression, generates
    // an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the
    // first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.
    //
    // isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not
    // effect the current flags. This means the production the parser parses is only used as an expression. Therefore
    // the CoverInitializedName check is conducted.
    //
    // inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates
    // the flags outside of the parser. This means the production the parser parses is used as a part of a potential
    // pattern. The CoverInitializedName check is deferred.
    function isolateCoverGrammar(parser) {
        var oldIsBindingElement = isBindingElement,
            oldIsAssignmentTarget = isAssignmentTarget,
            oldFirstCoverInitializedNameError = firstCoverInitializedNameError,
            result;
        isBindingElement = true;
        isAssignmentTarget = true;
        firstCoverInitializedNameError = null;
        result = parser();
        if (firstCoverInitializedNameError !== null) {
            throwUnexpectedToken(firstCoverInitializedNameError);
        }
        isBindingElement = oldIsBindingElement;
        isAssignmentTarget = oldIsAssignmentTarget;
        firstCoverInitializedNameError = oldFirstCoverInitializedNameError;
        return result;
    }

    function inheritCoverGrammar(parser) {
        var oldIsBindingElement = isBindingElement,
            oldIsAssignmentTarget = isAssignmentTarget,
            oldFirstCoverInitializedNameError = firstCoverInitializedNameError,
            result;
        isBindingElement = true;
        isAssignmentTarget = true;
        firstCoverInitializedNameError = null;
        result = parser();
        isBindingElement = isBindingElement && oldIsBindingElement;
        isAssignmentTarget = isAssignmentTarget && oldIsAssignmentTarget;
        firstCoverInitializedNameError = oldFirstCoverInitializedNameError || firstCoverInitializedNameError;
        return result;
    }

    // ECMA-262 13.3.3 Destructuring Binding Patterns

    function parseArrayPattern(params, kind) {
        var node = new Node(), elements = [], rest, restNode;
        expect('[');

        while (!match(']')) {
            if (match(',')) {
                lex();
                elements.push(null);
            } else {
                if (match('...')) {
                    restNode = new Node();
                    lex();
                    params.push(lookahead);
                    rest = parseVariableIdentifier(kind);
                    elements.push(restNode.finishRestElement(rest));
                    break;
                } else {
                    elements.push(parsePatternWithDefault(params, kind));
                }
                if (!match(']')) {
                    expect(',');
                }
            }

        }

        expect(']');

        return node.finishArrayPattern(elements);
    }

    function parsePropertyPattern(params, kind) {
        var node = new Node(), key, keyToken, computed = match('['), init;
        if (lookahead.type === Token.Identifier) {
            keyToken = lookahead;
            key = parseVariableIdentifier();
            if (match('=')) {
                params.push(keyToken);
                lex();
                init = parseAssignmentExpression();

                return node.finishProperty(
                    'init', key, false,
                    new WrappingNode(keyToken).finishAssignmentPattern(key, init), false, true);
            } else if (!match(':')) {
                params.push(keyToken);
                return node.finishProperty('init', key, false, key, false, true);
            }
        } else {
            key = parseObjectPropertyKey();
        }
        expect(':');
        init = parsePatternWithDefault(params, kind);
        return node.finishProperty('init', key, computed, init, false, false);
    }

    function parseObjectPattern(params, kind) {
        var node = new Node(), properties = [];

        expect('{');

        while (!match('}')) {
            properties.push(parsePropertyPattern(params, kind));
            if (!match('}')) {
                expect(',');
            }
        }

        lex();

        return node.finishObjectPattern(properties);
    }

    function parsePattern(params, kind) {
        if (match('[')) {
            return parseArrayPattern(params, kind);
        } else if (match('{')) {
            return parseObjectPattern(params, kind);
        } else if (matchKeyword('let')) {
            if (kind === 'const' || kind === 'let') {
                tolerateUnexpectedToken(lookahead, Messages.UnexpectedToken);
            }
        }

        params.push(lookahead);
        return parseVariableIdentifier(kind);
    }

    function parsePatternWithDefault(params, kind) {
        var startToken = lookahead, pattern, previousAllowYield, right;
        pattern = parsePattern(params, kind);
        if (match('=')) {
            lex();
            previousAllowYield = state.allowYield;
            state.allowYield = true;
            right = isolateCoverGrammar(parseAssignmentExpression);
            state.allowYield = previousAllowYield;
            pattern = new WrappingNode(startToken).finishAssignmentPattern(pattern, right);
        }
        return pattern;
    }

    // ECMA-262 12.2.5 Array Initializer

    function parseArrayInitializer() {
        var elements = [], node = new Node(), restSpread;

        expect('[');

        while (!match(']')) {
            if (match(',')) {
                lex();
                elements.push(null);
            } else if (match('...')) {
                restSpread = new Node();
                lex();
                restSpread.finishSpreadElement(inheritCoverGrammar(parseAssignmentExpression));

                if (!match(']')) {
                    isAssignmentTarget = isBindingElement = false;
                    expect(',');
                }
                elements.push(restSpread);
            } else {
                elements.push(inheritCoverGrammar(parseAssignmentExpression));

                if (!match(']')) {
                    expect(',');
                }
            }
        }

        lex();

        return node.finishArrayExpression(elements);
    }

    // ECMA-262 12.2.6 Object Initializer

    function parsePropertyFunction(node, paramInfo, isGenerator) {
        var previousStrict, body;

        isAssignmentTarget = isBindingElement = false;

        previousStrict = strict;
        body = isolateCoverGrammar(parseFunctionSourceElements);

        if (strict && paramInfo.firstRestricted) {
            tolerateUnexpectedToken(paramInfo.firstRestricted, paramInfo.message);
        }
        if (strict && paramInfo.stricted) {
            tolerateUnexpectedToken(paramInfo.stricted, paramInfo.message);
        }

        strict = previousStrict;
        return node.finishFunctionExpression(null, paramInfo.params, paramInfo.defaults, body, isGenerator);
    }

    function parsePropertyMethodFunction() {
        var params, method, node = new Node(),
            previousAllowYield = state.allowYield;

        state.allowYield = false;
        params = parseParams();
        state.allowYield = previousAllowYield;

        state.allowYield = false;
        method = parsePropertyFunction(node, params, false);
        state.allowYield = previousAllowYield;

        return method;
    }

    function parseObjectPropertyKey() {
        var token, node = new Node(), expr;

        token = lex();

        // Note: This function is called only from parseObjectProperty(), where
        // EOF and Punctuator tokens are already filtered out.

        switch (token.type) {
        case Token.StringLiteral:
        case Token.NumericLiteral:
            if (strict && token.octal) {
                tolerateUnexpectedToken(token, Messages.StrictOctalLiteral);
            }
            return node.finishLiteral(token);
        case Token.Identifier:
        case Token.BooleanLiteral:
        case Token.NullLiteral:
        case Token.Keyword:
            return node.finishIdentifier(token.value);
        case Token.Punctuator:
            if (token.value === '[') {
                expr = isolateCoverGrammar(parseAssignmentExpression);
                expect(']');
                return expr;
            }
            break;
        }
        throwUnexpectedToken(token);
    }

    function lookaheadPropertyName() {
        switch (lookahead.type) {
        case Token.Identifier:
        case Token.StringLiteral:
        case Token.BooleanLiteral:
        case Token.NullLiteral:
        case Token.NumericLiteral:
        case Token.Keyword:
            return true;
        case Token.Punctuator:
            return lookahead.value === '[';
        }
        return false;
    }

    // This function is to try to parse a MethodDefinition as defined in 14.3. But in the case of object literals,
    // it might be called at a position where there is in fact a short hand identifier pattern or a data property.
    // This can only be determined after we consumed up to the left parentheses.
    //
    // In order to avoid back tracking, it returns `null` if the position is not a MethodDefinition and the caller
    // is responsible to visit other options.
    function tryParseMethodDefinition(token, key, computed, node) {
        var value, options, methodNode, params,
            previousAllowYield = state.allowYield;

        if (token.type === Token.Identifier) {
            // check for `get` and `set`;

            if (token.value === 'get' && lookaheadPropertyName()) {
                computed = match('[');
                key = parseObjectPropertyKey();
                methodNode = new Node();
                expect('(');
                expect(')');

                state.allowYield = false;
                value = parsePropertyFunction(methodNode, {
                    params: [],
                    defaults: [],
                    stricted: null,
                    firstRestricted: null,
                    message: null
                }, false);
                state.allowYield = previousAllowYield;

                return node.finishProperty('get', key, computed, value, false, false);
            } else if (token.value === 'set' && lookaheadPropertyName()) {
                computed = match('[');
                key = parseObjectPropertyKey();
                methodNode = new Node();
                expect('(');

                options = {
                    params: [],
                    defaultCount: 0,
                    defaults: [],
                    firstRestricted: null,
                    paramSet: {}
                };
                if (match(')')) {
                    tolerateUnexpectedToken(lookahead);
                } else {
                    state.allowYield = false;
                    parseParam(options);
                    state.allowYield = previousAllowYield;
                    if (options.defaultCount === 0) {
                        options.defaults = [];
                    }
                }
                expect(')');

                state.allowYield = false;
                value = parsePropertyFunction(methodNode, options, false);
                state.allowYield = previousAllowYield;

                return node.finishProperty('set', key, computed, value, false, false);
            }
        } else if (token.type === Token.Punctuator && token.value === '*' && lookaheadPropertyName()) {
            computed = match('[');
            key = parseObjectPropertyKey();
            methodNode = new Node();

            state.allowYield = true;
            params = parseParams();
            state.allowYield = previousAllowYield;

            state.allowYield = false;
            value = parsePropertyFunction(methodNode, params, true);
            state.allowYield = previousAllowYield;

            return node.finishProperty('init', key, computed, value, true, false);
        }

        if (key && match('(')) {
            value = parsePropertyMethodFunction();
            return node.finishProperty('init', key, computed, value, true, false);
        }

        // Not a MethodDefinition.
        return null;
    }

    function parseObjectProperty(hasProto) {
        var token = lookahead, node = new Node(), computed, key, maybeMethod, proto, value;

        computed = match('[');
        if (match('*')) {
            lex();
        } else {
            key = parseObjectPropertyKey();
        }
        maybeMethod = tryParseMethodDefinition(token, key, computed, node);
        if (maybeMethod) {
            return maybeMethod;
        }

        if (!key) {
            throwUnexpectedToken(lookahead);
        }

        // Check for duplicated __proto__
        if (!computed) {
            proto = (key.type === Syntax.Identifier && key.name === '__proto__') ||
                (key.type === Syntax.Literal && key.value === '__proto__');
            if (hasProto.value && proto) {
                tolerateError(Messages.DuplicateProtoProperty);
            }
            hasProto.value |= proto;
        }

        if (match(':')) {
            lex();
            value = inheritCoverGrammar(parseAssignmentExpression);
            return node.finishProperty('init', key, computed, value, false, false);
        }

        if (token.type === Token.Identifier) {
            if (match('=')) {
                firstCoverInitializedNameError = lookahead;
                lex();
                value = isolateCoverGrammar(parseAssignmentExpression);
                return node.finishProperty('init', key, computed,
                    new WrappingNode(token).finishAssignmentPattern(key, value), false, true);
            }
            return node.finishProperty('init', key, computed, key, false, true);
        }

        throwUnexpectedToken(lookahead);
    }

    function parseObjectInitializer() {
        var properties = [], hasProto = {value: false}, node = new Node();

        expect('{');

        while (!match('}')) {
            properties.push(parseObjectProperty(hasProto));

            if (!match('}')) {
                expectCommaSeparator();
            }
        }

        expect('}');

        return node.finishObjectExpression(properties);
    }

    function reinterpretExpressionAsPattern(expr) {
        var i;
        switch (expr.type) {
        case Syntax.Identifier:
        case Syntax.MemberExpression:
        case Syntax.RestElement:
        case Syntax.AssignmentPattern:
            break;
        case Syntax.SpreadElement:
            expr.type = Syntax.RestElement;
            reinterpretExpressionAsPattern(expr.argument);
            break;
        case Syntax.ArrayExpression:
            expr.type = Syntax.ArrayPattern;
            for (i = 0; i < expr.elements.length; i++) {
                if (expr.elements[i] !== null) {
                    reinterpretExpressionAsPattern(expr.elements[i]);
                }
            }
            break;
        case Syntax.ObjectExpression:
            expr.type = Syntax.ObjectPattern;
            for (i = 0; i < expr.properties.length; i++) {
                reinterpretExpressionAsPattern(expr.properties[i].value);
            }
            break;
        case Syntax.AssignmentExpression:
            expr.type = Syntax.AssignmentPattern;
            reinterpretExpressionAsPattern(expr.left);
            break;
        default:
            // Allow other node type for tolerant parsing.
            break;
        }
    }

    // ECMA-262 12.2.9 Template Literals

    function parseTemplateElement(option) {
        var node, token;

        if (lookahead.type !== Token.Template || (option.head && !lookahead.head)) {
            throwUnexpectedToken();
        }

        node = new Node();
        token = lex();

        return node.finishTemplateElement({ raw: token.value.raw, cooked: token.value.cooked }, token.tail);
    }

    function parseTemplateLiteral() {
        var quasi, quasis, expressions, node = new Node();

        quasi = parseTemplateElement({ head: true });
        quasis = [quasi];
        expressions = [];

        while (!quasi.tail) {
            expressions.push(parseExpression());
            quasi = parseTemplateElement({ head: false });
            quasis.push(quasi);
        }

        return node.finishTemplateLiteral(quasis, expressions);
    }

    // ECMA-262 12.2.10 The Grouping Operator

    function parseGroupExpression() {
        var expr, expressions, startToken, i, params = [];

        expect('(');

        if (match(')')) {
            lex();
            if (!match('=>')) {
                expect('=>');
            }
            return {
                type: PlaceHolders.ArrowParameterPlaceHolder,
                params: [],
                rawParams: []
            };
        }

        startToken = lookahead;
        if (match('...')) {
            expr = parseRestElement(params);
            expect(')');
            if (!match('=>')) {
                expect('=>');
            }
            return {
                type: PlaceHolders.ArrowParameterPlaceHolder,
                params: [expr]
            };
        }

        isBindingElement = true;
        expr = inheritCoverGrammar(parseAssignmentExpression);

        if (match(',')) {
            isAssignmentTarget = false;
            expressions = [expr];

            while (startIndex < length) {
                if (!match(',')) {
                    break;
                }
                lex();

                if (match('...')) {
                    if (!isBindingElement) {
                        throwUnexpectedToken(lookahead);
                    }
                    expressions.push(parseRestElement(params));
                    expect(')');
                    if (!match('=>')) {
                        expect('=>');
                    }
                    isBindingElement = false;
                    for (i = 0; i < expressions.length; i++) {
                        reinterpretExpressionAsPattern(expressions[i]);
                    }
                    return {
                        type: PlaceHolders.ArrowParameterPlaceHolder,
                        params: expressions
                    };
                }

                expressions.push(inheritCoverGrammar(parseAssignmentExpression));
            }

            expr = new WrappingNode(startToken).finishSequenceExpression(expressions);
        }


        expect(')');

        if (match('=>')) {
            if (expr.type === Syntax.Identifier && expr.name === 'yield') {
                return {
                    type: PlaceHolders.ArrowParameterPlaceHolder,
                    params: [expr]
                };
            }

            if (!isBindingElement) {
                throwUnexpectedToken(lookahead);
            }

            if (expr.type === Syntax.SequenceExpression) {
                for (i = 0; i < expr.expressions.length; i++) {
                    reinterpretExpressionAsPattern(expr.expressions[i]);
                }
            } else {
                reinterpretExpressionAsPattern(expr);
            }

            expr = {
                type: PlaceHolders.ArrowParameterPlaceHolder,
                params: expr.type === Syntax.SequenceExpression ? expr.expressions : [expr]
            };
        }
        isBindingElement = false;
        return expr;
    }


    // ECMA-262 12.2 Primary Expressions

    function parsePrimaryExpression() {
        var type, token, expr, node;

        if (match('(')) {
            isBindingElement = false;
            return inheritCoverGrammar(parseGroupExpression);
        }

        if (match('[')) {
            return inheritCoverGrammar(parseArrayInitializer);
        }

        if (match('{')) {
            return inheritCoverGrammar(parseObjectInitializer);
        }

        type = lookahead.type;
        node = new Node();

        if (type === Token.Identifier) {
            if (state.sourceType === 'module' && lookahead.value === 'await') {
                tolerateUnexpectedToken(lookahead);
            }
            expr = node.finishIdentifier(lex().value);
        } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {
            isAssignmentTarget = isBindingElement = false;
            if (strict && lookahead.octal) {
                tolerateUnexpectedToken(lookahead, Messages.StrictOctalLiteral);
            }
            expr = node.finishLiteral(lex());
        } else if (type === Token.Keyword) {
            if (!strict && state.allowYield && matchKeyword('yield')) {
                return parseNonComputedProperty();
            }
            if (!strict && matchKeyword('let')) {
                return node.finishIdentifier(lex().value);
            }
            isAssignmentTarget = isBindingElement = false;
            if (matchKeyword('function')) {
                return parseFunctionExpression();
            }
            if (matchKeyword('this')) {
                lex();
                return node.finishThisExpression();
            }
            if (matchKeyword('class')) {
                return parseClassExpression();
            }
            throwUnexpectedToken(lex());
        } else if (type === Token.BooleanLiteral) {
            isAssignmentTarget = isBindingElement = false;
            token = lex();
            token.value = (token.value === 'true');
            expr = node.finishLiteral(token);
        } else if (type === Token.NullLiteral) {
            isAssignmentTarget = isBindingElement = false;
            token = lex();
            token.value = null;
            expr = node.finishLiteral(token);
        } else if (match('/') || match('/=')) {
            isAssignmentTarget = isBindingElement = false;
            index = startIndex;

            if (typeof extra.tokens !== 'undefined') {
                token = collectRegex();
            } else {
                token = scanRegExp();
            }
            lex();
            expr = node.finishLiteral(token);
        } else if (type === Token.Template) {
            expr = parseTemplateLiteral();
        } else {
            throwUnexpectedToken(lex());
        }

        return expr;
    }

    // ECMA-262 12.3 Left-Hand-Side Expressions

    function parseArguments() {
        var args = [], expr;

        expect('(');

        if (!match(')')) {
            while (startIndex < length) {
                if (match('...')) {
                    expr = new Node();
                    lex();
                    expr.finishSpreadElement(isolateCoverGrammar(parseAssignmentExpression));
                } else {
                    expr = isolateCoverGrammar(parseAssignmentExpression);
                }
                args.push(expr);
                if (match(')')) {
                    break;
                }
                expectCommaSeparator();
            }
        }

        expect(')');

        return args;
    }

    function parseNonComputedProperty() {
        var token, node = new Node();

        token = lex();

        if (!isIdentifierName(token)) {
            throwUnexpectedToken(token);
        }

        return node.finishIdentifier(token.value);
    }

    function parseNonComputedMember() {
        expect('.');

        return parseNonComputedProperty();
    }

    function parseComputedMember() {
        var expr;

        expect('[');

        expr = isolateCoverGrammar(parseExpression);

        expect(']');

        return expr;
    }

    // ECMA-262 12.3.3 The new Operator

    function parseNewExpression() {
        var callee, args, node = new Node();

        expectKeyword('new');

        if (match('.')) {
            lex();
            if (lookahead.type === Token.Identifier && lookahead.value === 'target') {
                if (state.inFunctionBody) {
                    lex();
                    return node.finishMetaProperty('new', 'target');
                }
            }
            throwUnexpectedToken(lookahead);
        }

        callee = isolateCoverGrammar(parseLeftHandSideExpression);
        args = match('(') ? parseArguments() : [];

        isAssignmentTarget = isBindingElement = false;

        return node.finishNewExpression(callee, args);
    }

    // ECMA-262 12.3.4 Function Calls

    function parseLeftHandSideExpressionAllowCall() {
        var quasi, expr, args, property, startToken, previousAllowIn = state.allowIn;

        startToken = lookahead;
        state.allowIn = true;

        if (matchKeyword('super') && state.inFunctionBody) {
            expr = new Node();
            lex();
            expr = expr.finishSuper();
            if (!match('(') && !match('.') && !match('[')) {
                throwUnexpectedToken(lookahead);
            }
        } else {
            expr = inheritCoverGrammar(matchKeyword('new') ? parseNewExpression : parsePrimaryExpression);
        }

        for (;;) {
            if (match('.')) {
                isBindingElement = false;
                isAssignmentTarget = true;
                property = parseNonComputedMember();
                expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);
            } else if (match('(')) {
                isBindingElement = false;
                isAssignmentTarget = false;
                args = parseArguments();
                expr = new WrappingNode(startToken).finishCallExpression(expr, args);
            } else if (match('[')) {
                isBindingElement = false;
                isAssignmentTarget = true;
                property = parseComputedMember();
                expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);
            } else if (lookahead.type === Token.Template && lookahead.head) {
                quasi = parseTemplateLiteral();
                expr = new WrappingNode(startToken).finishTaggedTemplateExpression(expr, quasi);
            } else {
                break;
            }
        }
        state.allowIn = previousAllowIn;

        return expr;
    }

    // ECMA-262 12.3 Left-Hand-Side Expressions

    function parseLeftHandSideExpression() {
        var quasi, expr, property, startToken;
        assert(state.allowIn, 'callee of new expression always allow in keyword.');

        startToken = lookahead;

        if (matchKeyword('super') && state.inFunctionBody) {
            expr = new Node();
            lex();
            expr = expr.finishSuper();
            if (!match('[') && !match('.')) {
                throwUnexpectedToken(lookahead);
            }
        } else {
            expr = inheritCoverGrammar(matchKeyword('new') ? parseNewExpression : parsePrimaryExpression);
        }

        for (;;) {
            if (match('[')) {
                isBindingElement = false;
                isAssignmentTarget = true;
                property = parseComputedMember();
                expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);
            } else if (match('.')) {
                isBindingElement = false;
                isAssignmentTarget = true;
                property = parseNonComputedMember();
                expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);
            } else if (lookahead.type === Token.Template && lookahead.head) {
                quasi = parseTemplateLiteral();
                expr = new WrappingNode(startToken).finishTaggedTemplateExpression(expr, quasi);
            } else {
                break;
            }
        }
        return expr;
    }

    // ECMA-262 12.4 Postfix Expressions

    function parsePostfixExpression() {
        var expr, token, startToken = lookahead;

        expr = inheritCoverGrammar(parseLeftHandSideExpressionAllowCall);

        if (!hasLineTerminator && lookahead.type === Token.Punctuator) {
            if (match('++') || match('--')) {
                // ECMA-262 11.3.1, 11.3.2
                if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                    tolerateError(Messages.StrictLHSPostfix);
                }

                if (!isAssignmentTarget) {
                    tolerateError(Messages.InvalidLHSInAssignment);
                }

                isAssignmentTarget = isBindingElement = false;

                token = lex();
                expr = new WrappingNode(startToken).finishPostfixExpression(token.value, expr);
            }
        }

        return expr;
    }

    // ECMA-262 12.5 Unary Operators

    function parseUnaryExpression() {
        var token, expr, startToken;

        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {
            expr = parsePostfixExpression();
        } else if (match('++') || match('--')) {
            startToken = lookahead;
            token = lex();
            expr = inheritCoverGrammar(parseUnaryExpression);
            // ECMA-262 11.4.4, 11.4.5
            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                tolerateError(Messages.StrictLHSPrefix);
            }

            if (!isAssignmentTarget) {
                tolerateError(Messages.InvalidLHSInAssignment);
            }
            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
            isAssignmentTarget = isBindingElement = false;
        } else if (match('+') || match('-') || match('~') || match('!')) {
            startToken = lookahead;
            token = lex();
            expr = inheritCoverGrammar(parseUnaryExpression);
            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
            isAssignmentTarget = isBindingElement = false;
        } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
            startToken = lookahead;
            token = lex();
            expr = inheritCoverGrammar(parseUnaryExpression);
            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {
                tolerateError(Messages.StrictDelete);
            }
            isAssignmentTarget = isBindingElement = false;
        } else {
            expr = parsePostfixExpression();
        }

        return expr;
    }

    function binaryPrecedence(token, allowIn) {
        var prec = 0;

        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {
            return 0;
        }

        switch (token.value) {
        case '||':
            prec = 1;
            break;

        case '&&':
            prec = 2;
            break;

        case '|':
            prec = 3;
            break;

        case '^':
            prec = 4;
            break;

        case '&':
            prec = 5;
            break;

        case '==':
        case '!=':
        case '===':
        case '!==':
            prec = 6;
            break;

        case '<':
        case '>':
        case '<=':
        case '>=':
        case 'instanceof':
            prec = 7;
            break;

        case 'in':
            prec = allowIn ? 7 : 0;
            break;

        case '<<':
        case '>>':
        case '>>>':
            prec = 8;
            break;

        case '+':
        case '-':
            prec = 9;
            break;

        case '*':
        case '/':
        case '%':
            prec = 11;
            break;

        default:
            break;
        }

        return prec;
    }

    // ECMA-262 12.6 Multiplicative Operators
    // ECMA-262 12.7 Additive Operators
    // ECMA-262 12.8 Bitwise Shift Operators
    // ECMA-262 12.9 Relational Operators
    // ECMA-262 12.10 Equality Operators
    // ECMA-262 12.11 Binary Bitwise Operators
    // ECMA-262 12.12 Binary Logical Operators

    function parseBinaryExpression() {
        var marker, markers, expr, token, prec, stack, right, operator, left, i;

        marker = lookahead;
        left = inheritCoverGrammar(parseUnaryExpression);

        token = lookahead;
        prec = binaryPrecedence(token, state.allowIn);
        if (prec === 0) {
            return left;
        }
        isAssignmentTarget = isBindingElement = false;
        token.prec = prec;
        lex();

        markers = [marker, lookahead];
        right = isolateCoverGrammar(parseUnaryExpression);

        stack = [left, token, right];

        while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {

            // Reduce: make a binary expression from the three topmost entries.
            while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {
                right = stack.pop();
                operator = stack.pop().value;
                left = stack.pop();
                markers.pop();
                expr = new WrappingNode(markers[markers.length - 1]).finishBinaryExpression(operator, left, right);
                stack.push(expr);
            }

            // Shift.
            token = lex();
            token.prec = prec;
            stack.push(token);
            markers.push(lookahead);
            expr = isolateCoverGrammar(parseUnaryExpression);
            stack.push(expr);
        }

        // Final reduce to clean-up the stack.
        i = stack.length - 1;
        expr = stack[i];
        markers.pop();
        while (i > 1) {
            expr = new WrappingNode(markers.pop()).finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
            i -= 2;
        }

        return expr;
    }


    // ECMA-262 12.13 Conditional Operator

    function parseConditionalExpression() {
        var expr, previousAllowIn, consequent, alternate, startToken;

        startToken = lookahead;

        expr = inheritCoverGrammar(parseBinaryExpression);
        if (match('?')) {
            lex();
            previousAllowIn = state.allowIn;
            state.allowIn = true;
            consequent = isolateCoverGrammar(parseAssignmentExpression);
            state.allowIn = previousAllowIn;
            expect(':');
            alternate = isolateCoverGrammar(parseAssignmentExpression);

            expr = new WrappingNode(startToken).finishConditionalExpression(expr, consequent, alternate);
            isAssignmentTarget = isBindingElement = false;
        }

        return expr;
    }

    // ECMA-262 14.2 Arrow Function Definitions

    function parseConciseBody() {
        if (match('{')) {
            return parseFunctionSourceElements();
        }
        return isolateCoverGrammar(parseAssignmentExpression);
    }

    function checkPatternParam(options, param) {
        var i;
        switch (param.type) {
        case Syntax.Identifier:
            validateParam(options, param, param.name);
            break;
        case Syntax.RestElement:
            checkPatternParam(options, param.argument);
            break;
        case Syntax.AssignmentPattern:
            checkPatternParam(options, param.left);
            break;
        case Syntax.ArrayPattern:
            for (i = 0; i < param.elements.length; i++) {
                if (param.elements[i] !== null) {
                    checkPatternParam(options, param.elements[i]);
                }
            }
            break;
        case Syntax.YieldExpression:
            break;
        default:
            assert(param.type === Syntax.ObjectPattern, 'Invalid type');
            for (i = 0; i < param.properties.length; i++) {
                checkPatternParam(options, param.properties[i].value);
            }
            break;
        }
    }
    function reinterpretAsCoverFormalsList(expr) {
        var i, len, param, params, defaults, defaultCount, options, token;

        defaults = [];
        defaultCount = 0;
        params = [expr];

        switch (expr.type) {
        case Syntax.Identifier:
            break;
        case PlaceHolders.ArrowParameterPlaceHolder:
            params = expr.params;
            break;
        default:
            return null;
        }

        options = {
            paramSet: {}
        };

        for (i = 0, len = params.length; i < len; i += 1) {
            param = params[i];
            switch (param.type) {
            case Syntax.AssignmentPattern:
                params[i] = param.left;
                if (param.right.type === Syntax.YieldExpression) {
                    if (param.right.argument) {
                        throwUnexpectedToken(lookahead);
                    }
                    param.right.type = Syntax.Identifier;
                    param.right.name = 'yield';
                    delete param.right.argument;
                    delete param.right.delegate;
                }
                defaults.push(param.right);
                ++defaultCount;
                checkPatternParam(options, param.left);
                break;
            default:
                checkPatternParam(options, param);
                params[i] = param;
                defaults.push(null);
                break;
            }
        }

        if (strict || !state.allowYield) {
            for (i = 0, len = params.length; i < len; i += 1) {
                param = params[i];
                if (param.type === Syntax.YieldExpression) {
                    throwUnexpectedToken(lookahead);
                }
            }
        }

        if (options.message === Messages.StrictParamDupe) {
            token = strict ? options.stricted : options.firstRestricted;
            throwUnexpectedToken(token, options.message);
        }

        if (defaultCount === 0) {
            defaults = [];
        }

        return {
            params: params,
            defaults: defaults,
            stricted: options.stricted,
            firstRestricted: options.firstRestricted,
            message: options.message
        };
    }

    function parseArrowFunctionExpression(options, node) {
        var previousStrict, previousAllowYield, body;

        if (hasLineTerminator) {
            tolerateUnexpectedToken(lookahead);
        }
        expect('=>');

        previousStrict = strict;
        previousAllowYield = state.allowYield;
        state.allowYield = true;

        body = parseConciseBody();

        if (strict && options.firstRestricted) {
            throwUnexpectedToken(options.firstRestricted, options.message);
        }
        if (strict && options.stricted) {
            tolerateUnexpectedToken(options.stricted, options.message);
        }

        strict = previousStrict;
        state.allowYield = previousAllowYield;

        return node.finishArrowFunctionExpression(options.params, options.defaults, body, body.type !== Syntax.BlockStatement);
    }

    // ECMA-262 14.4 Yield expression

    function parseYieldExpression() {
        var argument, expr, delegate, previousAllowYield;

        argument = null;
        expr = new Node();
        delegate = false;

        expectKeyword('yield');

        if (!hasLineTerminator) {
            previousAllowYield = state.allowYield;
            state.allowYield = false;
            delegate = match('*');
            if (delegate) {
                lex();
                argument = parseAssignmentExpression();
            } else {
                if (!match(';') && !match('}') && !match(')') && lookahead.type !== Token.EOF) {
                    argument = parseAssignmentExpression();
                }
            }
            state.allowYield = previousAllowYield;
        }

        return expr.finishYieldExpression(argument, delegate);
    }

    // ECMA-262 12.14 Assignment Operators

    function parseAssignmentExpression() {
        var token, expr, right, list, startToken;

        startToken = lookahead;
        token = lookahead;

        if (!state.allowYield && matchKeyword('yield')) {
            return parseYieldExpression();
        }

        expr = parseConditionalExpression();

        if (expr.type === PlaceHolders.ArrowParameterPlaceHolder || match('=>')) {
            isAssignmentTarget = isBindingElement = false;
            list = reinterpretAsCoverFormalsList(expr);

            if (list) {
                firstCoverInitializedNameError = null;
                return parseArrowFunctionExpression(list, new WrappingNode(startToken));
            }

            return expr;
        }

        if (matchAssign()) {
            if (!isAssignmentTarget) {
                tolerateError(Messages.InvalidLHSInAssignment);
            }

            // ECMA-262 12.1.1
            if (strict && expr.type === Syntax.Identifier) {
                if (isRestrictedWord(expr.name)) {
                    tolerateUnexpectedToken(token, Messages.StrictLHSAssignment);
                }
                if (isStrictModeReservedWord(expr.name)) {
                    tolerateUnexpectedToken(token, Messages.StrictReservedWord);
                }
            }

            if (!match('=')) {
                isAssignmentTarget = isBindingElement = false;
            } else {
                reinterpretExpressionAsPattern(expr);
            }

            token = lex();
            right = isolateCoverGrammar(parseAssignmentExpression);
            expr = new WrappingNode(startToken).finishAssignmentExpression(token.value, expr, right);
            firstCoverInitializedNameError = null;
        }

        return expr;
    }

    // ECMA-262 12.15 Comma Operator

    function parseExpression() {
        var expr, startToken = lookahead, expressions;

        expr = isolateCoverGrammar(parseAssignmentExpression);

        if (match(',')) {
            expressions = [expr];

            while (startIndex < length) {
                if (!match(',')) {
                    break;
                }
                lex();
                expressions.push(isolateCoverGrammar(parseAssignmentExpression));
            }

            expr = new WrappingNode(startToken).finishSequenceExpression(expressions);
        }

        return expr;
    }

    // ECMA-262 13.2 Block

    function parseStatementListItem() {
        if (lookahead.type === Token.Keyword) {
            switch (lookahead.value) {
            case 'export':
                if (state.sourceType !== 'module') {
                    tolerateUnexpectedToken(lookahead, Messages.IllegalExportDeclaration);
                }
                return parseExportDeclaration();
            case 'import':
                if (state.sourceType !== 'module') {
                    tolerateUnexpectedToken(lookahead, Messages.IllegalImportDeclaration);
                }
                return parseImportDeclaration();
            case 'const':
                return parseLexicalDeclaration({inFor: false});
            case 'function':
                return parseFunctionDeclaration(new Node());
            case 'class':
                return parseClassDeclaration();
            }
        }

        if (matchKeyword('let') && isLexicalDeclaration()) {
            return parseLexicalDeclaration({inFor: false});
        }

        return parseStatement();
    }

    function parseStatementList() {
        var list = [];
        while (startIndex < length) {
            if (match('}')) {
                break;
            }
            list.push(parseStatementListItem());
        }

        return list;
    }

    function parseBlock() {
        var block, node = new Node();

        expect('{');

        block = parseStatementList();

        expect('}');

        return node.finishBlockStatement(block);
    }

    // ECMA-262 13.3.2 Variable Statement

    function parseVariableIdentifier(kind) {
        var token, node = new Node();

        token = lex();

        if (token.type === Token.Keyword && token.value === 'yield') {
            if (strict) {
                tolerateUnexpectedToken(token, Messages.StrictReservedWord);
            } if (!state.allowYield) {
                throwUnexpectedToken(token);
            }
        } else if (token.type !== Token.Identifier) {
            if (strict && token.type === Token.Keyword && isStrictModeReservedWord(token.value)) {
                tolerateUnexpectedToken(token, Messages.StrictReservedWord);
            } else {
                if (strict || token.value !== 'let' || kind !== 'var') {
                    throwUnexpectedToken(token);
                }
            }
        } else if (state.sourceType === 'module' && token.type === Token.Identifier && token.value === 'await') {
            tolerateUnexpectedToken(token);
        }

        return node.finishIdentifier(token.value);
    }

    function parseVariableDeclaration(options) {
        var init = null, id, node = new Node(), params = [];

        id = parsePattern(params, 'var');

        // ECMA-262 12.2.1
        if (strict && isRestrictedWord(id.name)) {
            tolerateError(Messages.StrictVarName);
        }

        if (match('=')) {
            lex();
            init = isolateCoverGrammar(parseAssignmentExpression);
        } else if (id.type !== Syntax.Identifier && !options.inFor) {
            expect('=');
        }

        return node.finishVariableDeclarator(id, init);
    }

    function parseVariableDeclarationList(options) {
        var opt, list;

        opt = { inFor: options.inFor };
        list = [parseVariableDeclaration(opt)];

        while (match(',')) {
            lex();
            list.push(parseVariableDeclaration(opt));
        }

        return list;
    }

    function parseVariableStatement(node) {
        var declarations;

        expectKeyword('var');

        declarations = parseVariableDeclarationList({ inFor: false });

        consumeSemicolon();

        return node.finishVariableDeclaration(declarations);
    }

    // ECMA-262 13.3.1 Let and Const Declarations

    function parseLexicalBinding(kind, options) {
        var init = null, id, node = new Node(), params = [];

        id = parsePattern(params, kind);

        // ECMA-262 12.2.1
        if (strict && id.type === Syntax.Identifier && isRestrictedWord(id.name)) {
            tolerateError(Messages.StrictVarName);
        }

        if (kind === 'const') {
            if (!matchKeyword('in') && !matchContextualKeyword('of')) {
                expect('=');
                init = isolateCoverGrammar(parseAssignmentExpression);
            }
        } else if ((!options.inFor && id.type !== Syntax.Identifier) || match('=')) {
            expect('=');
            init = isolateCoverGrammar(parseAssignmentExpression);
        }

        return node.finishVariableDeclarator(id, init);
    }

    function parseBindingList(kind, options) {
        var list = [parseLexicalBinding(kind, options)];

        while (match(',')) {
            lex();
            list.push(parseLexicalBinding(kind, options));
        }

        return list;
    }


    function tokenizerState() {
        return {
            index: index,
            lineNumber: lineNumber,
            lineStart: lineStart,
            hasLineTerminator: hasLineTerminator,
            lastIndex: lastIndex,
            lastLineNumber: lastLineNumber,
            lastLineStart: lastLineStart,
            startIndex: startIndex,
            startLineNumber: startLineNumber,
            startLineStart: startLineStart,
            lookahead: lookahead,
            tokenCount: extra.tokens ? extra.tokens.length : 0
        };
    }

    function resetTokenizerState(ts) {
        index = ts.index;
        lineNumber = ts.lineNumber;
        lineStart = ts.lineStart;
        hasLineTerminator = ts.hasLineTerminator;
        lastIndex = ts.lastIndex;
        lastLineNumber = ts.lastLineNumber;
        lastLineStart = ts.lastLineStart;
        startIndex = ts.startIndex;
        startLineNumber = ts.startLineNumber;
        startLineStart = ts.startLineStart;
        lookahead = ts.lookahead;
        if (extra.tokens) {
            extra.tokens.splice(ts.tokenCount, extra.tokens.length);
        }
    }

    function isLexicalDeclaration() {
        var lexical, ts;

        ts = tokenizerState();

        lex();
        lexical = (lookahead.type === Token.Identifier) || match('[') || match('{') ||
            matchKeyword('let') || matchKeyword('yield');

        resetTokenizerState(ts);

        return lexical;
    }

    function parseLexicalDeclaration(options) {
        var kind, declarations, node = new Node();

        kind = lex().value;
        assert(kind === 'let' || kind === 'const', 'Lexical declaration must be either let or const');

        declarations = parseBindingList(kind, options);

        consumeSemicolon();

        return node.finishLexicalDeclaration(declarations, kind);
    }

    function parseRestElement(params) {
        var param, node = new Node();

        lex();

        if (match('{')) {
            throwError(Messages.ObjectPatternAsRestParameter);
        }

        params.push(lookahead);

        param = parseVariableIdentifier();

        if (match('=')) {
            throwError(Messages.DefaultRestParameter);
        }

        if (!match(')')) {
            throwError(Messages.ParameterAfterRestParameter);
        }

        return node.finishRestElement(param);
    }

    // ECMA-262 13.4 Empty Statement

    function parseEmptyStatement(node) {
        expect(';');
        return node.finishEmptyStatement();
    }

    // ECMA-262 12.4 Expression Statement

    function parseExpressionStatement(node) {
        var expr = parseExpression();
        consumeSemicolon();
        return node.finishExpressionStatement(expr);
    }

    // ECMA-262 13.6 If statement

    function parseIfStatement(node) {
        var test, consequent, alternate;

        expectKeyword('if');

        expect('(');

        test = parseExpression();

        expect(')');

        consequent = parseStatement();

        if (matchKeyword('else')) {
            lex();
            alternate = parseStatement();
        } else {
            alternate = null;
        }

        return node.finishIfStatement(test, consequent, alternate);
    }

    // ECMA-262 13.7 Iteration Statements

    function parseDoWhileStatement(node) {
        var body, test, oldInIteration;

        expectKeyword('do');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = parseStatement();

        state.inIteration = oldInIteration;

        expectKeyword('while');

        expect('(');

        test = parseExpression();

        expect(')');

        if (match(';')) {
            lex();
        }

        return node.finishDoWhileStatement(body, test);
    }

    function parseWhileStatement(node) {
        var test, body, oldInIteration;

        expectKeyword('while');

        expect('(');

        test = parseExpression();

        expect(')');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = parseStatement();

        state.inIteration = oldInIteration;

        return node.finishWhileStatement(test, body);
    }

    function parseForStatement(node) {
        var init, forIn, initSeq, initStartToken, test, update, left, right, kind, declarations,
            body, oldInIteration, previousAllowIn = state.allowIn;

        init = test = update = null;
        forIn = true;

        expectKeyword('for');

        expect('(');

        if (match(';')) {
            lex();
        } else {
            if (matchKeyword('var')) {
                init = new Node();
                lex();

                state.allowIn = false;
                declarations = parseVariableDeclarationList({ inFor: true });
                state.allowIn = previousAllowIn;

                if (declarations.length === 1 && matchKeyword('in')) {
                    init = init.finishVariableDeclaration(declarations);
                    lex();
                    left = init;
                    right = parseExpression();
                    init = null;
                } else if (declarations.length === 1 && declarations[0].init === null && matchContextualKeyword('of')) {
                    init = init.finishVariableDeclaration(declarations);
                    lex();
                    left = init;
                    right = parseAssignmentExpression();
                    init = null;
                    forIn = false;
                } else {
                    init = init.finishVariableDeclaration(declarations);
                    expect(';');
                }
            } else if (matchKeyword('const') || matchKeyword('let')) {
                init = new Node();
                kind = lex().value;

                if (!strict && lookahead.value === 'in') {
                    init = init.finishIdentifier(kind);
                    lex();
                    left = init;
                    right = parseExpression();
                    init = null;
                } else {
                    state.allowIn = false;
                    declarations = parseBindingList(kind, {inFor: true});
                    state.allowIn = previousAllowIn;

                    if (declarations.length === 1 && declarations[0].init === null && matchKeyword('in')) {
                        init = init.finishLexicalDeclaration(declarations, kind);
                        lex();
                        left = init;
                        right = parseExpression();
                        init = null;
                    } else if (declarations.length === 1 && declarations[0].init === null && matchContextualKeyword('of')) {
                        init = init.finishLexicalDeclaration(declarations, kind);
                        lex();
                        left = init;
                        right = parseAssignmentExpression();
                        init = null;
                        forIn = false;
                    } else {
                        consumeSemicolon();
                        init = init.finishLexicalDeclaration(declarations, kind);
                    }
                }
            } else {
                initStartToken = lookahead;
                state.allowIn = false;
                init = inheritCoverGrammar(parseAssignmentExpression);
                state.allowIn = previousAllowIn;

                if (matchKeyword('in')) {
                    if (!isAssignmentTarget) {
                        tolerateError(Messages.InvalidLHSInForIn);
                    }

                    lex();
                    reinterpretExpressionAsPattern(init);
                    left = init;
                    right = parseExpression();
                    init = null;
                } else if (matchContextualKeyword('of')) {
                    if (!isAssignmentTarget) {
                        tolerateError(Messages.InvalidLHSInForLoop);
                    }

                    lex();
                    reinterpretExpressionAsPattern(init);
                    left = init;
                    right = parseAssignmentExpression();
                    init = null;
                    forIn = false;
                } else {
                    if (match(',')) {
                        initSeq = [init];
                        while (match(',')) {
                            lex();
                            initSeq.push(isolateCoverGrammar(parseAssignmentExpression));
                        }
                        init = new WrappingNode(initStartToken).finishSequenceExpression(initSeq);
                    }
                    expect(';');
                }
            }
        }

        if (typeof left === 'undefined') {

            if (!match(';')) {
                test = parseExpression();
            }
            expect(';');

            if (!match(')')) {
                update = parseExpression();
            }
        }

        expect(')');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = isolateCoverGrammar(parseStatement);

        state.inIteration = oldInIteration;

        return (typeof left === 'undefined') ?
                node.finishForStatement(init, test, update, body) :
                forIn ? node.finishForInStatement(left, right, body) :
                    node.finishForOfStatement(left, right, body);
    }

    // ECMA-262 13.8 The continue statement

    function parseContinueStatement(node) {
        var label = null, key;

        expectKeyword('continue');

        // Optimize the most common form: 'continue;'.
        if (source.charCodeAt(startIndex) === 0x3B) {
            lex();

            if (!state.inIteration) {
                throwError(Messages.IllegalContinue);
            }

            return node.finishContinueStatement(null);
        }

        if (hasLineTerminator) {
            if (!state.inIteration) {
                throwError(Messages.IllegalContinue);
            }

            return node.finishContinueStatement(null);
        }

        if (lookahead.type === Token.Identifier) {
            label = parseVariableIdentifier();

            key = '$' + label.name;
            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError(Messages.UnknownLabel, label.name);
            }
        }

        consumeSemicolon();

        if (label === null && !state.inIteration) {
            throwError(Messages.IllegalContinue);
        }

        return node.finishContinueStatement(label);
    }

    // ECMA-262 13.9 The break statement

    function parseBreakStatement(node) {
        var label = null, key;

        expectKeyword('break');

        // Catch the very common case first: immediately a semicolon (U+003B).
        if (source.charCodeAt(lastIndex) === 0x3B) {
            lex();

            if (!(state.inIteration || state.inSwitch)) {
                throwError(Messages.IllegalBreak);
            }

            return node.finishBreakStatement(null);
        }

        if (hasLineTerminator) {
            if (!(state.inIteration || state.inSwitch)) {
                throwError(Messages.IllegalBreak);
            }
        } else if (lookahead.type === Token.Identifier) {
            label = parseVariableIdentifier();

            key = '$' + label.name;
            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError(Messages.UnknownLabel, label.name);
            }
        }

        consumeSemicolon();

        if (label === null && !(state.inIteration || state.inSwitch)) {
            throwError(Messages.IllegalBreak);
        }

        return node.finishBreakStatement(label);
    }

    // ECMA-262 13.10 The return statement

    function parseReturnStatement(node) {
        var argument = null;

        expectKeyword('return');

        if (!state.inFunctionBody) {
            tolerateError(Messages.IllegalReturn);
        }

        // 'return' followed by a space and an identifier is very common.
        if (source.charCodeAt(lastIndex) === 0x20) {
            if (isIdentifierStart(source.charCodeAt(lastIndex + 1))) {
                argument = parseExpression();
                consumeSemicolon();
                return node.finishReturnStatement(argument);
            }
        }

        if (hasLineTerminator) {
            // HACK
            return node.finishReturnStatement(null);
        }

        if (!match(';')) {
            if (!match('}') && lookahead.type !== Token.EOF) {
                argument = parseExpression();
            }
        }

        consumeSemicolon();

        return node.finishReturnStatement(argument);
    }

    // ECMA-262 13.11 The with statement

    function parseWithStatement(node) {
        var object, body;

        if (strict) {
            tolerateError(Messages.StrictModeWith);
        }

        expectKeyword('with');

        expect('(');

        object = parseExpression();

        expect(')');

        body = parseStatement();

        return node.finishWithStatement(object, body);
    }

    // ECMA-262 13.12 The switch statement

    function parseSwitchCase() {
        var test, consequent = [], statement, node = new Node();

        if (matchKeyword('default')) {
            lex();
            test = null;
        } else {
            expectKeyword('case');
            test = parseExpression();
        }
        expect(':');

        while (startIndex < length) {
            if (match('}') || matchKeyword('default') || matchKeyword('case')) {
                break;
            }
            statement = parseStatementListItem();
            consequent.push(statement);
        }

        return node.finishSwitchCase(test, consequent);
    }

    function parseSwitchStatement(node) {
        var discriminant, cases, clause, oldInSwitch, defaultFound;

        expectKeyword('switch');

        expect('(');

        discriminant = parseExpression();

        expect(')');

        expect('{');

        cases = [];

        if (match('}')) {
            lex();
            return node.finishSwitchStatement(discriminant, cases);
        }

        oldInSwitch = state.inSwitch;
        state.inSwitch = true;
        defaultFound = false;

        while (startIndex < length) {
            if (match('}')) {
                break;
            }
            clause = parseSwitchCase();
            if (clause.test === null) {
                if (defaultFound) {
                    throwError(Messages.MultipleDefaultsInSwitch);
                }
                defaultFound = true;
            }
            cases.push(clause);
        }

        state.inSwitch = oldInSwitch;

        expect('}');

        return node.finishSwitchStatement(discriminant, cases);
    }

    // ECMA-262 13.14 The throw statement

    function parseThrowStatement(node) {
        var argument;

        expectKeyword('throw');

        if (hasLineTerminator) {
            throwError(Messages.NewlineAfterThrow);
        }

        argument = parseExpression();

        consumeSemicolon();

        return node.finishThrowStatement(argument);
    }

    // ECMA-262 13.15 The try statement

    function parseCatchClause() {
        var param, params = [], paramMap = {}, key, i, body, node = new Node();

        expectKeyword('catch');

        expect('(');
        if (match(')')) {
            throwUnexpectedToken(lookahead);
        }

        param = parsePattern(params);
        for (i = 0; i < params.length; i++) {
            key = '$' + params[i].value;
            if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
                tolerateError(Messages.DuplicateBinding, params[i].value);
            }
            paramMap[key] = true;
        }

        // ECMA-262 12.14.1
        if (strict && isRestrictedWord(param.name)) {
            tolerateError(Messages.StrictCatchVariable);
        }

        expect(')');
        body = parseBlock();
        return node.finishCatchClause(param, body);
    }

    function parseTryStatement(node) {
        var block, handler = null, finalizer = null;

        expectKeyword('try');

        block = parseBlock();

        if (matchKeyword('catch')) {
            handler = parseCatchClause();
        }

        if (matchKeyword('finally')) {
            lex();
            finalizer = parseBlock();
        }

        if (!handler && !finalizer) {
            throwError(Messages.NoCatchOrFinally);
        }

        return node.finishTryStatement(block, handler, finalizer);
    }

    // ECMA-262 13.16 The debugger statement

    function parseDebuggerStatement(node) {
        expectKeyword('debugger');

        consumeSemicolon();

        return node.finishDebuggerStatement();
    }

    // 13 Statements

    function parseStatement() {
        var type = lookahead.type,
            expr,
            labeledBody,
            key,
            node;

        if (type === Token.EOF) {
            throwUnexpectedToken(lookahead);
        }

        if (type === Token.Punctuator && lookahead.value === '{') {
            return parseBlock();
        }
        isAssignmentTarget = isBindingElement = true;
        node = new Node();

        if (type === Token.Punctuator) {
            switch (lookahead.value) {
            case ';':
                return parseEmptyStatement(node);
            case '(':
                return parseExpressionStatement(node);
            default:
                break;
            }
        } else if (type === Token.Keyword) {
            switch (lookahead.value) {
            case 'break':
                return parseBreakStatement(node);
            case 'continue':
                return parseContinueStatement(node);
            case 'debugger':
                return parseDebuggerStatement(node);
            case 'do':
                return parseDoWhileStatement(node);
            case 'for':
                return parseForStatement(node);
            case 'function':
                return parseFunctionDeclaration(node);
            case 'if':
                return parseIfStatement(node);
            case 'return':
                return parseReturnStatement(node);
            case 'switch':
                return parseSwitchStatement(node);
            case 'throw':
                return parseThrowStatement(node);
            case 'try':
                return parseTryStatement(node);
            case 'var':
                return parseVariableStatement(node);
            case 'while':
                return parseWhileStatement(node);
            case 'with':
                return parseWithStatement(node);
            default:
                break;
            }
        }

        expr = parseExpression();

        // ECMA-262 12.12 Labelled Statements
        if ((expr.type === Syntax.Identifier) && match(':')) {
            lex();

            key = '$' + expr.name;
            if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError(Messages.Redeclaration, 'Label', expr.name);
            }

            state.labelSet[key] = true;
            labeledBody = parseStatement();
            delete state.labelSet[key];
            return node.finishLabeledStatement(expr, labeledBody);
        }

        consumeSemicolon();

        return node.finishExpressionStatement(expr);
    }

    // ECMA-262 14.1 Function Definition

    function parseFunctionSourceElements() {
        var statement, body = [], token, directive, firstRestricted,
            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody,
            node = new Node();

        expect('{');

        while (startIndex < length) {
            if (lookahead.type !== Token.StringLiteral) {
                break;
            }
            token = lookahead;

            statement = parseStatementListItem();
            body.push(statement);
            if (statement.expression.type !== Syntax.Literal) {
                // this is not directive
                break;
            }
            directive = source.slice(token.start + 1, token.end - 1);
            if (directive === 'use strict') {
                strict = true;
                if (firstRestricted) {
                    tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);
                }
            } else {
                if (!firstRestricted && token.octal) {
                    firstRestricted = token;
                }
            }
        }

        oldLabelSet = state.labelSet;
        oldInIteration = state.inIteration;
        oldInSwitch = state.inSwitch;
        oldInFunctionBody = state.inFunctionBody;

        state.labelSet = {};
        state.inIteration = false;
        state.inSwitch = false;
        state.inFunctionBody = true;

        while (startIndex < length) {
            if (match('}')) {
                break;
            }
            body.push(parseStatementListItem());
        }

        expect('}');

        state.labelSet = oldLabelSet;
        state.inIteration = oldInIteration;
        state.inSwitch = oldInSwitch;
        state.inFunctionBody = oldInFunctionBody;

        return node.finishBlockStatement(body);
    }

    function validateParam(options, param, name) {
        var key = '$' + name;
        if (strict) {
            if (isRestrictedWord(name)) {
                options.stricted = param;
                options.message = Messages.StrictParamName;
            }
            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                options.stricted = param;
                options.message = Messages.StrictParamDupe;
            }
        } else if (!options.firstRestricted) {
            if (isRestrictedWord(name)) {
                options.firstRestricted = param;
                options.message = Messages.StrictParamName;
            } else if (isStrictModeReservedWord(name)) {
                options.firstRestricted = param;
                options.message = Messages.StrictReservedWord;
            } else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                options.stricted = param;
                options.message = Messages.StrictParamDupe;
            }
        }
        options.paramSet[key] = true;
    }

    function parseParam(options) {
        var token, param, params = [], i, def;

        token = lookahead;
        if (token.value === '...') {
            param = parseRestElement(params);
            validateParam(options, param.argument, param.argument.name);
            options.params.push(param);
            options.defaults.push(null);
            return false;
        }

        param = parsePatternWithDefault(params);
        for (i = 0; i < params.length; i++) {
            validateParam(options, params[i], params[i].value);
        }

        if (param.type === Syntax.AssignmentPattern) {
            def = param.right;
            param = param.left;
            ++options.defaultCount;
        }

        options.params.push(param);
        options.defaults.push(def);

        return !match(')');
    }

    function parseParams(firstRestricted) {
        var options;

        options = {
            params: [],
            defaultCount: 0,
            defaults: [],
            firstRestricted: firstRestricted
        };

        expect('(');

        if (!match(')')) {
            options.paramSet = {};
            while (startIndex < length) {
                if (!parseParam(options)) {
                    break;
                }
                expect(',');
            }
        }

        expect(')');

        if (options.defaultCount === 0) {
            options.defaults = [];
        }

        return {
            params: options.params,
            defaults: options.defaults,
            stricted: options.stricted,
            firstRestricted: options.firstRestricted,
            message: options.message
        };
    }

    function parseFunctionDeclaration(node, identifierIsOptional) {
        var id = null, params = [], defaults = [], body, token, stricted, tmp, firstRestricted, message, previousStrict,
            isGenerator, previousAllowYield;

        previousAllowYield = state.allowYield;

        expectKeyword('function');

        isGenerator = match('*');
        if (isGenerator) {
            lex();
        }

        if (!identifierIsOptional || !match('(')) {
            token = lookahead;
            id = parseVariableIdentifier();
            if (strict) {
                if (isRestrictedWord(token.value)) {
                    tolerateUnexpectedToken(token, Messages.StrictFunctionName);
                }
            } else {
                if (isRestrictedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictFunctionName;
                } else if (isStrictModeReservedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictReservedWord;
                }
            }
        }

        state.allowYield = !isGenerator;
        tmp = parseParams(firstRestricted);
        params = tmp.params;
        defaults = tmp.defaults;
        stricted = tmp.stricted;
        firstRestricted = tmp.firstRestricted;
        if (tmp.message) {
            message = tmp.message;
        }


        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (strict && firstRestricted) {
            throwUnexpectedToken(firstRestricted, message);
        }
        if (strict && stricted) {
            tolerateUnexpectedToken(stricted, message);
        }

        strict = previousStrict;
        state.allowYield = previousAllowYield;

        return node.finishFunctionDeclaration(id, params, defaults, body, isGenerator);
    }

    function parseFunctionExpression() {
        var token, id = null, stricted, firstRestricted, message, tmp,
            params = [], defaults = [], body, previousStrict, node = new Node(),
            isGenerator, previousAllowYield;

        previousAllowYield = state.allowYield;

        expectKeyword('function');

        isGenerator = match('*');
        if (isGenerator) {
            lex();
        }

        state.allowYield = !isGenerator;
        if (!match('(')) {
            token = lookahead;
            id = (!strict && !isGenerator && matchKeyword('yield')) ? parseNonComputedProperty() : parseVariableIdentifier();
            if (strict) {
                if (isRestrictedWord(token.value)) {
                    tolerateUnexpectedToken(token, Messages.StrictFunctionName);
                }
            } else {
                if (isRestrictedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictFunctionName;
                } else if (isStrictModeReservedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictReservedWord;
                }
            }
        }

        tmp = parseParams(firstRestricted);
        params = tmp.params;
        defaults = tmp.defaults;
        stricted = tmp.stricted;
        firstRestricted = tmp.firstRestricted;
        if (tmp.message) {
            message = tmp.message;
        }

        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (strict && firstRestricted) {
            throwUnexpectedToken(firstRestricted, message);
        }
        if (strict && stricted) {
            tolerateUnexpectedToken(stricted, message);
        }
        strict = previousStrict;
        state.allowYield = previousAllowYield;

        return node.finishFunctionExpression(id, params, defaults, body, isGenerator);
    }

    // ECMA-262 14.5 Class Definitions

    function parseClassBody() {
        var classBody, token, isStatic, hasConstructor = false, body, method, computed, key;

        classBody = new Node();

        expect('{');
        body = [];
        while (!match('}')) {
            if (match(';')) {
                lex();
            } else {
                method = new Node();
                token = lookahead;
                isStatic = false;
                computed = match('[');
                if (match('*')) {
                    lex();
                } else {
                    key = parseObjectPropertyKey();
                    if (key.name === 'static' && (lookaheadPropertyName() || match('*'))) {
                        token = lookahead;
                        isStatic = true;
                        computed = match('[');
                        if (match('*')) {
                            lex();
                        } else {
                            key = parseObjectPropertyKey();
                        }
                    }
                }
                method = tryParseMethodDefinition(token, key, computed, method);
                if (method) {
                    method['static'] = isStatic; // jscs:ignore requireDotNotation
                    if (method.kind === 'init') {
                        method.kind = 'method';
                    }
                    if (!isStatic) {
                        if (!method.computed && (method.key.name || method.key.value.toString()) === 'constructor') {
                            if (method.kind !== 'method' || !method.method || method.value.generator) {
                                throwUnexpectedToken(token, Messages.ConstructorSpecialMethod);
                            }
                            if (hasConstructor) {
                                throwUnexpectedToken(token, Messages.DuplicateConstructor);
                            } else {
                                hasConstructor = true;
                            }
                            method.kind = 'constructor';
                        }
                    } else {
                        if (!method.computed && (method.key.name || method.key.value.toString()) === 'prototype') {
                            throwUnexpectedToken(token, Messages.StaticPrototype);
                        }
                    }
                    method.type = Syntax.MethodDefinition;
                    delete method.method;
                    delete method.shorthand;
                    body.push(method);
                } else {
                    throwUnexpectedToken(lookahead);
                }
            }
        }
        lex();
        return classBody.finishClassBody(body);
    }

    function parseClassDeclaration(identifierIsOptional) {
        var id = null, superClass = null, classNode = new Node(), classBody, previousStrict = strict;
        strict = true;

        expectKeyword('class');

        if (!identifierIsOptional || lookahead.type === Token.Identifier) {
            id = parseVariableIdentifier();
        }

        if (matchKeyword('extends')) {
            lex();
            superClass = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall);
        }
        classBody = parseClassBody();
        strict = previousStrict;

        return classNode.finishClassDeclaration(id, superClass, classBody);
    }

    function parseClassExpression() {
        var id = null, superClass = null, classNode = new Node(), classBody, previousStrict = strict;
        strict = true;

        expectKeyword('class');

        if (lookahead.type === Token.Identifier) {
            id = parseVariableIdentifier();
        }

        if (matchKeyword('extends')) {
            lex();
            superClass = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall);
        }
        classBody = parseClassBody();
        strict = previousStrict;

        return classNode.finishClassExpression(id, superClass, classBody);
    }

    // ECMA-262 15.2 Modules

    function parseModuleSpecifier() {
        var node = new Node();

        if (lookahead.type !== Token.StringLiteral) {
            throwError(Messages.InvalidModuleSpecifier);
        }
        return node.finishLiteral(lex());
    }

    // ECMA-262 15.2.3 Exports

    function parseExportSpecifier() {
        var exported, local, node = new Node(), def;
        if (matchKeyword('default')) {
            // export {default} from 'something';
            def = new Node();
            lex();
            local = def.finishIdentifier('default');
        } else {
            local = parseVariableIdentifier();
        }
        if (matchContextualKeyword('as')) {
            lex();
            exported = parseNonComputedProperty();
        }
        return node.finishExportSpecifier(local, exported);
    }

    function parseExportNamedDeclaration(node) {
        var declaration = null,
            isExportFromIdentifier,
            src = null, specifiers = [];

        // non-default export
        if (lookahead.type === Token.Keyword) {
            // covers:
            // export var f = 1;
            switch (lookahead.value) {
                case 'let':
                case 'const':
                    declaration = parseLexicalDeclaration({inFor: false});
                    return node.finishExportNamedDeclaration(declaration, specifiers, null);
                case 'var':
                case 'class':
                case 'function':
                    declaration = parseStatementListItem();
                    return node.finishExportNamedDeclaration(declaration, specifiers, null);
            }
        }

        expect('{');
        while (!match('}')) {
            isExportFromIdentifier = isExportFromIdentifier || matchKeyword('default');
            specifiers.push(parseExportSpecifier());
            if (!match('}')) {
                expect(',');
                if (match('}')) {
                    break;
                }
            }
        }
        expect('}');

        if (matchContextualKeyword('from')) {
            // covering:
            // export {default} from 'foo';
            // export {foo} from 'foo';
            lex();
            src = parseModuleSpecifier();
            consumeSemicolon();
        } else if (isExportFromIdentifier) {
            // covering:
            // export {default}; // missing fromClause
            throwError(lookahead.value ?
                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
        } else {
            // cover
            // export {foo};
            consumeSemicolon();
        }
        return node.finishExportNamedDeclaration(declaration, specifiers, src);
    }

    function parseExportDefaultDeclaration(node) {
        var declaration = null,
            expression = null;

        // covers:
        // export default ...
        expectKeyword('default');

        if (matchKeyword('function')) {
            // covers:
            // export default function foo () {}
            // export default function () {}
            declaration = parseFunctionDeclaration(new Node(), true);
            return node.finishExportDefaultDeclaration(declaration);
        }
        if (matchKeyword('class')) {
            declaration = parseClassDeclaration(true);
            return node.finishExportDefaultDeclaration(declaration);
        }

        if (matchContextualKeyword('from')) {
            throwError(Messages.UnexpectedToken, lookahead.value);
        }

        // covers:
        // export default {};
        // export default [];
        // export default (1 + 2);
        if (match('{')) {
            expression = parseObjectInitializer();
        } else if (match('[')) {
            expression = parseArrayInitializer();
        } else {
            expression = parseAssignmentExpression();
        }
        consumeSemicolon();
        return node.finishExportDefaultDeclaration(expression);
    }

    function parseExportAllDeclaration(node) {
        var src;

        // covers:
        // export * from 'foo';
        expect('*');
        if (!matchContextualKeyword('from')) {
            throwError(lookahead.value ?
                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
        }
        lex();
        src = parseModuleSpecifier();
        consumeSemicolon();

        return node.finishExportAllDeclaration(src);
    }

    function parseExportDeclaration() {
        var node = new Node();
        if (state.inFunctionBody) {
            throwError(Messages.IllegalExportDeclaration);
        }

        expectKeyword('export');

        if (matchKeyword('default')) {
            return parseExportDefaultDeclaration(node);
        }
        if (match('*')) {
            return parseExportAllDeclaration(node);
        }
        return parseExportNamedDeclaration(node);
    }

    // ECMA-262 15.2.2 Imports

    function parseImportSpecifier() {
        // import {<foo as bar>} ...;
        var local, imported, node = new Node();

        imported = parseNonComputedProperty();
        if (matchContextualKeyword('as')) {
            lex();
            local = parseVariableIdentifier();
        }

        return node.finishImportSpecifier(local, imported);
    }

    function parseNamedImports() {
        var specifiers = [];
        // {foo, bar as bas}
        expect('{');
        while (!match('}')) {
            specifiers.push(parseImportSpecifier());
            if (!match('}')) {
                expect(',');
                if (match('}')) {
                    break;
                }
            }
        }
        expect('}');
        return specifiers;
    }

    function parseImportDefaultSpecifier() {
        // import <foo> ...;
        var local, node = new Node();

        local = parseNonComputedProperty();

        return node.finishImportDefaultSpecifier(local);
    }

    function parseImportNamespaceSpecifier() {
        // import <* as foo> ...;
        var local, node = new Node();

        expect('*');
        if (!matchContextualKeyword('as')) {
            throwError(Messages.NoAsAfterImportNamespace);
        }
        lex();
        local = parseNonComputedProperty();

        return node.finishImportNamespaceSpecifier(local);
    }

    function parseImportDeclaration() {
        var specifiers = [], src, node = new Node();

        if (state.inFunctionBody) {
            throwError(Messages.IllegalImportDeclaration);
        }

        expectKeyword('import');

        if (lookahead.type === Token.StringLiteral) {
            // import 'foo';
            src = parseModuleSpecifier();
        } else {

            if (match('{')) {
                // import {bar}
                specifiers = specifiers.concat(parseNamedImports());
            } else if (match('*')) {
                // import * as foo
                specifiers.push(parseImportNamespaceSpecifier());
            } else if (isIdentifierName(lookahead) && !matchKeyword('default')) {
                // import foo
                specifiers.push(parseImportDefaultSpecifier());
                if (match(',')) {
                    lex();
                    if (match('*')) {
                        // import foo, * as foo
                        specifiers.push(parseImportNamespaceSpecifier());
                    } else if (match('{')) {
                        // import foo, {bar}
                        specifiers = specifiers.concat(parseNamedImports());
                    } else {
                        throwUnexpectedToken(lookahead);
                    }
                }
            } else {
                throwUnexpectedToken(lex());
            }

            if (!matchContextualKeyword('from')) {
                throwError(lookahead.value ?
                        Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
            }
            lex();
            src = parseModuleSpecifier();
        }

        consumeSemicolon();
        return node.finishImportDeclaration(specifiers, src);
    }

    // ECMA-262 15.1 Scripts

    function parseScriptBody() {
        var statement, body = [], token, directive, firstRestricted;

        while (startIndex < length) {
            token = lookahead;
            if (token.type !== Token.StringLiteral) {
                break;
            }

            statement = parseStatementListItem();
            body.push(statement);
            if (statement.expression.type !== Syntax.Literal) {
                // this is not directive
                break;
            }
            directive = source.slice(token.start + 1, token.end - 1);
            if (directive === 'use strict') {
                strict = true;
                if (firstRestricted) {
                    tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);
                }
            } else {
                if (!firstRestricted && token.octal) {
                    firstRestricted = token;
                }
            }
        }

        while (startIndex < length) {
            statement = parseStatementListItem();
            /* istanbul ignore if */
            if (typeof statement === 'undefined') {
                break;
            }
            body.push(statement);
        }
        return body;
    }

    function parseProgram() {
        var body, node;

        peek();
        node = new Node();

        body = parseScriptBody();
        return node.finishProgram(body, state.sourceType);
    }

    function filterTokenLocation() {
        var i, entry, token, tokens = [];

        for (i = 0; i < extra.tokens.length; ++i) {
            entry = extra.tokens[i];
            token = {
                type: entry.type,
                value: entry.value
            };
            if (entry.regex) {
                token.regex = {
                    pattern: entry.regex.pattern,
                    flags: entry.regex.flags
                };
            }
            if (extra.range) {
                token.range = entry.range;
            }
            if (extra.loc) {
                token.loc = entry.loc;
            }
            tokens.push(token);
        }

        extra.tokens = tokens;
    }

    function tokenize(code, options, delegate) {
        var toString,
            tokens;

        toString = String;
        if (typeof code !== 'string' && !(code instanceof String)) {
            code = toString(code);
        }

        source = code;
        index = 0;
        lineNumber = (source.length > 0) ? 1 : 0;
        lineStart = 0;
        startIndex = index;
        startLineNumber = lineNumber;
        startLineStart = lineStart;
        length = source.length;
        lookahead = null;
        state = {
            allowIn: true,
            allowYield: true,
            labelSet: {},
            inFunctionBody: false,
            inIteration: false,
            inSwitch: false,
            lastCommentStart: -1,
            curlyStack: []
        };

        extra = {};

        // Options matching.
        options = options || {};

        // Of course we collect tokens here.
        options.tokens = true;
        extra.tokens = [];
        extra.tokenValues = [];
        extra.tokenize = true;
        extra.delegate = delegate;

        // The following two fields are necessary to compute the Regex tokens.
        extra.openParenToken = -1;
        extra.openCurlyToken = -1;

        extra.range = (typeof options.range === 'boolean') && options.range;
        extra.loc = (typeof options.loc === 'boolean') && options.loc;

        if (typeof options.comment === 'boolean' && options.comment) {
            extra.comments = [];
        }
        if (typeof options.tolerant === 'boolean' && options.tolerant) {
            extra.errors = [];
        }

        try {
            peek();
            if (lookahead.type === Token.EOF) {
                return extra.tokens;
            }

            lex();
            while (lookahead.type !== Token.EOF) {
                try {
                    lex();
                } catch (lexError) {
                    if (extra.errors) {
                        recordError(lexError);
                        // We have to break on the first error
                        // to avoid infinite loops.
                        break;
                    } else {
                        throw lexError;
                    }
                }
            }

            tokens = extra.tokens;
            if (typeof extra.errors !== 'undefined') {
                tokens.errors = extra.errors;
            }
        } catch (e) {
            throw e;
        } finally {
            extra = {};
        }
        return tokens;
    }

    function parse(code, options) {
        var program, toString;

        toString = String;
        if (typeof code !== 'string' && !(code instanceof String)) {
            code = toString(code);
        }

        source = code;
        index = 0;
        lineNumber = (source.length > 0) ? 1 : 0;
        lineStart = 0;
        startIndex = index;
        startLineNumber = lineNumber;
        startLineStart = lineStart;
        length = source.length;
        lookahead = null;
        state = {
            allowIn: true,
            allowYield: true,
            labelSet: {},
            inFunctionBody: false,
            inIteration: false,
            inSwitch: false,
            lastCommentStart: -1,
            curlyStack: [],
            sourceType: 'script'
        };
        strict = false;

        extra = {};
        if (typeof options !== 'undefined') {
            extra.range = (typeof options.range === 'boolean') && options.range;
            extra.loc = (typeof options.loc === 'boolean') && options.loc;
            extra.attachComment = (typeof options.attachComment === 'boolean') && options.attachComment;

            if (extra.loc && options.source !== null && options.source !== undefined) {
                extra.source = toString(options.source);
            }

            if (typeof options.tokens === 'boolean' && options.tokens) {
                extra.tokens = [];
            }
            if (typeof options.comment === 'boolean' && options.comment) {
                extra.comments = [];
            }
            if (typeof options.tolerant === 'boolean' && options.tolerant) {
                extra.errors = [];
            }
            if (extra.attachComment) {
                extra.range = true;
                extra.comments = [];
                extra.bottomRightStack = [];
                extra.trailingComments = [];
                extra.leadingComments = [];
            }
            if (options.sourceType === 'module') {
                // very restrictive condition for now
                state.sourceType = options.sourceType;
                strict = true;
            }
        }

        try {
            program = parseProgram();
            if (typeof extra.comments !== 'undefined') {
                program.comments = extra.comments;
            }
            if (typeof extra.tokens !== 'undefined') {
                filterTokenLocation();
                program.tokens = extra.tokens;
            }
            if (typeof extra.errors !== 'undefined') {
                program.errors = extra.errors;
            }
        } catch (e) {
            throw e;
        } finally {
            extra = {};
        }

        return program;
    }

    // Sync with *.json manifests.
    exports.version = '2.7.3';

    exports.tokenize = tokenize;

    exports.parse = parse;

    // Deep copy.
    /* istanbul ignore next */
    exports.Syntax = (function () {
        var name, types = {};

        if (typeof Object.create === 'function') {
            types = Object.create(null);
        }

        for (name in Syntax) {
            if (Syntax.hasOwnProperty(name)) {
                types[name] = Syntax[name];
            }
        }

        if (typeof Object.freeze === 'function') {
            Object.freeze(types);
        }

        return types;
    }());

}));
/* vim: set sw=4 ts=4 et tw=80 : */

},{}],20:[function(require,module,exports){
/*
  Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/*jslint vars:false, bitwise:true*/
/*jshint indent:4*/
/*global exports:true*/
(function clone(exports) {
    'use strict';

    var Syntax,
        isArray,
        VisitorOption,
        VisitorKeys,
        objectCreate,
        objectKeys,
        BREAK,
        SKIP,
        REMOVE;

    function ignoreJSHintError() { }

    isArray = Array.isArray;
    if (!isArray) {
        isArray = function isArray(array) {
            return Object.prototype.toString.call(array) === '[object Array]';
        };
    }

    function deepCopy(obj) {
        var ret = {}, key, val;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                val = obj[key];
                if (typeof val === 'object' && val !== null) {
                    ret[key] = deepCopy(val);
                } else {
                    ret[key] = val;
                }
            }
        }
        return ret;
    }

    function shallowCopy(obj) {
        var ret = {}, key;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                ret[key] = obj[key];
            }
        }
        return ret;
    }
    ignoreJSHintError(shallowCopy);

    // based on LLVM libc++ upper_bound / lower_bound
    // MIT License

    function upperBound(array, func) {
        var diff, len, i, current;

        len = array.length;
        i = 0;

        while (len) {
            diff = len >>> 1;
            current = i + diff;
            if (func(array[current])) {
                len = diff;
            } else {
                i = current + 1;
                len -= diff + 1;
            }
        }
        return i;
    }

    function lowerBound(array, func) {
        var diff, len, i, current;

        len = array.length;
        i = 0;

        while (len) {
            diff = len >>> 1;
            current = i + diff;
            if (func(array[current])) {
                i = current + 1;
                len -= diff + 1;
            } else {
                len = diff;
            }
        }
        return i;
    }
    ignoreJSHintError(lowerBound);

    objectCreate = Object.create || (function () {
        function F() { }

        return function (o) {
            F.prototype = o;
            return new F();
        };
    })();

    objectKeys = Object.keys || function (o) {
        var keys = [], key;
        for (key in o) {
            keys.push(key);
        }
        return keys;
    };

    function extend(to, from) {
        var keys = objectKeys(from), key, i, len;
        for (i = 0, len = keys.length; i < len; i += 1) {
            key = keys[i];
            to[key] = from[key];
        }
        return to;
    }

    Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        AssignmentPattern: 'AssignmentPattern',
        ArrayExpression: 'ArrayExpression',
        ArrayPattern: 'ArrayPattern',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        AwaitExpression: 'AwaitExpression', // CAUTION: It's deferred to ES7.
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ClassBody: 'ClassBody',
        ClassDeclaration: 'ClassDeclaration',
        ClassExpression: 'ClassExpression',
        ComprehensionBlock: 'ComprehensionBlock',  // CAUTION: It's deferred to ES7.
        ComprehensionExpression: 'ComprehensionExpression',  // CAUTION: It's deferred to ES7.
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DebuggerStatement: 'DebuggerStatement',
        DirectiveStatement: 'DirectiveStatement',
        DoWhileStatement: 'DoWhileStatement',
        EmptyStatement: 'EmptyStatement',
        ExportAllDeclaration: 'ExportAllDeclaration',
        ExportDefaultDeclaration: 'ExportDefaultDeclaration',
        ExportNamedDeclaration: 'ExportNamedDeclaration',
        ExportSpecifier: 'ExportSpecifier',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        ForOfStatement: 'ForOfStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        GeneratorExpression: 'GeneratorExpression',  // CAUTION: It's deferred to ES7.
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        ImportDeclaration: 'ImportDeclaration',
        ImportDefaultSpecifier: 'ImportDefaultSpecifier',
        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
        ImportSpecifier: 'ImportSpecifier',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        MetaProperty: 'MetaProperty',
        MethodDefinition: 'MethodDefinition',
        ModuleSpecifier: 'ModuleSpecifier',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        ObjectPattern: 'ObjectPattern',
        Program: 'Program',
        Property: 'Property',
        RestElement: 'RestElement',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SpreadElement: 'SpreadElement',
        Super: 'Super',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        TaggedTemplateExpression: 'TaggedTemplateExpression',
        TemplateElement: 'TemplateElement',
        TemplateLiteral: 'TemplateLiteral',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement',
        YieldExpression: 'YieldExpression'
    };

    VisitorKeys = {
        AssignmentExpression: ['left', 'right'],
        AssignmentPattern: ['left', 'right'],
        ArrayExpression: ['elements'],
        ArrayPattern: ['elements'],
        ArrowFunctionExpression: ['params', 'body'],
        AwaitExpression: ['argument'], // CAUTION: It's deferred to ES7.
        BlockStatement: ['body'],
        BinaryExpression: ['left', 'right'],
        BreakStatement: ['label'],
        CallExpression: ['callee', 'arguments'],
        CatchClause: ['param', 'body'],
        ClassBody: ['body'],
        ClassDeclaration: ['id', 'superClass', 'body'],
        ClassExpression: ['id', 'superClass', 'body'],
        ComprehensionBlock: ['left', 'right'],  // CAUTION: It's deferred to ES7.
        ComprehensionExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.
        ConditionalExpression: ['test', 'consequent', 'alternate'],
        ContinueStatement: ['label'],
        DebuggerStatement: [],
        DirectiveStatement: [],
        DoWhileStatement: ['body', 'test'],
        EmptyStatement: [],
        ExportAllDeclaration: ['source'],
        ExportDefaultDeclaration: ['declaration'],
        ExportNamedDeclaration: ['declaration', 'specifiers', 'source'],
        ExportSpecifier: ['exported', 'local'],
        ExpressionStatement: ['expression'],
        ForStatement: ['init', 'test', 'update', 'body'],
        ForInStatement: ['left', 'right', 'body'],
        ForOfStatement: ['left', 'right', 'body'],
        FunctionDeclaration: ['id', 'params', 'body'],
        FunctionExpression: ['id', 'params', 'body'],
        GeneratorExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.
        Identifier: [],
        IfStatement: ['test', 'consequent', 'alternate'],
        ImportDeclaration: ['specifiers', 'source'],
        ImportDefaultSpecifier: ['local'],
        ImportNamespaceSpecifier: ['local'],
        ImportSpecifier: ['imported', 'local'],
        Literal: [],
        LabeledStatement: ['label', 'body'],
        LogicalExpression: ['left', 'right'],
        MemberExpression: ['object', 'property'],
        MetaProperty: ['meta', 'property'],
        MethodDefinition: ['key', 'value'],
        ModuleSpecifier: [],
        NewExpression: ['callee', 'arguments'],
        ObjectExpression: ['properties'],
        ObjectPattern: ['properties'],
        Program: ['body'],
        Property: ['key', 'value'],
        RestElement: [ 'argument' ],
        ReturnStatement: ['argument'],
        SequenceExpression: ['expressions'],
        SpreadElement: ['argument'],
        Super: [],
        SwitchStatement: ['discriminant', 'cases'],
        SwitchCase: ['test', 'consequent'],
        TaggedTemplateExpression: ['tag', 'quasi'],
        TemplateElement: [],
        TemplateLiteral: ['quasis', 'expressions'],
        ThisExpression: [],
        ThrowStatement: ['argument'],
        TryStatement: ['block', 'handler', 'finalizer'],
        UnaryExpression: ['argument'],
        UpdateExpression: ['argument'],
        VariableDeclaration: ['declarations'],
        VariableDeclarator: ['id', 'init'],
        WhileStatement: ['test', 'body'],
        WithStatement: ['object', 'body'],
        YieldExpression: ['argument']
    };

    // unique id
    BREAK = {};
    SKIP = {};
    REMOVE = {};

    VisitorOption = {
        Break: BREAK,
        Skip: SKIP,
        Remove: REMOVE
    };

    function Reference(parent, key) {
        this.parent = parent;
        this.key = key;
    }

    Reference.prototype.replace = function replace(node) {
        this.parent[this.key] = node;
    };

    Reference.prototype.remove = function remove() {
        if (isArray(this.parent)) {
            this.parent.splice(this.key, 1);
            return true;
        } else {
            this.replace(null);
            return false;
        }
    };

    function Element(node, path, wrap, ref) {
        this.node = node;
        this.path = path;
        this.wrap = wrap;
        this.ref = ref;
    }

    function Controller() { }

    // API:
    // return property path array from root to current node
    Controller.prototype.path = function path() {
        var i, iz, j, jz, result, element;

        function addToPath(result, path) {
            if (isArray(path)) {
                for (j = 0, jz = path.length; j < jz; ++j) {
                    result.push(path[j]);
                }
            } else {
                result.push(path);
            }
        }

        // root node
        if (!this.__current.path) {
            return null;
        }

        // first node is sentinel, second node is root element
        result = [];
        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
            element = this.__leavelist[i];
            addToPath(result, element.path);
        }
        addToPath(result, this.__current.path);
        return result;
    };

    // API:
    // return type of current node
    Controller.prototype.type = function () {
        var node = this.current();
        return node.type || this.__current.wrap;
    };

    // API:
    // return array of parent elements
    Controller.prototype.parents = function parents() {
        var i, iz, result;

        // first node is sentinel
        result = [];
        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
            result.push(this.__leavelist[i].node);
        }

        return result;
    };

    // API:
    // return current node
    Controller.prototype.current = function current() {
        return this.__current.node;
    };

    Controller.prototype.__execute = function __execute(callback, element) {
        var previous, result;

        result = undefined;

        previous  = this.__current;
        this.__current = element;
        this.__state = null;
        if (callback) {
            result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
        }
        this.__current = previous;

        return result;
    };

    // API:
    // notify control skip / break
    Controller.prototype.notify = function notify(flag) {
        this.__state = flag;
    };

    // API:
    // skip child nodes of current node
    Controller.prototype.skip = function () {
        this.notify(SKIP);
    };

    // API:
    // break traversals
    Controller.prototype['break'] = function () {
        this.notify(BREAK);
    };

    // API:
    // remove node
    Controller.prototype.remove = function () {
        this.notify(REMOVE);
    };

    Controller.prototype.__initialize = function(root, visitor) {
        this.visitor = visitor;
        this.root = root;
        this.__worklist = [];
        this.__leavelist = [];
        this.__current = null;
        this.__state = null;
        this.__fallback = null;
        if (visitor.fallback === 'iteration') {
            this.__fallback = objectKeys;
        } else if (typeof visitor.fallback === 'function') {
            this.__fallback = visitor.fallback;
        }

        this.__keys = VisitorKeys;
        if (visitor.keys) {
            this.__keys = extend(objectCreate(this.__keys), visitor.keys);
        }
    };

    function isNode(node) {
        if (node == null) {
            return false;
        }
        return typeof node === 'object' && typeof node.type === 'string';
    }

    function isProperty(nodeType, key) {
        return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;
    }

    Controller.prototype.traverse = function traverse(root, visitor) {
        var worklist,
            leavelist,
            element,
            node,
            nodeType,
            ret,
            key,
            current,
            current2,
            candidates,
            candidate,
            sentinel;

        this.__initialize(root, visitor);

        sentinel = {};

        // reference
        worklist = this.__worklist;
        leavelist = this.__leavelist;

        // initialize
        worklist.push(new Element(root, null, null, null));
        leavelist.push(new Element(null, null, null, null));

        while (worklist.length) {
            element = worklist.pop();

            if (element === sentinel) {
                element = leavelist.pop();

                ret = this.__execute(visitor.leave, element);

                if (this.__state === BREAK || ret === BREAK) {
                    return;
                }
                continue;
            }

            if (element.node) {

                ret = this.__execute(visitor.enter, element);

                if (this.__state === BREAK || ret === BREAK) {
                    return;
                }

                worklist.push(sentinel);
                leavelist.push(element);

                if (this.__state === SKIP || ret === SKIP) {
                    continue;
                }

                node = element.node;
                nodeType = node.type || element.wrap;
                candidates = this.__keys[nodeType];
                if (!candidates) {
                    if (this.__fallback) {
                        candidates = this.__fallback(node);
                    } else {
                        throw new Error('Unknown node type ' + nodeType + '.');
                    }
                }

                current = candidates.length;
                while ((current -= 1) >= 0) {
                    key = candidates[current];
                    candidate = node[key];
                    if (!candidate) {
                        continue;
                    }

                    if (isArray(candidate)) {
                        current2 = candidate.length;
                        while ((current2 -= 1) >= 0) {
                            if (!candidate[current2]) {
                                continue;
                            }
                            if (isProperty(nodeType, candidates[current])) {
                                element = new Element(candidate[current2], [key, current2], 'Property', null);
                            } else if (isNode(candidate[current2])) {
                                element = new Element(candidate[current2], [key, current2], null, null);
                            } else {
                                continue;
                            }
                            worklist.push(element);
                        }
                    } else if (isNode(candidate)) {
                        worklist.push(new Element(candidate, key, null, null));
                    }
                }
            }
        }
    };

    Controller.prototype.replace = function replace(root, visitor) {
        var worklist,
            leavelist,
            node,
            nodeType,
            target,
            element,
            current,
            current2,
            candidates,
            candidate,
            sentinel,
            outer,
            key;

        function removeElem(element) {
            var i,
                key,
                nextElem,
                parent;

            if (element.ref.remove()) {
                // When the reference is an element of an array.
                key = element.ref.key;
                parent = element.ref.parent;

                // If removed from array, then decrease following items' keys.
                i = worklist.length;
                while (i--) {
                    nextElem = worklist[i];
                    if (nextElem.ref && nextElem.ref.parent === parent) {
                        if  (nextElem.ref.key < key) {
                            break;
                        }
                        --nextElem.ref.key;
                    }
                }
            }
        }

        this.__initialize(root, visitor);

        sentinel = {};

        // reference
        worklist = this.__worklist;
        leavelist = this.__leavelist;

        // initialize
        outer = {
            root: root
        };
        element = new Element(root, null, null, new Reference(outer, 'root'));
        worklist.push(element);
        leavelist.push(element);

        while (worklist.length) {
            element = worklist.pop();

            if (element === sentinel) {
                element = leavelist.pop();

                target = this.__execute(visitor.leave, element);

                // node may be replaced with null,
                // so distinguish between undefined and null in this place
                if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
                    // replace
                    element.ref.replace(target);
                }

                if (this.__state === REMOVE || target === REMOVE) {
                    removeElem(element);
                }

                if (this.__state === BREAK || target === BREAK) {
                    return outer.root;
                }
                continue;
            }

            target = this.__execute(visitor.enter, element);

            // node may be replaced with null,
            // so distinguish between undefined and null in this place
            if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
                // replace
                element.ref.replace(target);
                element.node = target;
            }

            if (this.__state === REMOVE || target === REMOVE) {
                removeElem(element);
                element.node = null;
            }

            if (this.__state === BREAK || target === BREAK) {
                return outer.root;
            }

            // node may be null
            node = element.node;
            if (!node) {
                continue;
            }

            worklist.push(sentinel);
            leavelist.push(element);

            if (this.__state === SKIP || target === SKIP) {
                continue;
            }

            nodeType = node.type || element.wrap;
            candidates = this.__keys[nodeType];
            if (!candidates) {
                if (this.__fallback) {
                    candidates = this.__fallback(node);
                } else {
                    throw new Error('Unknown node type ' + nodeType + '.');
                }
            }

            current = candidates.length;
            while ((current -= 1) >= 0) {
                key = candidates[current];
                candidate = node[key];
                if (!candidate) {
                    continue;
                }

                if (isArray(candidate)) {
                    current2 = candidate.length;
                    while ((current2 -= 1) >= 0) {
                        if (!candidate[current2]) {
                            continue;
                        }
                        if (isProperty(nodeType, candidates[current])) {
                            element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));
                        } else if (isNode(candidate[current2])) {
                            element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));
                        } else {
                            continue;
                        }
                        worklist.push(element);
                    }
                } else if (isNode(candidate)) {
                    worklist.push(new Element(candidate, key, null, new Reference(node, key)));
                }
            }
        }

        return outer.root;
    };

    function traverse(root, visitor) {
        var controller = new Controller();
        return controller.traverse(root, visitor);
    }

    function replace(root, visitor) {
        var controller = new Controller();
        return controller.replace(root, visitor);
    }

    function extendCommentRange(comment, tokens) {
        var target;

        target = upperBound(tokens, function search(token) {
            return token.range[0] > comment.range[0];
        });

        comment.extendedRange = [comment.range[0], comment.range[1]];

        if (target !== tokens.length) {
            comment.extendedRange[1] = tokens[target].range[0];
        }

        target -= 1;
        if (target >= 0) {
            comment.extendedRange[0] = tokens[target].range[1];
        }

        return comment;
    }

    function attachComments(tree, providedComments, tokens) {
        // At first, we should calculate extended comment ranges.
        var comments = [], comment, len, i, cursor;

        if (!tree.range) {
            throw new Error('attachComments needs range information');
        }

        // tokens array is empty, we attach comments to tree as 'leadingComments'
        if (!tokens.length) {
            if (providedComments.length) {
                for (i = 0, len = providedComments.length; i < len; i += 1) {
                    comment = deepCopy(providedComments[i]);
                    comment.extendedRange = [0, tree.range[0]];
                    comments.push(comment);
                }
                tree.leadingComments = comments;
            }
            return tree;
        }

        for (i = 0, len = providedComments.length; i < len; i += 1) {
            comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
        }

        // This is based on John Freeman's implementation.
        cursor = 0;
        traverse(tree, {
            enter: function (node) {
                var comment;

                while (cursor < comments.length) {
                    comment = comments[cursor];
                    if (comment.extendedRange[1] > node.range[0]) {
                        break;
                    }

                    if (comment.extendedRange[1] === node.range[0]) {
                        if (!node.leadingComments) {
                            node.leadingComments = [];
                        }
                        node.leadingComments.push(comment);
                        comments.splice(cursor, 1);
                    } else {
                        cursor += 1;
                    }
                }

                // already out of owned node
                if (cursor === comments.length) {
                    return VisitorOption.Break;
                }

                if (comments[cursor].extendedRange[0] > node.range[1]) {
                    return VisitorOption.Skip;
                }
            }
        });

        cursor = 0;
        traverse(tree, {
            leave: function (node) {
                var comment;

                while (cursor < comments.length) {
                    comment = comments[cursor];
                    if (node.range[1] < comment.extendedRange[0]) {
                        break;
                    }

                    if (node.range[1] === comment.extendedRange[0]) {
                        if (!node.trailingComments) {
                            node.trailingComments = [];
                        }
                        node.trailingComments.push(comment);
                        comments.splice(cursor, 1);
                    } else {
                        cursor += 1;
                    }
                }

                // already out of owned node
                if (cursor === comments.length) {
                    return VisitorOption.Break;
                }

                if (comments[cursor].extendedRange[0] > node.range[1]) {
                    return VisitorOption.Skip;
                }
            }
        });

        return tree;
    }

    exports.version = require('./package.json').version;
    exports.Syntax = Syntax;
    exports.traverse = traverse;
    exports.replace = replace;
    exports.attachComments = attachComments;
    exports.VisitorKeys = VisitorKeys;
    exports.VisitorOption = VisitorOption;
    exports.Controller = Controller;
    exports.cloneEnvironment = function () { return clone({}); };

    return exports;
}(exports));
/* vim: set sw=4 ts=4 et tw=80 : */

},{"./package.json":21}],21:[function(require,module,exports){
module.exports={
  "_from": "estraverse@^4.1.x",
  "_id": "estraverse@4.2.0",
  "_inBundle": false,
  "_integrity": "sha1-De4/7TH81GlhjOc0IJn8GvoL2xM=",
  "_location": "/estraverse",
  "_phantomChildren": {},
  "_requested": {
    "type": "range",
    "registry": true,
    "raw": "estraverse@^4.1.x",
    "name": "estraverse",
    "escapedName": "estraverse",
    "rawSpec": "^4.1.x",
    "saveSpec": null,
    "fetchSpec": "^4.1.x"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/estraverse/-/estraverse-4.2.0.tgz",
  "_shasum": "0dee3fed31fcd469618ce7342099fc1afa0bdb13",
  "_spec": "estraverse@^4.1.x",
  "_where": "/data/chalmers/project/jsflow",
  "bugs": {
    "url": "https://github.com/estools/estraverse/issues"
  },
  "bundleDependencies": false,
  "deprecated": false,
  "description": "ECMAScript JS AST traversal functions",
  "devDependencies": {
    "babel-preset-es2015": "^6.3.13",
    "babel-register": "^6.3.13",
    "chai": "^2.1.1",
    "espree": "^1.11.0",
    "gulp": "^3.8.10",
    "gulp-bump": "^0.2.2",
    "gulp-filter": "^2.0.0",
    "gulp-git": "^1.0.1",
    "gulp-tag-version": "^1.2.1",
    "jshint": "^2.5.6",
    "mocha": "^2.1.0"
  },
  "engines": {
    "node": ">=0.10.0"
  },
  "homepage": "https://github.com/estools/estraverse",
  "license": "BSD-2-Clause",
  "main": "estraverse.js",
  "maintainers": [
    {
      "name": "Yusuke Suzuki",
      "email": "utatane.tea@gmail.com",
      "url": "http://github.com/Constellation"
    }
  ],
  "name": "estraverse",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/estools/estraverse.git"
  },
  "scripts": {
    "lint": "jshint estraverse.js",
    "test": "npm run-script lint && npm run-script unit-test",
    "unit-test": "mocha --compilers js:babel-register"
  },
  "version": "4.2.0"
}

},{}],22:[function(require,module,exports){
(function (global){
//     Underscore.js 1.9.1
//     http://underscorejs.org
//     (c) 2009-2018 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` (`self`) in the browser, `global`
  // on the server, or `this` in some virtual machines. We use `self`
  // instead of `window` for `WebWorker` support.
  var root = typeof self == 'object' && self.self === self && self ||
            typeof global == 'object' && global.global === global && global ||
            this ||
            {};

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype;
  var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;

  // Create quick reference variables for speed access to core prototypes.
  var push = ArrayProto.push,
      slice = ArrayProto.slice,
      toString = ObjProto.toString,
      hasOwnProperty = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var nativeIsArray = Array.isArray,
      nativeKeys = Object.keys,
      nativeCreate = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for their old module API. If we're in
  // the browser, add `_` as a global object.
  // (`nodeType` is checked to ensure that `module`
  // and `exports` are not HTML elements.)
  if (typeof exports != 'undefined' && !exports.nodeType) {
    if (typeof module != 'undefined' && !module.nodeType && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.9.1';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      // The 2-argument case is omitted because were not using it.
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  var builtinIteratee;

  // An internal function to generate callbacks that can be applied to each
  // element in a collection, returning the desired result  either `identity`,
  // an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (_.iteratee !== builtinIteratee) return _.iteratee(value, context);
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value) && !_.isArray(value)) return _.matcher(value);
    return _.property(value);
  };

  // External wrapper for our callback generator. Users may customize
  // `_.iteratee` if they want additional predicate/iteratee shorthand styles.
  // This abstraction hides the internal-only argCount argument.
  _.iteratee = builtinIteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // Some functions take a variable number of arguments, or a few expected
  // arguments at the beginning and then a variable number of values to operate
  // on. This helper accumulates all remaining arguments past the functions
  // argument length (or an explicit `startIndex`), into an array that becomes
  // the last argument. Similar to ES6s "rest parameter".
  var restArguments = function(func, startIndex) {
    startIndex = startIndex == null ? func.length - 1 : +startIndex;
    return function() {
      var length = Math.max(arguments.length - startIndex, 0),
          rest = Array(length),
          index = 0;
      for (; index < length; index++) {
        rest[index] = arguments[index + startIndex];
      }
      switch (startIndex) {
        case 0: return func.call(this, rest);
        case 1: return func.call(this, arguments[0], rest);
        case 2: return func.call(this, arguments[0], arguments[1], rest);
      }
      var args = Array(startIndex + 1);
      for (index = 0; index < startIndex; index++) {
        args[index] = arguments[index];
      }
      args[startIndex] = rest;
      return func.apply(this, args);
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  var shallowProperty = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  var has = function(obj, path) {
    return obj != null && hasOwnProperty.call(obj, path);
  }

  var deepGet = function(obj, path) {
    var length = path.length;
    for (var i = 0; i < length; i++) {
      if (obj == null) return void 0;
      obj = obj[path[i]];
    }
    return length ? obj : void 0;
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object.
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = shallowProperty('length');
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  var createReduce = function(dir) {
    // Wrap code that reassigns argument variables in a separate function than
    // the one that accesses `arguments.length` to avoid a perf hit. (#1991)
    var reducer = function(obj, iteratee, memo, initial) {
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      if (!initial) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    };

    return function(obj, iteratee, memo, context) {
      var initial = arguments.length >= 3;
      return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);
    };
  };

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var keyFinder = isArrayLike(obj) ? _.findIndex : _.findKey;
    var key = keyFinder(obj, predicate, context);
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = restArguments(function(obj, path, args) {
    var contextPath, func;
    if (_.isFunction(path)) {
      func = path;
    } else if (_.isArray(path)) {
      contextPath = path.slice(0, -1);
      path = path[path.length - 1];
    }
    return _.map(obj, function(context) {
      var method = func;
      if (!method) {
        if (contextPath && contextPath.length) {
          context = deepGet(context, contextPath);
        }
        if (context == null) return void 0;
        method = context[path];
      }
      return method == null ? method : method.apply(context, args);
    });
  });

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value != null && value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(v, index, list) {
        computed = iteratee(v, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = v;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value != null && value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(v, index, list) {
        computed = iteratee(v, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = v;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection.
  _.shuffle = function(obj) {
    return _.sample(obj, Infinity);
  };

  // Sample **n** random values from a collection using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    var sample = isArrayLike(obj) ? _.clone(obj) : _.values(obj);
    var length = getLength(sample);
    n = Math.max(Math.min(n, length), 0);
    var last = length - 1;
    for (var index = 0; index < n; index++) {
      var rand = _.random(index, last);
      var temp = sample[index];
      sample[index] = sample[rand];
      sample[rand] = temp;
    }
    return sample.slice(0, n);
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    var index = 0;
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, key, list) {
      return {
        value: value,
        index: index++,
        criteria: iteratee(value, key, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior, partition) {
    return function(obj, iteratee, context) {
      var result = partition ? [[], []] : {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (has(result, key)) result[key]++; else result[key] = 1;
  });

  var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (_.isString(obj)) {
      // Keep surrogate pair characters together
      return obj.match(reStrSymbol);
    }
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = group(function(result, value, pass) {
    result[pass ? 0 : 1].push(value);
  }, true);

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null || array.length < 1) return n == null ? void 0 : [];
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null || array.length < 1) return n == null ? void 0 : [];
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, Boolean);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, output) {
    output = output || [];
    var idx = output.length;
    for (var i = 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        // Flatten current level of array or arguments object.
        if (shallow) {
          var j = 0, len = value.length;
          while (j < len) output[idx++] = value[j++];
        } else {
          flatten(value, shallow, strict, output);
          idx = output.length;
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = restArguments(function(array, otherArrays) {
    return _.difference(array, otherArrays);
  });

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // The faster algorithm will not work with an iteratee if the iteratee
  // is not a one-to-one function, so providing an iteratee will disable
  // the faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted && !iteratee) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = restArguments(function(arrays) {
    return _.uniq(flatten(arrays, true, true));
  });

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      var j;
      for (j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = restArguments(function(array, rest) {
    rest = flatten(rest, true, true);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  });

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices.
  _.unzip = function(array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = restArguments(_.unzip);

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values. Passing by pairs is the reverse of _.pairs.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions.
  var createPredicateIndexFinder = function(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  };

  // Returns the first index on an array-like that passes a predicate test.
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions.
  var createIndexFinder = function(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
          i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
          length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  };

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    if (!step) {
      step = stop < start ? -1 : 1;
    }

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Chunk a single array into multiple arrays, each containing `count` or fewer
  // items.
  _.chunk = function(array, count) {
    if (count == null || count < 1) return [];
    var result = [];
    var i = 0, length = array.length;
    while (i < length) {
      result.push(slice.call(array, i, i += count));
    }
    return result;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments.
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = restArguments(function(func, context, args) {
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var bound = restArguments(function(callArgs) {
      return executeBound(func, bound, context, this, args.concat(callArgs));
    });
    return bound;
  });

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder by default, allowing any combination of arguments to be
  // pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.
  _.partial = restArguments(function(func, boundArgs) {
    var placeholder = _.partial.placeholder;
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  });

  _.partial.placeholder = _;

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = restArguments(function(obj, keys) {
    keys = flatten(keys, false, false);
    var index = keys.length;
    if (index < 1) throw new Error('bindAll must be passed function names');
    while (index--) {
      var key = keys[index];
      obj[key] = _.bind(obj[key], obj);
    }
  });

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = restArguments(function(func, wait, args) {
    return setTimeout(function() {
      return func.apply(null, args);
    }, wait);
  });

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var timeout, context, args, result;
    var previous = 0;
    if (!options) options = {};

    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };

    var throttled = function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };

    throttled.cancel = function() {
      clearTimeout(timeout);
      previous = 0;
      timeout = context = args = null;
    };

    return throttled;
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, result;

    var later = function(context, args) {
      timeout = null;
      if (args) result = func.apply(context, args);
    };

    var debounced = restArguments(function(args) {
      if (timeout) clearTimeout(timeout);
      if (immediate) {
        var callNow = !timeout;
        timeout = setTimeout(later, wait);
        if (callNow) result = func.apply(this, args);
      } else {
        timeout = _.delay(later, wait, this, args);
      }

      return result;
    });

    debounced.cancel = function() {
      clearTimeout(timeout);
      timeout = null;
    };

    return debounced;
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  _.restArguments = restArguments;

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
    'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  var collectNonEnumProps = function(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = _.isFunction(constructor) && constructor.prototype || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  };

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`.
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object.
  // In contrast to _.map it returns an object.
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = _.keys(obj),
        length = keys.length,
        results = {};
    for (var index = 0; index < length; index++) {
      var currentKey = keys[index];
      results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  // The opposite of _.object.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`.
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, defaults) {
    return function(obj) {
      var length = arguments.length;
      if (defaults) obj = Object(obj);
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!defaults || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s).
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test.
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Internal pick helper function to determine if `obj` has key `key`.
  var keyInObj = function(value, key, obj) {
    return key in obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = restArguments(function(obj, keys) {
    var result = {}, iteratee = keys[0];
    if (obj == null) return result;
    if (_.isFunction(iteratee)) {
      if (keys.length > 1) iteratee = optimizeCb(iteratee, keys[1]);
      keys = _.allKeys(obj);
    } else {
      iteratee = keyInObj;
      keys = flatten(keys, false, false);
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  });

  // Return a copy of the object without the blacklisted properties.
  _.omit = restArguments(function(obj, keys) {
    var iteratee = keys[0], context;
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
      if (keys.length > 1) context = keys[1];
    } else {
      keys = _.map(flatten(keys, false, false), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  });

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq, deepEq;
  eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // `null` or `undefined` only equal to itself (strict comparison).
    if (a == null || b == null) return false;
    // `NaN`s are equivalent, but non-reflexive.
    if (a !== a) return b !== b;
    // Exhaust primitive checks
    var type = typeof a;
    if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;
    return deepEq(a, b, aStack, bStack);
  };

  // Internal recursive comparison function for `isEqual`.
  deepEq = function(a, b, aStack, bStack) {
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN.
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
      case '[object Symbol]':
        return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError, isMap, isWeakMap, isSet, isWeakSet.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error', 'Symbol', 'Map', 'WeakMap', 'Set', 'WeakSet'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).
  var nodelist = root.document && root.document.childNodes;
  if (typeof /./ != 'function' && typeof Int8Array != 'object' && typeof nodelist != 'function') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return !_.isSymbol(obj) && isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`?
  _.isNaN = function(obj) {
    return _.isNumber(obj) && isNaN(obj);
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, path) {
    if (!_.isArray(path)) {
      return has(obj, path);
    }
    var length = path.length;
    for (var i = 0; i < length; i++) {
      var key = path[i];
      if (obj == null || !hasOwnProperty.call(obj, key)) {
        return false;
      }
      obj = obj[key];
    }
    return !!length;
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  // Creates a function that, when passed an object, will traverse that objects
  // properties down the given `path`, specified as an array of keys or indexes.
  _.property = function(path) {
    if (!_.isArray(path)) {
      return shallowProperty(path);
    }
    return function(obj) {
      return deepGet(obj, path);
    };
  };

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    if (obj == null) {
      return function(){};
    }
    return function(path) {
      return !_.isArray(path) ? obj[path] : deepGet(obj, path);
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

  // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped.
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // Traverses the children of `obj` along `path`. If a child is a function, it
  // is invoked with its parent as context. Returns the value of the final
  // child, or `fallback` if any child is undefined.
  _.result = function(obj, path, fallback) {
    if (!_.isArray(path)) path = [path];
    var length = path.length;
    if (!length) {
      return _.isFunction(fallback) ? fallback.call(obj) : fallback;
    }
    for (var i = 0; i < length; i++) {
      var prop = obj == null ? void 0 : obj[path[i]];
      if (prop === void 0) {
        prop = fallback;
        i = length; // Ensure we don't continue iterating.
      }
      obj = _.isFunction(prop) ? prop.call(obj) : prop;
    }
    return obj;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate: /<%([\s\S]+?)%>/g,
    interpolate: /<%=([\s\S]+?)%>/g,
    escape: /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'": "'",
    '\\': '\\',
    '\r': 'r',
    '\n': 'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offset.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    var render;
    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var chainResult = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return chainResult(this, func.apply(_, args));
      };
    });
    return _;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return chainResult(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return chainResult(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return String(this._wrapped);
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define == 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}());

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],23:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var values_1 = require("../values");
var constants = require("../constants");
var function_1 = require("../function");
var label_1 = require("../label");
var ecma_1 = require("../ecma");
var ArrayObject_1 = require("../Objects/ArrayObject");
var HasInstance_1 = require("../HasInstance");
// ------------------------------------------------------------
// 15.4.3
var ArrayConstructor = /** @class */ (function (_super) {
    __extends(ArrayConstructor, _super);
    function ArrayConstructor(host) {
        var _this = _super.call(this) || this;
        _this.Class = 'Function';
        _this.Extensible = true;
        _this.host = host;
        return _this;
    }
    ArrayConstructor.prototype.Setup = function () {
        this.Prototype = new values_1.Value(monitor.instances.FunctionPrototype, label_1.bot);
        ecma_1.DefineFFF(this, constants.length, 1);
        ecma_1.DefineFFF(this, constants.prototype, monitor.instances.ArrayPrototype);
        ecma_1.DefineTFT(this, constants.isArray, new function_1.BuiltinFunctionObject(isArray, 1, Array.isArray));
    };
    ArrayConstructor.prototype.HasInstance = function (V) {
        return HasInstance_1.HasInstance.call(this, V);
    };
    // ------------------------------------------------------------
    ArrayConstructor.prototype.Call = function (thisArg, args) {
        return this.Construct(args);
    };
    // ------------------------------------------------------------
    ArrayConstructor.prototype.Construct = function (args) {
        var array;
        var len = args.length;
        if (len === 0 || len >= 2) {
            array = ArrayObject_1.ArrayObject.fromValueArray(args, label_1.bot);
        }
        else {
            var arg = args[0];
            if (typeof arg.value === 'number') {
                array = new ArrayObject_1.ArrayObject();
                array.properties.length = arg.value;
                array.labels.length = {
                    value: arg.label,
                    existence: label_1.bot
                };
            }
            else {
                array = ArrayObject_1.ArrayObject.fromValueArray(args, label_1.bot);
            }
        }
        return new values_1.Value(array, label_1.bot);
    };
    return ArrayConstructor;
}(ecma_1.Ecma));
exports.ArrayConstructor = ArrayConstructor;
// ------------------------------------------------------------
// isArray, 15.4.3.1
var isArray = function (thisArg, args) {
    var arg = args[0] || new values_1.Value(undefined, label_1.bot);
    if (arg.value === null || typeof arg.value !== 'object') {
        return new values_1.Value(false, arg.label);
    }
    return new values_1.Value(arg.value.Class === 'Array', arg.label);
};

},{"../HasInstance":37,"../Objects/ArrayObject":38,"../constants":50,"../ecma":53,"../function":57,"../label":60,"../values":75}],24:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var values_1 = require("../values");
var constants = require("../constants");
var HasInstance_1 = require("../HasInstance");
var ecma_1 = require("../ecma");
var label_1 = require("../label");
var BooleanObject_1 = require("../Objects/BooleanObject");
var ToBoolean_1 = require("../Conversion/ToBoolean");
// ------------------------------------------------------------
// 15.6.2 -----------------------------------------------------
var BooleanConstructor = /** @class */ (function (_super) {
    __extends(BooleanConstructor, _super);
    function BooleanConstructor(host) {
        var _this = _super.call(this) || this;
        _this.Class = 'Function';
        _this.Extensible = true;
        _this.host = host;
        return _this;
    }
    BooleanConstructor.prototype.Setup = function () {
        this.Prototype = new values_1.Value(monitor.instances.FunctionPrototype, label_1.bot);
        ecma_1.DefineFFF(this, constants.length, 1); //REMOVE ?
        ecma_1.DefineFFF(this, constants.prototype, monitor.instances.BooleanPrototype);
    };
    BooleanConstructor.prototype.HasInstance = function (V) {
        HasInstance_1.HasInstance.call(this, V);
    };
    // 15.6.1.1
    BooleanConstructor.prototype.Call = function (thisArg, args) {
        var arg0 = args[0] ? args[0] : new values_1.Value(undefined, label_1.bot);
        return ToBoolean_1.ToBoolean(arg0);
    };
    // 15.6.2.1
    BooleanConstructor.prototype.Construct = function (args) {
        var arg0 = args[0] ? args[0] : new values_1.Value(undefined, label_1.bot);
        var b = ToBoolean_1.ToBoolean(arg0);
        var obj = new BooleanObject_1.BooleanObject(b.value, b.label);
        return new values_1.Value(obj, label_1.bot);
    };
    return BooleanConstructor;
}(ecma_1.Ecma));
exports.BooleanConstructor = BooleanConstructor;

},{"../Conversion/ToBoolean":28,"../HasInstance":37,"../Objects/BooleanObject":39,"../constants":50,"../ecma":53,"../label":60,"../values":75}],25:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var label_1 = require("../label");
var values_1 = require("../values");
var ecma_1 = require("../ecma");
var constants = require("../constants");
var FunctionObject_1 = require("../Objects/FunctionObject");
var HasInstance_1 = require("../HasInstance");
var esprima = require("esprima");
var ToString_1 = require("../Conversion/ToString");
// ------------------------------------------------------------
// Function Constructor, 15.3.2 (15.3.1, 15.3.1.1)
var FunctionConstructor = /** @class */ (function (_super) {
    __extends(FunctionConstructor, _super);
    function FunctionConstructor(host) {
        var _this = _super.call(this) || this;
        // Properties, 15.3.3.
        _this.Class = 'Function';
        _this.host = host;
        _this.Extensible = true;
        return _this;
    }
    FunctionConstructor.prototype.Setup = function () {
        // 15.3.3.1 
        ecma_1.DefineFFF(this, constants.prototype, monitor.instances.FunctionPrototype);
        this.Prototype = new values_1.Value(monitor.instances.FunctionPrototype, label_1.bot);
        // 15.3.3.2 
        ecma_1.DefineFFF(this, constants.length, 1);
    };
    // ---
    FunctionConstructor.prototype.HasInstance = function (V) {
        return HasInstance_1.HasInstance.call(this, V);
    };
    // 15.3.1
    FunctionConstructor.prototype.Call = function (thisArg, args) {
        return this.Construct(args);
    };
    // 15.3.2
    FunctionConstructor.prototype.Construct = function (args) {
        var argCount = args.length;
        var P = '';
        var body;
        var label = label_1.bot;
        if (argCount === 0) {
            body = new values_1.Value('', label_1.bot);
        }
        else if (argCount === 1) {
            body = args[0];
        }
        else {
            var firstArg = ToString_1.ToString(args[0]);
            label = label_1.lub(label, firstArg.label);
            P = firstArg.value;
            for (var i = 1; i < argCount - 1; i++) {
                var nextArg = ToString_1.ToString(args[i]);
                label = label_1.lub(label, firstArg.label);
                P += ', ' + nextArg.value;
            }
            body = args[argCount - 1];
        }
        body = ToString_1.ToString(body);
        label = label_1.lub(label, body.label);
        P = '(function (' + P + ') { ' + body.value + '});';
        var prog;
        try {
            prog = esprima.parse(P, { loc: true, source: 'Function' });
        }
        catch (e) {
            monitor.Throw(monitor.modules.error.SyntaxErrorObject, e.message, label);
        }
        // parsing returns a program --- we are interested in function declaration
        var func = prog.body[0].expression;
        var F = new FunctionObject_1.FunctionObject(func.params, func.body, new values_1.Value(monitor.instances.globalEnvironment, label_1.bot));
        // For pretty printing
        F.Source = func;
        return new values_1.Value(F, label);
    };
    return FunctionConstructor;
}(ecma_1.Ecma));
exports.FunctionConstructor = FunctionConstructor;

},{"../Conversion/ToString":34,"../HasInstance":37,"../Objects/FunctionObject":40,"../constants":50,"../ecma":53,"../label":60,"../values":75,"esprima":19}],26:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var label_1 = require("../label");
var values_1 = require("../values");
var ecma_1 = require("../ecma");
var constants = require("../constants");
var HasInstance_1 = require("../HasInstance");
var NumberObject_1 = require("../Objects/NumberObject");
var ToNumber_1 = require("../Conversion/ToNumber");
// ------------------------------------------------------------
// The Number Constructor, 15.7.2
var NumberConstructor = /** @class */ (function (_super) {
    __extends(NumberConstructor, _super);
    function NumberConstructor(host) {
        var _this = _super.call(this) || this;
        _this.Class = 'Function';
        // not mandated by standard
        _this.Extensible = true;
        _this.host = host;
        return _this;
    }
    NumberConstructor.prototype.Setup = function () {
        this.Prototype = new values_1.Value(monitor.instances.FunctionPrototype, label_1.bot);
        ecma_1.DefineFFF(this, constants.prototype, monitor.instances.NumberPrototype);
        ecma_1.DefineFFF(this, constants.length, 1);
        ecma_1.DefineFFF(this, constants.MAX_VALUE, this.host.MAX_VALUE);
        ecma_1.DefineFFF(this, constants.MIN_VALUE, this.host.MIN_VALUE);
        ecma_1.DefineFFF(this, constants.NaN, this.host.NaN);
        ecma_1.DefineFFF(this, constants.NEGATIVE_INFINITY, this.host.NEGATIVE_INFINITY);
        ecma_1.DefineFFF(this, constants.POSITIVE_INFINITY, this.host.POSITIVE_INFINITY);
    };
    NumberConstructor.prototype.HasInstance = function (V) {
        return HasInstance_1.HasInstance(V);
    };
    // 15.7.1.1
    NumberConstructor.prototype.Call = function (thisArg, args) {
        if (!args[0]) {
            return new values_1.Value(0, label_1.bot);
        }
        return ToNumber_1.ToNumber(args[0]);
    };
    // 15.7.2.1
    NumberConstructor.prototype.Construct = function (args) {
        var arg0 = args[0] ? ToNumber_1.ToNumber(args[0]) : new values_1.Value(0, label_1.bot);
        var res = new NumberObject_1.NumberObject(arg0.value, arg0.label);
        return new values_1.Value(res, label_1.bot);
    };
    return NumberConstructor;
}(ecma_1.Ecma));
exports.NumberConstructor = NumberConstructor;

},{"../Conversion/ToNumber":31,"../HasInstance":37,"../Objects/NumberObject":41,"../constants":50,"../ecma":53,"../label":60,"../values":75}],27:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var label_1 = require("../label");
var values_1 = require("../values");
var ecma_1 = require("../ecma");
var constants = require("../constants");
var function_1 = require("../function");
var ObjectObject_1 = require("../Objects/ObjectObject");
var ArrayObject_1 = require("../Objects/ArrayObject");
var ToBoolean_1 = require("../Conversion/ToBoolean");
var HasInstance_1 = require("../HasInstance");
var ToString_1 = require("../Conversion/ToString");
var ToObject_1 = require("../Conversion/ToObject");
// ------------------------------------------------------------
// Object Constructor, 15.2.3
var ObjectConstructor = /** @class */ (function (_super) {
    __extends(ObjectConstructor, _super);
    function ObjectConstructor(host) {
        var _this = _super.call(this) || this;
        _this.Class = 'Function';
        _this.host = host;
        return _this;
    }
    ObjectConstructor.prototype.Setup = function () {
        ecma_1.DefineFFF(this, constants.length, 1);
        // 15.2.3
        this.Prototype = new values_1.Value(monitor.instances.FunctionPrototype, label_1.bot);
        // 15.2.3.1
        ecma_1.DefineFFF(this, constants.prototype, monitor.instances.ObjectPrototype);
        ecma_1.DefineTFT(this, constants.getPrototypeOf, new function_1.BuiltinFunctionObject(getPrototypeOf, 1, Object.getPrototypeOf));
        ecma_1.DefineTFT(this, constants.getOwnPropertyDescriptor, new function_1.BuiltinFunctionObject(getOwnPropertyDescriptor, 2, Object.getOwnPropertyDescriptor));
        ecma_1.DefineTFT(this, constants.getOwnPropertyNames, new function_1.BuiltinFunctionObject(getOwnPropertyNames, 1, Object.getOwnPropertyNames));
        ecma_1.DefineTFT(this, constants.create, new function_1.BuiltinFunctionObject(create, 2, Object.create));
        ecma_1.DefineTFT(this, constants.defineProperty, new function_1.BuiltinFunctionObject(defineProperty, 3, Object.defineProperty));
        ecma_1.DefineTFT(this, constants.defineProperties, new function_1.BuiltinFunctionObject(defineProperties, 2, Object.defineProperties));
        ecma_1.DefineTFT(this, constants.seal, new function_1.BuiltinFunctionObject(seal, 1, Object.seal));
        ecma_1.DefineTFT(this, constants.freeze, new function_1.BuiltinFunctionObject(freeze, 1, Object.freeze));
        ecma_1.DefineTFT(this, constants.preventExtensions, new function_1.BuiltinFunctionObject(preventExtensions, 1, Object.preventExtensions));
        ecma_1.DefineTFT(this, constants.isSealed, new function_1.BuiltinFunctionObject(isSealed, 1, Object.isSealed));
        ecma_1.DefineTFT(this, constants.isFrozen, new function_1.BuiltinFunctionObject(isFrozen, 1, Object.isFrozen));
        ecma_1.DefineTFT(this, constants.isExtensible, new function_1.BuiltinFunctionObject(isExtensible, 1, Object.isExtensible));
        ecma_1.DefineTFT(this, constants.keys, new function_1.BuiltinFunctionObject(keys, 1, Object.keys));
    };
    ObjectConstructor.prototype.HasInstance = function (V) {
        return HasInstance_1.HasInstance.call(V);
    };
    // ------------------------------------------------------------
    // 15.2.1.1
    ObjectConstructor.prototype.Call = function (thisArg, args) {
        var arg0 = args[0] || new values_1.Value(undefined, label_1.bot);
        var res;
        monitor.context.pushPC(arg0.label);
        if (arg0.value === undefined || arg0.value === null) {
            res = this.Construct(args);
            res.raise(arg0.label);
            monitor.context.popPC();
            return res;
        }
        res = ToObject_1.ToObject(arg0);
        monitor.context.popPC();
        return res;
    };
    // ------------------------------------------------------------
    // 15.2.2.1
    ObjectConstructor.prototype.Construct = function (args) {
        var arg0 = args[0] || new values_1.Value(undefined, label_1.bot);
        monitor.context.pushPC(arg0.label);
        var res;
        if (arg0.value === undefined || arg0.value === null) {
            var o = new ObjectObject_1.ObjectObject();
            res = new values_1.Value(o, arg0.label);
            monitor.context.popPC();
            return res;
        }
        if (typeof arg0.value === 'object') {
            res = new values_1.Value(arg0.value, arg0.label);
            monitor.context.popPC();
            return res;
        }
        res = ToObject_1.ToObject(arg0);
        monitor.context.popPC();
        return res;
    };
    return ObjectConstructor;
}(ecma_1.Ecma));
exports.ObjectConstructor = ObjectConstructor;
// ------------------------------------------------------------
function assertObject(arg, callee) {
    if (typeof arg.value !== 'object') {
        monitor.context.pushPC(arg.label);
        monitor.Throw(monitor.modules.error.TypeErrorObject, callee + ' called on non-object', arg.label);
    }
}
// ------------------------------------------------------------
// 15.2.3.2
function getPrototypeOf(thisArg, args) {
    var O = args[0] || new values_1.Value(undefined, label_1.bot);
    assertObject(O, 'Object.getPrototypeOf');
    var proto = O.value.Prototype;
    return new values_1.Value(proto.value, label_1.lub(proto.label, O.label));
}
// ------------------------------------------------------------
// 15.2.3.3
var getOwnPropertyDescriptor = function (thisArg, args) {
    var O = args[0] || new values_1.Value(undefined, label_1.bot);
    var P = args[1] || new values_1.Value(undefined, label_1.bot);
    assertObject(O, 'Object.getOwnPropertyDescriptor');
    var name = ToString_1.ToString(P);
    var desc = O.GetOwnProperty(name);
    if (desc.value === undefined) {
        return desc;
    }
    var obj = new ObjectObject_1.ObjectObject();
    if (ecma_1.IsDataDescriptor(desc.value)) {
        obj.DefineOwnProperty(constants.value, {
            value: desc.value.value,
            writable: true, enumerable: true, configurable: true,
            label: desc.value.label
        }, false);
        obj.DefineOwnProperty(constants.writable, {
            value: desc.value.writable,
            writable: true, enumerable: true, configurable: true,
            label: desc.value.label
        }, false);
    }
    else {
        var get = desc.value.get ? desc.value.get.actualFunction : desc.value.get;
        obj.DefineOwnProperty(constants.get, {
            value: get,
            writable: true, enumerable: true, configurable: true,
            label: desc.value.label
        }, false);
        var set = desc.value.set ? desc.value.set.actualFunction : desc.value.set;
        obj.DefineOwnProperty(constants.set, {
            value: set,
            writable: true, enumerable: true, configurable: true,
            label: desc.value.label
        }, false);
    }
    obj.DefineOwnProperty(constants.enumerable, {
        value: desc.value.enumerable,
        writable: true, enumerable: true, configurable: true,
        label: desc.value.label
    }, false);
    obj.DefineOwnProperty(constants.configurable, {
        value: desc.value.configurable,
        writable: true, enumerable: true, configurable: true,
        label: desc.value.label
    }, false);
    return new values_1.Value(obj, desc.label);
};
// ------------------------------------------------------------
// 15.2.3.4
function getOwnPropertyNames(thisArg, args) {
    var O = args[0] || new values_1.Value(undefined, label_1.bot);
    assertObject(O, 'Object.getOwnPropertyNames');
    var propertyNames = O.value.getOwnPropertyNames(O.label);
    var array = ArrayObject_1.ArrayObject.fromPropertyArray(propertyNames, O.value.struct);
    return new values_1.Value(array, label_1.bot);
}
// ------------------------------------------------------------
// 15.2.3.5
function create(thisArg, args) {
    var O = args[0] || new values_1.Value(undefined, label_1.bot);
    var Properties = args[1] || new values_1.Value(undefined, label_1.bot);
    if (O.value !== null) {
        assertObject(O, 'Object.create');
    }
    var obj = new ObjectObject_1.ObjectObject();
    obj.Prototype = O;
    var objValue = new values_1.Value(obj, label_1.bot);
    if (Properties.value !== undefined) {
        defineProperties(thisArg, [objValue, Properties]);
    }
    return objValue;
}
// ------------------------------------------------------------
function ToPropertyDescriptor(Obj) {
    assertObject(Obj, 'Object.ToPropertyDescriptor');
    var c = monitor.context;
    var lbl = new label_1.Label();
    var desc = {};
    var b;
    var x;
    var propertyName;
    // enumerable
    propertyName = constants.enumerable;
    b = Obj.HasProperty(propertyName);
    lbl.lub(b.label);
    if (b.value) {
        c.pushPC(b.label);
        x = ToBoolean_1.ToBoolean(Obj.Get(propertyName));
        c.popPC();
        lbl.lub(x.label);
        desc[propertyName.value] = x.value;
    }
    // configurable
    propertyName = constants.configurable;
    b = Obj.HasProperty(propertyName);
    lbl.lub(b.label);
    if (b.value) {
        c.pushPC(b.label);
        x = ToBoolean_1.ToBoolean(Obj.Get(propertyName));
        c.popPC();
        lbl.lub(x.label);
        desc[propertyName.value] = x.value;
    }
    // value
    propertyName = constants.value;
    b = Obj.HasProperty(propertyName);
    lbl.lub(b.label);
    if (b.value) {
        c.pushPC(b.label);
        x = Obj.Get(propertyName);
        c.popPC();
        lbl.lub(x.label);
        desc[propertyName.value] = x.value;
    }
    // writable
    propertyName = constants.writable;
    b = Obj.HasProperty(propertyName);
    lbl.lub(b.label);
    if (b.value) {
        c.pushPC(b.label);
        x = ToBoolean_1.ToBoolean(Obj.Get(propertyName));
        c.popPC();
        lbl.lub(x.label);
        desc[propertyName.value] = x.value;
    }
    // get
    propertyName = constants.get;
    b = Obj.HasProperty(propertyName);
    lbl.lub(b.label);
    if (b.value) {
        c.pushPC(b.label);
        x = Obj.Get(propertyName);
        c.popPC();
        lbl.lub(x.label);
        desc[propertyName.value] = x.value;
    }
    // set
    propertyName = constants.set;
    b = Obj.HasProperty(propertyName);
    lbl.lub(b.label);
    if (b.value) {
        c.pushPC(b.label);
        x = Obj.Get(propertyName);
        c.popPC();
        lbl.lub(x.label);
        desc[propertyName.value] = x.value;
    }
    desc.label = lbl;
    return desc;
}
// ------------------------------------------------------------
// 15.2.3.6
function defineProperty(thisArg, args) {
    var O = args[0] || new values_1.Value(undefined, label_1.bot);
    var P = args[1] || new values_1.Value(undefined, label_1.bot);
    var Attributes = args[2] || new values_1.Value(undefined, label_1.bot);
    assertObject(O, 'Object.defineProperty');
    var name = ToString_1.ToString(P);
    var desc = ToPropertyDescriptor(Attributes);
    O.DefineOwnProperty(name, desc, true);
    return O;
}
// ------------------------------------------------------------
// 15.2.3.7
function defineProperties(thisArg, args) {
    var O = args[0] || new values_1.Value(undefined, label_1.bot);
    var Properties = args[1] || new values_1.Value(undefined, label_1.bot);
    assertObject(O, 'Object.defineProperties');
    var props = ToObject_1.ToObject(Properties);
    var names = props.value.getOwnEnumerablePropertyNames(props.label);
    var descriptors = [];
    for (var i = 0, len = names.length; i < len; i++) {
        var P_1 = names[i];
        var descObject = props.Get(P_1);
        var desc = ToPropertyDescriptor(descObject);
        descriptors.push(P_1);
        descriptors.push(desc);
    }
    for (var i = 0, len = descriptors.length; i < len; i = i + 2) {
        var P = descriptors[i];
        var desc = descriptors[i + 1];
        O.DefineOwnProperty(P, desc, true);
    }
    return O;
}
// ------------------------------------------------------------
// 15.2.3.8
function seal(thisArg, args) {
    var O = args[0] || new values_1.Value(undefined, label_1.bot);
    assertObject(O, 'Object.defineProperties');
    var context = label_1.lub(monitor.context.effectivePC, O.label);
    monitor.assert(label_1.le(context, O.value.struct), 'Object.seal: context label ' + context + ' not below structural label ' + O.value.struct + ' of object');
    var labels = O.value.labels;
    for (var x in labels) {
        if (Object.hasOwnProperty.call(labels, x)) {
            monitor.assert(label_1.le(context, labels[x].value), 'Object.seal: context label ' + context + ' not below label ' + labels[x].value + ' of ' + x);
        }
    }
    Object.seal(O.value.properties);
    O.value.Extensible = false;
    return O;
}
// ------------------------------------------------------------
// 15.2.3.9
function freeze(thisArg, args) {
    var O = args[0] || new values_1.Value(undefined, label_1.bot);
    assertObject(O, 'Object.freeze');
    var context = label_1.lub(monitor.context.effectivePC, O.label);
    monitor.assert(label_1.le(context, O.value.struct), 'Object.freeze: context label ' + context + ' not below structural label ' + O.value.struct + ' of object');
    var labels = O.value.labels;
    var properties = O.value.properties;
    for (var x in properties) {
        if (Object.hasOwnProperty.call(properties, x)) {
            var desc = Object.getOwnPropertyDescriptor(properties, x);
            if (desc.enumerable) {
                monitor.assert(label_1.le(context, labels[x].value), 'Object.freeze: context label ' + context + ' not below label ' + labels[x].value + ' of ' + x);
            }
        }
    }
    Object.freeze(O.value.properties);
    O.value.Extensible = false;
    return O;
}
// ------------------------------------------------------------
// 15.2.3.10
function preventExtensions(thisArg, args) {
    var O = args[0] || new values_1.Value(undefined, label_1.bot);
    assertObject(O, 'Object.preventExtensions');
    var context = label_1.lub(monitor.context.effectivePC, O.label);
    monitor.assert(label_1.le(context, O.value.struct), 'Object.preventExtensions: context label ' + context + ' not below structural label ' + O.value.struct + ' of object');
    Object.preventExtensions(O.value.properties);
    O.value.Extensible = false;
    return O;
}
// ------------------------------------------------------------
// 15.2.3.11
function isSealed(thisArg, args) {
    var O = args[0] || new values_1.Value(undefined, label_1.bot);
    assertObject(O, 'Object.isSealed');
    var result = Object.isSealed(O.value.properties);
    return new values_1.Value(result, label_1.lub(O.label, O.value.struct));
}
// ------------------------------------------------------------
// 15.2.3.12
function isFrozen(thisArg, args) {
    var O = args[0] || new values_1.Value(undefined, label_1.bot);
    assertObject(O, 'Object.isFrozen');
    var result = Object.isFrozen(O.value.properties);
    return new values_1.Value(result, label_1.lub(O.label, O.value.struct));
}
// ------------------------------------------------------------
// 15.2.3.13
function isExtensible(thisAr, args) {
    var O = args[0] || new values_1.Value(undefined, label_1.bot);
    assertObject(O, 'Object.isExtensible');
    var result = Object.isExtensible(O.value.properties);
    return new values_1.Value(result, label_1.lub(O.label, O.value.struct));
}
// ------------------------------------------------------------
// 15.2.3.14
function keys(thisArg, args) {
    var O = args[0] || new values_1.Value(undefined, label_1.bot);
    assertObject(O, 'Object.keys');
    var enumerable = O.value.getOwnEnumerablePropertyNames(O.label);
    var array = ArrayObject_1.ArrayObject.fromPropertyArray(enumerable, O.value.struct);
    return new values_1.Value(array, label_1.bot);
}

},{"../Conversion/ToBoolean":28,"../Conversion/ToObject":32,"../Conversion/ToString":34,"../HasInstance":37,"../Objects/ArrayObject":38,"../Objects/ObjectObject":42,"../constants":50,"../ecma":53,"../function":57,"../label":60,"../values":75}],28:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
var values_1 = require("../values");
// -------------------------------------------------------------
// ToBoolean, 9.2
function ToBoolean(x) {
    return new values_1.Value(Boolean(x.value), x.label);
}
exports.ToBoolean = ToBoolean;

},{"../values":75}],29:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
var ToNumber_1 = require("./ToNumber");
// -------------------------------------------------------------
// ToInt32, 9.5
function ToInt32(x) {
    return ToNumber_1.ToNumber(x);
}
exports.ToInt32 = ToInt32;

},{"./ToNumber":31}],30:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
var values_1 = require("../values");
var ToNumber_1 = require("./ToNumber");
// -------------------------------------------------------------
// ToInteger, 9.4
//        Using ToNumber to capture the ToPrimitive
//        and rely on the internal conversion at the point of use
//        should suffice.
function ToInteger(x) {
    var number = ToNumber_1.ToNumber(x);
    var sign = function (n) {
        if (n > 0) {
            return 1;
        }
        else if (n < 0) {
            return -1;
        }
        return 0;
    };
    if (isNaN(number.value)) {
        return new values_1.Value(0, number.label);
    }
    else if (number.value === 0 ||
        number.value === Number.POSITIVE_INFINITY ||
        number.value === Number.NEGATIVE_INFINITY) {
        return number;
    }
    else {
        return new values_1.Value(sign(number.value) * Math.floor(Math.abs(number.value)), number.label);
    }
}
exports.ToInteger = ToInteger;

},{"../values":75,"./ToNumber":31}],31:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
var values_1 = require("../values");
var ToPrimitive_1 = require("./ToPrimitive");
// -------------------------------------------------------------
// ToNumber, 9.3
function ToNumber(x) {
    if (typeof x.value !== 'object') {
        return new values_1.Value(Number(x.value), x.label);
    }
    monitor.context.pushPC(x.label);
    var primValue = ToPrimitive_1.ToPrimitive(x, 'number');
    monitor.context.popPC();
    return new values_1.Value(Number(primValue.value), primValue.label);
}
exports.ToNumber = ToNumber;

},{"../values":75,"./ToPrimitive":33}],32:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
var values_1 = require("../values");
var label_1 = require("../label");
var BooleanObject_1 = require("../Objects/BooleanObject");
var NumberObject_1 = require("../Objects/NumberObject");
// -------------------------------------------------------------
// ToObject, 9.9
function ToObject(x) {
    // null or undefined, hence ==
    if (x.value === null || x.value === undefined) {
        monitor.context.pushPC(x.label);
        monitor.Throw(monitor.modules.error.TypeErrorObject, 'cannot convert ' + String(x.value) + ' to object', label_1.bot);
    }
    var res = new values_1.Value(x.value, x.label);
    monitor.context.pushPC(x.label);
    switch (typeof x.value) {
        case 'boolean':
            res.value = new BooleanObject_1.BooleanObject(x.value, x.label);
            break;
        case 'number':
            res.value = new NumberObject_1.NumberObject(x.value, x.label);
            break;
        case 'string':
            res.value = new monitor.modules.string.StringObject(x.value, x.label);
            break;
    }
    monitor.context.popPC();
    return res;
}
exports.ToObject = ToObject;

},{"../Objects/BooleanObject":39,"../Objects/NumberObject":41,"../label":60,"../values":75}],33:[function(require,module,exports){
// -------------------------------------------------------------
// ToPrimitive, 9.1  
Object.defineProperty(exports, "__esModule", { value: true });
function ToPrimitive(x, PreferredType) {
    if (x.value === null || typeof x.value !== 'object') {
        return x;
    }
    // will run int the context of x due to value lifting
    var res = x.DefaultValue(PreferredType);
    return res;
}
exports.ToPrimitive = ToPrimitive;

},{}],34:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
var values_1 = require("../values");
var ToPrimitive_1 = require("./ToPrimitive");
// -------------------------------------------------------------
// ToString, 9.8
function ToString(x) {
    if (typeof x.value !== 'object')
        return new values_1.Value(String(x.value), x.label);
    monitor.context.pushPC(x.label);
    var primValue = ToPrimitive_1.ToPrimitive(x, 'string');
    monitor.context.popPC();
    return new values_1.Value(String(primValue.value), primValue.label);
}
exports.ToString = ToString;

},{"../values":75,"./ToPrimitive":33}],35:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
var values_1 = require("../values");
var ToNumber_1 = require("./ToNumber");
// -------------------------------------------------------------
// ToUInt16, 9.7
function ToUInt16(x) {
    var sign = function (n) {
        if (n > 0) {
            return 1;
        }
        else if (n < 0) {
            return -1;
        }
        return 0;
    };
    var number = ToNumber_1.ToNumber(x);
    if (isNaN(number.value) ||
        number.value === 0 ||
        number.value === Number.POSITIVE_INFINITY ||
        number.value === Number.NEGATIVE_INFINITY) {
        return new values_1.Value(0, number.label);
    }
    var posInt = sign(number.value) * Math.floor(Math.abs(number.value));
    var int16bit = posInt % Math.pow(2, 16);
    return new values_1.Value(int16bit, number.label);
}
exports.ToUInt16 = ToUInt16;

},{"../values":75,"./ToNumber":31}],36:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
var ToNumber_1 = require("./ToNumber");
// -------------------------------------------------------------
// ToUInt32, 9.6
function ToUInt32(x) {
    return ToNumber_1.ToNumber(x);
}
exports.ToUInt32 = ToUInt32;

},{"./ToNumber":31}],37:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
var label_1 = require("./label");
var values_1 = require("./values");
var constants = require("./constants");
// ------------------------------------------------------------
function HasInstance(V) {
    var F = this;
    if (typeof V.value !== 'object')
        return new values_1.Value(false, V.label);
    var l = V.label;
    var O = F.Get(constants.prototype);
    if (typeof O.value !== 'object') {
        monitor.Throw(monitor.modules.error.TypeErrorObject, 'HasInstance', label_1.bot);
    }
    while (V.value !== null) {
        V = V.value.Prototype;
        l = label_1.lub(l, V.label);
        if (O.value === V.value)
            return new values_1.Value(true, l);
    }
    return new values_1.Value(false, l);
}
exports.HasInstance = HasInstance;

},{"./constants":50,"./label":60,"./values":75}],38:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var values_1 = require("../values");
var _ = require("underscore");
var ecma_1 = require("../ecma");
var label_1 = require("../label");
// ------------------------------------------------------------
// 15.4.2.1, and 15.4.2.2
var ArrayObject = /** @class */ (function (_super) {
    __extends(ArrayObject, _super);
    function ArrayObject(struct) {
        var _this = _super.call(this) || this;
        _this.Class = 'Array';
        _this.Prototype = new values_1.Value(monitor.instances.ArrayPrototype, label_1.bot);
        _this.Extensible = true;
        _this.properties = [];
        _this.labels = {};
        struct = struct || label_1.bot;
        _this.labels.length = {
            value: struct,
            existence: label_1.bot
        };
        _this.struct = struct;
        return _this;
    }
    // ---
    ArrayObject.fromValueArray = function (values, struct) {
        var array = new ArrayObject(struct);
        for (var i = 0, len = values.length; i < len; i++) {
            var value = values[i];
            array.properties[i] = value.value;
            array.labels[i] = {
                value: value.label,
                existence: label_1.bot
            };
        }
        return array;
    };
    // ---
    ArrayObject.fromPropertyArray = function (values, struct) {
        var array = new ArrayObject(struct);
        for (var i = 0, len = values.length; i < len; i++) {
            var value = values[i];
            array.properties[i] = value.value;
            array.labels[i] = {
                value: value.label,
                existence: value.label
            };
        }
        return array;
    };
    // ---
    ArrayObject.fromArray = function (values, label, existence) {
        var array = new ArrayObject(existence);
        for (var i = 0, len = values.length; i < len; i++) {
            array.properties[i] = values[i];
            array.labels[i] = {
                value: label,
                existence: existence
            };
        }
        return array;
    };
    // ---
    ArrayObject.prototype.toString = function () {
        return this.properties.toString();
    };
    // ---
    ArrayObject.prototype.DefineOwnProperty = function (s, desc, Throw) {
        var c = monitor.context;
        /* Instead of lengthContext = lub(c.effectivePC, s.label), push s.label to
           pc-stack, and use pc (to make taintMode easier) */
        c.pcStack.push(s.label);
        if (!label_1.le(c.effectivePC, this.labels.length.value)) {
            var msgt = _.template('Array.prototype.DefineOwnProperty: write context <%=wc%> not below length label <%=ll%>');
            monitor.securityError(msgt({ wc: lengthContext, ll: this.labels.length.value }));
            // For observable flows
            this.labels.length.value.lub(lengthContext);
        }
        c.pcStack.pop();
        return ecma_1.Ecma.prototype.DefineOwnProperty.call(this, s, desc, Throw);
    };
    return ArrayObject;
}(ecma_1.Ecma));
exports.ArrayObject = ArrayObject;

},{"../ecma":53,"../label":60,"../values":75,"underscore":22}],39:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var values_1 = require("../values");
var ecma_1 = require("../ecma");
var label_1 = require("../label");
// ------------------------------------------------------------
// Boolean Object, 15.6.5
var BooleanObject = /** @class */ (function (_super) {
    __extends(BooleanObject, _super);
    function BooleanObject(val, lbl) {
        var _this = _super.call(this) || this;
        _this.Class = 'Boolean';
        _this.PrimitiveValue = new Boolean(val);
        _this.PrimitiveLabel = lbl;
        _this.Extensible = true;
        _this.Prototype = new values_1.Value(monitor.instances.BooleanPrototype, label_1.bot);
        return _this;
    }
    return BooleanObject;
}(ecma_1.Ecma));
exports.BooleanObject = BooleanObject;

},{"../ecma":53,"../label":60,"../values":75}],40:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var label_1 = require("../label");
var values_1 = require("../values");
var ecma_1 = require("../ecma");
var constants = require("../constants");
var function_1 = require("../function");
var ObjectObject_1 = require("../Objects/ObjectObject");
var HasInstance_1 = require("../HasInstance");
// ------------------------------------------------------------
// Function objects, 13.2
var FunctionObject = /** @class */ (function (_super) {
    __extends(FunctionObject, _super);
    function FunctionObject(parms, code, scope) {
        var _this = _super.call(this) || this;
        _this.Class = 'Function';
        _this.Prototype = new values_1.Value(monitor.instances.FunctionPrototype, label_1.bot);
        _this.Scope = scope;
        _this.FormalParameters = parms ? parms : { length: 0 };
        _this.Code = code;
        _this.Extensible = true;
        ecma_1.DefineFFT(_this, constants.length, _this.FormalParameters.length);
        // NOTE: will be updated when called and since we piggyback properties on native properties
        // defining as FFF will cause future updates to fail. Thus we define it as TFT even though
        // this violates the standard.
        ecma_1.DefineTFT(_this, constants.arguments, null);
        ecma_1.DefineFFF(_this, constants.caller, null);
        var proto = new ObjectObject_1.ObjectObject();
        ecma_1.DefineTFT(proto, constants.constructor, _this);
        ecma_1.DefineTFF(_this, constants.prototype, proto);
        return _this;
    }
    // ---
    FunctionObject.prototype.AsyncCall = function (thisArg, args) {
        // step 1, as in 10.4.3 embodied in enterFunctionCode
        var funcCtx = function_1.enterFunctionCode(this, thisArg, args);
        // for stack trace
        funcCtx.owner = this.Name;
        monitor.contextStack.push(funcCtx);
        var ip = funcCtx.workList.top();
        var res;
        if (this.Code) {
            ip.then(this.Code);
            ip.then(AsyncCallEnd);
        }
        else {
            ip.then(AsyncCallEnd);
        }
    };
    // ---
    // 13.2.1 
    FunctionObject.prototype.Call = function (thisArg, args) {
        // step 1, as in 10.4.3 embodied in enterFunctionCode
        var funcCtx = function_1.enterFunctionCode(this, thisArg, args);
        // for stack trace
        funcCtx.owner = this.Name;
        var res;
        monitor.contextStack.push(funcCtx);
        if (this.Code) {
            res = monitor.modules.exec.execute(this.Code, false);
        }
        if (funcCtx.result.value) {
            funcCtx.result.value.raise(funcCtx.labels.ret);
        }
        monitor.contextStack.pop();
        // copy out the inner exception level
        monitor.context.labels.exc = label_1.lub(monitor.context.labels.exc, funcCtx.labels.exc);
        switch (res.type) {
            case 'throw':
                throw res.value;
            case 'return':
                return res.value;
        }
        return new values_1.Value(undefined, funcCtx.labels.ret);
    };
    // ---
    FunctionObject.prototype.AsyncConstruct = function (args) {
        var obj = new ecma_1.Ecma();
        obj.Class = 'Object';
        obj.Extensible = true;
        var proto = this.Get(constants.prototype);
        if (typeof proto.value !== 'object') {
            proto.value = new values_1.Value(monitor.instances.ObjectPrototype, label_1.bot);
        }
        obj.Prototype = proto;
        var ip = monitor.context.workList.top();
        this.AsyncCall(new values_1.Value(obj, label_1.bot), args);
        ip.then(AsyncConstructEnd, { object: obj });
        return ip;
    };
    // ---
    // ---
    // 13.2.2
    FunctionObject.prototype.Construct = function (args) {
        var obj = new ecma_1.Ecma();
        obj.Class = 'Object';
        obj.Extensible = true;
        var proto = this.Get(constants.prototype);
        if (typeof proto.value !== 'object') {
            proto.value = new values_1.Value(monitor.instances.ObjectPrototype, label_1.bot);
        }
        obj.Prototype = proto;
        var result = this.Call(new values_1.Value(obj, label_1.bot), args);
        if (result.value !== 'object') {
            result = new values_1.Value(obj, label_1.bot);
        }
        return result;
    };
    FunctionObject.prototype.HasInstance = function (V) {
        return HasInstance_1.HasInstance.call(this, V);
    };
    FunctionObject.prototype.toString = function () {
        if (this.Source) {
            return pp.pretty(this.Source);
        }
        else if (this.host) {
            return this.host.toString();
        }
        else {
            return 'host undefined for ' + this.Class;
        }
    };
    return FunctionObject;
}(ecma_1.Ecma));
exports.FunctionObject = FunctionObject;
// ---
function AsyncCallEnd() {
    var callContext = monitor.context;
    monitor.contextStack.pop();
    var callerContext = monitor.context;
    var result = callContext.result;
    var retlabel = callContext.labels.ret;
    if (result.type !== 'normal' && result.value) {
        result.value.raise(retlabel);
    }
    else {
        result.value = new values_1.Value(undefined, retlabel);
    }
    // copy out the inner exception level
    callerContext.labels.exc = label_1.lub(callerContext.labels.exc, callContext.labels.exc);
    callerContext.valueStack.push(result);
}
exports.AsyncCallEnd = AsyncCallEnd;
AsyncCallEnd.runfor = { 'return': true, 'throw': true };
function AsyncConstructEnd() {
    var retval = monitor.context.valueStack.peek();
    if (typeof retval.value.value !== 'object') {
        retval.value = new values_1.Value(this.object, label_1.bot);
    }
}
exports.AsyncConstructEnd = AsyncConstructEnd;
AsyncConstructEnd.runfor = { 'return': true, 'throw': true };

},{"../HasInstance":37,"../Objects/ObjectObject":42,"../constants":50,"../ecma":53,"../function":57,"../label":60,"../values":75}],41:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var label_1 = require("../label");
var values_1 = require("../values");
var ecma_1 = require("../ecma");
// ------------------------------------------------------------
// Number Object, 15.7.5
var NumberObject = /** @class */ (function (_super) {
    __extends(NumberObject, _super);
    function NumberObject(val, lbl) {
        var _this = _super.call(this) || this;
        _this.Class = 'Number';
        _this.PrimitiveValue = new Number(val);
        _this.PrimitiveLabel = lbl;
        _this.Extensible = true;
        _this.Prototype = new values_1.Value(monitor.instances.NumberPrototype, label_1.bot);
        return _this;
    }
    return NumberObject;
}(ecma_1.Ecma));
exports.NumberObject = NumberObject;

},{"../ecma":53,"../label":60,"../values":75}],42:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var label_1 = require("../label");
var values_1 = require("../values");
var ecma_1 = require("../ecma");
// ------------------------------------------------------------
// Object objects, 15.2.2.1
var ObjectObject = /** @class */ (function (_super) {
    __extends(ObjectObject, _super);
    function ObjectObject() {
        var _this = _super.call(this) || this;
        _this.Prototype = new values_1.Value(monitor.instances.ObjectPrototype, label_1.bot);
        _this.Class = 'Object';
        _this.Extensible = true;
        return _this;
        // this.host      = {};
    }
    return ObjectObject;
}(ecma_1.Ecma));
exports.ObjectObject = ObjectObject;
// ---
ObjectObject.prototype.toString = function () {
    var properties = [];
    for (x in this.properties) {
        if (this.properties.hasOwnProperty(x)) {
            properties.push(x + ': ' + this.properties[x]);
        }
    }
    return '{' + properties.join(', ') + '}';
};
// ------------------------------------------------------------

},{"../ecma":53,"../label":60,"../values":75}],43:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var values_1 = require("../values");
var constants = require("../constants");
var function_1 = require("../function");
var label_1 = require("../label");
var ecma_1 = require("../ecma");
var ArrayObject_1 = require("../Objects/ArrayObject");
var ToBoolean_1 = require("../Conversion/ToBoolean");
var ToInteger_1 = require("../Conversion/ToInteger");
var ToString_1 = require("../Conversion/ToString");
var ToObject_1 = require("../Conversion/ToObject");
var IsCallable_1 = require("../Utility/IsCallable");
var ToUInt32_1 = require("../Conversion/ToUInt32");
// ------------------------------------------------------------
// 15.4.4
var ArrayPrototype = /** @class */ (function (_super) {
    __extends(ArrayPrototype, _super);
    function ArrayPrototype(host) {
        var _this = _super.call(this) || this;
        _this.Class = 'Array';
        _this.host = host;
        return _this;
    }
    ArrayPrototype.prototype.Setup = function () {
        this.Prototype = new values_1.Value(monitor.instances.ObjectPrototype, label_1.bot);
        ecma_1.Define(this, constants.length, 0, { writable: true });
        ecma_1.DefineTFT(this, constants.constructor, monitor.instances.ArrayConstructor);
        ecma_1.DefineTFT(this, constants.toString, new function_1.BuiltinFunctionObject(toString, 0, Array.prototype.toString));
        ecma_1.DefineTFT(this, constants.toLocaleString, new function_1.BuiltinFunctionObject(toLocaleString, 0, Array.prototype.toLocaleString));
        ecma_1.DefineTFT(this, constants.concat, new function_1.BuiltinFunctionObject(concat, 1, Array.prototype.concat));
        ecma_1.DefineTFT(this, constants.join, new function_1.BuiltinFunctionObject(join, 1, Array.prototype.join));
        ecma_1.DefineTFT(this, constants.pop, new function_1.BuiltinFunctionObject(pop, 0, Array.prototype.pop));
        ecma_1.DefineTFT(this, constants.push, new function_1.BuiltinFunctionObject(push, 1, Array.prototype.push));
        ecma_1.DefineTFT(this, constants.reverse, new function_1.BuiltinFunctionObject(reverse, 0, Array.prototype.reverse));
        ecma_1.DefineTFT(this, constants.shift, new function_1.BuiltinFunctionObject(shift, 0, Array.prototype.shift));
        ecma_1.DefineTFT(this, constants.slice, new function_1.BuiltinFunctionObject(slice, 2, Array.prototype.slice));
        ecma_1.DefineTFT(this, constants.sort, new function_1.BuiltinFunctionObject(sort, 1, Array.prototype.sort));
        ecma_1.DefineTFT(this, constants.splice, new function_1.BuiltinFunctionObject(splice, 2, Array.prototype.splice));
        ecma_1.DefineTFT(this, constants.unshift, new function_1.BuiltinFunctionObject(unshift, 1, Array.prototype.unshift));
        ecma_1.DefineTFT(this, constants.indexOf, new function_1.BuiltinFunctionObject(indexOf, 1, Array.prototype.indexOf));
        ecma_1.DefineTFT(this, constants.lastIndexOf, new function_1.BuiltinFunctionObject(lastIndexOf, 1, Array.prototype.lastIndexOf));
        ecma_1.DefineTFT(this, constants.every, new function_1.BuiltinFunctionObject(every, 1, Array.prototype.every));
        ecma_1.DefineTFT(this, constants.some, new function_1.BuiltinFunctionObject(some, 1, Array.prototype.some));
        ecma_1.DefineTFT(this, constants.forEach, new function_1.BuiltinFunctionObject(forEach, 1, Array.prototype.forEach));
        ecma_1.DefineTFT(this, constants.map, new function_1.BuiltinFunctionObject(map, 1, Array.prototype.map));
        ecma_1.DefineTFT(this, constants.filter, new function_1.BuiltinFunctionObject(filter, 1, Array.prototype.filter));
        ecma_1.DefineTFT(this, constants.reduce, new function_1.BuiltinFunctionObject(reduce, 1, Array.prototype.reduce));
        ecma_1.DefineTFT(this, constants.reduceRight, new function_1.BuiltinFunctionObject(reduceRight, 1, Array.prototype.reduceRight));
    };
    return ArrayPrototype;
}(ecma_1.Ecma));
exports.ArrayPrototype = ArrayPrototype;
// ------------------------------------------------------------
// toString, 15.4.4.2
var toString = function (thisArg, args) {
    var array = ToObject_1.ToObject(thisArg);
    var func = array.Get(constants.join);
    if (!IsCallable_1.IsCallable(func).value) {
        func = monitor.instances.ObjectPrototype.Get(constants.toString);
    }
    return func.value.Call(array, []);
};
// ------------------------------------------------------------
// toLocaleString, 15.4.4.3
var toLocaleString = function (thisArg) {
    var array, arrayLen, len, separator, firstElement, R, elementObj, func, k, S, nextElement;
    array = ToObject_1.ToObject(thisArg);
    arrayLen = array.Get(new values_1.Value("length", label_1.bot));
    len = ToUInt32_1.ToUInt32(arrayLen);
    separator = ',';
    var label = label_1.lub(monitor.context.effectivePC, array.label);
    if (len.value === 0) {
        return new values_1.Value("", label);
    }
    firstElement = array.Get(new values_1.Value("0", label_1.bot));
    if (firstElement.value === undefined || firstElement.value === null) {
        R = new values_1.Value("", label);
    }
    else {
        elementObj = ToObject_1.ToObject(firstElement);
        func = elementObj.Get(new values_1.Value("toLocaleString", label_1.bot));
        if (IsCallable_1.IsCallable(func).value === false) {
            monitor.Throw(monitor.modules.error.TypeErrorObject, 'Array.prototype.toLocaleString: not a function', label_1.bot);
        }
        R = func.value.Call(elementObj, []);
    }
    k = 1;
    while (k < len.value) {
        S = R.value.concat(separator);
        nextElement = array.Get(new values_1.Value('' + k, label_1.bot));
        if (nextElement.value === undefined || firstElement.value === null) {
            R = new values_1.Value("", label);
        }
        else {
            elementObj = ToObject_1.ToObject(nextElement);
            func = elementObj.Get(new values_1.Value("toLocaleString", label_1.bot));
            if (IsCallable_1.IsCallable(func).value === false) {
                monitor.Throw(monitor.modules.error.TypeErrorObject, 'Array.prototype.toLocaleString: not a function', label_1.bot);
            }
            R = func.value.Call(elementObj, []);
        }
        R = new values_1.Value(S.concat(R.value), R.label);
        k++;
    }
    R.raise(label);
    return R;
};
// ------------------------------------------------------------
// concat, 15.4.4.4
var concat = function (thisArg, args) {
    var O = ToObject_1.ToObject(thisArg);
    var A = new ArrayObject_1.ArrayObject();
    var n = 0;
    var c = monitor.context;
    var label = new label_1.Label();
    function aux(E) {
        c.pushPC(E.label);
        label.lub(E.label);
        if (E.value && E.value.Class === 'Array') {
            var k = 0;
            var len = E.Get(constants.length);
            label.lub(len.label);
            monitor.context.pushPC(len.label);
            while (k < len.value) {
                var _k = new values_1.Value(k, label_1.bot);
                var exists = E.HasProperty(_k);
                if (exists.value) {
                    monitor.context.pushPC(exists.label);
                    var subElement = E.Get(_k);
                    A.DefineOwnProperty(new values_1.Value(n, label), {
                        value: subElement.value,
                        label: subElement.label,
                        writable: true,
                        enumerable: true,
                        configurable: true
                    }, false);
                    monitor.context.popPC();
                }
                n++;
                k++;
            }
            monitor.context.popPC();
        }
        else {
            A.DefineOwnProperty(new values_1.Value(n, label), {
                value: E.value,
                label: E.label,
                writable: true,
                enumerable: true,
                configurable: true
            }, false);
            n++;
        }
        c.popPC();
    }
    aux(O);
    for (var i = 0, len = args.length; i < len; i++) {
        aux(args[i]);
    }
    // This is a fix they added in ECMA-262 v6 standard, but browsers used it
    // in ECMA-262 v5 as well.
    A.Put(new values_1.Value("length", label_1.bot), new values_1.Value(n, label_1.bot));
    return new values_1.Value(A, label_1.bot);
};
// ------------------------------------------------------------
// join, 15.4.4.5
function join(thisArg, args) {
    var O = ToObject_1.ToObject(thisArg);
    var len = ToUInt32_1.ToUInt32(O.Get(constants.length));
    var separator = args[0];
    if (separator) {
        if (separator.value === undefined) {
            separator.value = ',';
        }
        separator = ToString_1.ToString(separator);
    }
    else {
        separator = new values_1.Value(undefined, label_1.bot);
    }
    var label = label_1.lub(len.label, separator.label);
    var arr = [];
    for (var i = 0; i < len.value; i++) {
        var v = O.Get(new values_1.Value(i, label_1.bot));
        var y;
        if (v.value === undefined || v.value === null) {
            y = new values_1.Value('', v.label);
        }
        else {
            y = ToString_1.ToString(v);
        }
        arr[i] = y.value;
        label = label_1.lub(label, y.label);
    }
    var res = arr.join(separator.value);
    return new values_1.Value(res, label);
}
;
// ------------------------------------------------------------
// pop, 15.4.4.6
function pop(thisArg, args) {
    var O = ToObject_1.ToObject(thisArg);
    var len = ToUInt32_1.ToUInt32(O.Get(constants.length));
    if (len.value === 0) {
        O.Put(constants.length, len, true);
        return new values_1.Value(undefined, len.label);
    }
    var indx = new values_1.Value(len.value - 1, len.label);
    var element = O.Get(indx);
    O.Delete(indx, true);
    O.Put(constants.length, indx, true);
    return element;
}
;
// ------------------------------------------------------------
// push, 15.4.4.7
function push(thisArg, args) {
    var O = ToObject_1.ToObject(thisArg);
    var n = ToUInt32_1.ToUInt32(O.Get(constants.length));
    for (var i = 0, len = args.length; i < len; i++) {
        var E = args[i];
        O.Put(n, E);
        n.value++;
    }
    O.Put(constants.length, n, true);
    return n;
}
// ------------------------------------------------------------
// reverse, 15.4.4.8
function reverse(thisArg, args) {
    var O = ToObject_1.ToObject(thisArg);
    var len = ToUInt32_1.ToUInt32(O.Get(constants.length));
    var P = len;
    len = len.value;
    var middle = Math.floor(len / 2);
    var lower = 0;
    var c = monitor.context;
    while (lower !== middle && lower > -2) {
        var upper = len - lower - 1;
        P.value = lower;
        var lowerValue = O.Get(P);
        P.value = upper;
        var upperValue = O.Get(P);
        P.value = lower;
        var lowerExists = O.HasProperty(P);
        P.value = upper;
        var upperExists = O.HasProperty(P);
        c.pushPC(label_1.lub(lowerExists.label, upperExists.label));
        if (lowerExists.value && upperExists.value) {
            P.value = lower;
            O.Put(P, upperValue, true);
            P.value = upper;
            O.Put(P, lowerValue, true);
        }
        else if (!lowerExists.value && upperExists.value) {
            P.value = lower;
            O.Put(P, upperValue, true);
            P.value = upper;
            O.Delete(P, true);
        }
        else if (lowerExists.value && !upperExists.value) {
            P.value = lower;
            O.Delete(P, true);
            P.value = upper;
            O.Put(P, lowerValue, true);
        }
        c.popPC();
        lower++;
    }
    return O;
}
// ------------------------------------------------------------
// shift, 15.4.4.9
function shift(thisArg, args) {
    var O = ToObject_1.ToObject(thisArg);
    var lenVal = O.Get(constants.length);
    var len = ToUInt32_1.ToUInt32(lenVal);
    if (len.value === 0) {
        monitor.context.pushPC(len.label);
        O.Put(constants.length, len, true);
        monitor.context.popPC();
        return new values_1.Value(undefined, len.label);
    }
    var first = O.Get(new values_1.Value(0, label_1.bot));
    var k = 1;
    monitor.context.pushPC(len.label);
    while (k < len.value) {
        var from = k;
        var _from = new values_1.Value(from, len.label);
        var to = k - 1;
        var _to = new values_1.Value(to, len.label);
        var fromPresent = O.HasProperty(_from);
        if (fromPresent.value) {
            monitor.context.pushPC(fromPresent.label);
            var fromVal = O.Get(_from);
            O.Put(_to, fromVal, true);
            monitor.context.popPC();
        }
        else {
            O.Delete(_to, true);
        }
        k++;
    }
    monitor.context.popPC();
    len.value--;
    O.Delete(len, true);
    O.Put(constants.length, len, true);
    return first;
}
;
// ------------------------------------------------------------
// slice, 15.4.4.10
function slice(thisArg, args) {
    var O = ToObject_1.ToObject(thisArg);
    var A = new ArrayObject_1.ArrayObject();
    var lenVal = O.Get(constants.length);
    var len = ToUInt32_1.ToUInt32(lenVal);
    var start = args[0] ? args[0] : new values_1.Value(undefined, label_1.bot);
    var end = args[1] ? args[1] : new values_1.Value(undefined, label_1.bot);
    var relativeStart = ToInteger_1.ToInteger(start);
    var k = new values_1.Value(0, label_1.lub(len.label, relativeStart.label));
    if (relativeStart.value < 0) {
        k.value = Math.max(len.value + relativeStart.value, 0);
    }
    else {
        k.value = Math.min(relativeStart.value, len.value);
    }
    var relativeEnd;
    if (end.value === undefined) {
        relativeEnd = len;
    }
    else {
        relativeEnd = ToInteger_1.ToInteger(end);
    }
    var _final = new values_1.Value(0, label_1.lub(len.label, relativeStart.label));
    if (relativeEnd.value < 0) {
        _final.value = Math.max(len.value + relativeEnd.value, 0);
    }
    else {
        _final.value = Math.min(relativeEnd.value, len.value);
    }
    var n = 0;
    monitor.context.pushPC(label_1.lub(k.label, _final.label));
    while (k.value < _final.value) {
        var Pk = ToString_1.ToString(k);
        var kPresent = O.HasProperty(Pk);
        if (kPresent.value) {
            var kValue = O.Get(Pk);
            A.DefineOwnProperty(new values_1.Value(n, label_1.bot), {
                value: kValue.value,
                label: kValue.label,
                writable: true,
                enumerable: true,
                configurable: true
            }, false);
        }
        k.value++;
        n++;
    }
    monitor.context.popPC();
    return new values_1.Value(A, label_1.bot);
}
;
// ------------------------------------------------------------
// sort, 15.4.4.11
var sort = function (thisArg, args) {
    var comparefun = args[0] || new values_1.Value(undefined, label_1.bot);
    var O = ToObject_1.ToObject(thisArg);
    var lenVal = O.Get(constants.length);
    var len = ToUInt32_1.ToUInt32(lenVal);
    var label = new label_1.Label();
    label.lub(O.label, len.label);
    var c = monitor.context;
    c.pushPC(len.label);
    var array = [];
    var k = new values_1.Value(0, len.label);
    while (k.value < len.value) {
        var kPresent = O.HasProperty(k);
        c.labels.pc.lub(kPresent.label);
        label.lub(kPresent.label);
        if (kPresent.value) {
            var kValue = O.Get(k);
            kValue.raise(label);
            array[k.value] = kValue;
        }
        k.value++;
    }
    var isCallable = IsCallable_1.IsCallable(comparefun);
    c.labels.pc.lub(isCallable.label);
    if (comparefun.value !== undefined && !isCallable.value) {
        monitor.Throw(monitor.modules.error.TypeErrorObject, 'Array.prototype.sort: not a function', label_1.bot);
    }
    var comparefunWrapper;
    if (comparefun.value) {
        comparefunWrapper = function (x, y) {
            if (x.value === undefined) {
                label.lub(x.label);
                return 1;
            }
            if (y.value === undefined) {
                label.lub(y.label);
                return -1;
            }
            var result = comparefun.Call(new values_1.Value(undefined, label_1.bot), [x, y]);
            c.labels.pc.lub(result.label, x.label, y.label);
            label.lub(result.label, x.label, y.label);
            return result.value;
        };
    }
    else {
        comparefunWrapper = function (x, y) {
            if (x.value === undefined) {
                label.lub(x.label);
                return 1;
            }
            if (y.value === undefined) {
                label.lub(y.label);
                return -1;
            }
            var xString = ToString_1.ToString(x);
            var yString = ToString_1.ToString(y);
            c.labels.pc.lub(xString.label, yString.label);
            label.lub(xString.label, yString.label);
            if (xString.value < yString.value) {
                return -1;
            }
            if (xString.value > yString.value) {
                return 1;
            }
            return 0;
        };
    }
    array = array.sort(comparefunWrapper);
    for (var i = 0, len = array.length; i < len; i++) {
        var v = array[i];
        if (v) {
            O.Put(new values_1.Value(i, label), v, true);
        }
        else {
            O.Delete(new values_1.Value(i, label), true);
        }
    }
    c.popPC();
    return O;
};
// ------------------------------------------------------------
// splice, 15.4.4.12
function splice(thisArg, args) {
    var start = args[0] || new values_1.Value(undefined, label_1.bot);
    var deleteCount = args[1] || new values_1.Value(undefined, label_1.bot);
    var O = ToObject_1.ToObject(thisArg);
    var A = new ArrayObject_1.ArrayObject();
    var lenVal = O.Get(constants.length);
    var len = ToUInt32_1.ToUInt32(lenVal);
    var relativeStart = ToInteger_1.ToInteger(start);
    var actualStart = new values_1.Value(null, label_1.lub(len.label, relativeStart.label));
    if (relativeStart.value < 0) {
        actualStart.value = Math.max((len.value + relativeStart.value), 0);
    }
    else {
        actualStart.value = Math.min(relativeStart.value, len.value);
    }
    deleteCount = ToInteger_1.ToInteger(deleteCount);
    var actualDeleteCount = new values_1.Value(null, label_1.lub(deleteCount.label, actualStart.label));
    actualDeleteCount.value = Math.min(Math.max(deleteCount.value, 0), len.value - actualStart.value);
    var k = 0;
    monitor.context.pushPC(actualDeleteCount.label);
    while (k < actualDeleteCount.value) {
        var from = new values_1.Value(actualStart.value + k, actualStart.label);
        var fromPresent = O.HasProperty(from);
        monitor.context.pushPC(fromPresent.label);
        if (fromPresent.value) {
            var fromValue = O.Get(from);
            A.DefineOwnProperty(new values_1.Value(k, actualDeleteCount.label), {
                value: fromValue.value,
                label: fromValue.label,
                writable: true,
                enumberable: true,
                configurable: true
            });
        }
        monitor.context.popPC();
        k++;
    }
    monitor.context.popPC();
    var items = [];
    for (var i = 0; i < args.length - 2; i++) {
        items[i] = args[i + 2];
    }
    var itemCount = items.length;
    if (itemCount < actualDeleteCount.value) {
        var k = actualStart.value;
        monitor.context.pushPC(actualStart.label);
        while (k < len.value - actualDeleteCount.value) {
            var from = new values_1.Value(k + actualDeleteCount.value, label_1.lub(actualStart.label, actualDeleteCount.label));
            var to = new values_1.Value(k + itemCount, actualStart.label);
            var fromPresent = O.HasProperty(from);
            monitor.context.pushPC(fromPresent.label);
            if (fromPresent.value) {
                var fromValue = O.Get(from);
                O.Put(to, fromValue, true);
            }
            else {
                O.Delete(to, true);
            }
            k++;
            monitor.context.popPC();
        }
        monitor.context.popPC();
        k = len.value;
        monitor.context.pushPC(label_1.lub(len.label, actualDeleteCount.label));
        while (k > (len.value - actualDeleteCount.value + itemCount)) {
            O.Delete(new values_1.Value(k, len.label));
            k--;
        }
        monitor.context.popPC();
    }
    else if (itemCount > actualDeleteCount.value) {
        var k = len.value - actualDeleteCount.value;
        monitor.context.pushPC(label_1.lub(len.label, actualDeleteCount.label));
        while (k > actualStart.value) {
            var from = new values_1.Value(k + actualDeleteCount.value - 1, actualDeleteCount.label);
            var to = new values_1.Value(k + itemCount - 1, label_1.bot);
            var fromPresent = O.HasProperty(from);
            if (fromPresent.value) {
                var fromValue = O.Get(from);
                O.Put(to, fromValue, true);
            }
            else {
                O.Delete(to, true);
            }
            k--;
        }
        monitor.context.popPC();
    }
    k = actualStart.value;
    for (var i = 0; i < items.length; i++) {
        O.Put(new values_1.Value(k + i, actualStart.label), items[i], true);
    }
    O.Put(constants.length, new values_1.Value(len.value - actualDeleteCount.value + itemCount, label_1.lub(len.label, actualDeleteCount.label)), true);
    return new values_1.Value(A, label_1.bot);
}
;
// ------------------------------------------------------------
// unshift, 15.4.4.13
function unshift(thisArg, args) {
    var O = ToObject_1.ToObject(thisArg);
    var lenVal = O.Get(constants.length);
    var len = ToUInt32_1.ToUInt32(lenVal);
    var argCount = args.length;
    var k = len.value;
    monitor.context.pushPC(len.label);
    while (k > 0) {
        var from = new values_1.Value(k - 1, len.label);
        var to = new values_1.Value(k + argCount - 1, len.label);
        var fromPresent = O.HasProperty(from);
        monitor.context.pushPC(fromPresent.label);
        if (fromPresent.value) {
            var fromValue = O.Get(from);
            O.Put(to, fromValue, true);
        }
        else {
            O.Delete(to, true);
        }
        monitor.context.popPC();
        k--;
    }
    monitor.context.popPC();
    var j = 0;
    var items = args;
    for (; j < argCount; j++) {
        var E = items[j];
        O.Put(new values_1.Value(j, label_1.bot), E, true);
    }
    O.Put(constants.length, new values_1.Value(len.value + argCount, len.label));
    return new values_1.Value(len.value + argCount, len.label);
}
;
// ------------------------------------------------------------
// indexOf, 15.4.4.14
function indexOf(thisArg, args) {
    var searchElement = args[0] || new values_1.Value(undefined, label_1.bot);
    var fromIndex = args[1];
    var O = ToObject_1.ToObject(thisArg);
    var lenVal = O.Get(constants.length);
    var len = ToUInt32_1.ToUInt32(lenVal);
    var c = monitor.context;
    if (len.value === 0) {
        return new values_1.Value(-1, len.label);
    }
    var label = new label_1.Label();
    c.pushPC(len.label);
    label.lub(len.label);
    var n = fromIndex ? ToInteger_1.ToInteger(fromIndex) : new values_1.Value(0, label_1.bot);
    c.labels.pc.lub(n.label);
    label.lub(n.label);
    if (n.value >= len.value) {
        c.popPC();
        return new values_1.Value(-1, label);
    }
    var k;
    if (n.value >= 0) {
        k = n;
    }
    else {
        k = new values_1.Value(len.value - Math.abs(n.value), label_1.lub(len.label, n.label));
        if (k.value < 0) {
            k.value = 0;
        }
    }
    while (k.value < len.value) {
        var kString = ToString_1.ToString(k);
        var kPresent = O.HasProperty(kString);
        c.labels.pc.lub(kPresent.label);
        label.lub(kPresent.label);
        if (kPresent.value) {
            var elementK = O.Get(kString);
            c.labels.pc.lub(elementK.label);
            label.lub(elementK.label);
            var same = searchElement.value === elementK.value;
            if (same) {
                k.label = label;
                c.popPC();
                return k;
            }
        }
        k.value++;
    }
    c.popPC();
    k.value = -1;
    k.label = label;
    return k;
}
// ------------------------------------------------------------
// lastIndexOf, 15.4.4.15
function lastIndexOf(thisArg, args) {
    var searchElement = args[0] || new values_1.Value(undefined, label_1.bot);
    var fromIndex = args[1];
    var O = ToObject_1.ToObject(thisArg);
    var lenVal = O.Get(constants.length);
    var len = ToUInt32_1.ToUInt32(lenVal);
    var c = monitor.context;
    if (len.value === 0) {
        return new values_1.Value(-1, len.label);
    }
    var label = new label_1.Label();
    c.pushPC(len.label);
    label.lub(len.label);
    var n = fromIndex ? ToInteger_1.ToInteger(fromIndex) : new values_1.Value(len.value - 1, len.label);
    var k;
    if (n.value >= 0) {
        k = new values_1.Value(Math.min(n.value, len.value - 1), label_1.lub(n.label, len.label));
    }
    else {
        k = new values_1.Value(len.value - Math.abs(n.value), label_1.lub(n.label, len.label));
    }
    c.labels.pc.lub(k.label);
    label.lub(k.label);
    while (k.value >= 0) {
        var kPresent = O.HasProperty(k);
        c.labels.pc.lub(kPresent.label);
        label.lub(kPresent.label);
        if (kPresent.value) {
            var elementK = O.Get(k);
            c.labels.pc.lub(elementK.label);
            label.lub(elementK.label);
            var same = searchElement.value === elementK.value;
            if (same) {
                k.label = label;
                c.popPC();
                return k;
            }
        }
        k.value--;
    }
    c.popPC();
    k.value = -1;
    k.label = label;
    return k;
}
// ------------------------------------------------------------
// every, 15.4.4.16
function every(thisArg, args) {
    var callbackfn = args[0] || new values_1.Value(undefined, label_1.bot);
    var callbackthisArg = args[1] || new values_1.Value(undefined, label_1.bot);
    var O = ToObject_1.ToObject(thisArg);
    var lenVal = O.Get(constants.length);
    var len = ToUInt32_1.ToUInt32(lenVal);
    var c = monitor.context;
    var isCallable = IsCallable_1.IsCallable(callbackfn);
    var label = new label_1.Label();
    label.lub(isCallable.label);
    c.pushPC(isCallable.label);
    if (!isCallable.value) {
        monitor.Throw(monitor.modules.error.TypeErrorObject, 'Array.prototype.every: not a function', label_1.bot);
    }
    var k = new values_1.Value(0, len.label);
    c.labels.pc.lub(len.label);
    label.lub(len.label);
    while (k.value < len.value) {
        var kPresent = O.HasProperty(k);
        c.labels.pc.lub(kPresent.label);
        label.lub(kPresent.label);
        if (kPresent.value) {
            var kValue = O.Get(k);
            var testResult = callbackfn.Call(callbackthisArg, [kValue, k, O]);
            var b = ToBoolean_1.ToBoolean(testResult);
            c.labels.pc.lub(b.label);
            label.lub(b.label);
            if (!b.value) {
                c.popPC();
                return new values_1.Value(false, label);
            }
        }
        k.value++;
    }
    c.popPC();
    return new values_1.Value(true, label);
}
// ------------------------------------------------------------
// some, 15.4.4.17
function some(thisArg, args) {
    var callbackfn = args[0] || new values_1.Value(undefined, label_1.bot);
    var callbackthisArg = args[1] || new values_1.Value(undefined, label_1.bot);
    var O = ToObject_1.ToObject(thisArg);
    var lenVal = O.Get(constants.length);
    var len = ToUInt32_1.ToUInt32(lenVal);
    var c = monitor.context;
    var isCallable = IsCallable_1.IsCallable(callbackfn);
    var label = new label_1.Label();
    label.lub(isCallable.label);
    c.pushPC(isCallable.label);
    if (!isCallable.value) {
        monitor.Throw(monitor.modules.error.TypeErrorObject, 'Array.prototype.every: not a function', label_1.bot);
    }
    var k = new values_1.Value(0, len.label);
    c.labels.pc.lub(len.label);
    label.lub(len.label);
    while (k.value < len.value) {
        var kPresent = O.HasProperty(k);
        c.labels.pc.lub(kPresent.label);
        label.lub(kPresent.label);
        if (kPresent.value) {
            var kValue = O.Get(k);
            var testResult = callbackfn.Call(callbackthisArg, [kValue, k, O]);
            var b = ToBoolean_1.ToBoolean(testResult);
            c.labels.pc.lub(b.label);
            label.lub(b.label);
            if (b.value) {
                c.popPC();
                return new values_1.Value(true, label);
            }
        }
        k.value++;
    }
    c.popPC();
    return new values_1.Value(false, label);
}
// ------------------------------------------------------------
// forEach, 15.4.4.18
function forEach(thisArg, args) {
    var callbackfn = args[0] || new values_1.Value(undefined, label_1.bot);
    var callbackthisArg = args[1] || new values_1.Value(undefined, label_1.bot);
    var O = ToObject_1.ToObject(thisArg);
    var lenVal = O.Get(constants.length);
    var len = ToUInt32_1.ToUInt32(lenVal);
    var c = monitor.context;
    var isCallable = IsCallable_1.IsCallable(callbackfn);
    c.pushPC(isCallable.label);
    if (!isCallable.value) {
        monitor.Throw(monitor.modules.error.TypeErrorObject, 'Array.prototype.every: not a function', label_1.bot);
    }
    var k = new values_1.Value(0, len.label);
    c.labels.pc.lub(len.label);
    while (k.value < len.value) {
        var kPresent = O.HasProperty(k);
        c.labels.pc.lub(kPresent.label);
        if (kPresent.value) {
            var kValue = O.Get(k);
            callbackfn.Call(callbackthisArg, [kValue, k, O]);
        }
        k.value++;
    }
    c.popPC();
    return new values_1.Value(undefined, label_1.bot);
}
// ------------------------------------------------------------
// map, 15.4.4.19
function map(thisArg, args) {
    var callbackfn = args[0] || new values_1.Value(undefined, label_1.bot);
    var callbackthisArg = args[1] || new values_1.Value(undefined, label_1.bot);
    var O = ToObject_1.ToObject(thisArg);
    var lenVal = O.Get(constants.length);
    var len = ToUInt32_1.ToUInt32(lenVal);
    var c = monitor.context;
    var isCallable = IsCallable_1.IsCallable(callbackfn);
    c.pushPC(isCallable.label);
    if (!isCallable.value) {
        monitor.Throw(monitor.modules.error.TypeErrorObject, 'Array.prototype.every: not a function', label_1.bot);
    }
    var A = new ArrayObject_1.ArrayObject();
    A.properties.length = len.value;
    A.labels.length = {
        value: len.label,
        existence: label_1.bot
    };
    var k = new values_1.Value(0, len.label);
    c.labels.pc.lub(len.label);
    while (k.value < len.value) {
        var kPresent = O.HasProperty(k);
        c.labels.pc.lub(kPresent.label);
        if (kPresent.value) {
            var kValue = O.Get(k);
            var mappedValue = callbackfn.Call(callbackthisArg, [kValue, k, O]);
            A.DefineOwnProperty(k, {
                value: mappedValue.value,
                label: mappedValue.label,
                writable: true,
                enumerable: true,
                configurable: true
            }, false);
        }
        k.value++;
    }
    c.popPC();
    return new values_1.Value(A, label_1.bot);
}
// ------------------------------------------------------------
// filter, 15.4.4.20
function filter(thisArg, args) {
    var callbackfn = args[0] || new values_1.Value(undefined, label_1.bot);
    var callbackthisArg = args[1] || new values_1.Value(undefined, label_1.bot);
    var O = ToObject_1.ToObject(thisArg);
    var lenVal = O.Get(constants.length);
    var len = ToUInt32_1.ToUInt32(lenVal);
    var c = monitor.context;
    var isCallable = IsCallable_1.IsCallable(callbackfn);
    c.pushPC(isCallable.label);
    if (!isCallable.value) {
        monitor.Throw(monitor.modules.error.TypeErrorObject, 'Array.prototype.every: not a function', label_1.bot);
    }
    var A = new ArrayObject_1.ArrayObject();
    var k = new values_1.Value(0, len.label);
    var to = new values_1.Value(0, len.label);
    c.labels.pc.lub(len.label);
    while (k.value < len.value) {
        var kPresent = O.HasProperty(k);
        c.labels.pc.lub(kPresent.label);
        if (kPresent.value) {
            var kValue = O.Get(k);
            var selected = callbackfn.Call(callbackthisArg, [kValue, k, O]);
            selected = ToBoolean_1.ToBoolean(selected);
            c.labels.pc.lub(selected.label);
            if (selected.value) {
                A.DefineOwnProperty(to, {
                    value: kValue.value,
                    label: kValue.label,
                    writable: true,
                    enumerable: true,
                    configurable: true
                }, false);
                to.value++;
            }
        }
        k.value++;
    }
    c.popPC();
    return new values_1.Value(A, label_1.bot);
}
// ------------------------------------------------------------
// reduce, 15.4.4.21
function reduce(thisArg, args) {
    var callbackfn = args[0] || new values_1.Value(undefined, label_1.bot);
    var initialValue = args[1];
    var O = ToObject_1.ToObject(thisArg);
    var lenVal = O.Get(constants.length);
    var len = ToUInt32_1.ToUInt32(lenVal);
    var c = monitor.context;
    var isCallable = IsCallable_1.IsCallable(callbackfn);
    var label = new label_1.Label();
    label.lub(isCallable.label);
    c.pushPC(isCallable.label);
    if (!isCallable.value) {
        monitor.Throw(monitor.modules.error.TypeErrorObject, 'Array.prototype.every: not a function', label_1.bot);
    }
    var k = new values_1.Value(0, len.label);
    var accumulator;
    if (initialValue) {
        accumulator = initialValue;
    }
    else {
        var kPresent = new values_1.Value(false, label_1.bot);
        c.labels.pc.lub(len.label);
        label.lub(len.label);
        while (!kPresent.value && k.value < len.value) {
            kPresent = O.HasProperty(k);
            c.labels.pc.lub(kPresent.label);
            label.lub(kPresent.label);
            if (kPresent.value) {
                accumulator = O.Get(k);
            }
            k.value++;
        }
        if (!kPresent.value) {
            monitor.Throw(monitor.modules.error.TypeErrorObject, 'Array.prototype.reduce: empty array with no initial value', label_1.bot);
        }
    }
    while (k.value < len.value) {
        var kPresent = O.HasProperty(k);
        c.labels.pc.lub(kPresent.label);
        label.lub(kPresent.label);
        if (kPresent.value) {
            var kValue = O.Get(k);
            accumulator = callbackfn.Call(new values_1.Value(undefined, label_1.bot), [accumulator, kValue, k, O]);
        }
        k.value++;
    }
    c.popPC();
    accumulator.raise(label);
    return accumulator;
}
// ------------------------------------------------------------
// reduceRight, 15.4.4.22
function reduceRight(thisArg, args) {
    var callbackfn = args[0] || new values_1.Value(undefined, label_1.bot);
    var initialValue = args[1];
    var O = ToObject_1.ToObject(thisArg);
    var lenVal = O.Get(constants.length);
    var len = ToUInt32_1.ToUInt32(lenVal);
    var c = monitor.context;
    var isCallable = IsCallable_1.IsCallable(callbackfn);
    var label = new label_1.Label();
    label.lub(isCallable.label);
    c.pushPC(isCallable.label);
    if (!isCallable.value) {
        monitor.Throw(monitor.modules.error.TypeErrorObject, 'Array.prototype.every: not a function', label_1.bot);
    }
    var k = new values_1.Value(len.value - 1, len.label);
    var accumulator;
    if (initialValue) {
        accumulator = initialValue;
    }
    else {
        var kPresent = new values_1.Value(false, label_1.bot);
        c.labels.pc.lub(len.label);
        label.lub(len.label);
        while (!kPresent.value && k.value >= 0) {
            kPresent = O.HasProperty(k);
            c.labels.pc.lub(kPresent.label);
            label.lub(kPresent.label);
            if (kPresent.value) {
                accumulator = O.Get(k);
            }
            k.value--;
        }
        if (!kPresent.value) {
            monitor.Throw(monitor.modules.error.TypeErrorObject, 'Array.prototype.reduce: empty array with no initial value', label_1.bot);
        }
    }
    while (k.value >= 0) {
        var kPresent = O.HasProperty(k);
        c.labels.pc.lub(kPresent.label);
        label.lub(kPresent.label);
        if (kPresent.value) {
            var kValue = O.Get(k);
            accumulator = callbackfn.Call(new values_1.Value(undefined, label_1.bot), [accumulator, kValue, k, O]);
        }
        k.value--;
    }
    c.popPC();
    accumulator.raise(label);
    return accumulator;
}

},{"../Conversion/ToBoolean":28,"../Conversion/ToInteger":30,"../Conversion/ToObject":32,"../Conversion/ToString":34,"../Conversion/ToUInt32":36,"../Objects/ArrayObject":38,"../Utility/IsCallable":49,"../constants":50,"../ecma":53,"../function":57,"../label":60,"../values":75}],44:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var values_1 = require("../values");
var constants = require("../constants");
var function_1 = require("../function");
var ecma_1 = require("../ecma");
var label_1 = require("../label");
// 15.6.4 ------------------------------------------------------------
var BooleanPrototype = /** @class */ (function (_super) {
    __extends(BooleanPrototype, _super);
    function BooleanPrototype(host) {
        var _this = _super.call(this) || this;
        _this.Class = 'Boolean';
        _this.PrimitiveValue = new Boolean(false);
        _this.host = host;
        return _this;
    }
    BooleanPrototype.prototype.Setup = function () {
        this.Prototype = new values_1.Value(monitor.instances.ObjectPrototype, label_1.bot);
        ecma_1.DefineFFF(this, constants.length, 1);
        ecma_1.DefineTFT(this, constants.constructor, monitor.instances.BooleanConstructor);
        ecma_1.DefineTFT(this, constants.toString, new function_1.BuiltinFunctionObject(toString, 0, this.host.toString));
        ecma_1.DefineTFT(this, new values_1.Value('valueOf', label_1.bot), new function_1.BuiltinFunctionObject(valueOf, 0, this.host.valueOf));
    };
    return BooleanPrototype;
}(ecma_1.Ecma));
exports.BooleanPrototype = BooleanPrototype;
// toString, 15.6.4.2 -----------------------------------------
var toString = function (thisArg, args) {
    var b = valueOf(thisArg);
    var s = b.value ? 'true' : 'false';
    return new values_1.Value(s, b.label);
};
// valueOf, 15.6.4.3 ------------------------------------------ 
var valueOf = function (thisArg, args) {
    if (typeof thisArg.value === 'boolean') {
        return thisArg;
    }
    if (thisArg.value !== null &&
        typeof thisArg.value === 'object' &&
        thisArg.value.Class === 'Boolean') {
        return new values_1.Value(thisArg.value.PrimitiveValue.valueOf(), thisArg.label);
    }
    monitor.Throw(monitor.modules.error.TypeErrorObject, 'Boolean.prototype.valueOf is not generic', thisArg.label);
};

},{"../constants":50,"../ecma":53,"../function":57,"../label":60,"../values":75}],45:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var label_1 = require("../label");
var pp = require("../pp");
var values_1 = require("../values");
var ecma_1 = require("../ecma");
var constants = require("../constants");
var function_1 = require("../function");
var ToUInt32_1 = require("../Conversion/ToUInt32");
var IsCallable_1 = require("../Utility/IsCallable");
// ------------------------------------------------------------
// Function Prototype, 15.3.4
var FunctionPrototype = /** @class */ (function (_super) {
    __extends(FunctionPrototype, _super);
    function FunctionPrototype(host) {
        var _this_1 = _super.call(this) || this;
        // 15.3.4
        _this_1.Class = 'Function';
        _this_1.Extensible = true;
        _this_1.host = host;
        return _this_1;
    }
    FunctionPrototype.prototype.Setup = function () {
        // 15.3.4.1
        ecma_1.DefineTFT(this, constants.constructor, monitor.instances.FunctionConstructor);
        this.Prototype = new values_1.Value(monitor.instances.ObjectPrototype, label_1.bot);
        ecma_1.DefineFFF(this, constants.length, 0);
        ecma_1.DefineTFT(this, constants.toString, new function_1.BuiltinFunctionObject(toString, 0, Function.prototype.toString));
        ecma_1.DefineTFT(this, constants.apply, new function_1.BuiltinFunctionObject(apply, 2, Function.prototype.apply));
        ecma_1.DefineTFT(this, constants.call, new function_1.BuiltinFunctionObject(call, 1, Function.prototype.call));
        ecma_1.DefineTFT(this, constants.bind, new function_1.BuiltinFunctionObject(bind, 1, Function.prototype.bind));
    };
    // 15.3.4
    FunctionPrototype.prototype.Call = function () { return new values_1.Value(undefined, label_1.bot); };
    ;
    FunctionPrototype.prototype.Construct = function () { return new values_1.Value(undefined, label_1.bot); };
    ;
    return FunctionPrototype;
}(ecma_1.Ecma));
exports.FunctionPrototype = FunctionPrototype;
// ------------------------------------------------------------
// 15.3.4.2 - Implementation Dependent
var toString = function (thisArg, args) {
    if (thisArg.value.Source) {
        var str = pp.pretty(thisArg.value.Source);
        return new values_1.Value(str, thisArg.label);
    }
    if (thisArg.value.host) {
        var str = thisArg.value.host.toString();
        return new values_1.Value(str, thisArg.label);
    }
    return new values_1.Value('function', thisArg.label);
};
// ------------------------------------------------------------
// 15.3.4.3
var apply = function (thisArg, args) {
    var _this = args[0] ? args[0] : new values_1.Value(undefined, label_1.bot);
    var argArray = args[1] ? args[1] : new values_1.Value(undefined, label_1.bot);
    monitor.context.pushPC(thisArg.label);
    if (!IsCallable_1.IsCallable(thisArg).value) {
        monitor.Throw(monitor.modules.error.TypeErrorObject, 'apply, not a function', label_1.bot);
    }
    monitor.context.raisePC(argArray.label);
    if (argArray.value === null || argArray.value === undefined) {
        var res = thisArg.Call(_this, []);
        monitor.context.popPC();
        return res;
    }
    if (typeof argArray.value !== 'object' || argArray.value.Class === undefined) {
        monitor.Throw(monitor.modules.error.TypeErrorObject, 'apply, argument array not an object', label_1.bot);
    }
    var len = argArray.Get(constants.length);
    var n = ToUInt32_1.ToUInt32(len);
    var argList = [];
    for (var index = 0; index < n.value; index++) {
        var nextArg = argArray.Get(new values_1.Value(index, n.label));
        argList.push(nextArg);
    }
    // Since we cannot transfer the structural or existence info to
    //  the array used by Call, we raise the context accordingly.
    //  This is sound, but potentially an over approximation.
    monitor.context.raisePC(n.label);
    var res = thisArg.Call(_this, argList);
    monitor.context.popPC();
    return res;
};
// ------------------------------------------------------------
// 15.3.4.4
var call = function (thisArg, args) {
    var _this = args[0] ? args[0] : new values_1.Value(undefined, label_1.bot);
    var argList = {};
    for (var i = 1; i < args.length; i++) {
        argList[i - 1] = args[i];
    }
    argList.length = args.length - 1;
    monitor.context.pushPC(thisArg.label);
    if (!IsCallable_1.IsCallable(thisArg).value) {
        monitor.Throw(monitor.modules.error.TypeErrorObject, 'call, not a function', label_1.bot);
    }
    var res = thisArg.Call(_this, argList);
    monitor.context.popPC();
    return res;
};
// ------------------------------------------------------------
// 15.3.4.5
var bind = function (thisArg, args) {
    var Target = thisArg;
    var _this = args[0] ? args[0] : new values_1.Value(undefined, label_1.bot);
    var argList = [];
    for (var i = 1; i < args.length; i++) {
        argList[i - 1] = args[i];
    }
    if (!IsCallable_1.IsCallable(Target).value) {
        monitor.Throw(monitor.modules.error.TypeErrorObject, 'bind: Target is not a function', label_1.bot);
    }
    var F = new ecma_1.Ecma();
    F.TargetFunction = Target;
    F.BoundThis = _this;
    F.BoundArgs = argList;
    F.Class = 'Function';
    F.Prototype = new values_1.Value(monitor.instances.FunctionPrototype, label_1.bot);
    F.Call = function (_thisVal, ExtraArgs) {
        var boundArgs = F.BoundArgs;
        var boundThis = F.BoundThis;
        var target = F.TargetFunction;
        var args = boundArgs.concat(ExtraArgs);
        return target.Call(boundThis, args);
    };
    F.Construct = function (ExtraArgs) {
        var target = F.TargetFunction;
        if (!target.Construct) {
            monitor.Throw(monitor.modules.error.TypeErrorObject, 'bind construct: no internal method Construct', label_1.bot);
        }
        var boundArgs = F.BoundArgs;
        var args = boundArgs.concat(ExtraArgs);
        return target.Construct(args);
    };
    F.HasInstance = function (V) {
        var target = F.TargetFunction;
        if (!target.HasInstance) {
            monitor.Throw(monitor.modules.error.TypeErrorObject, 'bind HasInstance: no internal method HasInstance', label_1.bot);
        }
        return target.HasInstance(V);
    };
    if (Target.Class === "Function") {
        var L = Target.length - args.length;
        F.length = L > 0 ? L : 0;
    }
    else {
        F.length = 0;
    }
    ecma_1.DefineFFF(F, constants.length, F.length);
    F.Extensible = true;
    var thrower = monitor.instances.ThrowTypeError;
    F.DefineOwnProperty(constants.caller, {
        get: thrower,
        set: thrower,
        enumerable: false, configurable: false,
        label: label_1.bot
    }, false);
    F.DefineOwnProperty(constants.arguments, {
        get: thrower,
        set: thrower,
        enumerable: false, configurable: false,
        label: label_1.bot
    }, false);
    return new values_1.Value(F, label_1.bot);
};

},{"../Conversion/ToUInt32":36,"../Utility/IsCallable":49,"../constants":50,"../ecma":53,"../function":57,"../label":60,"../pp":64,"../values":75}],46:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var label_1 = require("../label");
var values_1 = require("../values");
var ecma_1 = require("../ecma");
var constants = require("../constants");
var function_1 = require("../function");
var ToInteger_1 = require("../Conversion/ToInteger");
var ToString_1 = require("../Conversion/ToString");
var ToObject_1 = require("../Conversion/ToObject");
var CheckObjectCoercible_1 = require("../Utility/CheckObjectCoercible");
// ------------------------------------------------------------
// The Number Prototype, 15.7.4
var NumberPrototype = /** @class */ (function (_super) {
    __extends(NumberPrototype, _super);
    function NumberPrototype(host) {
        var _this_1 = _super.call(this) || this;
        _this_1.Class = 'Number';
        _this_1.PrimitiveValue = new Number(0);
        _this_1.PrimitiveLabel = label_1.bot;
        _this_1.host = host;
        return _this_1;
    }
    NumberPrototype.prototype.Setup = function () {
        this.Prototype = new values_1.Value(monitor.instances.ObjectPrototype, label_1.bot);
        ecma_1.DefineTFT(this, constants.constructor, monitor.instances.NumberConstructor);
        ecma_1.DefineFFF(this, constants.length, 0);
        ecma_1.DefineTFT(this, constants.toString, new function_1.BuiltinFunctionObject(toString, 1, this.host.toString));
        ecma_1.DefineTFT(this, constants.toLocaleString, new function_1.BuiltinFunctionObject(toLocaleString, 0, this.host.toLocaleString));
        ecma_1.DefineTFT(this, new values_1.Value('valueOf', label_1.bot), new function_1.BuiltinFunctionObject(valueOf, 0, this.host.valueOf));
        ecma_1.DefineTFT(this, constants.toFixed, new function_1.BuiltinFunctionObject(toFixed, 0, this.host.toFixed));
        ecma_1.DefineTFT(this, constants.toExponential, new function_1.BuiltinFunctionObject(toExponential, 0, this.host.toExponential));
        ecma_1.DefineTFT(this, constants.toPrecision, new function_1.BuiltinFunctionObject(toPrecision, 0, this.host.toPrecision));
    };
    return NumberPrototype;
}(ecma_1.Ecma));
exports.NumberPrototype = NumberPrototype;
// ------------------------------------------------------------
// toString, 15.7.4.2
var toString = function (thisArg, args) {
    var error = monitor.require('error');
    if (!(typeof thisArg.value === 'number' || (thisArg.value !== null && typeof thisArg.value === 'object' && thisArg.value.Class === 'Number'))) {
        monitor.Throw(error.TypeErrorObject, 'Number.prototype.toString is not generic', thisArg.label);
    }
    var radix = args[0] || new values_1.Value(undefined, label_1.bot);
    if (radix.value === undefined) {
        radix.value = 10;
    }
    radix = ToInteger_1.ToInteger(radix);
    var result;
    if (typeof thisArg.value === 'number') {
        result = thisArg.value.toString(radix.value);
        return new values_1.Value(result, label_1.lub(thisArg.label, radix.label));
    }
    else {
        result = thisArg.value.PrimitiveValue.toString(radix.value);
        return new values_1.Value(result, label_1.lub(thisArg.value.PrimitiveLabel, radix.label));
    }
};
// ------------------------------------------------------------
// toLocaleString, 15.7.4.3
var toLocaleString = function (thisArg, args) {
    var O = ToObject_1.ToObject(thisArg);
    var result = O.value.PrimitiveValue.toLocaleString();
    return new values_1.Value(result, O.value.PrimitiveLabel);
};
// ------------------------------------------------------------
// valueOf, 15.7.4.4
var valueOf = function (thisArg, args) {
    var error = monitor.require('error');
    if (!(typeof thisArg.value === 'number' || (thisArg.value !== null && typeof thisArg.value === 'object' && thisArg.value.Class === 'Number'))) {
        monitor.Throw(error.TypeErrorObject, 'Number.prototype.valueOf is not generic', thisArg.label);
    }
    if (typeof thisArg.value === 'number') {
        return thisArg;
    }
    var result = thisArg.value.PrimitiveValue.valueOf();
    return new values_1.Value(result, thisArg.value.PrimitiveLabel);
};
// ------------------------------------------------------------
// toFixed, 15.7.4.5
var toFixed = function (thisArg, args) {
    var precision = args[0] ? ToInteger_1.ToInteger(args[0]) : new values_1.Value(undefined, label_1.bot);
    CheckObjectCoercible_1.CheckObjectCoercible(thisArg);
    var _this = ToObject_1.ToObject(thisArg);
    return new values_1.Value(_this.value.PrimitiveValue.toFixed(precision.value), label_1.lub(precision.label, _this.label));
};
// ------------------------------------------------------------
// toExponential, 15.7.4.6
var toExponential = function (thisArg, args) {
    var precision = args[0] ? ToInteger_1.ToInteger(args[0]) : new values_1.Value(undefined, label_1.bot);
    CheckObjectCoercible_1.CheckObjectCoercible(thisArg);
    var _this = ToObject_1.ToObject(thisArg);
    return new values_1.Value(_this.value.PrimitiveValue.toExponential(precision.value), label_1.lub(precision.label, _this.label));
};
// ------------------------------------------------------------
// toPrecision, 15.7.4.7
var toPrecision = function (thisArg, args) {
    var precision = args[0] ? args[0] : new values_1.Value(undefined, label_1.bot);
    var lbl = label_1.lub(precision.label, thisArg.label);
    if (precision.value === undefined) {
        var strX = ToString_1.ToString(thisArg); //step 2
        return new values_1.Value(strX.value, lbl);
    }
    var p = ToInteger_1.ToInteger(precision); //step 3
    if (thisArg.value === NaN)
        return new values_1.Value('NaN', lbl); //step 4
    return new values_1.Value(thisArg.value.toPrecision(precision.value), lbl);
};

},{"../Conversion/ToInteger":30,"../Conversion/ToObject":32,"../Conversion/ToString":34,"../Utility/CheckObjectCoercible":48,"../constants":50,"../ecma":53,"../function":57,"../label":60,"../values":75}],47:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var label_1 = require("../label");
var values_1 = require("../values");
var ecma_1 = require("../ecma");
var constants = require("../constants");
var function_1 = require("../function");
var ToString_1 = require("../Conversion/ToString");
var ToObject_1 = require("../Conversion/ToObject");
var IsCallable_1 = require("../Utility/IsCallable");
// ------------------------------------------------------------
// The object prototype, 15.2.4
var ObjectPrototype = /** @class */ (function (_super) {
    __extends(ObjectPrototype, _super);
    function ObjectPrototype(host) {
        var _this = _super.call(this) || this;
        _this.Prototype = new values_1.Value(null, label_1.bot);
        _this.Class = 'Object';
        _this.Extensible = true;
        _this.host = host;
        return _this;
    }
    ObjectPrototype.prototype.Setup = function () {
        // 15.2.4.1
        ecma_1.DefineTFT(this, constants.constructor, monitor.instances.ObjectConstructor);
        ecma_1.DefineTFT(this, constants.toString, new function_1.BuiltinFunctionObject(toString, 0, Object.prototype.toString));
        ecma_1.DefineTFT(this, constants.toLocaleString, new function_1.BuiltinFunctionObject(toLocaleString, 0, Object.prototype.toLocaleString));
        ecma_1.DefineTFT(this, new values_1.Value('valueOf', label_1.bot), new function_1.BuiltinFunctionObject(valueOf, 0, Object.prototype.valueOf));
        ecma_1.DefineTFT(this, constants.hasOwnProperty, new function_1.BuiltinFunctionObject(hasOwnProperty, 1, Object.prototype.hasOwnProperty));
        ecma_1.DefineTFT(this, constants.isPrototypeOf, new function_1.BuiltinFunctionObject(isPrototypeOf, 1, Object.prototype.isPrototypeOf));
        ecma_1.DefineTFT(this, constants.propertyIsEnumerable, new function_1.BuiltinFunctionObject(propertyIsEnumerable, 1, Object.prototype.propertyIsEnumerable));
    };
    return ObjectPrototype;
}(ecma_1.Ecma));
exports.ObjectPrototype = ObjectPrototype;
// ------------------------------------------------------------
// Object.prototype.toString(), 15.2.4.2
function toString(thisArg, args) {
    if (thisArg.value === undefined)
        return new values_1.Value('[object Undefined]', thisArg.label);
    if (thisArg.value === null)
        return new values_1.Value('[object Null]', thisArg.label);
    var O = ToObject_1.ToObject(thisArg);
    return new values_1.Value('[object ' + O.value.Class + ']', thisArg.label);
}
// ------------------------------------------------------------
// 15.2.4.3
function toLocaleString(thisArg, args) {
    var O = ToObject_1.ToObject(thisArg);
    var toString = O.Get(constants.toString);
    var b = IsCallable_1.IsCallable(toString);
    var result;
    monitor.context.pushPC(b.label);
    if (b.value) {
        result = toString.Call(O);
        result.raise(b.label);
    }
    else {
        monitor.Throw(monitor.modules.error.TypeError, "property 'toString' of object " + O + " is not a function ", label_1.bot);
    }
    monitor.context.popPC();
    return result;
}
// ------------------------------------------------------------
// 15.2.4.4
function valueOf(thisArg) {
    var o = ToObject_1.ToObject(thisArg);
    return o;
}
// ------------------------------------------------------------
// 15.2.4.5
function hasOwnProperty(thisArg, args) {
    var V = args[0] || new values_1.Value(undefined, label_1.bot);
    var P = ToString_1.ToString(V);
    var O = ToObject_1.ToObject(thisArg);
    var desc = O.GetOwnProperty(P);
    var result = desc.value !== undefined;
    return new values_1.Value(result, desc.label);
}
// ------------------------------------------------------------
// 15.2.4.6
function isPrototypeOf(thisArg, args) {
    var c = monitor.context;
    var V = args[0] || new values_1.Value(undefined, label_1.bot);
    if (V.value === null || typeof V.value !== 'object') {
        return new values_1.Value(false, V.label);
    }
    c.pushPC(V.label);
    var O = ToObject_1.ToObject(thisArg);
    c.popPC();
    var lbl = new label_1.Label();
    lbl.lub(V.label);
    while (true) {
        V = V.value.Prototype;
        lbl.lub(V.label);
        if (V.value === null) {
            return new values_1.Value(false, lbl);
        }
        if (O.value === V.value) {
            return new values_1.Value(true, lbl);
        }
        if (V === undefined) {
            throw new Error('Object.prototype.isPrototypeOf: object with undefined prototype');
        }
    }
}
// ------------------------------------------------------------
// 15.2.4.7
function propertyIsEnumerable(thisArg, args) {
    var V = args[0] || new values_1.Value(undefined, label_1.bot);
    var P = ToString_1.ToString(V);
    var O = ToObject_1.ToObject(thisArg);
    var desc = O.GetOwnProperty(P);
    if (desc.value === undefined) {
        return new values_1.Value(false, desc.label);
    }
    return new values_1.Value(desc.value.value, label_1.lub(desc.label, desc.value.label));
}

},{"../Conversion/ToObject":32,"../Conversion/ToString":34,"../Utility/IsCallable":49,"../constants":50,"../ecma":53,"../function":57,"../label":60,"../values":75}],48:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
// -------------------------------------------------------------
// CheckObjectCoercible, 9.10
function CheckObjectCoercible(x) {
    if (x.value === null || x.value === undefined) {
        monitor.context.raisePC(x.label);
        monitor.Throw(monitor.modules.error.TypeErrorObject, String(x.value) + ' is not coercible', x.label);
    }
}
exports.CheckObjectCoercible = CheckObjectCoercible;

},{}],49:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
var values_1 = require("../values");
// -------------------------------------------------------------
// IsCallable, 9.11
function IsCallable(x) {
    var b = false;
    if (x.value !== null && typeof x.value === 'object') {
        b = x.value.Call !== undefined;
    }
    return new values_1.Value(b, x.label);
}
exports.IsCallable = IsCallable;

},{"../values":75}],50:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
var label_1 = require("./label");
var values_1 = require("./values");
exports.index = new values_1.Value('index', label_1.bot);
exports.input = new values_1.Value('input', label_1.bot);
exports.value = new values_1.Value('value', label_1.bot);
exports.writable = new values_1.Value('writable', label_1.bot);
exports.enumerable = new values_1.Value('enumerable', label_1.bot);
exports.configurable = new values_1.Value('configurable', label_1.bot);
exports.get = new values_1.Value('get', label_1.bot);
exports.set = new values_1.Value('set', label_1.bot);
exports.print = new values_1.Value('print', label_1.bot);
exports.console = new values_1.Value('console', label_1.bot);
exports.alert = new values_1.Value('alert', label_1.bot);
exports.log = new values_1.Value('log', label_1.bot);
exports.prototype = new values_1.Value('prototype', label_1.bot);
exports.constructor = new values_1.Value('constructor', label_1.bot);
exports.length = new values_1.Value('length', label_1.bot);
exports.arguments = new values_1.Value('arguments', label_1.bot);
exports.upg = new values_1.Value('upg', label_1.bot);
exports.upgv = new values_1.Value('upgv', label_1.bot);
exports.upgf = new values_1.Value('upgf', label_1.bot);
exports.upgs = new values_1.Value('upgs', label_1.bot);
exports.getPrototypeOf = new values_1.Value('getPrototypeOf', label_1.bot);
exports.getOwnPropertyDescriptor = new values_1.Value('getOwnPropertyDescriptor', label_1.bot);
exports.getOwnPropertyNames = new values_1.Value('getOwnPropertyNames', label_1.bot);
exports.create = new values_1.Value('create', label_1.bot);
exports.require = new values_1.Value('require', label_1.bot);
exports.defineProperty = new values_1.Value('defineProperty', label_1.bot);
exports.defineProperties = new values_1.Value('defineProperties', label_1.bot);
exports.seal = new values_1.Value('seal', label_1.bot);
exports.freeze = new values_1.Value('freeze', label_1.bot);
exports.preventExtensions = new values_1.Value('preventExtensions', label_1.bot);
exports.isSealed = new values_1.Value('isSealed', label_1.bot);
exports.isFrozen = new values_1.Value('isFrozen', label_1.bot);
exports.isExtensible = new values_1.Value('isExtensible', label_1.bot);
exports.keys = new values_1.Value('keys', label_1.bot);
exports.toString = new values_1.Value('toString', label_1.bot);
exports.toLocaleString = new values_1.Value('toLocaleString', label_1.bot);
exports.valueOf = new values_1.Value('valueOf', label_1.bot);
exports.hasOwnProperty = new values_1.Value('hasOwnProperty', label_1.bot);
exports.isPrototypeOf = new values_1.Value('isPrototypeOf', label_1.bot);
exports.propertyIsEnumerable = new values_1.Value('propertyIsEnumerable', label_1.bot);
exports.apply = new values_1.Value('apply', label_1.bot);
exports.call = new values_1.Value('call', label_1.bot);
exports.caller = new values_1.Value('caller', label_1.bot);
exports.bind = new values_1.Value('bind', label_1.bot);
exports.NaN = new values_1.Value('NaN', label_1.bot);
exports.Infinity = new values_1.Value('Infinity', label_1.bot);
exports.undefined = new values_1.Value('undefined', label_1.bot);
exports.eval = new values_1.Value('eval', label_1.bot);
exports.parseInt = new values_1.Value('parseInt', label_1.bot);
exports.parseFloat = new values_1.Value('parseFloat', label_1.bot);
exports.isNaN = new values_1.Value('isNaN', label_1.bot);
exports.isFinite = new values_1.Value('isFinite', label_1.bot);
exports.decodeURI = new values_1.Value('decodeURI', label_1.bot);
exports.decodeURIComponent = new values_1.Value('decodeURIComponent', label_1.bot);
exports.encodeURI = new values_1.Value('encodeURI', label_1.bot);
exports.encodeURIComponent = new values_1.Value('encodeURIComponent', label_1.bot);
exports.Object = new values_1.Value('Object', label_1.bot);
exports.Function = new values_1.Value('Function', label_1.bot);
exports.Array = new values_1.Value('Array', label_1.bot);
exports.String = new values_1.Value('String', label_1.bot);
exports.Boolean = new values_1.Value('Boolean', label_1.bot);
exports.Number = new values_1.Value('Number', label_1.bot);
exports.Date = new values_1.Value('Date', label_1.bot);
exports.RegExp = new values_1.Value('RegExp', label_1.bot);
exports.Error = new values_1.Value('Error', label_1.bot);
exports.EvalError = new values_1.Value('EvalError', label_1.bot);
exports.RangeError = new values_1.Value('RangeError', label_1.bot);
exports.ReferenceError = new values_1.Value('ReferenceError', label_1.bot);
exports.SyntaxError = new values_1.Value('SyntaxError', label_1.bot);
exports.TypeError = new values_1.Value('TypeError', label_1.bot);
exports.URIError = new values_1.Value('URIError', label_1.bot);
exports.Math = new values_1.Value('Math', label_1.bot);
exports.JSON = new values_1.Value('JSON', label_1.bot);
exports.parse = new values_1.Value('parse', label_1.bot);
exports.stringify = new values_1.Value('stringify', label_1.bot);
exports.name = new values_1.Value('name', label_1.bot);
exports.message = new values_1.Value('message', label_1.bot);
exports.isArray = new values_1.Value('isArray', label_1.bot);
exports.concat = new values_1.Value('concat', label_1.bot);
exports.join = new values_1.Value('join', label_1.bot);
exports.pop = new values_1.Value('pop', label_1.bot);
exports.push = new values_1.Value('push', label_1.bot);
exports.reverse = new values_1.Value('reverse', label_1.bot);
exports.shift = new values_1.Value('shift', label_1.bot);
exports.slice = new values_1.Value('slice', label_1.bot);
exports.sort = new values_1.Value('sort', label_1.bot);
exports.splice = new values_1.Value('splice', label_1.bot);
exports.unshift = new values_1.Value('unshift', label_1.bot);
exports.indexOf = new values_1.Value('indexOf', label_1.bot);
exports.lastIndexOf = new values_1.Value('lastIndexOf', label_1.bot);
exports.every = new values_1.Value('every', label_1.bot);
exports.some = new values_1.Value('some', label_1.bot);
exports.forEach = new values_1.Value('forEach', label_1.bot);
exports.map = new values_1.Value('map', label_1.bot);
exports.filter = new values_1.Value('filter', label_1.bot);
exports.reduce = new values_1.Value('reduce', label_1.bot);
exports.reduceRight = new values_1.Value('reduceRight', label_1.bot);
exports.fromCharCode = new values_1.Value('fromCharCode', label_1.bot);
exports.charAt = new values_1.Value('charAt', label_1.bot);
exports.charCodeAt = new values_1.Value('charCodeAt', label_1.bot);
exports.localeCompare = new values_1.Value('localeCompare', label_1.bot);
exports.match = new values_1.Value('match', label_1.bot);
exports.replace = new values_1.Value('replace', label_1.bot);
exports.search = new values_1.Value('search', label_1.bot);
exports.split = new values_1.Value('split', label_1.bot);
exports.substring = new values_1.Value('substring', label_1.bot);
exports.substr = new values_1.Value('substr', label_1.bot);
exports.toLowerCase = new values_1.Value('toLowerCase', label_1.bot);
exports.toLocaleLowerCase = new values_1.Value('toLocaleLowerCase', label_1.bot);
exports.toUpperCase = new values_1.Value('toUpperCase', label_1.bot);
exports.toLocaleUpperCase = new values_1.Value('toLocaleUpperCase', label_1.bot);
exports.trim = new values_1.Value('trim', label_1.bot);
exports.MAX_VALUE = new values_1.Value('MAX_VALUE', label_1.bot);
exports.MIN_VALUE = new values_1.Value('MIN_VALUE', label_1.bot);
exports.NEGATIVE_INFINITY = new values_1.Value('NEGATIVE_INFINITY', label_1.bot);
exports.POSITIVE_INFINITY = new values_1.Value('POSITIVE_INFINITY', label_1.bot);
exports.toFixed = new values_1.Value('toFixed', label_1.bot);
exports.toExponential = new values_1.Value('toExponential', label_1.bot);
exports.toPrecision = new values_1.Value('toPrecision', label_1.bot);
exports.E = new values_1.Value('E', label_1.bot);
exports.LN10 = new values_1.Value('LN10', label_1.bot);
exports.LN2 = new values_1.Value('LN2', label_1.bot);
exports.LOG2E = new values_1.Value('LOG2E', label_1.bot);
exports.LOG10E = new values_1.Value('LOG10E', label_1.bot);
exports.PI = new values_1.Value('PI', label_1.bot);
exports.SQRT1_2 = new values_1.Value('SQRT1_2', label_1.bot);
exports.SQRT2 = new values_1.Value('SQRT2', label_1.bot);
exports.abs = new values_1.Value('abs', label_1.bot);
exports.acos = new values_1.Value('acos', label_1.bot);
exports.asin = new values_1.Value('asin', label_1.bot);
exports.atan = new values_1.Value('atan', label_1.bot);
exports.atan2 = new values_1.Value('atan2', label_1.bot);
exports.ceil = new values_1.Value('ceil', label_1.bot);
exports.cos = new values_1.Value('cos', label_1.bot);
exports.exp = new values_1.Value('exp', label_1.bot);
exports.floor = new values_1.Value('floor', label_1.bot);
exports.log = new values_1.Value('log', label_1.bot);
exports.max = new values_1.Value('max', label_1.bot);
exports.min = new values_1.Value('min', label_1.bot);
exports.pow = new values_1.Value('pow', label_1.bot);
exports.random = new values_1.Value('random', label_1.bot);
exports.round = new values_1.Value('round', label_1.bot);
exports.sin = new values_1.Value('sin', label_1.bot);
exports.sqrt = new values_1.Value('sqrt', label_1.bot);
exports.tan = new values_1.Value('tan', label_1.bot);
exports.toDateString = new values_1.Value('toDateString', label_1.bot);
exports.toTimeString = new values_1.Value('toTimeString', label_1.bot);
exports.toLocaleDateString = new values_1.Value('toLocaleDateString', label_1.bot);
exports.toLocaleTimeString = new values_1.Value('toLocaleTimeString', label_1.bot);
exports.getTime = new values_1.Value('getTime', label_1.bot);
exports.getFullYear = new values_1.Value('getFullYear', label_1.bot);
exports.getUTCFullYear = new values_1.Value('getUTCFullYear', label_1.bot);
exports.getMonth = new values_1.Value('getMonth', label_1.bot);
exports.getUTCMonth = new values_1.Value('getUTCMonth', label_1.bot);
exports.getDate = new values_1.Value('getDate', label_1.bot);
exports.getUTCDate = new values_1.Value('getUTCDate', label_1.bot);
exports.getDay = new values_1.Value('getDay', label_1.bot);
exports.getUTCDay = new values_1.Value('getUTCDay', label_1.bot);
exports.getHours = new values_1.Value('getHours', label_1.bot);
exports.getUTCHours = new values_1.Value('getUTCHours', label_1.bot);
exports.getMinutes = new values_1.Value('getMinutes', label_1.bot);
exports.getUTCMinutes = new values_1.Value('getUTCMinutes', label_1.bot);
exports.getSeconds = new values_1.Value('getSeconds', label_1.bot);
exports.getUTCSeconds = new values_1.Value('getUTCSeconds', label_1.bot);
exports.getMilliseconds = new values_1.Value('getMilliseconds', label_1.bot);
exports.getUTCMilliseconds = new values_1.Value('getUTCMilliseconds', label_1.bot);
exports.getTimezoneOffset = new values_1.Value('getTimezoneOffset', label_1.bot);
exports.setTime = new values_1.Value('setTime', label_1.bot);
exports.setMilliseconds = new values_1.Value('setMilliseconds', label_1.bot);
exports.setUTCMilliseconds = new values_1.Value('setUTCMilliseconds', label_1.bot);
exports.setSeconds = new values_1.Value('setSeconds', label_1.bot);
exports.setUTCSeconds = new values_1.Value('setUTCSeconds', label_1.bot);
exports.setMinutes = new values_1.Value('setMinutes', label_1.bot);
exports.setUTCMinutes = new values_1.Value('setUTCMinutes', label_1.bot);
exports.setHours = new values_1.Value('setHours', label_1.bot);
exports.setUTCHours = new values_1.Value('setUTCHours', label_1.bot);
exports.setDate = new values_1.Value('setDate', label_1.bot);
exports.setUTCDate = new values_1.Value('setUTCDate', label_1.bot);
exports.setMonth = new values_1.Value('setMonth', label_1.bot);
exports.setUTCMonth = new values_1.Value('setUTCMonth', label_1.bot);
exports.setFullYear = new values_1.Value('setFullYear', label_1.bot);
exports.setUTCFullYear = new values_1.Value('setUTCFullYear', label_1.bot);
exports.toUTCString = new values_1.Value('toUTCString', label_1.bot);
exports.toISOString = new values_1.Value('toISOString', label_1.bot);
exports.toJSON = new values_1.Value('toJSON', label_1.bot);
exports.parse = new values_1.Value('parse', label_1.bot);
exports.UTC = new values_1.Value('UTC', label_1.bot);
exports.now = new values_1.Value('now', label_1.bot);
exports.exec = new values_1.Value('exec', label_1.bot);
exports.test = new values_1.Value('test', label_1.bot);
exports.source = new values_1.Value('source', label_1.bot);
exports.global = new values_1.Value('global', label_1.bot);
exports.ignoreCase = new values_1.Value('ignoreCase', label_1.bot);
exports.multiline = new values_1.Value('multiline', label_1.bot);
exports.lastIndex = new values_1.Value('lastIndex', label_1.bot);
/*
var strings = [
  'index',
  'input',
  'value',
  'writable',
  'enumerable',
  'configurable',
  'get',
  'set',
  'print',
  'console',
  'alert',
  'log',
  'prototype',
  'constructor',
  'length',
  'arguments',
  'upg',
  'upgv',
  'upgf',
  'upgs',
  'getPrototypeOf',
  'getOwnPropertyDescriptor',
  'getOwnPropertyNames',
  'create',
  'require',
  'defineProperty',
  'defineProperties',
  'seal',
  'freeze',
  'preventExtensions',
  'isSealed',
  'isFrozen',
  'isExtensible',
  'keys',
  'toString',
  'toLocaleString',
  'valueOf',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'apply',
  'call',
  'caller',
  'bind',
  'NaN',
  'Infinity',
  'undefined',
  'eval',
  'parseInt',
  'parseFloat',
  'isNaN',
  'isFinite',
  'decodeURI',
  'decodeURIComponent',
  'encodeURI',
  'encodeURIComponent',
  'Object',
  'Function',
  'Array',
  'String',
  'Boolean',
  'Number',
  'Date',
  'RegExp',
  'Error',
  'EvalError',
  'RangeError',
  'ReferenceError',
  'SyntaxError',
  'TypeError',
  'URIError',
  'Math',
  'JSON',
  'parse',
  'stringify',
  'name',
  'message',
  'isArray',
  'concat',
  'join',
  'pop',
  'push',
  'reverse',
  'shift',
  'slice',
  'sort',
  'splice',
  'unshift',
  'indexOf',
  'lastIndexOf',
  'every',
  'some',
  'forEach',
  'map',
  'filter',
  'reduce',
  'reduceRight',
  'fromCharCode',
  'charAt',
  'charCodeAt',
  'localeCompare',
  'match',
  'replace',
  'search',
  'split',
  'substring',
  'substr',
  'toLowerCase',
  'toLocaleLowerCase',
  'toUpperCase',
  'toLocaleUpperCase',
  'trim',
  'MAX_VALUE',
  'MIN_VALUE',
  'NEGATIVE_INFINITY',
  'POSITIVE_INFINITY',
  'toFixed',
  'toExponential',
  'toPrecision',
  'E',
  'LN10',
  'LN2',
  'LOG2E',
  'LOG10E',
  'PI',
  'SQRT1_2',
  'SQRT2',
  'abs',
  'acos',
  'asin',
  'atan',
  'atan2',
  'ceil',
  'cos',
  'exp',
  'floor',
  'log',
  'max',
  'min',
  'pow',
  'random',
  'round',
  'sin',
  'sqrt',
  'tan',
  'toDateString',
  'toTimeString',
  'toLocaleDateString',
  'toLocaleTimeString',
  'getTime',
  'getFullYear',
  'getUTCFullYear',
  'getMonth',
  'getUTCMonth',
  'getDate',
  'getUTCDate',
  'getDay',
  'getUTCDay',
  'getHours',
  'getUTCHours',
  'getMinutes',
  'getUTCMinutes',
  'getSeconds',
  'getUTCSeconds',
  'getMilliseconds',
  'getUTCMilliseconds',
  'getTimezoneOffset',
  'setTime',
  'setMilliseconds',
  'setUTCMilliseconds',
  'setSeconds',
  'setUTCSeconds',
  'setMinutes',
  'setUTCMinutes',
  'setHours',
  'setUTCHours',
  'setDate',
  'setUTCDate',
  'setMonth',
  'setUTCMonth',
  'setFullYear',
  'setUTCFullYear',
  'toUTCString',
  'toISOString',
  'toJSON',
  'parse',
  'UTC',
  'now',
  'exec',
  'test',
  'source',
  'global',
  'ignoreCase',
  'multiline',
  'lastIndex'
];

export var constants = {};
for (var i = 0, len = strings.length; i < len; i++) {
  var str = strings[i];
  console.log(`export var ${str} = new Value('${str}', bot);`)
  constants[str] = new Value(str, Label.bot);
}
*/



},{"./label":60,"./values":75}],51:[function(require,module,exports){
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
var label_1 = require("./label");
var stack_1 = require("./stack");
var pp_1 = require("./pp");
// --- -----------------------------------------------------------------------
var Bucket = /** @class */ (function () {
    function Bucket(element, prev, next) {
        this.element = element;
        this.next = next || null;
        this.prev = prev || null;
    }
    return Bucket;
}());
var WorkList = /** @class */ (function () {
    function WorkList() {
        this.length = 0;
        this.head = null;
        this.thenloc = null;
    }
    // ---
    WorkList.prototype.toString = function () {
        var pos = this.head;
        var str = 'worklist:';
        var cnt = 1;
        while (pos) {
            var element = pos.element;
            var line;
            if (typeof element === 'function') {
                line = cnt + ': ' + String(element);
            }
            else if ('func' in element && 'data' in element) {
                line = cnt + ': ' + String(element.func);
            }
            else {
                line = cnt + ': ' + element.type + ' ' + pp_1.pretty(element);
            }
            var ix = line.indexOf('\n');
            if (ix > 0) {
                line = line.slice(0, ix);
            }
            str = str + '\n' + line;
            pos = pos.next;
            cnt++;
        }
        return str;
    };
    // ---
    WorkList.prototype.push = function (element) {
        this.head = new Bucket(element, null, this.head);
        if (this.head.next) {
            this.head.next.prev = this.head;
        }
        this.length++;
    };
    // ---
    WorkList.prototype.prepend = function (elements) {
        for (var i = elements.length - 1; i >= 0; i--) {
            this.push(elements[i]);
        }
    };
    // ---
    WorkList.prototype.peek = function () {
        if (this.head === null) {
            return monitor.fatal("WorkList.peek() empty work list");
        }
        return this.head.element;
    };
    // ---
    WorkList.prototype.pop = function () {
        if (this.head === null) {
            return monitor.fatal("WorkList.pop() empty work list");
        }
        var element = this.head.element;
        this.head = this.head.next;
        this.length--;
        return element;
    };
    // ---
    WorkList.prototype.empty = function () {
        return (this.head === null);
    };
    // ---
    WorkList.prototype.top = function () {
        return new WorkListPtr(this, null);
    };
    // ---
    WorkList.prototype.first = function (element) {
        if (element) {
            this.push(element);
            this.thenloc = this.head;
        }
        else {
            // if no element given, reset thenloc to force next called 'then'
            // to be a 'first'
            this.thenloc = null;
        }
    };
    // ---
    WorkList.prototype.then = function (element) {
        if (!this.thenloc) {
            this.first(element);
        }
        else {
            var before = this.thenloc;
            var after = this.thenloc.next;
            var bucket = new Bucket(element, before, after);
            before.next = bucket;
            this.thenloc = before.next;
            if (after) {
                after.prev = before.next;
            }
            this.length++;
        }
    };
    return WorkList;
}());
// -------------------------------------------------------------
var WorkListPtr = /** @class */ (function () {
    function WorkListPtr(worklist, pos) {
        this.worklist = worklist;
        this.pos = pos;
    }
    WorkListPtr.prototype.then = function (element, data) {
        if (!element) {
            throw Error();
        }
        var thing = element;
        if (data) {
            thing = { func: element, data: data };
        }
        if (this.pos) {
            var before = this.pos;
            var after = this.pos.next;
            var bucket = new Bucket(thing, before, after);
            before.next = bucket;
            this.pos = before.next;
            if (after) {
                after.prev = before.next;
            }
            this.worklist.length++;
        }
        else {
            this.worklist.push(thing);
            this.pos = this.worklist.head;
        }
        return this;
    };
    return WorkListPtr;
}());
var Result = /** @class */ (function () {
    function Result(value) {
        this.type = 'normal';
        this.target = null;
        this.value = value || null;
    }
    return Result;
}());
exports.Result = Result;
// -------------------------------------------------------------
// The Execution Context
var Context = /** @class */ (function () {
    function Context(thisValue, variableEnv, lexicalEnv) {
        this.labels = new /** @class */ (function () {
            function class_1(outer) {
                this.excLbl = label_1.bot;
                this.retLbl = label_1.bot;
                this.labelmap = {};
                this.outer = outer;
            }
            Object.defineProperty(class_1.prototype, "exc", {
                get: function () {
                    if (monitor.options.get('monitor.taintMode')) {
                        return label_1.bot;
                    }
                    return this.excLbl;
                },
                set: function (l) {
                    this.excLbl = l;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(class_1.prototype, "ret", {
                get: function () {
                    if (monitor.options.get('monitor.taintMode')) {
                        return label_1.bot;
                    }
                    return this.retLbl;
                },
                set: function (l) {
                    this.retLbl = l;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(class_1.prototype, "pc", {
                get: function () {
                    if (monitor.options.get('monitor.taintMode')) {
                        return label_1.bot;
                    }
                    return this.outer.pcStack.peek();
                },
                set: function (l) {
                    this.outer.pcStack.pop();
                    this.outer.pcStack.push(l);
                },
                enumerable: true,
                configurable: true
            });
            return class_1;
        }())(this);
        this.thisValue = thisValue;
        this.variableEnv = variableEnv;
        this.lexicalEnv = lexicalEnv;
        this.pcStack = new stack_1.Stack();
        this.pcStack.push(label_1.Label.bot);
        this.workList = new WorkList();
        this.result = new Result();
        this.valueStack = new stack_1.Stack();
    }
    Object.defineProperty(Context.prototype, "effectivePC", {
        // ---
        get: function () {
            if (monitor.options.get('monitor.taintMode')) {
                return label_1.bot;
            }
            return label_1.lub(this.labels.pc, this.labels.exc, this.labels.ret);
        },
        enumerable: true,
        configurable: true
    });
    // ---
    Context.prototype.clone = function (thisValue, variableEnv, lexicalEnv) {
        var tV = thisValue || this.thisValue;
        var lE = lexicalEnv || this.lexicalEnv;
        var vE = variableEnv || this.variableEnv;
        var newCtx = new Context(tV, vE, lE);
        newCtx.labels.pc = this.effectivePC;
        newCtx.labels.exc = this.labels.exc;
        newCtx.labels.ret = this.labels.ret;
        return newCtx;
    };
    // ---
    Context.prototype.pushPC = function (l) {
        this.pcStack.push(label_1.lub(l, this.labels.pc));
    };
    // ---
    Context.prototype.raisePC = function (l) {
        this.labels.pc = label_1.lub(this.labels.pc, l);
    };
    // ---
    Context.prototype.popPC = function () {
        return this.pcStack.pop();
    };
    return Context;
}());
exports.Context = Context;

},{"./label":60,"./pp":64,"./stack":68}],52:[function(require,module,exports){
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var label = require("./label");
var values_1 = require("./values");
var ecma = require("./ecma");
var constants = require("./constants");
var function_1 = require("./function");
var HasInstance_1 = require("./HasInstance");
var ToPrimitive_1 = require("./Conversion/ToPrimitive");
var ToNumber_1 = require("./Conversion/ToNumber");
var ToString_1 = require("./Conversion/ToString");
exports.functor = function (monitor) {
    var error = monitor.require('error');
    var Ecma = ecma.Ecma;
    var Label = label.Label;
    var lub = label.lub;
    var le = label.le;
    var bot = Label.bot;
    var top = Label.top;
    // ------------------------------------------------------------
    function allocate(host) {
        var dateConstructor = new DateConstructor(host.Date);
        var datePrototype = dateConstructor._proto;
        return { DateConstructor: dateConstructor,
            DatePrototype: datePrototype
        };
    }
    // ------------------------------------------------------------
    // The Date Constructor, 15.9.3
    var DateConstructor = /** @class */ (function (_super) {
        __extends(DateConstructor, _super);
        function DateConstructor(host) {
            var _this = _super.call(this) || this;
            _this.Prototype = new values_1.Value(monitor.instances.FunctionPrototype, bot);
            _this.Class = 'Function';
            _this.Extensible = true;
            _this._proto = new DatePrototype(_this, host);
            _this.host = host;
            ecma.DefineFFF(_this, constants.length, 7);
            ecma.DefineFFF(_this, constants.prototype, _this._proto);
            ecma.DefineTFT(_this, constants.parse, new function_1.BuiltinFunctionObject(parse, 0, Date.parse));
            ecma.DefineTFT(_this, constants.UTC, new function_1.BuiltinFunctionObject(UTC, 0, Date.UTC));
            ecma.DefineTFT(_this, constants.now, new function_1.BuiltinFunctionObject(now, 0, Date.now));
            return _this;
        }
        return DateConstructor;
    }(Ecma));
    DateConstructor.prototype.HasInstance = HasInstance_1.HasInstance;
    //----------------------------------------------------
    // 15.9.1.1
    DateConstructor.prototype.Call = function (thisArg, args) {
        var str = monitor.instances.DateConstructor.host();
        return new values_1.Value(str, bot);
    };
    //----------------------------------------------------
    // 15.9.3.1
    DateConstructor.prototype.Construct = function (args) {
        var _args = [];
        var label = new Label();
        var obj;
        var _Date = monitor.instances.DateConstructor.host;
        switch (args.length) {
            case 0:
                obj = new DateObject(new _Date(), new Label('Date'));
                break;
            case 1:
                var v = ToPrimitive_1.ToPrimitive(args[0]);
                if (typeof v.value !== 'string') {
                    v = ToNumber_1.ToNumber(v);
                }
                obj = new DateObject(new _Date(v.value), v.label);
                break;
            default:
                for (var i = 0, len = args.length; i < len; i++) {
                    var val = ToNumber_1.ToNumber(args[i]);
                    _args[i] = val.value;
                    label.lub(val.label);
                }
                if (len == 2) {
                    _args[2] = 1;
                }
                for (; i < 7; i++) {
                    _args[i] = 0;
                }
                var date = new _Date(_args[0], _args[1], _args[2], _args[3], _args[4], _args[5], _args[6]);
                obj = new DateObject(date, label);
        }
        return new values_1.Value(obj, bot);
    };
    // ------------------------------------------------------------
    // parse, 15.9.4.2
    function parse(thisArg, args) {
        var string = args[0] || new values_1.Value(undefined, bot);
        string = ToString_1.ToString(string);
        var number = monitor.instances.DateConstructor.host.parse(string.value);
        return new values_1.Value(number, string.label);
    }
    // ------------------------------------------------------------
    // UTC, 15.9.4.3
    function UTC(thisArg, args) {
        var _args = [];
        var label = new Label();
        for (var i = 0, len = args.length; i < len; i++) {
            var val = ToNumber_1.ToNumber(args[i]);
            _args[i] = val.value;
            label.lub(val.label);
        }
        var number = monitor.instances.DateConstructor.host.UTC.apply(null, _args);
        return new values_1.Value(number, label);
    }
    // ------------------------------------------------------------
    // now, 15.9.4.4
    function now(thisArg, args) {
        var number = monitor.instances.DateConstructor.host.now();
        return new values_1.Value(number, bot /*top*/);
    }
    // ------------------------------------------------------------
    // The Date Prototype, 15.9.5
    var DatePrototype = /** @class */ (function (_super) {
        __extends(DatePrototype, _super);
        function DatePrototype(constructor, _Date) {
            var _this = _super.call(this) || this;
            _this.Class = 'Date';
            _this.PrimitiveValue = new values_1.Value(NaN, bot);
            _this.Prototype = new values_1.Value(monitor.instances.ObjectPrototype, bot);
            _this.host = _Date.prototype;
            ecma.DefineFFF(_this, constants.length, 0);
            ecma.DefineTFT(_this, constants.constructor, constructor);
            ecma.DefineTFT(_this, constants.toString, new function_1.BuiltinFunctionObject(toString, 0, _Date.prototype.toString));
            ecma.DefineTFT(_this, constants.toDateString, new function_1.BuiltinFunctionObject(toDateString, 0, _Date.prototype.toDateString));
            ecma.DefineTFT(_this, constants.toTimeString, new function_1.BuiltinFunctionObject(toTimeString, 0, _Date.prototype.toTimeString));
            ecma.DefineTFT(_this, constants.toLocaleString, new function_1.BuiltinFunctionObject(toLocaleString, 0, _Date.prototype.toLocaleString));
            ecma.DefineTFT(_this, constants.toLocaleDateString, new function_1.BuiltinFunctionObject(toLocaleDateString, 0, _Date.prototype.toLocaleDateString));
            ecma.DefineTFT(_this, constants.toLocaleTimeString, new function_1.BuiltinFunctionObject(toLocaleTimeString, 0, _Date.prototype.toLocaleTimeString));
            ecma.DefineTFT(_this, new values_1.Value('valueOf', bot), new function_1.BuiltinFunctionObject(valueOf, 0, _Date.prototype.valueOf));
            ecma.DefineTFT(_this, constants.getTime, new function_1.BuiltinFunctionObject(getTime, 0, _Date.prototype.getTime));
            ecma.DefineTFT(_this, constants.getFullYear, new function_1.BuiltinFunctionObject(getFullYear, 0, _Date.prototype.getFullYear));
            ecma.DefineTFT(_this, constants.getUTCFullYear, new function_1.BuiltinFunctionObject(getUTCFullYear, 0, _Date.prototype.getUTCFullYear));
            ecma.DefineTFT(_this, constants.getMonth, new function_1.BuiltinFunctionObject(getMonth, 0, _Date.prototype.getMonth));
            ecma.DefineTFT(_this, constants.getUTCMonth, new function_1.BuiltinFunctionObject(getUTCMonth, 0, _Date.prototype.getUTCMonth));
            ecma.DefineTFT(_this, constants.getDate, new function_1.BuiltinFunctionObject(getDate, 0, _Date.prototype.getDate));
            ecma.DefineTFT(_this, constants.getUTCDate, new function_1.BuiltinFunctionObject(getUTCDate, 0, _Date.prototype.getUTCDate));
            ecma.DefineTFT(_this, constants.getDay, new function_1.BuiltinFunctionObject(getDay, 0, _Date.prototype.getDay));
            ecma.DefineTFT(_this, constants.getUTCDay, new function_1.BuiltinFunctionObject(getUTCDay, 0, _Date.prototype.getUTCDay));
            ecma.DefineTFT(_this, constants.getHours, new function_1.BuiltinFunctionObject(getHours, 0, _Date.prototype.getHours));
            ecma.DefineTFT(_this, constants.getUTCHours, new function_1.BuiltinFunctionObject(getUTCHours, 0, _Date.prototype.getUTCHours));
            ecma.DefineTFT(_this, constants.getMinutes, new function_1.BuiltinFunctionObject(getMinutes, 0, _Date.prototype.getMinutes));
            ecma.DefineTFT(_this, constants.getUTCMinutes, new function_1.BuiltinFunctionObject(getUTCMinutes, 0, _Date.prototype.getUTCMinutes));
            ecma.DefineTFT(_this, constants.getSeconds, new function_1.BuiltinFunctionObject(getSeconds, 0, _Date.prototype.getSeconds));
            ecma.DefineTFT(_this, constants.getUTCSeconds, new function_1.BuiltinFunctionObject(getUTCSeconds, 0, _Date.prototype.getUTCSeconds));
            ecma.DefineTFT(_this, constants.getMilliseconds, new function_1.BuiltinFunctionObject(getMilliseconds, 0, _Date.prototype.getMilliseconds));
            ecma.DefineTFT(_this, constants.getUTCMilliseconds, new function_1.BuiltinFunctionObject(getUTCMilliseconds, 0, _Date.prototype.getUTCMilliseconds));
            ecma.DefineTFT(_this, constants.getTimezoneOffset, new function_1.BuiltinFunctionObject(getTimezoneOffset, 0, _Date.prototype.getTimezoneOffset));
            ecma.DefineTFT(_this, constants.setTime, new function_1.BuiltinFunctionObject(setTime, 1, _Date.prototype.setTime));
            ecma.DefineTFT(_this, constants.setMilliseconds, new function_1.BuiltinFunctionObject(setMilliseconds, 0, _Date.prototype.setMilliseconds));
            ecma.DefineTFT(_this, constants.setUTCMilliseconds, new function_1.BuiltinFunctionObject(setUTCMilliseconds, 0, _Date.prototype.setUTCMilliseconds));
            ecma.DefineTFT(_this, constants.setSeconds, new function_1.BuiltinFunctionObject(setSeconds, 0, _Date.prototype.setSeconds));
            ecma.DefineTFT(_this, constants.setUTCSeconds, new function_1.BuiltinFunctionObject(setUTCSeconds, 0, _Date.prototype.setUTCSeconds));
            ecma.DefineTFT(_this, constants.setMinutes, new function_1.BuiltinFunctionObject(setMinutes, 0, _Date.prototype.setMinutes));
            ecma.DefineTFT(_this, constants.setUTCMinutes, new function_1.BuiltinFunctionObject(setUTCMinutes, 0, _Date.prototype.setUTCMinutes));
            ecma.DefineTFT(_this, constants.setHours, new function_1.BuiltinFunctionObject(setHours, 0, _Date.prototype.setHours));
            ecma.DefineTFT(_this, constants.setUTCHours, new function_1.BuiltinFunctionObject(setUTCHours, 0, _Date.prototype.setUTCHours));
            ecma.DefineTFT(_this, constants.setDate, new function_1.BuiltinFunctionObject(setDate, 0, _Date.prototype.setDate));
            ecma.DefineTFT(_this, constants.setUTCDate, new function_1.BuiltinFunctionObject(setUTCDate, 0, _Date.prototype.setUTCDate));
            ecma.DefineTFT(_this, constants.setMonth, new function_1.BuiltinFunctionObject(setMonth, 2, _Date.prototype.setMonth));
            ecma.DefineTFT(_this, constants.setUTCMonth, new function_1.BuiltinFunctionObject(setUTCMonth, 0, _Date.prototype.setUTCMonth));
            ecma.DefineTFT(_this, constants.setFullYear, new function_1.BuiltinFunctionObject(setFullYear, 0, _Date.prototype.setFullYear));
            ecma.DefineTFT(_this, constants.setUTCFullYear, new function_1.BuiltinFunctionObject(setUTCFullYear, 0, _Date.prototype.setUTCFullYear));
            ecma.DefineTFT(_this, constants.toUTCString, new function_1.BuiltinFunctionObject(toUTCString, 0, _Date.prototype.toUTCString));
            ecma.DefineTFT(_this, constants.toISOString, new function_1.BuiltinFunctionObject(toISOString, 0, _Date.prototype.toISOString));
            ecma.DefineTFT(_this, constants.toJSON, new function_1.BuiltinFunctionObject(toJSON, 0, _Date.prototype.toJSON));
            // B.2.6 - used by google analytics
            ecma.DefineTFT(_this, new values_1.Value('toGMTString', bot), new function_1.BuiltinFunctionObject(toUTCString, 0, _Date.prototype.toGTMString));
            return _this;
        }
        return DatePrototype;
    }(Ecma));
    function assertDate(v, caller) {
        if (v.value === null || typeof v.value !== 'object' || v.value.Class !== 'Date') {
            monitor.context.pushPC(v.label);
            monitor.Throw(monitor.modules.error.TypeErrorObject, caller + ' is not generic', bot);
        }
    }
    // ------------------------------------------------------------
    function mkGenericGet(fname) {
        return function (thisArg, args) {
            assertDate(thisArg, fname);
            var label = lub(thisArg.label, thisArg.value.PrimitiveLabel);
            var date = thisArg.value.PrimitiveValue;
            var value = date[fname].call(date);
            return new values_1.Value(value, label);
        };
    }
    // ------------------------------------------------------------
    function mkGenericSet(fname) {
        return function (thisArg, args) {
            assertDate(thisArg, fname);
            var context = lub(thisArg.label, monitor.context.effectivePC);
            monitor.assert(le(context, thisArg.value.PrimitiveLabel), fname + ': context ' + context + ' not below state label of Date object ' + thisArg.value.PrimitiveLabel);
            var _args = [];
            var label = new Label();
            for (var i = 0, len = args.length; i < len; i++) {
                var x = ToNumber_1.ToNumber(args[i]);
                label.lub(x.label);
                _args[i] = x.value;
            }
            thisArg.value.PrimitiveLabel = lub(thisArg.value.PrimitiveLabel, label);
            label = lub(thisArg.label, thisArg.value.PrimitiveLabel);
            var date = thisArg.value.PrimitiveValue;
            var value = date[fname].apply(date, _args);
            return new values_1.Value(value, label);
        };
    }
    // ------------------------------------------------------------
    // toISOString, 15.9.5.43
    var toISOString = mkGenericGet('toISOString');
    // ------------------------------------------------------------
    // toString, 15.9.5.2
    var toString = mkGenericGet('toString');
    // ------------------------------------------------------------
    // toDateString, 15.9.5.?
    var toDateString = mkGenericGet('toDateString');
    // ------------------------------------------------------------
    // toTimeString, 15.9.5.?
    var toTimeString = mkGenericGet('toTimeString');
    // ------------------------------------------------------------
    // toLocaleString, 15.9.5.?
    var toLocaleString = mkGenericGet('toLocaleString');
    // ------------------------------------------------------------
    // toLocaleDateString, 15.9.5.?
    var toLocaleDateString = mkGenericGet('toLocaleDateString');
    // ------------------------------------------------------------
    // toLocaleTimeString, 15.9.5.?
    var toLocaleTimeString = mkGenericGet('toLocaleTimeString');
    // ------------------------------------------------------------
    // valueOf, 15.9.5.?
    function valueOf(thisArg, args) {
        assertDate(thisArg, 'valueOf');
        return new values_1.Value(thisArg.value.PrimitiveValue.valueOf(), thisArg.label);
    }
    // ------------------------------------------------------------
    // getTime, 15.9.5.9
    var getTime = mkGenericGet('getTime');
    // ------------------------------------------------------------
    // getFullYear, 15.9.5.?
    var getFullYear = mkGenericGet('getFullYear');
    // ------------------------------------------------------------
    // getUTCFullYear, 15.9.5.?
    var getUTCFullYear = mkGenericGet('getUTCFullYear');
    // ------------------------------------------------------------
    // getMonth, 15.9.5.?
    var getMonth = mkGenericGet('getMonth');
    // ------------------------------------------------------------
    // getUTCMonth, 15.9.5.?
    var getUTCMonth = mkGenericGet('getUTCMonth');
    // ------------------------------------------------------------
    // getDate, 15.9.5.?
    var getDate = mkGenericGet('getDate');
    // ------------------------------------------------------------
    // getUTCDate, 15.9.5.?
    var getUTCDate = mkGenericGet('getUTCDate');
    // ------------------------------------------------------------
    // getDay, 15.9.5.?
    var getDay = mkGenericGet('getDay');
    // ------------------------------------------------------------
    // getUTCDay, 15.9.5.?
    var getUTCDay = mkGenericGet('getUTCDay');
    // ------------------------------------------------------------
    // getHours, 15.9.5.?
    var getHours = mkGenericGet('getHours');
    // ------------------------------------------------------------
    // getUTCHours, 15.9.5.?
    var getUTCHours = mkGenericGet('getUTCHours');
    // ------------------------------------------------------------
    // getMinutes, 15.9.5.?
    var getMinutes = mkGenericGet('getMinutes');
    // ------------------------------------------------------------
    // getUTCMinutes, 15.9.5.?
    var getUTCMinutes = mkGenericGet('getUTCMinutes');
    // ------------------------------------------------------------
    // getSeconds, 15.9.5.?
    var getSeconds = mkGenericGet('getSeconds');
    // ------------------------------------------------------------
    // getUTCSeconds, 15.9.5.?
    var getUTCSeconds = mkGenericGet('getUTCSeconds');
    // ------------------------------------------------------------
    // getMilliseconds, 15.9.5.?
    var getMilliseconds = mkGenericGet('getMilliseconds');
    // ------------------------------------------------------------
    // getUTCMilliseconds, 15.9.5.?
    var getUTCMilliseconds = mkGenericGet('getUTCMilliseconds');
    // ------------------------------------------------------------
    // getTimezoneOffset, 15.9.5.?
    var getTimezoneOffset = mkGenericGet('getTimezoneOffset');
    // ------------------------------------------------------------
    // setTime, 15.9.5.?
    var setTime = mkGenericSet('setTime');
    // ------------------------------------------------------------
    // setMilliseconds, 15.9.5.?
    var setMilliseconds = mkGenericSet('setMilliseconds');
    // ------------------------------------------------------------
    // setUTCMilliseconds, 15.9.5.?
    var setUTCMilliseconds = mkGenericSet('setUTCMilliseconds');
    // ------------------------------------------------------------
    // setSeconds, 15.9.5.?
    var setSeconds = mkGenericSet('setSeconds');
    // ------------------------------------------------------------
    // setUTCSeconds, 15.9.5.?
    var setUTCSeconds = mkGenericSet('setUTCSeconds');
    // ------------------------------------------------------------
    // setMinutes, 15.9.5.?
    var setMinutes = mkGenericSet('setMinutes');
    // ------------------------------------------------------------
    // setUTCMinutes, 15.9.5.?
    var setUTCMinutes = mkGenericSet('setUTCMinutes');
    // ------------------------------------------------------------
    // setHours, 15.9.5.?
    var setHours = mkGenericSet('setHours');
    // ------------------------------------------------------------
    // setUTCHours, 15.9.5.?
    var setUTCHours = mkGenericSet('setUTCHours');
    // ------------------------------------------------------------
    // setDate, 15.9.5.?
    var setDate = mkGenericSet('setDate');
    // ------------------------------------------------------------
    // setUTCDate, 15.9.5.?
    var setUTCDate = mkGenericSet('setUTCDate');
    // ------------------------------------------------------------
    // setMonth, 15.9.5.?
    var setMonth = mkGenericSet('setMonth');
    // ------------------------------------------------------------
    // setUTCMonth, 15.9.5.?
    var setUTCMonth = mkGenericSet('setUTCMonth');
    // ------------------------------------------------------------
    // setFullYear, 15.9.5.?
    var setFullYear = mkGenericSet('setFullYear');
    // ------------------------------------------------------------
    // setUTCFullYear, 15.9.5.?
    var setUTCFullYear = mkGenericSet('setUTCFullYear');
    // ------------------------------------------------------------
    // toUTCString, 15.9.5.?
    var toUTCString = mkGenericGet('toUTCString');
    // ------------------------------------------------------------
    // toJSON, 15.9.5.?
    var toJSON = mkGenericGet('toJSON');
    // ------------------------------------------------------------
    // Date Object, 15.9.5
    var DateObject = /** @class */ (function (_super) {
        __extends(DateObject, _super);
        function DateObject(date, label) {
            var _this = _super.call(this) || this;
            _this.Class = 'Date';
            _this.PrimitiveValue = date;
            _this.PrimitiveLabel = label;
            _this.Extensible = true;
            _this.Prototype = new values_1.Value(monitor.instances.DatePrototype, bot);
            return _this;
        }
        return DateObject;
    }(Ecma));
    // ------------------------------------------------------------
    var module = {};
    module.DateObject = DateObject;
    module.allocate = allocate;
    return module;
};



},{"./Conversion/ToNumber":31,"./Conversion/ToPrimitive":33,"./Conversion/ToString":34,"./HasInstance":37,"./constants":50,"./ecma":53,"./function":57,"./label":60,"./values":75}],53:[function(require,module,exports){
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
var label_1 = require("./label");
var values_1 = require("./values");
var constants = require("./constants");
var _ = require("underscore");
var IsCallable_1 = require("./Utility/IsCallable");
// ------------------------------------------------------------
// Property descriptors, 8.10
function IsAccessorDescriptor(pd) {
    if (pd === undefined) {
        return false;
    }
    else {
        return ('get' in pd || 'put' in pd);
    }
}
exports.IsAccessorDescriptor = IsAccessorDescriptor;
function IsDataDescriptor(pd) {
    if (pd === undefined) {
        return false;
    }
    else {
        return ('value' in pd || 'writable' in pd);
    }
}
exports.IsDataDescriptor = IsDataDescriptor;
var Ecma = /** @class */ (function () {
    function Ecma(klass) {
        this.Prototype = new values_1.Value(null, label_1.bot);
        this.Extensible = true;
        this.properties = {};
        this.labels = {};
        this.Class = klass;
        this.properties = {};
        this.labels = {};
        this.struct = monitor.context.effectivePC;
        Object.defineProperty(this, 'map', {
            get: function () {
                throw new Error('Something touched Ecma.map');
            },
            configurable: true
        });
    }
    // ---
    Ecma.prototype.getOwnPropertyNames = function (label) {
        var names = Object.getOwnPropertyNames(this.properties);
        var result = [];
        for (var i = 0, len = names.length; i < len; i++) {
            var name = names[i];
            result[i] = new values_1.Value(name, label_1.lub(label, this.labels[name].existence));
        }
        return result;
    };
    // ---
    Ecma.prototype.getOwnEnumerablePropertyNames = function (label) {
        var names = Object.getOwnPropertyNames(this.properties);
        var enumerable = [];
        var j = 0;
        for (var i = 0, len = names.length; i < len; i++) {
            var name = names[i];
            // from getOwnPropertyNames; guaranteed to be found
            var desc = Object.getOwnPropertyDescriptor(this.properties, name);
            if (desc.enumerable) {
                enumerable[j++] = new values_1.Value(name, label_1.lub(label, this.labels[name].existence));
            }
        }
        return enumerable;
    };
    // ---
    Ecma.prototype.getEnumerablePropertyNames = function (initialLabel) {
        var defined = {};
        var result = [];
        var j = 0;
        var current = this;
        var lbl = initialLabel || label_1.bot;
        while (current) {
            var enumerable = current.getOwnEnumerablePropertyNames(lbl);
            for (var i = 0, len = enumerable.length; i < len; i++) {
                var name = enumerable[i];
                if (!defined.hasOwnProperty(name.value)) {
                    defined[name.value] = true;
                    result[j++] = name;
                }
            }
            var next = current.Prototype;
            current = next.value;
            lbl = label_1.lub(lbl, next.label);
        }
        return result;
    };
    // GetOwnProperty, 8.12.1 -----------------------------------------------------
    Ecma.prototype.GetOwnProperty = function (s) {
        var propName = s.value;
        var propNameLabel = s.label;
        var jsdesc = Object.getOwnPropertyDescriptor(this.properties, propName);
        if (jsdesc === undefined) {
            return new values_1.Value(undefined, label_1.lub(this.struct, propNameLabel));
        }
        var propLabel = this.labels[propName];
        // TODO: add proper cloning?
        // @ts-ignore
        jsdesc.label = propLabel.value;
        var result = new values_1.Value(jsdesc, label_1.lub(propNameLabel, propLabel.existence));
        return result;
    };
    // GetProperty, 8.12.2 --------------------------------------------------------
    Ecma.prototype.GetProperty = function (s) {
        var prop = this.GetOwnProperty(s);
        if (prop.value !== undefined) {
            return prop;
        }
        var proto = this.Prototype;
        var lbl = label_1.lub(prop.label, proto.label);
        if (proto.value === null) {
            return new values_1.Value(undefined, lbl);
        }
        // DEBUG: remove
        if (proto.value === undefined) {
            monitor.fatal('ECMA Object with undefined Prototype');
        }
        var res = proto.GetProperty(s);
        res.label = lbl.lub(res.label);
        return res;
    };
    // Get, 8.12.3 ----------------------------------------------------------------
    Ecma.prototype.Get = function (s) {
        var labeledDesc = this.GetProperty(s);
        // TODO: is this really correct?
        if (labeledDesc.value === undefined) {
            return labeledDesc;
        }
        var v;
        var desc = labeledDesc.value;
        monitor.context.pushPC(labeledDesc.label);
        if ('value' in desc) {
            v = new values_1.Value(desc.value, desc.label);
        }
        else if (desc.get) {
            v = desc.get.call(this);
        }
        else {
            v = new values_1.Value(undefined, labeledDesc.label);
        }
        monitor.context.popPC();
        v.raise(labeledDesc.label);
        return v;
    };
    // CanPut, 8.12.4 -------------------------------------------------------------
    Ecma.prototype.CanPut = function (p) {
        var labeledDesc = this.GetOwnProperty(p);
        var label = labeledDesc.label;
        if (labeledDesc.value) {
            var desc = labeledDesc.value;
            label = label_1.lub(label, desc.label);
            if (IsAccessorDescriptor(desc)) {
                return new values_1.Value(desc.set !== undefined, label);
            }
            else {
                return new values_1.Value(!!desc.writable, label);
            }
        }
        var proto = this.Prototype;
        if (proto.value === null) {
            return new values_1.Value(this.Extensible, label);
        }
        var lableledPrototypeDesc = proto.GetProperty(p);
        label = label_1.lub(label, lableledPrototypeDesc.label);
        if (lableledPrototypeDesc.value === undefined) {
            return new values_1.Value(this.Extensible, label);
        }
        var prototypeDesc = lableledPrototypeDesc.value;
        label.lub(prototypeDesc.label);
        if (IsAccessorDescriptor(prototypeDesc)) {
            return new values_1.Value(prototypeDesc.set !== undefined, label);
        }
        else {
            if (!this.Extensible) {
                return new values_1.Value(false, label);
            }
            else {
                return new values_1.Value(!!prototypeDesc.writable, label);
            }
        }
    };
    // Put, 8.12.5 ----------------------------------------------------------------
    Ecma.prototype.Put = function (s, v, Throw) {
        var c = monitor.context;
        var canPut = this.CanPut(s);
        if (!canPut.value) {
            if (Throw) {
                c.pushPC(canPut.label);
                monitor.Throw(monitor.modules.error.TypeErrorObject, 'illegal access', label_1.bot);
            }
            return;
        }
        c.pushPC(new label_1.Label());
        var ownDesc = this.GetOwnProperty(s);
        if (ownDesc.value && IsDataDescriptor(ownDesc.value)) {
            this.DefineOwnProperty(s, { value: v.value, label: v.label }, Throw);
            c.popPC();
            return;
        }
        var desc = this.GetProperty(s);
        if (desc.value && IsAccessorDescriptor(desc.value)) {
            this.struct.lub(s.label);
            if (desc.value.set) {
                c.labels.pc.lub(desc.label);
                try {
                    desc.value.set.call(this, v);
                }
                catch (e) {
                    monitor.tryRethrow(e, Throw);
                    monitor.fatal('unable to lift', e);
                }
            }
            c.popPC();
            return;
        }
        c.labels.pc.lub(desc.label);
        this.DefineOwnProperty(s, {
            value: v.value,
            label: v.label,
            writable: true,
            enumerable: true,
            configurable: true
        }, Throw);
        c.popPC();
        return;
    };
    // HasProperty, 8.12.6 --------------------------------------------------------
    Ecma.prototype.HasProperty = function (s) {
        var desc = this.GetProperty(s);
        var val = new values_1.Value(desc.value !== undefined, desc.label);
        return val;
    };
    // Delete, 8.12.7 -------------------------------------------------------------
    Ecma.prototype.Delete = function (s, Throw) {
        var c = monitor.context;
        var propertyName = s.value;
        var desc = this.GetOwnProperty(s);
        if (desc.value === undefined) {
            return new values_1.Value(true, desc.label);
        }
        if (!label_1.le(c.effectivePC, this.struct)) {
            var msg = _.template('Ecma.prototype.Delete: security context <%=el%> not below structure <%=sl%>');
            monitor.securityError(msg({ el: c.effectivePC, sl: this.struct }));
            // For observable flows
            this.struct.lub(c.effectivePC);
        }
        var lbl = label_1.lub(c.effectivePC, desc.label);
        var existence = this.labels[propertyName].existence;
        if (!label_1.le(lbl, existence)) {
            var msg = _.template('Ecma.prototype.Delete: security context <%=el%> not below exstence label <%=sl%>');
            monitor.securityError(msg({ el: lbl, sl: existence }));
            // For observable flows
            existence.lub(lbl);
        }
        var res;
        try {
            res = delete this.properties[propertyName];
            if (res) {
                delete this.labels[propertyName];
            }
        }
        catch (e) {
            monitor.tryRethrow(e, Throw);
            monitor.fatal('unable to lift', e);
        }
        return new values_1.Value(res, label_1.lub(desc.label, existence));
    };
    // DefaultValue, 8.12.8 -------------------------------------------------------
    Ecma.prototype.DefaultValue = function (hint) {
        if (hint === undefined) {
            if (this.Class === 'Date')
                hint = 'string';
            else
                hint = 'number';
        }
        if (hint === 'string') {
            var toString = this.Get(constants.toString);
            if (IsCallable_1.IsCallable(toString).value) {
                var str = toString.Call(new values_1.Value(this, label_1.bot), []);
                if (values_1.isDefinedPrimitiveValue(str))
                    return str;
            }
            monitor.context.pushPC(toString.label);
            var valueOf = this.Get(constants.valueOf);
            if (IsCallable_1.IsCallable(valueOf).value) {
                var str = valueOf.Call(new values_1.Value(this, label_1.bot), []);
                if (values_1.isDefinedPrimitiveValue(str)) {
                    str.raise(toString.label);
                    monitor.context.popPC();
                    return str;
                }
            }
            // return new Value('DefaultValue: unable to convert', bot);
            monitor.Throw(monitor.modules.error.TypeErrorObject, 'default value, unable to convert', label_1.lub(toString.label, valueOf.label));
        }
        // hint must be 'number'
        var valueOf = this.Get(constants.valueOf);
        if (IsCallable_1.IsCallable(valueOf).value) {
            var str = valueOf.Call(new values_1.Value(this, label_1.bot), []);
            if (values_1.isDefinedPrimitiveValue(str))
                return str;
        }
        monitor.context.pushPC(valueOf.label);
        var toString = this.Get(constants.toString);
        if (IsCallable_1.IsCallable(toString).value) {
            var str = toString.Call(new values_1.Value(this, label_1.bot), []);
            if (values_1.isDefinedPrimitiveValue(str)) {
                str.raise(valueOf.label);
                monitor.context.popPC();
                return str;
            }
        }
        return monitor.Throw(monitor.modules.error.TypeErrorObject, 'default value, unable to convert', label_1.lub(toString.label, valueOf.label));
    };
    // DefineOwnProperty, 8.12.9 --------------------------------------------------
    Ecma.prototype.DefineOwnProperty = function (s, desc, Throw) {
        var c = monitor.context;
        var propName = s.value;
        var propNameLabel = s.label;
        this.struct = label_1.lub(this.struct, propNameLabel);
        var contextLabel = label_1.lub(c.effectivePC, propNameLabel);
        try {
            if (Object.hasOwnProperty.call(this.properties, propName)) {
                var valueLabel = this.labels[propName].value;
                if (!label_1.le(contextLabel, valueLabel)) {
                    var msg = _.template('Ecma.prototype.DefineOwnProperty: security context <%=el%> not below existing value label <%=vl%> for property <%=pn%>');
                    monitor.securityError(msg({ el: contextLabel, vl: valueLabel, pn: propName }));
                    // For observable flows
                    valueLabel.lub(contextLabel);
                }
            }
            else {
                if (!label_1.le(c.effectivePC, this.struct)) {
                    var msg = _.template('Ecma.prototype.DefineOwnProperty: security context <%=el%> not below structure <%=sl%>');
                    monitor.securityError(msg({ el: c.effectivePC, sl: this.struct }));
                    // For observable flows
                    this.struct.lub(c.effectivePC);
                }
            }
            if (desc.get) {
                var get = desc.get;
                desc.get = function () { return get.Call(new values_1.Value(this, label_1.bot), []); };
                desc.get.actualFunction = get;
            }
            if (desc.set) {
                var set = desc.set;
                desc.set = function (v) { return set.Call(new values_1.Value(this, label_1.bot), [v]); };
                desc.set.actualFunction = set;
            }
            Object.defineProperty(this.properties, propName, desc);
            this.labels[propName] = { value: label_1.lub(desc.label, contextLabel), existence: contextLabel };
        }
        catch (e) {
            monitor.tryRethrow(e, Throw);
            monitor.fatal('unable to lift', e);
        }
        return new values_1.Value(true, label_1.bot);
    };
    return Ecma;
}());
exports.Ecma = Ecma;
// ------------------------------------------------------------
function Define(_this, name, v, opts) {
    opts = opts || {};
    name = name.value || name;
    var pd = { value: v };
    pd.writable = Boolean(opts.writable);
    pd.enumerable = Boolean(opts.enumerable);
    pd.configurable = Boolean(opts.configurable);
    Object.defineProperty(_this.properties, name, pd);
    _this.labels[name] = { value: opts.label || label_1.bot, existence: opts.existence || label_1.bot };
}
exports.Define = Define;
function DefineFFT(_this, name, v, opts) {
    opts = opts || {};
    name = name.value || name;
    Object.defineProperty(_this.properties, name, {
        value: v,
        configurable: true
    });
    _this.labels[name] = { value: opts.label || label_1.bot, existence: opts.existence || label_1.bot };
}
exports.DefineFFT = DefineFFT;
function DefineFFF(_this, name, v, opts) {
    opts = opts || {};
    name = name.value || name;
    Object.defineProperty(_this.properties, name, { value: v });
    _this.labels[name] = { value: opts.label || label_1.bot, existence: opts.existence || label_1.bot };
}
exports.DefineFFF = DefineFFF;
function DefineTFF(_this, name, v, opts) {
    opts = opts || {};
    name = name.value || name;
    Object.defineProperty(_this.properties, name, {
        value: v,
        writable: true
    });
    _this.labels[name] = { value: opts.label || label_1.bot, existence: opts.existence || label_1.bot };
}
exports.DefineTFF = DefineTFF;
function DefineTFT(_this, name, v, opts) {
    opts = opts || {};
    name = name.value || name;
    Object.defineProperty(_this.properties, name, {
        value: v,
        writable: true,
        configurable: true
    });
    _this.labels[name] = { value: opts.label || label_1.bot, existence: opts.existence || label_1.bot };
}
exports.DefineTFT = DefineTFT;
// ------------------------------------------------------------

},{"./Utility/IsCallable":49,"./constants":50,"./label":60,"./values":75,"underscore":22}],54:[function(require,module,exports){
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var label_1 = require("./label");
var values_1 = require("./values");
var ecma_1 = require("./ecma");
// ------------------------------------------------------------
// 10.2
// ------------------------------------------------------------
// 10.2.2.2
function NewDeclarativeEnvironment(e) {
    var envRec = new DeclarativeEnvironmentRecord();
    var env = new LexicalEnvironment(envRec, e);
    return env;
}
exports.NewDeclarativeEnvironment = NewDeclarativeEnvironment;
// ------------------------------------------------------------
// 10.2.2.3
function NewObjectEnvironment(o, e) {
    var envRec = new ObjectEnvironmentRecord(o);
    var env = new LexicalEnvironment(envRec, e);
    return env;
}
exports.NewObjectEnvironment = NewObjectEnvironment;
// ------------------------------------------------------------
// Environment records, 10.2.1.2
var ObjectEnvironmentRecord = /** @class */ (function (_super) {
    __extends(ObjectEnvironmentRecord, _super);
    function ObjectEnvironmentRecord(p) {
        var _this = _super.call(this) || this;
        _this.provideThis = false;
        if (p.value === undefined)
            monitor.fatal('ObjectEnvironmentRecord, undefined binding object');
        _this.bindingObject = p; // Value
        return _this;
    }
    // ---
    ObjectEnvironmentRecord.prototype.raise = function (l) {
        this.bindingObject.raise(l);
    };
    // ---
    // HasBinding, 10.2.1.2.1
    ObjectEnvironmentRecord.prototype.HasBinding = function (p) {
        return this.bindingObject.HasProperty(p);
    };
    // ---
    // CreateMutableBinding, 10.2.1.2.2
    ObjectEnvironmentRecord.prototype.CreateMutableBinding = function (p, d) {
        var desc = {
            value: undefined,
            label: monitor.context.effectivePC,
            writable: true,
            enumerable: true,
            configurable: d
        };
        this.bindingObject.DefineOwnProperty(p, desc, true);
    };
    // ---
    // GetBindingValue, 10.2.1.2.4
    ObjectEnvironmentRecord.prototype.GetBindingValue = function (p, s) {
        return this.bindingObject.Get(p);
    };
    // SetMutableBinding, 10.2.1.2.3
    ObjectEnvironmentRecord.prototype.SetMutableBinding = function (p, v, s) {
        this.bindingObject.Put(p, v, s);
    };
    // DeleteBinding, 10.2.1.2.5
    ObjectEnvironmentRecord.prototype.DeleteBinding = function (p) {
        return this.bindingObject.Delete(p);
    };
    // ImplicitThisValue, 10.2.1.2.6
    ObjectEnvironmentRecord.prototype.ImplicitThisValue = function () {
        if (this.provideThis) {
            return this.bindingObject.clone();
        }
        else {
            return new values_1.Value(undefined, label_1.bot);
        }
    };
    return ObjectEnvironmentRecord;
}(ecma_1.Ecma));
exports.ObjectEnvironmentRecord = ObjectEnvironmentRecord;
// ------------------------------------------------------------
// Declarative Environment Record, 10.2.1.1
var DeclarativeEnvironmentRecord = /** @class */ (function (_super) {
    __extends(DeclarativeEnvironmentRecord, _super);
    function DeclarativeEnvironmentRecord() {
        return _super.call(this) || this;
    }
    // HasBinding, 10.2.1.1.1
    DeclarativeEnvironmentRecord.prototype.HasBinding = function (s) {
        return this.HasProperty(s);
    };
    // CreateMutableBinding, 10.2.1.1.2
    DeclarativeEnvironmentRecord.prototype.CreateMutableBinding = function (p, d) {
        var desc = {
            value: undefined,
            label: monitor.context.effectivePC,
            writable: true,
            enumerable: true,
            configurable: d
        };
        this.DefineOwnProperty(p, desc, true);
    };
    // GetBindingValue 10.2.1.1.4
    DeclarativeEnvironmentRecord.prototype.GetBindingValue = function (p, s) {
        return this.Get(p);
    };
    // SetMutableBinding, 10.2.1.1.3
    DeclarativeEnvironmentRecord.prototype.SetMutableBinding = function (p, v, s) {
        this.Put(p, v, s);
    };
    // DeleteBinding, 10.2.1.1.5
    DeclarativeEnvironmentRecord.prototype.DeleteBinding = function (p) {
        return this.Delete(p);
    };
    // ImplicitThisValie. 10.2.1.1.6
    DeclarativeEnvironmentRecord.prototype.ImplicitThisValue = function () {
        return new values_1.Value(undefined, label_1.bot);
    };
    // CreateImmutableBinding, 10.2.1.1.7
    DeclarativeEnvironmentRecord.prototype.CreateImmutableBinding = function (p) {
        var desc = {
            value: undefined,
            label: label_1.bot,
            writable: false,
            enumerable: true,
            configurable: true
        };
        this.DefineOwnProperty(p, desc, false);
    };
    // InitializeImmutableBinding, 10.2.1.1.8
    DeclarativeEnvironmentRecord.prototype.InitializeImmutableBinding = function (p, v) {
        var desc = this.GetOwnProperty(p).value;
        desc.value = v.value;
        desc.label = v.label;
        this.DefineOwnProperty(p, desc, false);
    };
    return DeclarativeEnvironmentRecord;
}(ecma_1.Ecma));
exports.DeclarativeEnvironmentRecord = DeclarativeEnvironmentRecord;
// ------------------------------------------------------------
function IsEnvironmentRecord(p) {
    return ('HasBinding' in p.value);
}
exports.IsEnvironmentRecord = IsEnvironmentRecord;
;
// ------------------------------------------------------------
var LexicalEnvironment = /** @class */ (function () {
    function LexicalEnvironment(er, le) {
        this.EnvironmentRecord = er; // Not Value
        this.OuterLexicalEnvironment = le; // Value
    }
    LexicalEnvironment.prototype.provideThis = function () {
        this.EnvironmentRecord.provideThis = true;
    };
    LexicalEnvironment.prototype.HasBinding = function (s) {
        return this.EnvironmentRecord.HasBinding(s);
    };
    LexicalEnvironment.prototype.CreateMutableBinding = function (s, d) {
        return this.EnvironmentRecord.CreateMutableBinding(s, d);
    };
    LexicalEnvironment.prototype.SetMutableBinding = function (s, v, d) {
        return this.EnvironmentRecord.SetMutableBinding(s, v, d);
    };
    LexicalEnvironment.prototype.GetBindingValue = function (s, d) {
        return this.EnvironmentRecord.GetBindingValue(s, d);
    };
    LexicalEnvironment.prototype.DeleteBinding = function (s) {
        return this.EnvironmentRecord.DeleteBinding(s);
    };
    LexicalEnvironment.prototype.ImplicitThisValue = function () {
        return this.EnvironmentRecord.ImplicitThisValue();
    };
    // Only meaningful if the underlying environment record is 
    //  a declarative environment record
    LexicalEnvironment.prototype.CreateImmutableBinding = function (s) {
        return this.EnvironmentRecord.CreateImmutableBinding(s);
    };
    LexicalEnvironment.prototype.InitializeImmutableBinding = function (s, v) {
        return this.EnvironmentRecord.InitializeImmutableBinding(s, v);
    };
    return LexicalEnvironment;
}());
exports.LexicalEnvironment = LexicalEnvironment;
// ------------------------------------------------------------
// GetIdentifierReference, 10.2.2.1
function GetIdentifierReference(p, x) {
    if (!p) {
        monitor.fatal('GetIdentifierReference: p undefined or null for ' + x);
    }
    if (p.value == null) {
        return new values_1.Reference(new values_1.Value(undefined, p.label), new values_1.Value(x, label_1.bot));
    }
    var erp = new values_1.Value(p.value.EnvironmentRecord, p.label);
    var b = erp.HasBinding(new values_1.Value(x, label_1.bot));
    if (b.value) {
        erp.label = b.label;
        return new values_1.Reference(erp, new values_1.Value(x, label_1.bot));
    }
    else {
        var res = GetIdentifierReference(p.value.OuterLexicalEnvironment, x);
        res.base.raise(b.label);
        return res;
    }
}
exports.GetIdentifierReference = GetIdentifierReference;

},{"./ecma":53,"./label":60,"./values":75}],55:[function(require,module,exports){
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var label = require("./label");
var values_1 = require("./values");
var ecma = require("./ecma");
var constants = require("./constants");
var function_1 = require("./function");
var HasInstance_1 = require("./HasInstance");
var ToString_1 = require("./Conversion/ToString");
exports.functor = function (monitor) {
    var Ecma = ecma.Ecma;
    var Label = label.Label;
    var lub = label.lub;
    var le = label.le;
    var bot = Label.bot;
    // ------------------------------------------------------------
    function allocate(global) {
        var errorConstructor = new ErrorConstructor();
        var errorPrototype = errorConstructor._proto;
        // 15.11.5
        var evalErrorConstructor = new NativeErrorConstructor(global, 'EvalError');
        var rangeErrorConstructor = new NativeErrorConstructor(global, 'RangeError');
        var referenceErrorConstructor = new NativeErrorConstructor(global, 'ReferenceError');
        var syntaxErrorConstructor = new NativeErrorConstructor(global, 'SyntaxError');
        var typeErrorConstructor = new NativeErrorConstructor(global, 'TypeError');
        var URIErrorConstructor = new NativeErrorConstructor(global, 'URIError');
        var evalErrorPrototype = evalErrorConstructor._proto;
        var rangeErrorPrototype = rangeErrorConstructor._proto;
        var referenceErrorPrototype = referenceErrorConstructor._proto;
        var syntaxErrorPrototype = syntaxErrorConstructor._proto;
        var typeErrorPrototype = typeErrorConstructor._proto;
        var uriErrorPrototype = URIErrorConstructor._proto;
        return { ErrorConstructor: errorConstructor,
            ErrorPrototype: errorPrototype,
            EvalErrorConstructor: evalErrorConstructor,
            EvalErrorPrototype: evalErrorPrototype,
            RangeErrorConstructor: rangeErrorConstructor,
            RangeErrorPrototype: rangeErrorPrototype,
            ReferenceErrorConstructor: referenceErrorConstructor,
            ReferenceErrorPrototype: referenceErrorPrototype,
            SyntaxErrorConstructor: syntaxErrorConstructor,
            SyntaxErrorPrototype: syntaxErrorPrototype,
            TypeErrorConstructor: typeErrorConstructor,
            TypeErrorPrototype: typeErrorPrototype,
            URIErrorConstructor: URIErrorConstructor,
            URIErrorPrototype: uriErrorPrototype
        };
    }
    // ------------------------------------------------------------
    // 15.11 - The Error Constructor
    var ErrorConstructor = /** @class */ (function (_super) {
        __extends(ErrorConstructor, _super);
        function ErrorConstructor(host) {
            var _this = _super.call(this) || this;
            _this.Class = 'Function';
            _this.host = host;
            _this.Prototype = new values_1.Value(monitor.instances.FunctionPrototype, bot);
            _this.Extensible = true;
            _this.name = 'Error';
            _this._proto = new ErrorPrototype(_this);
            ecma.DefineFFF(_this, constants.length, 1);
            ecma.DefineFFF(_this, constants.prototype, _this._proto);
            return _this;
        }
        return ErrorConstructor;
    }(Ecma));
    ErrorConstructor.prototype.HasInstance = HasInstance_1.HasInstance;
    // 15.11.2
    ErrorConstructor.prototype.Call = function (thisArg, args) {
        return this.Construct(args);
    };
    // 15.11.2.1
    ErrorConstructor.prototype.Construct = function (args) {
        var arg0 = args[0] ? args[0] : new values_1.Value(undefined, bot);
        var o = new ErrorObject(arg0);
        return new values_1.Value(o, bot);
    };
    // ------------------------------------------------------------
    // 15.11.4 The Error Prototype
    var ErrorPrototype = /** @class */ (function (_super) {
        __extends(ErrorPrototype, _super);
        function ErrorPrototype(constructor) {
            var _this = _super.call(this) || this;
            _this.Class = 'Error';
            _this.Prototype = new values_1.Value(monitor.instances.ObjectPrototype, bot);
            _this.host = Object.getPrototypeOf(Error);
            ecma.DefineTFT(_this, constants.constructor, constructor);
            ecma.DefineTFT(_this, constants.name, 'Error');
            ecma.DefineTFT(_this, constants.message, '');
            ecma.DefineTFT(_this, constants.toString, new function_1.BuiltinFunctionObject(tostring, 0, undefined));
            return _this;
        }
        return ErrorPrototype;
    }(Ecma));
    // ------------------------------------------------------------
    function tostring(thisArg, args) {
        var c = monitor.context;
        if (thisArg.value === null
            || typeof thisArg.value !== 'object'
            || thisArg.value.Class !== 'Error') {
            c.pushPC(thisArg.label);
            monitor.Throw(TypeErrorObject, 'Error object expected', bot);
        }
        var name = thisArg.Get(constants.name);
        if (name.value === undefined) {
            name.value = 'Error';
        }
        else {
            c.pushPC(name.label);
            name = ToString_1.ToString(name);
            c.popPC();
        }
        var msg = thisArg.Get(constants.message);
        if (msg.value === undefined) {
            msg.value = '';
        }
        else {
            c.pushPC(msg.label);
            msg = ToString_1.ToString(msg);
            c.popPC();
        }
        if (name.value === '') {
            msg.raise(name.label);
            return msg;
        }
        if (msg.value === '') {
            name.raise(msg.label);
            return name;
        }
        name.value += ': ' + msg.value;
        name.raise(msg.label);
        return name;
    }
    // ------------------------------------------------------------
    var ErrorObject = /** @class */ (function (_super) {
        __extends(ErrorObject, _super);
        function ErrorObject(v) {
            var _this = _super.call(this) || this;
            _this.Prototype = new values_1.Value(monitor.instances.ErrorPrototype, bot);
            _this.Class = 'Error';
            _this.Extensible = true;
            if (v.value !== undefined) {
                v = ToString_1.ToString(v);
                _this.DefineOwnProperty(constants.message, { value: v.value,
                    label: v.label,
                    writable: true,
                    enumerable: false,
                    configurable: true
                });
            }
            return _this;
        }
        return ErrorObject;
    }(Ecma));
    ErrorObject.prototype.toString = function () {
        var str = ToString_1.ToString(new values_1.Value(this, bot));
        return str.value;
    };
    // ------------------------------------------------------------
    // 15.11.7 The NativeError Constructor
    var NativeErrorConstructor = /** @class */ (function (_super) {
        __extends(NativeErrorConstructor, _super);
        function NativeErrorConstructor(global, name) {
            var _this = _super.call(this) || this;
            _this.Class = 'Function';
            _this.Prototype = new values_1.Value(monitor.instances.FunctionPrototype, bot);
            _this.Extensible = true;
            _this.name = name;
            _this.host = global[name];
            _this._proto = new NativeErrorPrototype(_this, name);
            ecma.DefineFFF(_this, constants.length, 1);
            ecma.DefineFFF(_this, constants.prototype, _this._proto);
            return _this;
        }
        return NativeErrorConstructor;
    }(Ecma));
    NativeErrorConstructor.prototype.HasInstance = HasInstance_1.HasInstance;
    // 15.11.7.2
    NativeErrorConstructor.prototype.Call = function (thisArg, args) {
        return this.Construct(args);
    };
    // 15.11.7.4
    NativeErrorConstructor.prototype.Construct = function (args) {
        var message = args[0] || new values_1.Value(undefined, bot);
        var o = new NativeErrorObject(this._proto, message);
        return new values_1.Value(o, bot);
    };
    // ------------------------------------------------------------
    // 15.11.7.6 The NativeError Prototype
    var NativeErrorPrototype = /** @class */ (function (_super) {
        __extends(NativeErrorPrototype, _super);
        function NativeErrorPrototype(constructor, name) {
            var _this = _super.call(this) || this;
            _this.Class = 'Error';
            _this.Prototype = new values_1.Value(monitor.instances.ObjectPrototype, bot);
            ecma.DefineTFT(_this, constants.constructor, constructor);
            ecma.DefineTFT(_this, constants.name, name);
            ecma.DefineTFT(_this, constants.message, '');
            ecma.DefineTFT(_this, constants.toString, new function_1.BuiltinFunctionObject(tostring, 0, undefined));
            return _this;
        }
        return NativeErrorPrototype;
    }(Ecma));
    // ------------------------------------------------------------
    var NativeErrorObject = /** @class */ (function (_super) {
        __extends(NativeErrorObject, _super);
        function NativeErrorObject(proto, message) {
            var _this = _super.call(this) || this;
            _this.Prototype = new values_1.Value(proto, bot);
            _this.Class = 'Error';
            _this.Extensible = true;
            _this.stack = monitor.stackTrace();
            if (message.value !== undefined) {
                message = ToString_1.ToString(message);
                _this.DefineOwnProperty(constants.message, { value: message.value,
                    writable: true,
                    configurable: true,
                    label: message.label
                });
            }
            return _this;
        }
        return NativeErrorObject;
    }(Ecma));
    NativeErrorObject.prototype.toString = function () {
        var str = ToString_1.ToString(new values_1.Value(this, bot));
        return str.value;
    };
    // -------------------------------------------------------------------------- 
    var EvalErrorObject = /** @class */ (function (_super) {
        __extends(EvalErrorObject, _super);
        function EvalErrorObject(v) {
            var _this = _super.call(this, monitor.instances.EvalErrorPrototype, v) || this;
            _this.Type = 'EvalError';
            return _this;
        }
        return EvalErrorObject;
    }(NativeErrorObject));
    var RangeErrorObject = /** @class */ (function (_super) {
        __extends(RangeErrorObject, _super);
        function RangeErrorObject(v) {
            var _this = _super.call(this, monitor.instances.RangeErrorPrototype, v) || this;
            _this.Type = 'RangeError';
            return _this;
        }
        return RangeErrorObject;
    }(NativeErrorObject));
    var ReferenceErrorObject = /** @class */ (function (_super) {
        __extends(ReferenceErrorObject, _super);
        function ReferenceErrorObject(v) {
            var _this = _super.call(this, monitor.instances.ReferenceErrorPrototype, v) || this;
            _this.Type = 'ReferenceError';
            return _this;
        }
        return ReferenceErrorObject;
    }(NativeErrorObject));
    var SyntaxErrorObject = /** @class */ (function (_super) {
        __extends(SyntaxErrorObject, _super);
        function SyntaxErrorObject(v) {
            var _this = _super.call(this, monitor.instances.SyntaxErrorPrototype, v) || this;
            _this.Type = 'SyntaxError';
            return _this;
        }
        return SyntaxErrorObject;
    }(NativeErrorObject));
    var TypeErrorObject = /** @class */ (function (_super) {
        __extends(TypeErrorObject, _super);
        function TypeErrorObject(v) {
            var _this = _super.call(this, monitor.instances.TypeErrorPrototype, v) || this;
            _this.Type = 'TypeError';
            return _this;
        }
        return TypeErrorObject;
    }(NativeErrorObject));
    var URIErrorObject = /** @class */ (function (_super) {
        __extends(URIErrorObject, _super);
        function URIErrorObject(v) {
            var _this = _super.call(this, monitor.instances.UriErrorPrototype, v) || this;
            _this.Type = 'URIError';
            return _this;
        }
        return URIErrorObject;
    }(NativeErrorObject));
    // -------------------------------------------------------------------------- 
    // ------------------------------------------------------------
    var module = {};
    module.EvalErrorObject = EvalErrorObject;
    module.RangeErrorObject = RangeErrorObject;
    module.ReferenceErrorObject = ReferenceErrorObject;
    module.SyntaxErrorObject = SyntaxErrorObject;
    module.TypeErrorObject = TypeErrorObject;
    module.URIErrorObject = URIErrorObject;
    module.ErrorObject = ErrorObject;
    module.allocate = allocate;
    module.nativeTable = {
        'Error': ErrorObject,
        'EvalError': EvalErrorObject,
        'RangeError': RangeErrorObject,
        'ReferenceError': ReferenceErrorObject,
        'SyntaxError': SyntaxErrorObject,
        'TypeError': TypeErrorObject,
        'URIError': URIErrorObject
    };
    return module;
};

},{"./Conversion/ToString":34,"./HasInstance":37,"./constants":50,"./ecma":53,"./function":57,"./label":60,"./values":75}],56:[function(require,module,exports){
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
var label = require("./label");
var pp = require("./pp");
var values_1 = require("./values");
var context_1 = require("./context");
var env = require("./env");
var ecma = require("./ecma");
var set_1 = require("./set");
var constants = require("./constants");
var esprima = require("esprima");
var function_1 = require("./function");
var FunctionObject_1 = require("./Objects/FunctionObject");
var ObjectObject_1 = require("./Objects/ObjectObject");
var ArrayObject_1 = require("./Objects/ArrayObject");
var ToBoolean_1 = require("./Conversion/ToBoolean");
var ToPrimitive_1 = require("./Conversion/ToPrimitive");
var ToNumber_1 = require("./Conversion/ToNumber");
var ToInt32_1 = require("./Conversion/ToInt32");
var ToUInt32_1 = require("./Conversion/ToUInt32");
var ToString_1 = require("./Conversion/ToString");
var ToObject_1 = require("./Conversion/ToObject");
var CheckObjectCoercible_1 = require("./Utility/CheckObjectCoercible");
var IsCallable_1 = require("./Utility/IsCallable");
exports.functor = function (monitor) {
    var error = monitor.require('error');
    var regexp = monitor.require('regexp');
    var RegExpObject = regexp.RegExpObject;
    var Label = label.Label;
    var lub = label.lub;
    var le = label.le;
    var bot = Label.bot;
    // ------------------------------------------------------------
    var runfor_all = { 'throw': true, 'continue': true, 'break': true };
    var runfor_throw = { 'throw': true };
    var runfor_continue = { 'continue': true };
    var runfor_break = { 'break': true };
    var runfor_continue_break = { 'break': true, 'continue': true };
    // ------------------------------------------------------------
    function initialize() {
        var global = monitor.instances.globalObject;
        var globalEnv = env.NewObjectEnvironment(new values_1.Value(global, bot), new values_1.Value(null, bot));
        monitor.instances.globalEnvironment = globalEnv;
        monitor.context.thisValue = new values_1.Value(global, bot);
        monitor.context.variableEnv = new values_1.Value(globalEnv, bot);
        monitor.context.lexicalEnv = new values_1.Value(globalEnv, bot);
        // set ThrowTypeError object in function, as we now have global environment
        monitor.instances.ThrowTypeError = new function_1.ThrowTypeError();
    }
    // ------------------------------------------------------------
    function running() {
        return !monitor.context.workList.empty();
    }
    // ------------------------------------------------------------
    function execute(ast, debugEnabled) {
        monitor.context.workList.push(ast);
        monitor.context.result = new context_1.Result();
        if (debugEnabled === undefined) {
            debugEnabled = true;
        }
        var stepCount = 0;
        var cont = true;
        do {
            if (debugEnabled && monitor.debug.active) {
                return monitor.context.result;
            }
            cont = step();
            stepCount++;
            if (stepCount % 1000000 === 0) {
                monitor.log('Executing ', stepCount);
            }
        } while (cont);
        monitor.log('Final number of execution steps: ', stepCount);
        return monitor.context.result;
    }
    // ------------------------------------------------------------
    function resume() {
        var cont = true;
        do {
            cont = step();
            if (monitor.debug.active) {
                return monitor.context.result;
            }
        } while (cont);
        return monitor.context.result;
    }
    // ------------------------------------------------------------
    function executeGlobalCode(code, filename, options) {
        try {
            monitor.code = code;
            monitor.ast = esprima.parse(code, { loc: true, range: true, tolerant: true, source: filename });
        }
        catch (e) {
            var msg = e.description + ' in ' + filename + ':' + e.lineNumber + ':' + e.column;
            msg = new values_1.Value(msg, bot);
            var obj = new error.SyntaxErrorObject(msg, bot);
            var result = new context_1.Result();
            result.type = 'throw';
            result.value = new values_1.Value(obj, bot);
            return result;
        }
        var debugEnabled = true;
        if (options && typeof options.debugEnabled !== 'undefined') {
            debugEnabled = options.debugEnabled;
        }
        enterGlobalCode(monitor.ast);
        return execute(monitor.ast, debugEnabled);
    }
    // ------------------------------------------------------------
    //   contains the declaration binding (10.5) of global code
    function enterGlobalCode(ast, filename) {
        var c = monitor.context;
        // 10.5 - hoisting
        function_1.HoistFunctions(c.variableEnv, ast, false, bot);
        function_1.HoistVariables(c.variableEnv, ast, false, bot);
    }
    // ------------------------------------------------------------
    // GetValue, 8.7.1
    function GetValue(v) {
        if (!v || !(v instanceof values_1.Reference))
            return v;
        if (v.base.label === undefined)
            monitor.fatal('GetValue, base.label undefined');
        if (v.IsUnresolvableReference()) {
            monitor.Throw(error.ReferenceErrorObject, v.propertyName.value + ' not defined', v.base.label);
        }
        var p = v.base;
        var s = v.propertyName;
        if (v.IsPropertyReference()) {
            if (!v.HasPrimitiveBase()) {
                return p.Get(s);
            }
            else {
                var o = ToObject_1.ToObject(p);
                var desc = o.GetProperty(s);
                if (desc.value === undefined) {
                    return desc;
                }
                var lbl = new Label();
                lbl.lub(desc.label, desc.value.label);
                desc = desc.value;
                if (ecma.IsDataDescriptor(desc)) {
                    return new values_1.Value(desc.value, lbl);
                }
                var get = desc.get;
                if (get === undefined) {
                    new values_1.Value(undefined, lbl);
                }
                monitor.context.pushPC(lbl);
                var res = get.Call(get, v.base);
                monitor.context.popPC();
                res.raise(lbl);
                return res;
            }
        }
        return p.GetBindingValue(s);
    }
    // ------------------------------------------------------------
    // PutValue
    function PutValue(r, v) {
        var ctx = monitor.context;
        if (!(r instanceof values_1.Reference)) {
            throw new Error();
            monitor.Throw(error.ReferenceErrorObject, 'PutValue: target is not a reference', r.label);
        }
        var p = r.base;
        var s = r.propertyName;
        if (r.IsUnresolvableReference()) {
            p.value = monitor.instances.globalObject;
            p.Put(s, v);
        }
        else if (r.IsPropertyReference()) {
            if (r.HasPrimitiveBase()) {
                var o = ToObject_1.ToObject(p);
                if (!o.CanPut(s).value) {
                    return;
                }
                var ownDesc = o.GetOwnProperty(s);
                if (ownDesc.value && ecma.IsDataDescriptor(ownDesc.value)) {
                    return;
                }
                var desc = o.GetProperty(s);
                if (desc.value && ecma.IsAccessorDescriptor(desc.value)) {
                    monitor.context.pushPC(lub(ownDesc.label, desc.label)); // contains o.label
                    desc.value.Set.Call(p, [v]);
                    monitor.context.popPC();
                }
            }
            else {
                p.Put(s, v);
            }
        }
        else {
            p.SetMutableBinding(s, v);
        }
    }
    // -------------------------------------------------------------
    // Unary operators
    // -------------------------------------------------------------
    // Unary -, 11.4.7
    function unaryMinus(wl, vs) {
        var ref = vs.pop();
        var n = ToNumber_1.ToNumber(GetValue(ref));
        n.value = -n.value;
        vs.push(n);
    }
    // -------------------------------------------------------------
    // Unary +, 11.4.6
    function unaryPlus(wl, vs) {
        var ref = vs.pop();
        var n = ToNumber_1.ToNumber(GetValue(ref));
        vs.push(n);
    }
    // -------------------------------------------------------------
    // Logical NOT, 11.4.9
    function unaryLogicalNot(wl, vs) {
        var ref = vs.pop();
        var b = ToBoolean_1.ToBoolean(GetValue(ref));
        b.value = !b.value;
        vs.push(b);
    }
    // -------------------------------------------------------------
    // Bitwise NOT, 11.4.8
    function unaryBitwiseNot(wl, vs) {
        var ref = vs.pop();
        var n = ToInt32_1.ToInt32(GetValue(ref));
        n.value = ~n.value;
        vs.push(n);
    }
    // -------------------------------------------------------------
    // The typeof Operator, 11.4.3
    function unaryTypeof(wl, vs) {
        var ref = vs.pop();
        var isRef = (ref instanceof values_1.Reference);
        if (isRef && ref.IsUnresolvableReference()) {
            vs.push(new values_1.Value('undefined', ref.base.label));
        }
        else {
            var val;
            if (isRef) {
                val = GetValue(ref);
            }
            else {
                val = ref;
            }
            if (val.value === null) {
                vs.push(new values_1.Value('object', val.label));
                return;
            }
            if (typeof val.value === 'object') {
                if ('Call' in val.value) {
                    vs.push(new values_1.Value('function', val.label));
                }
                else {
                    vs.push(new values_1.Value('object', val.label));
                }
            }
            else {
                vs.push(new values_1.Value(typeof val.value, val.label));
            }
        }
    }
    // -------------------------------------------------------------
    // The void Operator, 11.4.2
    function unaryVoid(wl, vs) {
        var ref = vs.pop();
        var _ignore = GetValue(ref);
        vs.push(new values_1.Value(undefined, bot));
    }
    // -------------------------------------------------------------
    // The delete Operator, 11.4.1
    function unaryDelete(wl, vs) {
        var ref = vs.pop();
        if (ref instanceof values_1.Reference) {
            if (ref.IsUnresolvableReference()) {
                vs.push(new values_1.Value(true, ref.base.label));
            }
            else {
                if (ref.IsPropertyReference()) {
                    var object = ToObject_1.ToObject(ref.base);
                    vs.push(object.Delete(ref.propertyName));
                }
                else {
                    vs.push(ref.base.DeleteBinding(ref.propertyName));
                }
            }
        }
        else {
            vs.push(new values_1.Value(true, ref.label));
        }
    }
    // -------------------------------------------------------------
    var unarytbl = {
        '-': unaryMinus,
        '+': unaryPlus,
        '!': unaryLogicalNot,
        '~': unaryBitwiseNot,
        'typeof': unaryTypeof,
        'void': unaryVoid,
        'delete': unaryDelete
    };
    // -------------------------------------------------------------
    // Equality Operators, 11.9
    function binaryEqs(op, wl, vs) {
        var rval = vs.pop();
        var lval = vs.pop();
        var res;
        while (true) {
            var lt = typeof lval.value;
            var rt = typeof rval.value;
            lt = lval.value === undefined ? 'undefined' : lt;
            rt = rval.value === undefined ? 'undefined' : rt;
            lt = lval.value === null ? 'null' : lt;
            rt = rval.value === null ? 'null' : rt;
            // must use strict in order not to trigger conversion
            //   but then null and undefined must be handled separately
            if (lt === rt) {
                res = new values_1.Value(lval.value === rval.value, lub(lval.label, rval.label));
                break;
            }
            if ((lval.value === null && rval.value === undefined) ||
                (lval.value === undefined && rval.value === null)) {
                res = new values_1.Value(true, lub(lval.label, rval.label));
                break;
            }
            if (lt === 'number' && rt === 'string') {
                rval = ToNumber_1.ToNumber(rval);
                continue;
            }
            if (lt === 'string' && rt === 'number') {
                lval = ToNumber_1.ToNumber(lval);
                continue;
            }
            if (lt === 'boolean') {
                lval = ToNumber_1.ToNumber(lval);
                continue;
            }
            if (rt === 'boolean') {
                rval = ToNumber_1.ToNumber(rval);
                continue;
            }
            if ((lt === 'string' || lt === 'number') &&
                rt === 'object') {
                rval = ToPrimitive_1.ToPrimitive(rval);
                continue;
            }
            if (lt === 'object' &&
                (rt === 'string' || rt === 'number')) {
                lval = ToPrimitive_1.ToPrimitive(lval);
                continue;
            }
            res = new values_1.Value(false, lub(lval.label, rval.label));
            break;
        }
        if (op === '!=') {
            res.value = !res.value;
        }
        vs.push(res);
    }
    // -------------------------------------------------------------
    // Strict Equality Operators, 11.9.4, 11.9.5
    function binaryStrictEqs(op, wl, vs) {
        var rval = vs.pop();
        var lval = vs.pop();
        var res = new values_1.Value(lval.value === rval.value, lub(lval.label, rval.label));
        if (op === '!==') {
            res.value = !res.value;
        }
        vs.push(res);
    }
    // -------------------------------------------------------------
    // Relational Operators, 11.8
    //  The evaluation order is important, 11.8.5
    function binaryOrds(op, wl, vs) {
        var rval = vs.pop();
        var lval = vs.pop();
        var lprim = ToPrimitive_1.ToPrimitive(lval);
        var rprim = ToPrimitive_1.ToPrimitive(rval);
        var res;
        if (typeof lprim.value !== 'string' &&
            typeof rprim.value !== 'string') {
            var lnum = ToNumber_1.ToNumber(lprim);
            var rnum = ToNumber_1.ToNumber(rprim);
            var val = eval('lnum.value ' + op + ' rnum.value');
            res = new values_1.Value(val, lub(lnum.label, rnum.label));
        }
        else {
            var val = eval('lprim.value ' + op + ' rprim.value');
            res = new values_1.Value(val, lub(lprim.label, rprim.label));
        }
        vs.push(res);
    }
    // -------------------------------------------------------------
    // Bitwise Shift Operators, 11.7
    function binaryShifts(op, wl, vs) {
        var rval = vs.pop();
        var lval = vs.pop();
        var lnum = (op === '>>>') ? ToUInt32_1.ToUInt32(lval) : ToInt32_1.ToInt32(lval);
        var rnum = ToUInt32_1.ToUInt32(rval);
        var val = eval('lnum.value ' + op + ' rnum.value');
        vs.push(new values_1.Value(val, lub(lnum.label, rnum.label)));
    }
    // -------------------------------------------------------------
    // Binary Bitwise Operators, 11.10
    function binaryBitwiseOps(op, wl, vs) {
        var rval = vs.pop();
        var lval = vs.pop();
        var lnum = ToInt32_1.ToInt32(lval);
        var rnum = ToInt32_1.ToInt32(rval);
        var val = eval('lnum.value ' + op + ' rnum.value');
        vs.push(new values_1.Value(val, lub(lnum.label, rnum.label)));
    }
    // -------------------------------------------------------------
    // Plus, 11.6
    function binaryPlus(wl, vs) {
        var rval = vs.pop();
        var lval = vs.pop();
        var lprim = ToPrimitive_1.ToPrimitive(lval);
        var rprim = ToPrimitive_1.ToPrimitive(rval);
        var res;
        if ((typeof lprim.value) === 'string' ||
            (typeof rprim.value) === 'string') {
            var lstr = ToString_1.ToString(lprim);
            var rstr = ToString_1.ToString(rprim);
            res = new values_1.Value(lstr.value + rstr.value, lub(lprim.label, rprim.label));
        }
        else {
            var lnum = ToNumber_1.ToNumber(lprim);
            var rnum = ToNumber_1.ToNumber(rprim);
            res = new values_1.Value(lnum.value + rnum.value, lub(lnum.label, rnum.label));
        }
        vs.push(res);
    }
    // -------------------------------------------------------------
    // Multiplicative operators, 11.5, and minus, 11.6
    function binaryArithmeticOps(op, wl, vs) {
        var rval = vs.pop();
        var lval = vs.pop();
        var leftNum = ToNumber_1.ToNumber(lval);
        var rightNum = ToNumber_1.ToNumber(rval);
        var val = eval('leftNum.value ' + op + ' rightNum.value');
        vs.push(new values_1.Value(val, lub(leftNum.label, rightNum.label)));
    }
    // -------------------------------------------------------------
    // The in operator, 11.8.7
    function binaryIn(wl, vs) {
        var rval = vs.pop();
        var lval = vs.pop();
        if (typeof rval.value !== 'object') {
            if (false) { // SILENT ERROR
                vs.push(new values_1.Value(false, lub(lval.label, rval.label)));
                return;
            }
            monitor.Throw(error.TypeErrorObject, "invalid 'in' parameter", rval.label);
        }
        vs.push(rval.HasProperty(ToString_1.ToString(lval)));
    }
    // -------------------------------------------------------------
    // The instanceof operator, 11.8.6
    function binaryInstanceof(wl, vs) {
        var rval = vs.pop();
        var lval = vs.pop();
        if (typeof rval.value !== 'object') {
            if (false) { // SILENT ERROR
                vs.push(new values_1.Value(false, lub(lval.label, rval.label)));
            }
            monitor.Throw(error.TypeErrorObject, "invalid 'instanceof' parameter", rval.label);
        }
        if (!('HasInstance' in rval.value)) {
            if (false) { // SILENT ERROR
                vs.push(new values_1.Value(false, lub(lval.label, rval.label)));
            }
            monitor.Throw(error.TypeErrorObject, "invalid 'instanceof' parameter", rval.label);
        }
        vs.push(rval.HasInstance(lval));
    }
    // -------------------------------------------------------------
    var binarytbl = {
        '==': binaryEqs.bind(null, '=='),
        '!=': binaryEqs.bind(null, '!='),
        '===': binaryStrictEqs.bind(null, '==='),
        '!==': binaryStrictEqs.bind(null, '!=='),
        '<': binaryOrds.bind(null, '<'),
        '<=': binaryOrds.bind(null, '<='),
        '>': binaryOrds.bind(null, '>'),
        '>=': binaryOrds.bind(null, '>='),
        '<<': binaryShifts.bind(null, '<<'),
        '>>': binaryShifts.bind(null, '>>'),
        '>>>': binaryShifts.bind(null, '>>>'),
        '+': binaryPlus,
        '-': binaryArithmeticOps.bind(null, '-'),
        '*': binaryArithmeticOps.bind(null, '*'),
        '/': binaryArithmeticOps.bind(null, '/'),
        '%': binaryArithmeticOps.bind(null, '%'),
        '|': binaryBitwiseOps.bind(null, '|'),
        '&': binaryBitwiseOps.bind(null, '&'),
        '^': binaryBitwiseOps.bind(null, '^'),
        'in': binaryIn,
        'instanceof': binaryInstanceof
    };
    // ------------------------------------------------------------- 
    // Prefix, and Postfix Expressions, 11.3, 11.4.4, 11.4.5
    function prefixOps(op, wl, vs) {
        var ref = vs.pop();
        var oldValue = ToNumber_1.ToNumber(GetValue(ref));
        var val = op === '++' ? oldValue.value + 1 : oldValue.value - 1;
        var newValue = new values_1.Value(val, oldValue.label);
        PutValue(ref, newValue);
        vs.push(newValue);
    }
    function postfixOps(op, wl, vs) {
        var ref = vs.pop();
        var oldValue = ToNumber_1.ToNumber(GetValue(ref));
        var val = op === '++' ? oldValue.value + 1 : oldValue.value - 1;
        var newValue = new values_1.Value(val, oldValue.label);
        PutValue(ref, newValue);
        vs.push(oldValue);
    }
    // -------------------------------------------------------------
    var prefixtbl = {
        '++': prefixOps.bind(null, '++'),
        '--': prefixOps.bind(null, '--')
    };
    var postfixtbl = {
        '++': postfixOps.bind(null, '++'),
        '--': postfixOps.bind(null, '--')
    };
    // -------------------------------------------------------------
    // Binary Logical ||, 11.11
    function binaryLogicalOr(wl, vs) {
        var lval = GetValue(vs.pop());
        vs.push(lval);
        var lb = ToBoolean_1.ToBoolean(lval);
        var right = wl.pop();
        if (lb.value) {
            return;
        }
        monitor.context.pushPC(lb.label);
        var ip = wl.top();
        ip.then(right);
        ip.then(binaryLogicalOr_end);
    }
    function binaryLogicalOr_end(wl, vs) {
        var rval = GetValue(vs.pop());
        var lval = vs.pop();
        monitor.context.popPC();
        vs.push(new values_1.Value(rval.value, lub(rval.label, lval.label)));
    }
    // -------------------------------------------------------------
    // Binary Logical &&, 11.11
    function binaryLogicalAnd(wl, vs) {
        var lval = GetValue(vs.pop());
        vs.push(lval);
        var lb = ToBoolean_1.ToBoolean(lval);
        var right = wl.pop();
        if (!lb.value) {
            return;
        }
        monitor.context.pushPC(lb.label);
        var ip = wl.top();
        ip.then(right);
        ip.then(binaryLogicalAnd_end);
    }
    function binaryLogicalAnd_end(wl, vs) {
        var rval = GetValue(vs.pop());
        var lval = vs.pop();
        monitor.context.popPC();
        vs.push(new values_1.Value(rval.value, lub(rval.label, lval.label)));
    }
    // -------------------------------------------------------------
    var logicaltbl = {
        '||': binaryLogicalOr,
        '&&': binaryLogicalAnd
    };
    // -------------------------------------------------------------
    function assignmentOps(op, wl, vs) {
        var rval = GetValue(vs.pop());
        var lref = vs.pop();
        if (op) {
            vs.push(lref);
            vs.push(GetValue(lref));
            vs.push(rval);
            binarytbl[op](wl, vs);
        }
        else {
            vs.push(lref);
            vs.push(rval);
        }
    }
    var assignmenttbl = {
        '=': assignmentOps.bind(null, null),
        '+=': assignmentOps.bind(null, '+'),
        '-=': assignmentOps.bind(null, '-'),
        '*=': assignmentOps.bind(null, '*'),
        '/=': assignmentOps.bind(null, '/'),
        '%=': assignmentOps.bind(null, '%'),
        '>>=': assignmentOps.bind(null, '>>'),
        '<<=': assignmentOps.bind(null, '<<'),
        '>>>=': assignmentOps.bind(null, '>>>'),
        '|=': assignmentOps.bind(null, '|'),
        '&=': assignmentOps.bind(null, '&'),
        '^=': assignmentOps.bind(null, '^')
    };
    // -------------------------------------------------------------
    function _GetValue() {
        var vs = monitor.context.valueStack;
        vs.push(GetValue(vs.pop()));
    }
    function _popPC() {
        monitor.context.popPC();
    }
    _popPC.runfor = runfor_continue_break;
    // -------------------------------------------------------------
    // expression handler functions 
    var expressiontbl = {
        'ThisExpression': thisExpression,
        'ArrayExpression': arrayExpression,
        'ObjectExpression': objectExpression,
        'FunctionExpression': functionExpression,
        'SequenceExpression': sequenceExpression,
        'UnaryExpression': unaryExpression,
        'BinaryExpression': binaryExpression,
        'UpdateExpression': updateExpression,
        'LogicalExpression': logicalExpression,
        'AssignmentExpression': assignmentExpression,
        'ConditionalExpression': conditionalExpression,
        'NewExpression': newExpression,
        'CallExpression': callExpression,
        'MemberExpression': memberExpression,
        'Identifier': identifierExpression,
        'Literal': literalExpression
    };
    // This, 11.1.1 -------------------------------------------- 
    function thisExpression(node, wl, vs) {
        var c = monitor.context;
        vs.push(c.thisValue.clone());
    }
    // Array Initializer, 11.1.4 -------------------------------
    function arrayExpression(node, wl, vs) {
        var ip = wl.top();
        var arr = new values_1.Value(new ArrayObject_1.ArrayObject(), bot);
        var es = node.elements;
        var len = es.length;
        arr.Put(constants.length, new values_1.Value(len, bot));
        vs.push(arr);
        for (var i = 0; i < len; i++) {
            if (es[i]) {
                ip.then(es[i]);
                ip.then(arrayExpressionUpdate, { array: arr, index: i });
            }
        }
    }
    // arrayExpressionUpdate
    function arrayExpressionUpdate(wl, vs) {
        var initValue = GetValue(vs.pop());
        this.array.Put(new values_1.Value(this.index, bot), initValue);
    }
    // Object Initializer, 11.1.5 ------------------------------
    function objectExpression(node, wl, vs) {
        var ip = wl.top();
        var obj = new values_1.Value(new ObjectObject_1.ObjectObject(), bot);
        vs.push(obj);
        var ps = node.properties;
        for (var i = 0, len = ps.length; i < len; i++) {
            ip.then(ps[i].value);
            ip.then(objectExpressionUpdate, { properties: ps, object: obj, index: i });
        }
    }
    // objectExpressionUpdate
    function objectExpressionUpdate(wl, vs) {
        var prop = this.properties[this.index];
        var propName = new values_1.Value(null, bot);
        switch (prop.key.type) {
            case 'Identifier':
                propName.value = prop.key.name;
                break;
            case 'Literal':
                // can only be string or number; conversion will occur once assigned to the object
                propName.value = prop.key.value;
                break;
        }
        var propValue = GetValue(vs.pop());
        var propDesc = { enumerable: true, configurable: true };
        switch (prop.kind) {
            case 'init':
                propDesc.value = propValue.value;
                propDesc.label = propValue.label;
                propDesc.writable = true;
                break;
            case 'get':
                propDesc.get = propValue.value;
                propDesc.label = propValue.label;
                break;
            case 'set':
                propDesc.set = propValue.value;
                propDesc.label = propValue.label;
                break;
        }
        var previous = this.object.GetOwnProperty(propName);
        monitor.context.pushPC(previous.label);
        if (previous.value !== undefined) {
            if ((ecma.IsDataDescriptor(previous) && ecma.IsAccessorDescriptor(propDesc)) ||
                (ecma.IsAccessorDescriptor(previous) && ecma.IsDataDescriptor(propDesc)) ||
                (ecma.IsAccessorDescriptor(previous) && ecma.IsAccessorDescriptor(propDesc) &&
                    ((previous.get && propDesc.get) || (previous.set && propDesc.set)))) {
                monitor.Throw(error.SyntaxErrorObject, 'Object initializer: illegal redefine of property', bot);
            }
        }
        monitor.context.popPC();
        this.object.DefineOwnProperty(propName, propDesc);
    }
    // Function Definition, 13 ----------------------------------------------
    function functionExpression(node, wl, vs) {
        var fun;
        if (node.id) {
            var funcEnv = env.NewDeclarativeEnvironment(monitor.context.lexicalEnv);
            var identifier = new values_1.Value(node.id.name, bot);
            funcEnv.CreateImmutableBinding(identifier);
            fun = new FunctionObject_1.FunctionObject(node.params, node.body, new values_1.Value(funcEnv, bot));
            fun.Name = node.id.name;
            fun.Source = node;
            funcEnv.InitializeImmutableBinding(identifier, new values_1.Value(fun, bot));
        }
        else {
            fun = new FunctionObject_1.FunctionObject(node.params, node.body, monitor.context.lexicalEnv);
            fun.Source = node;
        }
        vs.push(new values_1.Value(fun, bot));
    }
    // Comma Operator, 11.14 ------------------------------------------------
    function sequenceExpression(node, wl, vs) {
        var ip = wl.top();
        var es = node.expressions;
        var len = es.length;
        for (var i = 0; i < len - 1; i++) {
            ip.then(es[i]);
        }
        if (i < len) {
            ip.then(es[i]);
            ip.then(sequenceExpressionEnd, { length: len });
        }
    }
    function sequenceExpressionEnd(wl, vs) {
        var result = vs.pop();
        // Pop all but last and execute GetValue on result for eventual side effects.
        for (var i = 0; i < this.length - 1; i++) {
            GetValue(vs.pop());
        }
        vs.push(result);
    }
    // Unary Operators, 11.4 ------------------------------------------------
    function unaryExpression(node, wl, vs) {
        var ip = wl.top();
        ip.then(node.argument);
        ip.then(unarytbl[node.operator]);
    }
    // Binary Operators, 11.5-11.9 -----------------------------------
    function binaryExpression(node, wl, vs) {
        var ip = wl.top();
        ip.then(node.left);
        ip.then(_GetValue);
        ip.then(node.right);
        ip.then(_GetValue);
        ip.then(binarytbl[node.operator]);
    }
    // Prefix, and Postfix Expressions, 11.3, 11.4.4, 11.4.5 -----------------
    function updateExpression(node, wl, vs) {
        var ip = wl.top();
        ip.then(node.argument);
        if (node.prefix) {
            ip.then(prefixtbl[node.operator]);
        }
        else {
            ip.then(postfixtbl[node.operator]);
        }
    }
    // Binary Operators, 11.5-11.9 -----------------------------------
    function logicalExpression(node, wl, vs) {
        var ip = wl.top();
        ip.then(node.left);
        ip.then(logicaltbl[node.operator]);
        ip.then(node.right);
    }
    // Assignment, 11.13 -----------------------------------------------------
    function assignmentExpression(node, wl, vs) {
        var ip = wl.top();
        ip.then(node.left);
        ip.then(node.right);
        ip.then(assignmenttbl[node.operator]);
        ip.then(assignmentExpressionEnd);
    }
    // assignmentExpressionEnd
    function assignmentExpressionEnd(wl, vs) {
        var rval = vs.pop();
        var lref = vs.pop();
        PutValue(lref, rval);
        vs.push(rval);
    }
    // Conditional Operator, 11.12 ------------------------------------------
    function conditionalExpression(node, wl, vs) {
        var ip = wl.top();
        ip.then(node.test);
        ip.then(conditionalExpressionChoose, { node: node });
    }
    // conditionalExpressionChoose
    function conditionalExpressionChoose(wl, vs) {
        var ip = wl.top();
        var lval = GetValue(vs.pop());
        var lb = ToBoolean_1.ToBoolean(lval);
        var val;
        monitor.context.pushPC(lb.label);
        if (lb.value) {
            ip.then(this.node.consequent);
        }
        else {
            ip.then(this.node.alternate);
        }
        ip.then(conditionalExpressionEnd, { test: lval });
    }
    // conditionalExpressionEnd
    function conditionalExpressionEnd(wl, vs) {
        var val = GetValue(vs.pop());
        monitor.context.popPC();
        vs.push(new values_1.Value(val.value, lub(val.label, this.test.label)));
    }
    // The new Operator, 11.2.2 ---------------------------------------------
    function newExpression(node, wl, vs) {
        var ip = wl.top();
        ip.then(node.callee);
        var as = node.arguments;
        var len = as.length;
        for (var i = 0; i < len; i++) {
            ip.then(as[i]);
        }
        ip.then(newExpressionExecute, { length: len });
    }
    // newExpression
    function newExpressionExecute(wl, vs) {
        var c = monitor.context;
        var ip = wl.top();
        var argList = [];
        for (var i = this.length - 1; i >= 0; i--) {
            argList[i] = GetValue(vs.pop());
        }
        var constructor = GetValue(vs.pop());
        if (typeof constructor.value !== 'object') {
            if (false) { // SILENT ERROR
                v = new values_1.Value(undefined, constructor.label);
                return;
            }
            monitor.Throw(error.TypeErrorObject, "invalid 'new' parameter", constructor.label);
        }
        if (!('Construct' in constructor.value)) {
            if (false) { // SILENT ERROR
                v = new values_1.Value(undefined, constructor.label);
                return;
            }
            monitor.Throw(error.TypeErrorObject, "invalid 'new' parameter", constructor.label);
        }
        if (constructor.value.AsyncConstruct) {
            c.pushPC(constructor.label);
            ip = constructor.value.AsyncConstruct(argList);
            ip.then(callExpressionEnd, { label: constructor.label });
        }
        else {
            try {
                var retval = constructor.Construct(argList);
                retval.raise(constructor.label);
                vs.push(retval);
            }
            catch (e) {
                if (!(e instanceof values_1.Value)) {
                    throw e;
                }
                var result = c.result;
                // Verfiy that the exception is allowed 
                monitor.assert(le(c.effectivePC, c.labels.exc), "exception in " + c.effectivePC + " not allowed with exception label " + c.labels.exc);
                // For observable flows
                c.labels.exc.lub(c.effectivePC);
                result.type = 'throw';
                result.value = e;
            }
        }
    }
    // Function Calls, 11.2.3 -----------------------------------------------
    function callExpression(node, wl, vs) {
        var ip = wl.top();
        var as = node.arguments;
        var len = as.length;
        ip.then(node.callee);
        for (var i = 0; i < len; i++) {
            ip.then(as[i]);
        }
        ip.then(callExpressionExecute, { length: len, node: node });
    }
    // callExpressionExecute
    function callExpressionExecute(wl, vs) {
        var c = monitor.context;
        var ip = wl.top();
        var argList = [];
        for (var i = this.length - 1; i >= 0; i--) {
            argList[i] = GetValue(vs.pop());
        }
        var ref = vs.pop();
        var func = GetValue(ref);
        // used to decide if eval is a direct call in function.enterEvalCode
        c.currentCall = { reference: ref, target: func.value, source: this.node };
        // for eval
        c.call = {};
        c.call.ref = ref;
        c.call.func = func;
        if (!IsCallable_1.IsCallable(func).value) {
            if (false) { // SILENT ERRORS
                v = new values_1.Value(undefined, func.label);
                return;
            }
            monitor.Throw(error.TypeErrorObject, 'Invalid call target; ' + pp.pretty(this.node.callee) + ' evaluates to ' + func.value + ' in ' + pp.pretty(this.node), func.label);
        }
        var thisValue;
        if (ref instanceof values_1.Reference) {
            if (ref.IsPropertyReference()) {
                thisValue = ref.base;
            }
            else {
                thisValue = ref.base.ImplicitThisValue();
            }
        }
        else {
            thisValue = new values_1.Value(undefined, ref.label);
        }
        if (func.value.AsyncCall) {
            monitor.context.pushPC(func.label);
            func.value.AsyncCall(thisValue, argList);
            ip.then(callExpressionEnd, { label: func.label });
        }
        else {
            try {
                var retval = func.Call(thisValue, argList);
                retval.raise(func.label);
                vs.push(retval);
            }
            catch (e) {
                if (!(e instanceof values_1.Value)) {
                    throw e;
                }
                var result = c.result;
                // Verfiy that the exception is allowed 
                monitor.assert(le(c.effectivePC, c.labels.exc), "exception in " + c.effectivePC + " not allowed with exception label " + c.labels.exc);
                // For observable flows
                c.labels.exc.lub(c.effectivePC);
                result.type = 'throw';
                result.value = e;
            }
        }
    }
    // callExpressionEnd 
    function callExpressionEnd(wl, vs) {
        var callResult = vs.pop();
        var c = monitor.context;
        var result = c.result;
        callResult.value.raise(this.label);
        if (callResult.type === 'throw') {
            result.type = 'throw';
            result.value = callResult.value;
            return;
        }
        c.popPC();
        vs.push(callResult.value);
    }
    // Property Accessors, 11.2.1 -------------------------------------------
    function memberExpression(node, wl, vs) {
        var ip = wl.top();
        ip.then(node.object);
        ip.then(_GetValue);
        if (node.computed) {
            ip.then(node.property);
            ip.then(_GetValue);
        }
        ip.then(memberExpressionExecute, { node: node });
    }
    function memberExpressionExecute(wl, vs) {
        var propertyNameValue;
        if (this.node.computed) {
            propertyNameValue = vs.pop();
        }
        else {
            propertyNameValue = new values_1.Value(this.node.property.name, bot);
        }
        var baseValue = vs.pop();
        if (baseValue.value === undefined || baseValue.value === null) {
            monitor.log(pp.pretty(this.node.object) + ' evaluates to ' + String(baseValue.value) + ' in ' + pp.pretty(this.node));
        }
        CheckObjectCoercible_1.CheckObjectCoercible(baseValue);
        vs.push(new values_1.Reference(baseValue, ToString_1.ToString(propertyNameValue)));
    }
    // Identifier, 11.1.2 -> 10.3.1 -----------------------------------------
    function identifierExpression(node, wl, vs) {
        vs.push(env.GetIdentifierReference(monitor.context.lexicalEnv, node.name));
    }
    // Literals, 11.1.3 -> 7.8 ----------------------------------------------
    function literalExpression(node, wl, vs) {
        var res = new values_1.Value(node.value, bot);
        if (node.value instanceof RegExp) {
            res.value = new RegExpObject(node.value, bot);
        }
        vs.push(res);
    }
    // ------------------------------------------------------------
    // statement handler functions
    var statementtbl = {
        'Program': blockStatement,
        'BlockStatement': blockStatement,
        'EmptyStatement': emptyStatement,
        'ExpressionStatement': expressionStatement,
        'IfStatement': ifStatement,
        'SwitchStatement': switchStatement,
        'LabeledStatement': labeledStatement,
        'BreakStatement': breakStatement,
        'ContinueStatement': continueStatement,
        'WithStatement': withStatement,
        'ReturnStatement': returnStatement,
        'ThrowStatement': throwStatement,
        'TryStatement': tryStatement,
        'WhileStatement': whileStatement,
        'DoWhileStatement': doWhileStatement,
        'ForStatement': forStatement,
        'ForInStatement': forInStatement,
        'VariableDeclaration': variableDeclaration,
        'FunctionDeclaration': emptyStatement,
        'DebuggerStatement': debuggerStatement
    };
    var emptyLabel = 'default'; // default is a reserved word so no actual label can be named default 
    // ------------------------------------------------------------
    function blockStatement(node, wl) {
        wl.prepend(node.body);
    }
    // ------------------------------------------------------------
    function emptyStatement() {
    }
    // ------------------------------------------------------------
    function expressionStatement(node, wl) {
        var ip = wl.top();
        ip.then(node.expression);
        ip.then(expressionStatementEnd);
    }
    function expressionStatementEnd() {
        var c = monitor.context;
        var vs = c.valueStack;
        c.result.value = GetValue(vs.pop());
    }
    // ------------------------------------------------------------
    function ifStatement(node, wl) {
        var ip = wl.top();
        ip.then(node.test);
        ip.then(ifStatementChoose, { node: node });
    }
    // ifStatementChoose
    function ifStatementChoose(wl, vs) {
        var ip = wl.top();
        var cond = GetValue(vs.pop());
        cond = ToBoolean_1.ToBoolean(cond);
        monitor.context.pushPC(cond.label);
        if (cond.label > monitor.context.pc && hybrid) {
            hybrid(this.node.consequent);
            hybrid(this.node.alternate);
        }
        if (cond.value) {
            ip.then(this.node.consequent);
        }
        else {
            this.node.alternate && ip.then(this.node.alternate);
        }
        ip.then(ifStatementEnd, { label: cond.label });
    }
    // ifStatementEnd
    function ifStatementEnd(wl, vs) {
        var c = monitor.context;
        c.popPC();
        if (c.result.value) {
            c.result.value.raise(this.label);
        }
    }
    ifStatementEnd.runfor = runfor_continue_break;
    // 12.11 ---------------------------------------------------------------------
    function switchStatement(node, wl) {
        var c = monitor.context;
        var lmap = monitor.context.labels.labelmap;
        if (!node.labelset) {
            node.labelset = new set_1.Set([]);
        }
        node.labelset.add(emptyLabel);
        var outerEmptyLabelData = lmap[emptyLabel];
        lmap[emptyLabel] = { label: c.effectivePC,
            pcmarker: c.pcStack.marker() };
        var contextLabel = lmap[emptyLabel].label;
        c.pushPC(contextLabel);
        var switchState = {
            node: node,
            outerEmptyLabelData: label,
            defaultCaseIndex: null,
            nextCase: 0
        };
        if (node.cases) {
            for (var i = 0; i < node.cases.length; i++) {
                if (node.cases[i].test === null) {
                    switchState.defaultCaseIndex = i;
                    break;
                }
            }
        }
        var ip = wl.top();
        // Store the discriminant value on the value stack.
        // It is later popped by switchStatementEnd.
        ip.then(node.discriminant);
        ip.then(_GetValue);
        // Set up statement labels
        ip.then(switchStatementUpgradeLabels, switchState);
        // Kick off the first case
        ip.then(switchStatementCase, switchState);
        // Clean up and handle breaks
        ip.then(switchStatementEnd, switchState);
    }
    function switchStatementUpgradeLabels(wl, vs) {
        var c = monitor.context;
        var discriminantLabel = vs.peek().label;
        var lblmap = c.labels.labelmap;
        c.labels.pc = lub(c.labels.pc, discriminantLabel);
        this.node.labelset.iter(function (name) {
            lblmap[name].label = lub(lblmap[name].label, discriminantLabel);
        });
    }
    function switchStatementCase(wl, vs) {
        var ip = wl.top();
        var idx = this.nextCase;
        if (this.node.cases === undefined || idx >= this.node.cases.length) {
            // No more cases to try, schedule the default 
            // case if there is one
            if (this.defaultCaseIndex !== null) {
                for (var i = this.defaultCaseIndex; i < this.node.cases.length; i++) {
                    for (var j = 0; j < this.node.cases[i].consequent.length; j++) {
                        ip.then(this.node.cases[i].consequent[j]);
                    }
                }
            }
            return;
        }
        if (idx === this.defaultCaseIndex) {
            // Skip the default case during matching
            this.nextCase += 1;
            ip.then(switchStatementCase, this);
            return;
        }
        vs.dup(); // Duplicate the discriminant value
        // Push the test value
        ip.then(this.node.cases[idx].test);
        ip.then(_GetValue);
        // Test for equality and decide what to do next
        ip.then(switchStatementTest, this);
    }
    function switchStatementTest(wl, vs) {
        var ip = wl.top();
        binaryStrictEqs('===', wl, vs);
        var bresult = vs.pop();
        monitor.context.labels.pc = lub(monitor.context.labels.pc, bresult.label);
        if (bresult.value) {
            // Found a match, schedule all statements from here down
            for (var i = this.nextCase; i < this.node.cases.length; i++) {
                for (var j = 0; j < this.node.cases[i].consequent.length; j++) {
                    ip.then(this.node.cases[i].consequent[j]);
                }
            }
        }
        else {
            this.nextCase += 1;
            ip.then(switchStatementCase, this);
        }
    }
    function switchStatementEnd(wl, vs) {
        var c = monitor.context;
        vs.pop(); // pop the discriminant value
        c.popPC(); // pop the labelContext
        if (c.result.type === 'break' && this.node.labelset.contains(c.result.target)) {
            c.result.type = 'normal';
            c.result.target = null;
            c.labels.labelmap['empty'] = this.outerEmptyLabelData;
        }
    }
    switchStatementEnd.runfor = runfor_break;
    // 12.12 ---------------------------------------------------------------------
    function labeledStatement(node, wl) {
        var ip = wl.top();
        var c = monitor.context;
        var pcmarker = c.pcStack.marker();
        var vsmarker = c.valueStack.marker();
        if (!node.body.labelset) {
            node.body.labelset = new set_1.Set([node.label.name]);
            if (node.labelset) {
                node.body.labelset.union(node.labelset);
            }
        }
        var name = node.label.name;
        var outerlabel = setupStatementLabel(name);
        var labeldata = c.labels.labelmap[name];
        labeldata.pcmarker = c.pcStack.marker();
        c.pushPC(labeldata.label);
        ip.then(node.body);
        ip.then(labeledStatementEnd, { name: name,
            outerlabel: labeldata.label,
            pcmarker: pcmarker,
            vsmarker: vsmarker });
    }
    // labeledStatementEnd
    function labeledStatementEnd(wl, vs) {
        var c = monitor.context;
        var result = c.result;
        // reset the outer label - no need to reset pcmarker since
        // statement labels with the same name cannot be nested
        c.labels.labelmap[this.name].label = this.outerlabel;
        c.pcStack.reset(this.pcmarker);
        c.valueStack.reset(this.vsmarker);
        if (result.type === 'break' && result.target === this.name) {
            result = c.result;
            result.type = 'normal';
            result.target = null;
        }
    }
    labeledStatementEnd.runfor = runfor_continue_break;
    // 12.8 ----------------------------------------------------------------------
    function breakStatement(node, wl) {
        var c = monitor.context;
        var result = monitor.context.result;
        var name = node.label ? node.label.name : emptyLabel;
        var lblcontext = c.labels.labelmap[name].label;
        var displayName = node.label ? '(' + name + ')' : '';
        monitor.assert(le(c.effectivePC, lblcontext), 'write context ' + c.effectivePC + ' not below ' +
            'label context ' + lblcontext + ' ' + displayName);
        // For observable flows
        lblcontext.lub(c.effectivePC);
        result.type = 'break';
        result.target = name;
    }
    // 12.7 ----------------------------------------------------------------------
    function continueStatement(node, wl) {
        var c = monitor.context;
        var result = monitor.context.result;
        var name = node.label ? node.label.name : emptyLabel;
        var lblcontext = c.labels.labelmap[name].label;
        var displayName = node.label ? '(' + name + ')' : '';
        monitor.assert(le(c.effectivePC, lblcontext), 'write context ' + c.effectivePC + ' not below ' +
            'label context ' + lblcontext + displayName);
        // For observable flows
        lblcontext.lub(c.effectivePC);
        result.type = 'continue';
        result.target = name;
    }
    // 12.10 ---------------------------------------------------------------------
    function withStatement(node, wl) {
        var ip = wl.top();
        ip.then(node.object);
        ip.then(withStatementBody, { node: node });
    }
    // withStatementBody
    function withStatementBody(wl, vs) {
        var ip = wl.top();
        var c = monitor.context;
        var val = GetValue(vs.pop());
        var obj = ToObject_1.ToObject(val);
        var oldEnv = c.lexicalEnv;
        var newEnv = env.NewObjectEnvironment(obj, oldEnv);
        newEnv.provideThis();
        c.lexicalEnv = new values_1.Value(newEnv, obj.label);
        ip.then(this.node.body);
        ip.then(withStatementEnd, { lexicalEnv: oldEnv });
    }
    // withStatementEnd
    function withStatementEnd(wl, vs) {
        monitor.context.lexicalEnv = this.lexicalEnv;
    }
    withStatementEnd.runfor = runfor_continue_break;
    //---------------------------------------------------------------------------- 
    function returnStatement(node, wl) {
        var c = monitor.context;
        var ip = wl.top();
        monitor.assert(le(c.effectivePC, c.labels.ret), 'write context ' + c.effectivePC + ' not below ' +
            'return context ' + c.labels.ret);
        // This is for the new mode of operation, for observable flows
        c.labels.ret.lub(c.effectivePC);
        if (node.argument) {
            ip.then(node.argument);
        }
        else {
            c.valueStack.push(new values_1.Value(undefined, bot));
        }
        ip.then(returnStatementEnd);
    }
    // returnStatementEnd
    function returnStatementEnd(wl, vs) {
        var result = monitor.context.result;
        result.type = 'return';
        result.value = GetValue(vs.pop());
        result.target = null;
    }
    //---------------------------------------------------------------------------- 
    function throwStatement(node, wl) {
        var ip = wl.top();
        ip.then(node.argument);
        ip.then(throwStatementEnd);
    }
    // throwStatementEnd
    function throwStatementEnd(wl, vs) {
        var c = monitor.context;
        var result = c.result;
        var exprRef = vs.pop();
        // Verfiy that the exception is allowed 
        monitor.assert(le(c.effectivePC, c.labels.exc), "exception in " + c.effectivePC + " not allowed with exception label " + c.labels.exc);
        // For observable flows
        c.labels.exc.lub(c.effectivePC);
        result.type = 'throw';
        result.value = GetValue(exprRef);
        monitor.offendingTrace = monitor.stackTrace();
    }
    //---------------------------------------------------------------------------- 
    function tryStatement(node, wl) {
        var ip = wl.top();
        var c = monitor.context;
        ip.then(node.block);
        // Expression evaluation might cause exceptions; if so the state of
        // the context might need some cleaning up.
        // The result stack and the worklist are not affected by expression so their
        // states are fine.
        // The ret label cannot be affected by exceptions.
        // The stacks needs to be reset. 
        var pcmarker = c.pcStack.marker();
        var vsmarker = c.valueStack.marker();
        var exc = c.labels.exc;
        // esprima seems to generate a list of handlers --- standard only supports one
        ip.then(tryStatementCatch, { handler: node.handlers[0],
            pcmarker: pcmarker,
            vsmarker: vsmarker,
            exc: exc });
        // The finalizer 
        var lexicalEnv = c.lexicalEnv;
        ip.then(tryStatementFinally, { body: node.finalizer,
            pcmarker: pcmarker,
            vsmarker: vsmarker,
            lexicalEnv: lexicalEnv });
    }
    // tryStatetementCatch
    function tryStatementCatch(wl, vs) {
        var c = monitor.context;
        var result = c.result;
        // We are in charge of resetting the exc label, the finally does the rest 
        // of the cleaning.
        // The pc of the catch block is pc + exc of body
        var handlerPC = lub(c.labels.pc, c.labels.exc);
        // The exc of the catch block is the exc of _catch, that resets the exc
        c.labels.exc = this.exc;
        // if there is no handler or no exception was thrown, there's nothing more to do
        if (!this.handler || result.type !== 'throw') {
            return;
        }
        c.pcStack.reset(this.pcmarker);
        c.valueStack.reset(this.vsmarker);
        c.pcStack.push(handlerPC);
        var catchEnv = env.NewDeclarativeEnvironment(c.lexicalEnv);
        // ECMA-262 allows only idenfifiers, but the parser allows patterns;
        if (this.handler.param.type !== 'Identifier') {
            monitor.fatal('Pattern in catch not supported');
        }
        var identifier = new values_1.Value(this.handler.param.name, bot);
        catchEnv.CreateMutableBinding(identifier);
        catchEnv.SetMutableBinding(identifier, result.value);
        c.lexicalEnv = new values_1.Value(catchEnv, c.effectivePC);
        result.type = 'normal';
        result.value = null;
        wl.push(this.handler.body);
    }
    tryStatementCatch.runfor = runfor_throw;
    // tryStatementFinally
    function tryStatementFinally() {
        var c = monitor.context;
        // The pc of the finally is the pc of the try.
        // The exc of the finally is the exc of the _catch, which is either
        // the exc of theee try, unless it was raised by a handler, in which
        // case it escapes the try, and should affect the finally too.
        // We are in charge of resetting the pcStack, and the lexicalEnv 
        c.pcStack.reset(this.pcmarker);
        c.valueStack.reset(this.vsmarker);
        c.lexicalEnv = this.lexicalEnv;
        // if there is no finally block, we're done
        if (!this.body) {
            return;
        }
        // Allocate a new result --- _finally env choses between the result
        // of the body/handler, and the result of the finally
        var result = c.result;
        c.result = new context_1.Result();
        var ip = c.workList.top();
        ip.then(this.body);
        ip.then(tryStatementFinallyEnd, { result: result });
    }
    tryStatementFinally.runfor = runfor_all;
    // tryStatementFinallyEnd
    function tryStatementFinallyEnd(wl, vs) {
        var c = monitor.context;
        if (c.result.type === 'normal') {
            c.result = this.result;
        }
    }
    tryStatementFinallyEnd.runfor = runfor_all;
    // ------------------------------------------------------------
    function whileStatement(node, wl) {
        var c = monitor.context;
        var ip = wl.top();
        var lmap = c.labels.labelmap;
        if (!node.labelset) {
            node.labelset = new set_1.Set([]);
        }
        node.labelset.add(emptyLabel);
        var outerEmptyLabelData = lmap[emptyLabel];
        lmap[emptyLabel] = { label: c.effectivePC,
            pcmarker: c.pcStack.marker() };
        var contextLabel = lmap[emptyLabel].label;
        c.pushPC(contextLabel);
        ip.then(whileStatementShared, { node: node, outerEmptyLabelData: outerEmptyLabelData });
    }
    // ------------------------------------------------------------
    function doWhileStatement(node, wl) {
        var c = monitor.context;
        var ip = wl.top();
        var lmap = c.labels.labelmap;
        if (!node.labelset) {
            node.labelset = new set_1.Set([]);
        }
        node.labelset.add(emptyLabel);
        var outerEmptyLabelData = lmap[emptyLabel];
        lmap[emptyLabel] = { label: c.effectivePC,
            pcmarker: c.pcStack.marker() };
        // used for both statement label security labels and control security label
        var contextLabel = lmap[emptyLabel].label;
        c.pushPC(contextLabel);
        ip.then(node.body);
        ip.then(whileStatementShared, { node: node, outerEmptyLabelData: outerEmptyLabelData });
    }
    // ------------------------------------------------------------
    function whileStatementShared(wl, vs) {
        var ip = wl.top();
        var c = monitor.context;
        var result = c.result;
        if (result.type === 'break' && this.node.labelset.contains(result.target)) {
            result.type = 'normal';
            result.target = null;
            c.labels.labelmap[emptyLabel] = this.outerEmptyLabelData;
            c.popPC(); // contextLabel
            return;
        }
        if (result.type !== 'continue' || !this.node.labelset.contains(result.target)) {
            if (result.type !== 'normal') {
                return;
            }
        }
        // continue gets us here
        result.type = 'normal';
        result.target = null;
        ip.then(this.node.test);
        ip.then(whileStatementSharedChoose, this);
    }
    whileStatementShared.runfor = runfor_continue_break;
    // whileStatementSharedChoose
    function whileStatementSharedChoose(wl, vs) {
        var c = monitor.context;
        var cond = GetValue(vs.pop());
        var condb = ToBoolean_1.ToBoolean(cond);
        c.labels.pc = lub(c.labels.pc, condb.label);
        if (condb.value) {
            var ip = wl.top();
            ip.then(this.node.body);
            ip.then(whileStatementShared, this);
        }
        else {
            c.labels.labelmap[emptyLabel] = this.outerEmptyLabelData;
            c.popPC(); // contextLabel
        }
    }
    whileStatementSharedChoose.runfor = runfor_continue;
    // ------------------------------------------------------------
    function forStatement(node, wl) {
        var c = monitor.context;
        var ip = wl.top();
        var lmap = c.labels.labelmap;
        if (node.init) {
            ip.then(node.init);
        }
        if (!node.labelset) {
            node.labelset = new set_1.Set([]);
        }
        node.labelset.add(emptyLabel);
        var outerEmptyLabelData = lmap[emptyLabel];
        lmap[emptyLabel] = { label: c.effectivePC,
            pcmarker: c.pcStack.marker() };
        var contextLabel = lmap[emptyLabel].label;
        c.pushPC(contextLabel);
        ip.then(forStatementMain, { node: node });
        ip.then(forStatementEnd, { outerEmptyLabelData: outerEmptyLabelData });
    }
    // forStatementMain
    function forStatementMain(wl, vs) {
        var c = monitor.context;
        var ip = wl.top();
        var result = c.result;
        if (result.type === 'break' && this.node.labelset.contains(result.target)) {
            result.type = 'normal';
            result.target = null;
            return;
        }
        if (result.type !== 'continue' || !this.node.labelset.contains(result.target)) {
            if (result.type !== 'normal') {
                return;
            }
        }
        result.type = 'normal';
        result.target = null;
        if (this.node.test) {
            ip.then(this.node.test);
            ip.then(forStatementChoose, this);
        }
        else {
            ip.then(forStatementExecute, this);
        }
    }
    forStatementMain.runfor = runfor_continue_break;
    // forStatementChoose
    function forStatementChoose(wl, vs) {
        var ip = wl.top();
        var c = monitor.context;
        var result = c.result;
        var cond = GetValue(vs.pop());
        var condb = ToBoolean_1.ToBoolean(cond);
        c.labels.pc = lub(c.labels.pc, condb.label);
        if (!condb.value) {
            result.type = 'normal';
            result.target = null;
            return;
        }
        ip.then(forStatementExecute, this);
    }
    forStatementChoose.runfor = runfor_continue;
    function forStatementExecute(wl, vs) {
        var ip = wl.top();
        ip.then(this.node.body);
        ip.then(forStatementUpdate, this);
        ip.then(forStatementMain, this);
    }
    function forStatementUpdate(wl, vs) {
        var ip = wl.top();
        var c = monitor.context;
        var result = c.result;
        if (result.type !== 'continue' || !this.node.labelset.contains(result.target)) {
            if (result.type !== 'normal') {
                return;
            }
        }
        result.type = 'normal';
        result.target = null;
        if (this.node.update) {
            ip.then(this.node.update);
            ip.then(_GetValue);
        }
    }
    forStatementUpdate.runfor = runfor_continue;
    // forStatementeEnd
    function forStatementEnd(wl, vs) {
        var c = monitor.context;
        c.labels.labelmap[emptyLabel] = this.outerEmptyLabelData;
        c.popPC();
    }
    // ------------------------------------------------------------
    function forInStatement(node, wl) {
        var ip = wl.top();
        var left;
        if (node.left.type === 'VariableDeclaration') {
            ip.then(node.left);
            // the standard only allows for one declaration, get the name
            left = node.left.declarations[0].id;
        }
        else {
            left = node.left;
        }
        ip.then(node.right);
        ip.then(forInStatementSetup, { node: node, left: left });
    }
    function forInStatementSetup(wl, vs) {
        var c = monitor.context;
        var ip = wl.top();
        var lmap = c.labels.labelmap;
        var node = this.node;
        if (!node.labelset) {
            node.labelset = new set_1.Set([]);
        }
        node.labelset.add(emptyLabel);
        var outerEmptyLabelData = lmap[emptyLabel];
        lmap[emptyLabel] = { label: c.effectivePC,
            pcmarker: c.pcStack.marker() };
        var contextLabel = lmap[emptyLabel].label;
        c.pushPC(contextLabel);
        var obj = ToObject_1.ToObject(GetValue(vs.pop()));
        var properties = obj.value.getEnumerablePropertyNames(obj.label).reverse();
        // monitor.context.pushPC(obj.label);
        ip.then(forInExecute, { node: this.node,
            left: this.left,
            properties: properties,
            outerEmptyLabelData: outerEmptyLabelData });
    }
    function forInExecute(wl, vs) {
        var ip = wl.top();
        var c = monitor.context;
        var result = c.result;
        if (result.type === 'break' && this.node.labelset.contains(result.target)) {
            result.type = 'normal';
            result.target = null;
            c.labels.labelmap[emptyLabel] = this.outerEmptyLabelData;
            c.popPC(); // contextLabel
            return;
        }
        if (result.type !== 'continue' || !this.node.labelset.contains(result.target)) {
            if (result.type !== 'normal') {
                return;
            }
        }
        // continue gets us here
        result.type = 'normal';
        result.target = null;
        var found = false;
        var propName;
        var P;
        if (this.properties.length === 0) {
            c.labels.labelmap[emptyLabel] = this.outerEmptyLabelMap;
            c.popPC(); // contextLabel
            return;
        }
        propName = this.properties.pop();
        vs.push(propName);
        ip.then(this.left);
        ip.then(forInUpdate, this);
    }
    forInExecute.runfor = runfor_continue_break;
    function forInUpdate(wl, vs) {
        var ip = wl.top();
        var lhs = vs.pop();
        var propName = vs.pop();
        PutValue(lhs, propName);
        monitor.context.pushPC(propName.label);
        ip.then(this.node.body);
        ip.then(forInSecurityContextEnd);
        ip.then(forInExecute, this);
    }
    function forInSecurityContextEnd(wl, vs) {
        monitor.context.popPC();
    }
    // ------------------------------------------------------------
    function variableDeclaration(node, wl) {
        var ip = wl.top();
        for (var i = 0, len = node.declarations.length; i < len; i++) {
            var vd = node.declarations[i];
            if (vd.init) {
                if (vd.id.type !== 'Identifier') {
                    monitor.fatal(vd.id.type + ' not supported in variable declarations');
                }
                var lhs = env.GetIdentifierReference(monitor.context.lexicalEnv, vd.id.name);
                ip.then(vd.init);
                ip.then(variableDeclarationUpdate, { lhs: lhs });
            }
        }
    }
    // variableUpdate
    function variableDeclarationUpdate(wl, vs) {
        var rhs = GetValue(vs.pop());
        PutValue(this.lhs, rhs);
    }
    // ------------------------------------------------------------
    function debuggerStatement(node, wl) {
        monitor.debug.active = true;
    }
    // https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API
    // -------------------------------------------------------------
    function step() {
        var c = monitor.context;
        var wl = c.workList;
        var vs = c.valueStack;
        var result = c.result;
        if (wl.empty()) {
            return false;
        }
        var task = wl.pop();
        try {
            // throw, continue, or break state
            if (result.type !== 'normal') {
                while (true) {
                    if (task.runfor && result.type in task.runfor) {
                        task(wl, vs);
                        return true;
                    }
                    if (task.func && task.func.runfor && result.type in task.func.runfor) {
                        task.func.call(task.data, wl, vs);
                        return true;
                    }
                    if (wl.empty()) {
                        break;
                    }
                    task = wl.pop();
                }
                return false;
            }
            // function?
            if (typeof task === 'function') {
                task(wl, vs);
                return true;
            }
            // closure?
            if ('func' in task && 'data' in task) {
                task.func.call(task.data, wl, vs);
                return true;
            }
            // otherwise, syntax
            var node = task;
            // for stackTrace
            c.currentStatement = node;
            // expressions
            if (node.type in expressiontbl) {
                expressiontbl[node.type](node, wl, vs);
                return true;
            }
            // statement 
            if (node.type in statementtbl) {
                statementtbl[node.type](node, wl);
                return true;
            }
            monitor.fatal(node.type + ' not implemented');
        }
        catch (e) {
            if (e instanceof values_1.Value) {
                // Verfiy that the exception is allowed 
                monitor.assert(le(c.effectivePC, c.labels.exc), "exception in " + c.effectivePC + " not allowed with exception label " + c.labels.exc);
                // For observable flows
                c.labels.exc.lub(c.effectivePC);
                result.type = 'throw';
                result.value = e;
                return true;
            }
            throw e;
        }
        return true;
    }
    // ----------------------------------------------------------------------------- 
    // Initializes the statement label security label.
    function setupStatementLabel(name) {
        var c = monitor.context;
        var lmap = c.labels.labelmap;
        if (!lmap[name]) {
            lmap[name] = { label: bot, pcmarker: undefined };
        }
        var labeldata = lmap[name];
        var outerlabel = labeldata.label;
        // raise to effective pc
        labeldata.label = lub(labeldata.label, c.effectivePC);
        return outerlabel;
    }
    // ------------------------------------------------------------
    var module = {};
    module.initialize = initialize;
    module.execute = execute;
    module.executeGlobalCode = executeGlobalCode;
    module.resume = resume;
    module.running = running;
    return module;
};

},{"./Conversion/ToBoolean":28,"./Conversion/ToInt32":29,"./Conversion/ToNumber":31,"./Conversion/ToObject":32,"./Conversion/ToPrimitive":33,"./Conversion/ToString":34,"./Conversion/ToUInt32":36,"./Objects/ArrayObject":38,"./Objects/FunctionObject":40,"./Objects/ObjectObject":42,"./Utility/CheckObjectCoercible":48,"./Utility/IsCallable":49,"./constants":50,"./context":51,"./ecma":53,"./env":54,"./function":57,"./label":60,"./pp":64,"./set":67,"./values":75,"esprima":19}],57:[function(require,module,exports){
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var label_1 = require("./label");
var values_1 = require("./values");
var ecma_1 = require("./ecma");
var env = require("./env");
var constants = require("./constants");
var esprima = require("esprima");
var estraverse = require("estraverse");
var FunctionObject_1 = require("./Objects/FunctionObject");
var ToObject_1 = require("./Conversion/ToObject");
// ------------------------------------------------------------
var NewBiFO = /** @class */ (function (_super) {
    __extends(NewBiFO, _super);
    function NewBiFO(self, f, n, host) {
        var _this_1 = _super.call(this) || this;
        _this_1.host = host;
        _this_1.actualFunction = f;
        _this_1.self = self;
        _this_1.Class = 'Function';
        _this_1.Prototype = new values_1.Value(monitor.instances.FunctionPrototype, label_1.bot);
        _this_1.Extensible = true;
        ecma_1.DefineFFF(_this_1, constants.length, n);
        return _this_1;
    }
    NewBiFO.prototype.Call = function (thisArg, args) {
        try {
            return this.actualFunction.call(this.self, thisArg, args);
        }
        catch (e) {
            monitor.tryRethrow(e, true);
            monitor.fatal('unable to lift', e);
        }
    };
    NewBiFO.prototype.Construct = function () {
        monitor.Throw(monitor.modules.error.TypeErrorObject, 'cannot be used as a constructor', label_1.bot);
    };
    NewBiFO.prototype.toString = function () {
        if (this.host) {
            return this.host.toString();
        }
        else {
            return 'NO HOST GIVEN! : ' + this.nativeFunction;
        }
    };
    return NewBiFO;
}(ecma_1.Ecma));
exports.NewBiFO = NewBiFO;
// ---
// proto allows FunctionPrototype to use BiFO before monitor.instances.FunctionPrototype is set
var BuiltinFunctionObject = /** @class */ (function (_super) {
    __extends(BuiltinFunctionObject, _super);
    function BuiltinFunctionObject(f, n, host) {
        var _this_1 = _super.call(this) || this;
        _this_1.host = host;
        _this_1.actualFunction = f;
        _this_1.Class = 'Function';
        _this_1.Prototype = new values_1.Value(monitor.instances.FunctionPrototype, label_1.bot);
        _this_1.Extensible = true;
        var _this = _this_1;
        _this_1.Call =
            function (thisArg, args) {
                try {
                    return f.call(_this, thisArg, args);
                }
                catch (e) {
                    monitor.tryRethrow(e, true);
                    monitor.fatal('unable to lift', e);
                }
            };
        _this_1.nativeFunction = f;
        ecma_1.DefineFFF(_this_1, constants.length, n);
        return _this_1;
    }
    BuiltinFunctionObject.prototype.Construct = function () {
        monitor.Throw(monitor.modules.error.TypeErrorObject, 'cannot be used as a constructor', label_1.bot);
    };
    BuiltinFunctionObject.prototype.toString = function () {
        if (this.host) {
            return this.host.toString();
        }
        else {
            return 'NO HOST GIVEN! : ' + this.nativeFunction;
        }
    };
    return BuiltinFunctionObject;
}(ecma_1.Ecma));
exports.BuiltinFunctionObject = BuiltinFunctionObject;
// ------------------------------------------------------------
// 10.4.3
function enterFunctionCode(F, thisArg, args) {
    var c = monitor.context;
    if (thisArg.value == null) {
        thisArg = new values_1.Value(monitor.instances.globalObject, thisArg.label);
    }
    else if (typeof thisArg.value !== 'object') {
        thisArg = ToObject_1.ToObject(thisArg);
    }
    var localEnv = new values_1.Value(env.NewDeclarativeEnvironment(F.Scope), c.effectivePC);
    var newContext = c.clone(thisArg, localEnv, localEnv);
    newContext.labels.ret = label_1.lub(newContext.labels.ret, newContext.labels.pc);
    DeclarationBindingInstantiation(newContext, F, args);
    return newContext;
}
exports.enterFunctionCode = enterFunctionCode;
function enterEvalCode(code, _eval) {
    var c = monitor.context;
    // 15.1.2.1.1, is direct call
    var isDirect;
    isDirect = c.currentCall.reference.base.value instanceof env.ObjectEnvironmentRecord ||
        c.currentCall.reference.base.value instanceof env.DeclarativeEnvironmentRecord;
    isDirect = isDirect && c.currentCall.reference.propertyName.value === 'eval';
    isDirect = isDirect && c.currentCall.target.actualFunction === _eval;
    var context = c.clone();
    // 10.4.2 - no calling context or not direct call
    if (!isDirect) {
        var global = monitor.instances.globalObject;
        var globalEnv = monitor.instances.globalEnvironment;
        context.thisValue = new values_1.Value(global, label_1.bot);
        context.lexicalEnv = new values_1.Value(globalEnv, label_1.bot);
        context.variableEnv = new values_1.Value(globalEnv, label_1.bot);
    }
    DeclarationBindingInstantiation(context, code);
    // for stack trace 
    context.owner = 'eval';
    return context;
}
exports.enterEvalCode = enterEvalCode;
// ------------------------------------------------------------
// 10.5 - strict ignored
function DeclarationBindingInstantiation(context, F, args) {
    var isFunctionCode, isEvalCode, code;
    if (F instanceof FunctionObject_1.FunctionObject) {
        isFunctionCode = true;
        isEvalCode = false;
        code = F.Code;
    }
    else {
        isFunctionCode = false;
        isEvalCode = true;
        code = F;
    }
    var env = context.variableEnv;
    var configurableBindings = isEvalCode;
    if (isFunctionCode) {
        BindArguments(env, F.FormalParameters, args);
    }
    var pc = context.effectivePC;
    HoistFunctions(env, code, configurableBindings, pc);
    var argumentsAlreadyDeclared = env.HasBinding(constants['arguments']);
    if (isFunctionCode && !argumentsAlreadyDeclared.value) {
        // make sure it returns a Value
        var argsObj = CreateArgumentsObject(env, F, args);
        F.DefineOwnProperty(constants['arguments'], argsObj, false);
        env.CreateMutableBinding(constants['arguments']);
        env.SetMutableBinding(constants['arguments'], argsObj, false);
    }
    HoistVariables(env, code, configurableBindings, pc);
}
exports.DeclarationBindingInstantiation = DeclarationBindingInstantiation;
// ------------------------------------------------------------
// Function hoisting, part of 10.5
function HoistFunctions(env, script, configurableBinding, pc) {
    if (!script.functionDeclarations) {
        // 
        script.functionDeclarations = [];
        var visitor = {};
        visitor.leave = function () { };
        visitor.enter = function (node) {
            if (node.type === 'FunctionDeclaration') {
                script.functionDeclarations.push(node);
            }
            // Do not hoist inside functions
            if (node.type === 'FunctionDeclaration' ||
                node.type === 'FunctionExpression') {
                this.skip();
            }
        };
        estraverse.traverse(script, visitor);
    }
    var ds = script.functionDeclarations;
    var i;
    var len = ds.length;
    for (i = 0; i < len; i++) {
        var fn = new values_1.Value(ds[i].id.name, label_1.bot);
        var fo = new FunctionObject_1.FunctionObject(ds[i].params, ds[i].body, env);
        fo.Name = ds[i].id.name;
        fo.Source = ds[i];
        var funcAlreadyDeclared = env.HasBinding(fn);
        if (!funcAlreadyDeclared.value) {
            env.CreateMutableBinding(fn, configurableBinding);
        }
        env.SetMutableBinding(fn, new values_1.Value(fo, pc));
    }
}
exports.HoistFunctions = HoistFunctions;
// ------------------------------------------------------------
// Variable hoisting, part of 10.5
function HoistVariables(env, script, configurableBindings, pc) {
    if (!script.variableDeclarations) {
        script.variableDeclarations = [];
        var visitor = {};
        visitor.leave = function () { };
        visitor.enter = function (node) {
            // Do not hoist inside functions
            if (node.type === 'FunctionDeclaration' ||
                node.type === 'FunctionExpression') {
                this.skip();
            }
            if (node.type === 'VariableDeclaration') {
                for (var i = 0, len = node.declarations.length; i < len; i++) {
                    var declarator = node.declarations[i];
                    var pattern = declarator.id;
                    script.variableDeclarations.push(pattern);
                }
            }
        };
        estraverse.traverse(script, visitor);
    }
    var ds = script.variableDeclarations;
    var i;
    var len = ds.length;
    for (i = 0; i < len; i++) {
        if (ds[i].type !== 'Identifier') {
            monitor.fatal('Patters is variable declarations not supported');
        }
        // declarations are indentifiers, not general patterns
        var dn = new values_1.Value(ds[i].name, label_1.bot);
        var varAlreadyDeclared = env.HasBinding(dn);
        if (!varAlreadyDeclared.value) {
            env.CreateMutableBinding(dn, configurableBindings);
            env.SetMutableBinding(dn, new values_1.Value(undefined, pc));
        }
    }
}
exports.HoistVariables = HoistVariables;
// ------------------------------------------------------------
// Create Arguments Object, 10.6
function CreateArgumentsObject(env, F, args) {
    return new values_1.Value(new ArgumentsObject(F, args), label_1.bot);
    /*
    var obj = new Ecma();
    obj.Class = 'Arguments';
  
    obj.Prototype = new Value(monitor.instances.ObjectPrototype,bot);
  
    args = args || [];
  
    for (var i = 0, len = args.length; i < len; i++) {
      obj.Put(new Value(i, bot), args[i]);
    }
  
  
    var argNames = F.FormalParameters;
  
    for (var i = 0, len = argNames.length; i < len; i++) {
      var id = argNames[i];
  
      if (id.type !== 'Identifier') {
        monitor.fatal(id.type + ' is not supported in CreateArgumentsObject');
      }
  
      if (args[i]) {
        obj.Put(new Value(id.name, bot), args[i]);
      }
    }
  
    obj.Put(new Value('length', bot), new Value(args.length, bot));
    obj.Put(new Value('callee', bot), new Value(F, bot));
  
    return new Value(obj, bot);
    */
}
exports.CreateArgumentsObject = CreateArgumentsObject;
// ------------------------------------------------------------
// Bind Arguments, 
function BindArguments(env, names, args) {
    if (args == undefined)
        return;
    var argCount = args.length;
    var nameCount = names.length;
    monitor.context.pushPC(label_1.bot);
    for (var n = 0; n < nameCount; n++) {
        var v;
        if (n >= argCount)
            v = new values_1.Value(undefined, label_1.bot);
        else
            v = args[n];
        var id = names[n];
        if (id.type !== 'Identifier') {
            monitor.fatal(id.type + ' is not supported in BindArguments');
        }
        var argName = new values_1.Value(id.name, label_1.bot);
        var argAlreadyDeclared = env.HasBinding(argName);
        monitor.context.raisePC(argAlreadyDeclared.label);
        if (!argAlreadyDeclared.value) {
            env.CreateMutableBinding(argName);
        }
        env.SetMutableBinding(argName, v);
    }
    monitor.context.popPC();
}
exports.BindArguments = BindArguments;
// ------------------------------------------------------------
var ArgumentsObject = /** @class */ (function (_super) {
    __extends(ArgumentsObject, _super);
    function ArgumentsObject(F, args) {
        var _this_1 = _super.call(this) || this;
        _this_1.Prototype = new values_1.Value(monitor.instances.ObjectPrototype, label_1.bot);
        _this_1.Class = 'Arguments';
        _this_1.Extensible = true;
        var formalParams = F.FormalParameters;
        var args = args || [];
        for (var i = 0; i < args.length; i++) {
            _this_1.Put(new values_1.Value(i, label_1.bot), args[i]);
        }
        for (var i = 0; i < formalParams.length; i++) {
            var id = formalParams[i];
            if (id.type !== 'Identifier') {
                monitor.fatal(id.type + ' is not supported in ArgumentsObject');
            }
            if (args[i]) {
                _this_1.Put(new values_1.Value(id.name, label_1.bot), args[i]);
            }
        }
        _this_1.Put(new values_1.Value('length', label_1.bot), new values_1.Value(args.length, label_1.bot));
        _this_1.Put(new values_1.Value('callee', label_1.bot), new values_1.Value(F, label_1.bot));
        return _this_1;
    }
    return ArgumentsObject;
}(ecma_1.Ecma));
exports.ArgumentsObject = ArgumentsObject;
// ---
// 13.2.3
var ThrowTypeError = /** @class */ (function (_super) {
    __extends(ThrowTypeError, _super);
    function ThrowTypeError() {
        var _this_1 = _super.call(this, [], esprima.parse("(function() { throw new TypeError(); })").body[0].expression, new values_1.Value(monitor.instances.globalEnvironment, label_1.bot)) || this;
        ecma_1.DefineFFF(_this_1, constants.length, 0);
        _this_1.Extensible = false;
        return _this_1;
    }
    return ThrowTypeError;
}(FunctionObject_1.FunctionObject));
exports.ThrowTypeError = ThrowTypeError;

},{"./Conversion/ToObject":32,"./Objects/FunctionObject":40,"./constants":50,"./ecma":53,"./env":54,"./label":60,"./values":75,"esprima":19,"estraverse":20}],58:[function(require,module,exports){
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var label = require("./label");
var values_1 = require("./values");
var ecma = require("./ecma");
var constants = require("./constants");
var esprima = require("esprima");
var function_1 = require("./function");
var ToNumber_1 = require("./Conversion/ToNumber");
var ToString_1 = require("./Conversion/ToString");
exports.functor = function (monitor) {
    var error = monitor.require('error');
    var Label = label.Label;
    var lub = label.lub;
    var le = label.le;
    var bot = Label.bot;
    // ------------------------------------------------------------
    function allocate(host) {
        var go = new GlobalObject(host);
        return { globalObject: go };
    }
    // ------------------------------------------------------------
    var GlobalObject = /** @class */ (function (_super) {
        __extends(GlobalObject, _super);
        function GlobalObject(host) {
            var _this = _super.call(this) || this;
            _this.Class = 'global';
            _this.JSFClass = 'GlobalObject';
            if (_this.Prototype === undefined || _this.Prototype.value === null) {
                _this.Prototype = new values_1.Value(monitor.instances.ObjectPrototype, bot);
            }
            _this.host = host;
            // 15.1.1
            ecma.DefineFFF(_this, constants.NaN, NaN);
            ecma.DefineFFF(_this, constants['Infinity'], Infinity);
            ecma.DefineFFF(_this, constants['undefined'], undefined);
            // 15.1.2
            ecma.DefineTFT(_this, constants['eval'], new function_1.BuiltinFunctionObject(__eval, 1, host.eval));
            ecma.DefineTFT(_this, constants.parseInt, new function_1.BuiltinFunctionObject(__parseInt, 2, host.parseInt));
            ecma.DefineTFT(_this, constants.parseFloat, new function_1.BuiltinFunctionObject(__parseFloat, 1, host.parseFloat));
            ecma.DefineTFT(_this, constants.isNaN, new function_1.BuiltinFunctionObject(__isNaN, 1, host.isNaN));
            ecma.DefineTFT(_this, constants.isFinite, new function_1.BuiltinFunctionObject(__isFinite, 1, host.isFinite));
            // 15.1.3
            ecma.DefineTFT(_this, constants.decodeURI, new function_1.BuiltinFunctionObject(__decodeURI, 1, host.decodeURI));
            ecma.DefineTFT(_this, constants.decodeURIComponent, new function_1.BuiltinFunctionObject(__decodeURIComponent, 1, host.decodeURIComponent));
            ecma.DefineTFT(_this, constants.encodeURI, new function_1.BuiltinFunctionObject(__encodeURI, 1, host.encodeURI));
            ecma.DefineTFT(_this, constants.encodeURIComponent, new function_1.BuiltinFunctionObject(__encodeURIComponent, 1, host.encodeURIComponent));
            // 15.1.4
            ecma.DefineTFT(_this, constants.Object, monitor.instances.ObjectConstructor);
            ecma.DefineTFT(_this, constants.Function, monitor.instances.FunctionConstructor);
            ecma.DefineTFT(_this, constants.Array, monitor.instances.ArrayConstructor);
            ecma.DefineTFT(_this, constants.String, monitor.instances.StringConstructor);
            ecma.DefineTFT(_this, constants.Boolean, monitor.instances.BooleanConstructor);
            ecma.DefineTFT(_this, constants.Number, monitor.instances.NumberConstructor);
            ecma.DefineTFT(_this, constants.Date, monitor.instances.DateConstructor);
            ecma.DefineTFT(_this, constants.RegExp, monitor.instances.RegExpConstructor);
            ecma.DefineTFT(_this, constants.Error, monitor.instances.ErrorConstructor);
            ecma.DefineTFT(_this, constants.EvalError, monitor.instances.EvalErrorConstructor);
            ecma.DefineTFT(_this, constants.RangeError, monitor.instances.RangeErrorConstructor);
            ecma.DefineTFT(_this, constants.ReferenceError, monitor.instances.ReferenceErrorConstructor);
            ecma.DefineTFT(_this, constants.SyntaxError, monitor.instances.SyntaxErrorConstructor);
            ecma.DefineTFT(_this, constants.TypeError, monitor.instances.TypeErrorConstructor);
            ecma.DefineTFT(_this, constants.URIError, monitor.instances.URIErrorConstructor);
            ecma.DefineTFT(_this, constants.Math, monitor.instances.MathObject);
            ecma.DefineTFT(_this, constants.JSON, monitor.instances.JSONObject);
            ecma.DefineTFT(_this, new values_1.Value('write', bot), new function_1.BuiltinFunctionObject(__print, 0, 'write'));
            ecma.DefineTFT(_this, new values_1.Value('print', bot), new function_1.BuiltinFunctionObject(__lprint, 0, 'print'));
            if (monitor.instances.LabelConstructor) {
                ecma.DefineTFT(_this, new values_1.Value('Label', bot), monitor.instances.LabelConstructor);
            }
            if (monitor.instances.ValueConstructor) {
                ecma.DefineTFT(_this, new values_1.Value('Value', bot), monitor.instances.ValueConstructor);
            }
            ecma.DefineFFF(_this, new values_1.Value('upg', bot), new function_1.BuiltinFunctionObject(__dupg, 1, undefined));
            ecma.DefineFFF(_this, new values_1.Value('upgs', bot), new function_1.BuiltinFunctionObject(__dupgs, 1, undefined));
            ecma.DefineFFF(_this, new values_1.Value('upge', bot), new function_1.BuiltinFunctionObject(__dupge, 1, undefined));
            ecma.DefineFFF(_this, new values_1.Value('lbl', bot), new function_1.BuiltinFunctionObject(__upg, 1, undefined));
            ecma.DefineFFF(_this, new values_1.Value('lbls', bot), new function_1.BuiltinFunctionObject(__upgs, 1, undefined));
            ecma.DefineFFF(_this, new values_1.Value('lble', bot), new function_1.BuiltinFunctionObject(__upge, 1, undefined));
            ecma.DefineFFF(_this, new values_1.Value('upgl', bot), new function_1.BuiltinFunctionObject(__upgl, 1, undefined));
            /*
            ecma.DefineTFT(this, new Value('Label',bot) ,__Label);
        
            ecma.DefineFFF(this , new Value('declassify'    , bot) , new BuiltinFunctionObject(__declassify    , 1, undefined));
        
            ecma.DefineFFF(this , new Value('upgs'   , bot) , new BuiltinFunctionObject(__upgs   , 1, undefined));
            ecma.DefineFFF(this , new Value('dupgs'  , bot) , new BuiltinFunctionObject(__dupgs  , 1, undefined));
            ecma.DefineFFF(this , new Value('getPC'  , bot) , new BuiltinFunctionObject(__getPC  , 0, undefined));
            ecma.DefineFFF(this , new Value('setPC'  , bot) , new BuiltinFunctionObject(__setPC  , 1, undefined));
            ecma.DefineFFF(this , new Value('getEXC' , bot) , new BuiltinFunctionObject(__getEXC , 0, undefined));
            ecma.DefineFFF(this , new Value('setEXC' , bot) , new BuiltinFunctionObject(__setEXC , 1, undefined));
            ecma.DefineFFF(this , new Value('getRET' , bot) , new BuiltinFunctionObject(__getRET , 0, undefined));
            ecma.DefineFFF(this , new Value('setRET' , bot) , new BuiltinFunctionObject(__setRET , 1, undefined));
            */
            ecma.DefineTFT(_this, new values_1.Value('unescape', bot), new function_1.BuiltinFunctionObject(__unescape, 1, host.unescape));
            return _this;
        }
        return GlobalObject;
    }(ecma.Ecma));
    /*
    GlobalObject.extensions = [];
    GlobalObject.addExtension = function(ext) {
      GlobalObject.extensions.push(ext);
    };
    */
    GlobalObject.prototype.toString = function () { return '[global object]'; };
    // ------------------------------------------------------------
    // unescape, B2.2
    var __unescape = function (thisArg, args) {
        var str = args[0] ? args[0] : new values_1.Value(undefined, bot);
        str = ToString_1.ToString(str);
        return new values_1.Value(unescape(str.value), str.label);
    };
    // ------------------------------------------------------------
    // 15.1.2.1
    var __eval = function (thisArg, args) {
        var arg0 = args[0];
        if (arg0 === undefined)
            return new values_1.Value(undefined, bot);
        if (typeof arg0.value !== 'string')
            return arg0;
        var prog;
        // raise the pc w.r.t. the program string; parsing may result in an exception
        monitor.context.pushPC(arg0.label);
        try {
            prog = esprima.parse(arg0.value, { loc: true, source: 'eval' });
        }
        catch (e) {
            var msg = e.description + ' in eval:' + e.lineNumber + ':' + e.column;
            monitor.Throw(error.SyntaxErrorObject, msg, arg0.label);
        }
        var evalCtx = function_1.enterEvalCode(prog, __eval);
        monitor.contextStack.push(evalCtx);
        // this is not a value, it is a result!!
        var result = monitor.modules.exec.execute(prog, false);
        // if value is 'empty' (represented by null)
        if (!result.value) {
            result.value = new values_1.Value(undefined, bot);
        }
        result.value.raise(arg0.label);
        // NOTE: parser should guarantee the result type is never return
        if (result.type === 'throw') {
            throw result.value;
        }
        // pop after throw, otherwise internal context thrown away before handler (catch)
        monitor.contextStack.pop();
        monitor.context.popPC();
        return result.value;
    };
    // ------------------------------------------------------------
    // 15.1.2.2
    var __parseInt = function (thisArg, args) {
        var string = args[0] || new values_1.Value(undefined, bot);
        var radix = args[1] || new values_1.Value(undefined, bot);
        string = ToString_1.ToString(string);
        var value = parseInt(string.value, radix.value);
        return new values_1.Value(value, lub(string.label, radix.label));
    };
    // ------------------------------------------------------------
    // 15.1.2.3
    var __parseFloat = function (thisArg, args) {
        var string = args[0] || new values_1.Value(undefined, bot);
        string = ToString_1.ToString(string);
        var value = parseFloat(string.value);
        return new values_1.Value(value, string.label);
    };
    // ------------------------------------------------------------
    // 15.1.2.4
    var __isNaN = function (thisArg, args) {
        var number = args[0] || new values_1.Value(undefined, bot);
        number = ToNumber_1.ToNumber(number);
        var value = isNaN(number.value);
        return new values_1.Value(value, number.label);
    };
    // ------------------------------------------------------------
    // 15.1.2.5
    var __isFinite = function (thisArg, args) {
        var number = args[0] || new values_1.Value(undefined, bot);
        number = ToNumber_1.ToNumber(number);
        var value = isFinite(number.value);
        return new values_1.Value(value, number.label);
    };
    // ------------------------------------------------------------
    // 15.1.3.1
    var __decodeURI = function (thisArg, args) {
        var arg0 = args[0] ? args[0] : new values_1.Value(undefined, bot);
        var enc = ToString_1.ToString(arg0);
        var res = new values_1.Value(decodeURI(enc.value), enc.label);
        return res;
    };
    // ------------------------------------------------------------
    // 15.1.3.2
    var __decodeURIComponent = function (thisArg, args) {
        var arg0 = args[0] ? args[0] : new values_1.Value(undefined, bot);
        var enc = ToString_1.ToString(arg0);
        var res = new values_1.Value(decodeURIComponent(enc.value), enc.label);
        return res;
    };
    // ------------------------------------------------------------
    // 15.1.2.3
    var __encodeURI = function (thisArg, args) {
        var arg0 = args[0] ? args[0] : new values_1.Value(undefined, bot);
        var enc = ToString_1.ToString(arg0);
        var res = new values_1.Value(encodeURI(enc.value), enc.label);
        return res;
    };
    // ------------------------------------------------------------
    // 15.1.3.4
    var __encodeURIComponent = function (thisArg, args) {
        var arg0 = args[0] !== undefined ? args[0] : new values_1.Value(undefined, bot);
        var componentString = ToString_1.ToString(arg0);
        return new values_1.Value(encodeURIComponent(componentString.value), componentString.label);
    };
    // ------------------------------------------------------------
    var __print = function (thisArg, args) {
        var str = '';
        for (var i = 0; i < args.length; i++)
            str += args[i].value;
        monitor.print(str);
        return new values_1.Value(undefined, bot);
    };
    var __lprint = function (thisArg, args) {
        if (monitor.options.get('monitor.testMode')) {
            __print(thisArg, args);
            return new values_1.Value(undefined, bot);
        }
        var str = '';
        for (var i = 0; i < args.length; i++)
            str += args[i];
        if (monitor.options.get('monitor.taintMode')) {
            monitor.print(str);
        }
        else {
            monitor.print('(' + monitor.context.effectivePC + '):' + str);
        }
        return new values_1.Value(undefined, bot);
    };
    // ------------------------------------------------------------
    var __alert = function (thisArg, args) {
        var str = 'alert: ';
        for (var i = 0; i < args.length; i++)
            str += args[i].value;
        monitor.print(str);
        return new values_1.Value(undefined, bot);
    };
    // ------------------------------------------------------------
    var __upgl = function (thisArg, args) {
        var labelName = args[0] ? args[0] : new values_1.Value('default', bot);
        monitor.assert(le(labelName.label, bot));
        var lbl = bot;
        for (var i = 1; i < args.length; i++) {
            monitor.assert(le(args[i].label, bot));
            lbl = lub(lbl, Label.fromString(args[i].value));
        }
        lbl = lbl.equals(bot) ? Label.top : lbl;
        var lblmap = monitor.context.labels.labelmap;
        var name = labelName.value;
        if (!lblmap[name]) {
            lblmap[name] = {
                label: lbl,
                pcmarker: undefined
            };
        }
        lblmap[name].label = lub(lblmap[name].label, lbl);
        if (lblmap[name].pcmarker) {
            monitor.context.pcStack.map(function (l) {
                return lub(l, lbl);
            }, lblmap[name].pcmarker);
        }
        return new values_1.Value(undefined, bot);
    };
    // ------------------------------------------------------------
    var __upg = function (thisArg, args) {
        var arg0 = args[0] ? args[0] : new values_1.Value(undefined, bot);
        var lbl = bot;
        for (var i = 1; i < args.length; i++) {
            monitor.assert(le(args[i].label, bot));
            lbl = lub(lbl, Label.fromString(args[i].value));
        }
        lbl = lbl.equals(bot) ? Label.top : lbl;
        return new values_1.Value(arg0.value, lub(arg0.label, lbl));
    };
    // ------------------------------------------------------------
    var __dupg = function (thisArg, args) {
        var arg0 = args[0] ? args[0] : new values_1.Value(undefined, bot);
        var lbl = bot;
        for (var i = 1; i < args.length; i++) {
            lbl = lub(lbl, args[i].label);
        }
        return new values_1.Value(arg0.value, lub(arg0.label, lbl));
    };
    // ------------------------------------------------------------
    var __upgs = function (thisArg, args) {
        var obj = args[0] ? args[0] : new values_1.Value(undefined, bot);
        var lbl = bot;
        for (var i = 1; i < args.length; i++) {
            monitor.assert(le(args[i].label, bot));
            lbl = lub(lbl, Label.fromString(args[i].value));
        }
        lbl = lbl.equals(bot) ? Label.top : lbl;
        if (obj.value != undefined && obj.value.struct !== undefined) {
            obj.value.struct = lub(obj.value.struct, lbl);
        }
        return obj;
    };
    // ------------------------------------------------------------
    var __dupgs = function (thisArg, args) {
        var arg0 = args[0] ? args[0] : new values_1.Value(undefined, bot);
        var lbl = bot;
        for (var i = 1; i < args.length; i++) {
            lbl = lub(lbl, args[i].label);
        }
        if (arg0.value != undefined && arg0.value.struct !== undefined) {
            arg0.value.struct = lub(arg0.value.struct, lbl);
        }
        return arg0;
    };
    // ------------------------------------------------------------
    var __upge = function (thisArg, args) {
        var obj = args[0] ? args[0] : new values_1.Value(undefined, bot);
        var ix = args[1] ? args[1] : new values_1.Value(undefined, bot);
        if (obj.value === undefined || obj.value === null) {
            return new values_1.Value(undefined, bot);
        }
        ix = ToString_1.ToString(ix);
        var lbl = bot;
        for (var i = 2; i < args.length; i++) {
            monitor.assert(le(args[i].label, bot));
            lbl = lub(lbl, Label.fromString(args[i].value));
        }
        lbl = lbl.equals(bot) ? Label.top : lbl;
        var prop = obj.value.map.get(ix.value);
        if (prop) {
            prop.existence = lub(prop.existence, lbl);
        }
        return new values_1.Value(undefined, bot);
    };
    // ------------------------------------------------------------
    var __dupge = function (thisArg, args) {
        var obj = args[0] ? args[0] : new values_1.Value(undefined, bot);
        var ix = args[1] ? args[1] : new values_1.Value(undefined, bot);
        if (obj.value === undefined || obj.value === null) {
            return new values_1.Value(undefined, bot);
        }
        ix = ToString_1.ToString(ix);
        var lbl = bot;
        for (var i = 1; i < args.length; i++) {
            lbl = lub(lbl, args[i].label);
        }
        var prop = obj.value.map.get(ix.value);
        if (prop) {
            prop.existence = lub(prop.existence, lbl);
        }
        return new values_1.Value(undefined, bot);
    };
    // ------------------------------------------------------------
    var __declassify = function (thisArg, args) {
        var val = new values_1.Value(args[0] ? args[0].value : undefined, bot);
        return val;
    };
    // ------------------------------------------------------------
    // ------------------------------------------------------------
    var module = {};
    module.GlobalObject = GlobalObject;
    module.allocate = allocate;
    return module;
};

},{"./Conversion/ToNumber":31,"./Conversion/ToString":34,"./constants":50,"./ecma":53,"./function":57,"./label":60,"./values":75,"esprima":19}],59:[function(require,module,exports){
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var label = require("./label");
var values_1 = require("./values");
var ecma = require("./ecma");
var constants = require("./constants");
var function_1 = require("./function");
var ObjectObject_1 = require("./Objects/ObjectObject");
var ArrayObject_1 = require("./Objects/ArrayObject");
var ToNumber_1 = require("./Conversion/ToNumber");
var ToInteger_1 = require("./Conversion/ToInteger");
var ToString_1 = require("./Conversion/ToString");
var IsCallable_1 = require("./Utility/IsCallable");
exports.functor = function (monitor) {
    var Label = label.Label;
    var lub = label.lub;
    var glb = label.glb;
    var le = label.le;
    var bot = Label.bot;
    // ------------------------------------------------------------
    function allocate(host) {
        var jsonObject = new JSONObject(host.JSON);
        return { JSONObject: jsonObject };
    }
    // ------------------------------------------------------------
    // The JSON object, 15.12
    var JSONObject = /** @class */ (function (_super) {
        __extends(JSONObject, _super);
        function JSONObject(host) {
            var _this = _super.call(this) || this;
            _this.Prototype = new values_1.Value(monitor.instances.ObjectPrototype, bot);
            _this.Class = 'JSON';
            _this.Extensible = true;
            _this.host = host;
            ecma.DefineFFF(_this, constants.prototype, monitor.instances.ObjectPrototype);
            ecma.DefineTFT(_this, constants.parse, new function_1.BuiltinFunctionObject(parse, 2, _this.host.parse));
            ecma.DefineTFT(_this, constants.stringify, new function_1.BuiltinFunctionObject(stringify, 3, _this.host.stringify));
            return _this;
        }
        return JSONObject;
    }(ecma.Ecma));
    // By the standard, there should be no Call or Construct for JSON object,
    // so throw a TypeError (as SpiderMonkey seem to do)
    JSONObject.prototype.Call = function () {
        monitor.Throw(monitor.modules.error.TypeErrorObject, 'JSON is not a function', bot);
    };
    JSONObject.prototype.Construct = function () {
        monitor.Throw(monitor.modules.error.TypeErrorObject, 'JSON is not a constructor', bot);
    };
    // ------------------------------------------------------------
    // parse, 15.12.2
    var parse = function (thisArg, args) {
        if (args[0] === undefined) {
            monitor.Throw(monitor.modules.error.SyntaxErrorObject, 'JSON.parse: No string to parse', bot);
        }
        var JText = ToString_1.ToString(args[0]) || new values_1.Value(undefined, bot);
        var reviver = args[1] || new values_1.Value(undefined, bot);
        var unfiltered = parseAndEvaluate(JText);
        // Do we have any junk characters left? If so, a bad string!
        if (unfiltered.finalIndex <= JText.value.length) {
            monitor.Throw(monitor.modules.error.SyntaxErrorObject, 'JSON.parse: String contains bad symbols in the end', bot);
        }
        var isReviverCallable = IsCallable_1.IsCallable(reviver);
        monitor.context.pushPC(isReviverCallable.label);
        if (isReviverCallable.value) {
            var root = new object.ObjectObject();
            root.DefineOwnProperty(new values_1.Value("", bot), { value: unfiltered,
                writable: true,
                enumerable: true,
                configurable: true,
                label: unfiltered.label
            }, false);
            monitor.context.popPC();
            return Walk(root, new values_1.Value("", lub(unfiltered.label, lub(JText.label, reviver.label))), reviver);
        }
        else {
            monitor.context.popPC();
            return unfiltered;
        }
    };
    // Walk, part of 15.12.2
    var Walk = function (holder, name, reviver) {
        var val = holder.Get(name);
        monitor.context.pushPC(val.label);
        if (val.value && typeof val.value === 'object') {
            val = val.value;
            monitor.context.pushPC(val.label);
            if (val.value.Class === 'Array') {
                var I = new values_1.Value(0, bot);
                var len = val.value.Get(constants.length);
                while (I.value < len.value) {
                    var newElement = Walk(val, ToString_1.ToString(I), reviver);
                    if (newElement === undefined) {
                        val.Delete(ToString_1.ToString(I), false);
                    }
                    else {
                        val.DefineOwnProperty(ToString_1.ToString(I), { value: newElement.value,
                            writable: true,
                            enumerable: true,
                            configurable: true,
                            label: val.label
                        }, false);
                    }
                    I.value++;
                }
            }
            else {
                var keys = [];
                var allKeys = Object.keys(val.value.properties);
                for (var i = 0; i < allKeys.length; i++) {
                    var keyVal = val.GetProperty(new values_1.Value(allKeys[i], bot));
                    if (keyVal.value && keyVal.value.enumerable) {
                        keys.push(new values_1.Value(allKeys[i], bot)); //keyVal.label?
                    }
                }
                for (var i = 0; i < keys.length; i++) {
                    var P = ToString_1.ToString(keys[i]);
                    var newElement = Walk(val, P, reviver);
                    if (newElement === undefined) {
                        val.Delete(P, false);
                    }
                    else {
                        val.DefineOwnProperty(P, { value: newElement.value,
                            writable: true,
                            enumerable: true,
                            configurable: true,
                            label: val.label
                        }, false);
                    }
                }
            }
            monitor.context.popPC();
        }
        monitor.context.popPC();
        return reviver.Call(holder, [name, val]);
    };
    // Inspiration from Douglas Crockford, https://github.com/douglascrockford/JSON-js/blob/master/json_parse.js
    // This is used for the 2nd and 3rd step in parse, 15.12.2
    var parseAndEvaluate = function (text) {
        var currentChar = ' ';
        var currentIndex = 0;
        // From 15.12.1.1, JSONEscapeCharacter :: one of " / \ b f n r t
        var escapeCharacters = {
            '"': '"',
            '/': '/',
            '\\': '\\',
            b: '\b',
            f: '\f',
            n: '\n',
            r: '\r',
            t: '\t'
        };
        // These are not allowed to have in a string!
        var invalidStringCharacters = {};
        for (var i = 0x00; i <= 0x1F; i++) {
            var s = String.fromCharCode(i);
            invalidStringCharacters[s] = s;
        }
        var mkError = function (message) {
            monitor.Throw(monitor.modules.error.SyntaxErrorObject, 'JSON.parse: ' + message, bot);
        };
        var nextChar = function (char) {
            if (char && char !== currentChar) {
                mkError('expected ' + char + ' to match ' + currentChar);
            }
            currentChar = text.charAt(currentIndex);
            currentIndex++;
            return currentChar;
        };
        //JSONWhiteSpace :: <TAB> <CR> <LF> <SP>
        var eatWhiteSpace = function () {
            while (currentChar && currentChar <= ' ') {
                nextChar();
            }
        };
        /* JSONValue :
             JSONNullLiteral
             JSONBooleanLiteral
             JSONObject
             JSONArray
             JSONString
             JSONNumber
        */
        var jsonValue = function () {
            eatWhiteSpace();
            switch (currentChar) {
                case '{':
                    // It must be an object
                    return jsonObject();
                case '[':
                    // It must be an array
                    return jsonArray();
                case '"':
                    // It must be a string
                    return jsonString();
                case '-':
                    // It must be a number
                    return jsonNumber();
                case 'n':
                    // It must be a null literal
                    return jsonNull();
                case 't':
                case 'f':
                    // It must be a boolean literal
                    return jsonBool();
                default:
                    if (currentChar >= '0' && currentChar <= '9') {
                        // It must be a number
                        return jsonNumber();
                    }
                    // Otherwise, something has gone wrong!
                    mkError('Cannot parse the structure!');
            }
        };
        var jsonObject = function () {
            var result = new object.ObjectObject();
            if (currentChar === '{') {
                nextChar('{');
                eatWhiteSpace();
                if (currentChar === '}') {
                    // Enter here and we have an "empty" object
                    nextChar('}');
                    return result;
                }
                while (currentChar) {
                    var key = jsonString();
                    eatWhiteSpace();
                    nextChar(':');
                    if (result.hasOwnProperty(key)) {
                        mkError('Bad object, duplicate key ' + key);
                    }
                    result.DefineOwnProperty(new values_1.Value(key, bot), { value: jsonValue(),
                        writable: true,
                        enumerable: true,
                        configurable: true,
                        label: bot
                    }, false);
                    eatWhiteSpace();
                    if (currentChar === '}') {
                        nextChar('}');
                        return result;
                    }
                    nextChar(',');
                    eatWhiteSpace();
                }
            }
            mkError('Malformed object');
        };
        var jsonArray = function () {
            var result = [];
            if (currentChar === '[') {
                nextChar('[');
                eatWhiteSpace();
                if (currentChar === ']') {
                    // Enter here and we have an empty array..
                    nextChar(']');
                    return ArrayObject_1.ArrayObject.fromValueArray(result);
                }
                while (currentChar) {
                    result.push(jsonValue());
                    eatWhiteSpace();
                    if (currentChar === ']') {
                        // Enter here and we are done..
                        nextChar(']');
                        for (var i = 0; i < result.length; i++) {
                            result[i] = new values_1.Value(result[i], bot);
                        }
                        return ArrayObject_1.ArrayObject.fromValueArray(result);
                    }
                    nextChar(','); // If we are not done, we expect a ','
                    eatWhiteSpace();
                }
            }
            mkError('Could not parse the array');
        };
        /*
          JSONString :: " JSONStringCharacters_opt "
          JSONStringCharacters :: JSONStringCharacter JSONStringCharacters_opt
          JSONStringCharacter :: SourceCharacter but not one of " or \ or U+0000 through U+001F \ JSONEscapeSequence
          JSONEscapeSequence :: JSONEscapeCharacter UnicodeEscapeSequence
         */
        var jsonString = function () {
            var result = "";
            if (currentChar === '"') {
                while (nextChar()) {
                    if (currentChar === '"') {
                        nextChar();
                        return result;
                    }
                    // Check if the current character is an invalid string
                    if (invalidStringCharacters[currentChar]) {
                        mkError("Invalid character in string");
                    }
                    if (currentChar === '\\') {
                        nextChar();
                        if (currentChar === 'u') {
                            var hexValue = 0;
                            for (var i = 0; i < 4; i++) {
                                var hex = parseInt(nextChar(), 16);
                                if (!isFinite(hex)) {
                                    break;
                                }
                                hexValue = hexValue * 16 + hex;
                            }
                            result += String.fromCharCode(hexValue);
                        }
                        else if (typeof escapeCharacters[currentChar] === 'string') {
                            result += escapeCharacters[currentChar];
                        }
                        else {
                            break;
                        }
                    }
                    else {
                        result += currentChar;
                    }
                }
            }
            mkError('Bad input string');
        };
        // JSONNumber :: -_opt DecimalIntegerLiteral JSONFraction_opt ExponentPart_opt
        var jsonNumber = function () {
            var result = "", checkOctal = false, checkFloat = false;
            if (currentChar === '-') {
                result += currentChar;
                nextChar('-');
            }
            if (currentChar === '0') {
                checkOctal = true;
            }
            // Get all the numbers
            while (currentChar >= '0' && currentChar <= '9') {
                result += currentChar;
                nextChar();
            }
            if (checkOctal && result.length > 1) {
                mkError("JSON.parse: Numbers cannot start with a 0");
            }
            // Check if it is a float
            if (currentChar === '.') {
                result += currentChar;
                checkFloat = true;
                // Get all the remaining numbers in the float
                while (nextChar() && currentChar >= '0' && currentChar <= '9') {
                    result += currentChar;
                    checkFloat = false;
                }
            }
            if (checkFloat) {
                mkError("JSON.parse: Number with nothing after the decimal");
            }
            if (currentChar === 'e' || currentChar === 'E') {
                result += currentChar;
                nextChar();
                if (currentChar === '-' || currentChar === '+') {
                    result += currentChar;
                    nextChar();
                }
                while (currentChar >= '0' && currentChar <= '9') {
                    result += currentChar;
                    nextChar();
                }
            }
            var num = +result; // Nasty conversion. :)
            if (!isFinite(num)) {
                mkError('Bad number, not finite');
            }
            return num;
        };
        // JSONNullLiteral :: NullLiteral
        var jsonNull = function () {
            nextChar('n');
            nextChar('u');
            nextChar('l');
            nextChar('l');
            return null;
        };
        // JSONBooleanLiteral :: BooleanLiteral
        var jsonBool = function () {
            switch (currentChar) {
                case 't':
                    nextChar('t');
                    nextChar('r');
                    nextChar('u');
                    nextChar('e');
                    return true;
                case 'f':
                    nextChar('f');
                    nextChar('a');
                    nextChar('l');
                    nextChar('s');
                    nextChar('e');
                    return false;
                default:
                    mkError('Could not deduce a boolean');
            }
        };
        if (text.value) {
            var textLabel = text.label;
            text = text.value;
            var res = new values_1.Value(jsonValue(), textLabel);
            eatWhiteSpace(); // Eat all trailing white spaces
            res.finalIndex = currentIndex; // This is needed to know if we have some garbage at the end of the string
            return res;
        }
        else {
            mkError('Bad format on input');
        }
    };
    // ------------------------------------------------------------
    // stringify, 15.12.3
    var stringify = function (thisArg, args) {
        // These are used for cycle detection
        var JA_counter = 0;
        var JO_counter = 0;
        //-------------------------------------------
        var stack = [];
        var indent = "";
        var PropertyList, ReplacerFunction;
        var gap = "";
        var value = args[0] || new values_1.Value(undefined, bot);
        var replacer = args[1] || new values_1.Value(undefined, bot);
        var space = args[2] || new values_1.Value(undefined, bot);
        var retLabel = lub(value.label, lub(replacer.label, space.label));
        monitor.context.pushPC(replacer.label);
        if (typeof replacer.value === 'object' || typeof replacer.value === 'function') {
            if (IsCallable_1.IsCallable(replacer).value) {
                ReplacerFunction = replacer;
            }
            else if (replacer.value && replacer.value.Class === 'Array') {
                PropertyList = [];
                var initialReplacerLength = replacer.value.properties.length;
                for (var i = 0; i < initialReplacerLength; i++) {
                    var item = undefined;
                    var v = replacer.Get(new values_1.Value(i, bot));
                    if (v.value !== undefined) {
                        if (typeof v.value === 'string') {
                            item = v;
                        }
                        else if (typeof v.value === 'number') {
                            item = ToString_1.ToString(v);
                        }
                        else if (typeof v.value === 'object') {
                            if (v.value && (v.value.Class === 'String' || v.value.Class === 'Number')) {
                                item = ToString_1.ToString(v);
                            }
                        }
                        if (item !== undefined) {
                            var itemNotInArray = true;
                            for (var j = 0; j < PropertyList.length; j++) {
                                if (item.value === PropertyList[j].value) {
                                    itemNotInArray = false;
                                    break;
                                }
                            }
                            if (itemNotInArray) {
                                PropertyList.push(item);
                            }
                        }
                    }
                }
            }
        }
        monitor.context.popPC();
        monitor.context.pushPC(space.label);
        if (typeof space.value === 'object') {
            if (space.value.Class === 'Number') {
                space = ToNumber_1.ToNumber(space);
            }
            else if (space.value.Class === 'String') {
                space = ToString_1.ToString(space);
            }
        }
        if (typeof space.value === 'number') {
            var intSpace = ToInteger_1.ToInteger(space);
            if (intSpace.value > 10) {
                space = new values_1.Value(10, space.label);
            }
            else {
                space = intSpace;
            }
            for (var i = 0; i < space.value; i++) {
                gap = gap + " ";
            }
        }
        else if (typeof space.value === 'string') {
            if (space.value.length <= 10) {
                gap = space.value;
            }
            else {
                gap = space.value.substring(0, 10);
            }
        }
        // Leave the last else, gap will be empty string if none of the above has been hit
        monitor.context.popPC(); // Pop space.label from the PC stack
        var wrapper = new ObjectObject_1.ObjectObject();
        wrapper.DefineOwnProperty(new values_1.Value("", bot), { value: value.value,
            writable: true,
            enumerable: true,
            configurable: true,
            label: value.label
        }, false);
        var Str = function (key, holder) {
            var value = holder.Get(key);
            retLabel = lub(retLabel, value.label);
            monitor.context.pushPC(value.label);
            if (value.value && typeof value.value === 'object') {
                var toJSON = value.Get(new values_1.Value("toJSON", bot));
                if (IsCallable_1.IsCallable(toJSON).value) {
                    value = toJSON.Call(value, [key]);
                }
            }
            monitor.context.popPC(); // As it is being pushed again later, is this needed?
            if (ReplacerFunction) {
                monitor.context.pushPC(ReplacerFunction.label);
                if (ReplacerFunction.value) {
                    value = ReplacerFunction.Call(holder, [key, value]);
                }
                monitor.context.popPC();
            }
            monitor.context.pushPC(value.label);
            if (value.value && typeof value.value === 'object') {
                if (value.value.Class === 'Number') {
                    value = ToNumber_1.ToNumber(value);
                }
                else if (value.value.Class === 'String') {
                    value = ToString_1.ToString(value);
                }
                else if (value.value.Class === 'Boolean') {
                    value = new values_1.Value(value.value.PrimitiveValue.valueOf(), retLabel);
                }
            }
            if (value.value === null) {
                monitor.context.popPC();
                return new values_1.Value("null", retLabel);
            }
            if (value.value === true) {
                monitor.context.popPC();
                return new values_1.Value("true", retLabel);
            }
            if (value.value === false) {
                monitor.context.popPC();
                return new values_1.Value("false", retLabel);
            }
            if (typeof value.value === 'string') {
                var res = Quote(value);
                monitor.context.popPC();
                return res;
            }
            if (typeof value.value === 'number') {
                if (isFinite(value.value)) {
                    var res = ToString_1.ToString(value);
                    monitor.context.popPC();
                    return res;
                }
                monitor.context.popPC();
                return new values_1.Value("null", retLabel);
            }
            if (typeof value.value === 'object' && !IsCallable_1.IsCallable(value).value) {
                if (value.value.Class === 'Array') {
                    var res = JA(value);
                    monitor.context.popPC();
                    return res;
                }
                var res = JO(value);
                monitor.context.popPC();
                return res;
            }
            monitor.context.popPC();
            return new values_1.Value(undefined, retLabel);
        };
        var Quote = function (value) {
            var product = "\"";
            for (var i = 0; i < value.value.length; i++) {
                var C = value.value[i];
                var cCodePointValue = C.codePointAt(0);
                var spaceCodePointValue = (" ").codePointAt(0);
                if (C === "\"" || C === "\\") {
                    product += "\\";
                    product += C;
                }
                else if (C === "\b" || C === "\f" || C === "\n" || C === "\r" || C === "\t") {
                    product += "\\";
                    var abbrev;
                    if (C === "\b")
                        abbrev = "b";
                    else if (C === "\f")
                        abbrev = "f";
                    else if (C === "\n")
                        abbrev = "n";
                    else if (C === "\r")
                        abbrev = "r";
                    else
                        abbrev = "t";
                    product += abbrev;
                }
                else if (cCodePointValue < spaceCodePointValue) {
                    product += "\\";
                    product += "u";
                    var hex = cCodePointValue.toString(16);
                    for (var j = hex.length; j < 4; j++) {
                        hex = "0" + hex;
                    }
                    product += hex;
                }
                else {
                    product += C;
                }
            }
            product += "\"";
            return new values_1.Value(product, lub(monitor.context.effectivePC, value.label));
        };
        var JO = function (value) {
            var JO_key = new values_1.Value("JO_property", bot);
            if (!value.Get(JO_key).value) {
                JO_counter++;
                value.DefineOwnProperty(JO_key, { value: new values_1.Value(JO_counter, bot),
                    writable: false,
                    enumerable: false,
                    configurable: false,
                    label: bot
                }, false);
            }
            else {
                checkCycle(JO_key, value);
            }
            stack.push(value);
            var stepback = indent;
            indent = indent + gap;
            if (PropertyList !== undefined) {
                var K = PropertyList;
            }
            else {
                var K = [];
                var allKeys = Object.keys(value.value.properties);
                for (var i = 0; i < allKeys.length; i++) {
                    var keyVal = value.GetProperty(new values_1.Value(allKeys[i], bot));
                    if (keyVal.value && keyVal.value.enumerable) {
                        K.push(new values_1.Value(allKeys[i], retLabel));
                    }
                }
            }
            var partial = [];
            for (var i = 0; i < K.length; i++) {
                var P = K[i];
                var strP = Str(P, value);
                if (strP && strP.value !== undefined) {
                    var member = Quote(P);
                    member.value += ":";
                    if (gap !== "") {
                        member.value += ' ';
                    }
                    member.value += strP.value;
                    partial.push(member);
                }
            }
            var final;
            if (partial.length === 0) {
                final = "{}";
            }
            else {
                var properties = "";
                if (gap === "") {
                    for (var i = 0; i < partial.length - 1; i++) {
                        properties += partial[i].value + ',';
                        retLabel = lub(retLabel, partial[i].label);
                    }
                    properties += partial[partial.length - 1].value;
                    retLabel = lub(retLabel, partial[partial.length - 1].label);
                    final = '{' + properties + '}';
                }
                else {
                    var separator = ",\n" + indent;
                    for (var i = 0; i < partial.length - 1; i++) {
                        properties += partial[i].value + separator;
                        retLabel = lub(retLabel, partial[i].label);
                    }
                    properties += partial[partial.length - 1].value;
                    retLabel = lub(retLabel, partial[partial.length - 1].label);
                    final = '{\n' + indent + properties + '\n' + stepback + '}';
                }
            }
            // Pop and remove JO_property
            var v = stack.pop();
            v.Delete(JO_key);
            indent = stepback;
            return new values_1.Value(final, retLabel);
        };
        var JA = function (value) {
            var JA_key = new values_1.Value("JA_property", bot);
            if (!value.Get(JA_key).value) {
                JA_counter++;
                value.DefineOwnProperty(JA_key, { value: new values_1.Value(JA_counter, bot),
                    writable: false,
                    enumerable: false,
                    configurable: false,
                    label: bot
                }, false);
            }
            else {
                checkCycle(JA_key, value);
            }
            stack.push(value);
            var stepback = indent;
            indent = indent + gap;
            var partial = [];
            var len = value.Get(new values_1.Value('length', bot));
            var index = new values_1.Value(0, bot);
            while (index.value < len.value) {
                var strP = Str(ToString_1.ToString(index), value);
                if (!strP || strP.value === undefined) {
                    partial.push(new values_1.Value("null", retLabel));
                }
                else {
                    partial.push(strP);
                    retLabel = lub(retLabel, strP.label);
                }
                index.value++;
            }
            var final;
            if (partial.length === 0) {
                final = "[]";
            }
            else {
                var properties = "";
                if (gap === "") {
                    for (var i = 0; i < partial.length - 1; i++) {
                        properties += partial[i].value + ',';
                        retLabel = lub(retLabel, partial[i].label);
                    }
                    properties += partial[partial.length - 1].value;
                    retLabel = lub(retLabel, partial[partial.length - 1].label);
                    final = '[' + properties + ']';
                }
                else {
                    var separator = ",\n" + indent;
                    for (var i = 0; i < partial.length - 1; i++) {
                        properties += partial[i].value + separator;
                        retLabel = lub(retLabel, partial[i].label);
                    }
                    properties += partial[partial.length - 1].value;
                    retLabel = lub(retLabel, partial[partial.length - 1].label);
                    final = '[\n' + indent + properties + '\n' + stepback + ']';
                }
            }
            // Pop and remove property of JA_key
            var v = stack.pop();
            v.Delete(JA_key);
            indent = stepback;
            return new values_1.Value(final, retLabel);
        };
        var checkCycle = function (key, value) {
            for (var i = 0; i < stack.length; i++) {
                if (value.Get(key).value === stack[i].Get(key).value) {
                    monitor.Throw(monitor.modules.error.TypeErrorObject, 'JSON.stringify: Cyclic structure', bot);
                }
            }
        };
        return Str(new values_1.Value("", bot), wrapper);
    };
    // ------------------------------------------------------------
    var module = {};
    module.allocate = allocate;
    return module;
};

},{"./Conversion/ToInteger":30,"./Conversion/ToNumber":31,"./Conversion/ToString":34,"./Objects/ArrayObject":38,"./Objects/ObjectObject":42,"./Utility/IsCallable":49,"./constants":50,"./ecma":53,"./function":57,"./label":60,"./values":75}],60:[function(require,module,exports){
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
// -------------------------------------------------------------------------- 
var Top;
(function (Top) {
    Top[Top["Top"] = 0] = "Top";
})(Top || (Top = {}));
;
var Label = /** @class */ (function () {
    function Label(p) {
        var e_1, _a;
        var rest = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            rest[_i - 1] = arguments[_i];
        }
        if (p === Top.Top) {
            this.principals = Top.Top;
            return;
        }
        this.principals = new Set(rest);
        if (typeof p === "string") {
            this.principals.add(p);
            return;
        }
        if (typeof p !== 'undefined') {
            try {
                for (var p_1 = __values(p), p_1_1 = p_1.next(); !p_1_1.done; p_1_1 = p_1.next()) {
                    var x = p_1_1.value;
                    this.principals.add(x);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (p_1_1 && !p_1_1.done && (_a = p_1.return)) _a.call(p_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
    }
    // -------------------------------------------------------------------------- 
    Label.fromString = function (l) {
        return new Label(l.split(','));
    };
    // -------------------------------------------------------------------------- 
    Label.fromURL = function (l) {
        var re = new RegExp('http://[^/]*/');
        var res = re.exec(l);
        if (res === null) {
            return new Label(l.split(','));
        }
        else {
            return new Label([res[0]]);
        }
    };
    // -------------------------------------------------------------------------- 
    Label.prototype.lub = function () {
        var e_2, _a, e_3, _b, e_4, _c, e_5, _d, e_6, _e;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (this.principals === Top.Top) {
            return this;
        }
        try {
            for (var args_1 = __values(args), args_1_1 = args_1.next(); !args_1_1.done; args_1_1 = args_1.next()) {
                var l = args_1_1.value;
                if (l.principals === Top.Top) {
                    this.principals = Top.Top;
                    return this;
                }
                try {
                    for (var _f = __values(l.principals), _g = _f.next(); !_g.done; _g = _f.next()) {
                        var p = _g.value;
                        this.principals.add(p);
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (args_1_1 && !args_1_1.done && (_a = args_1.return)) _a.call(args_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        var bad_principals = ['global.navigator.plugins',
            'global.navigator.maxTouchPoints',
            'global.Intl.DateTimeFormat',
            'global.navigator.hardwareConcurrency',
            'global.navigator.deviceMemory',
            'global.screen.colorDepth',
            'global.navigator.userAgent',
            'global.navigator.appName',
            'global.navigator.language',
            'global.navigator.languages',
            '.toDataURL',
            'getContext.getExtension',
            'global.screen.availWidth',
            'global.screen.availHeight',
            'global.screen.width',
            'global.screen.height'
        ];
        var bad_count = 0;
        var bad_limit = 7;
        try {
            for (var _h = __values(this.principals), _j = _h.next(); !_j.done; _j = _h.next()) {
                var p = _j.value;
                try {
                    for (var bad_principals_1 = __values(bad_principals), bad_principals_1_1 = bad_principals_1.next(); !bad_principals_1_1.done; bad_principals_1_1 = bad_principals_1.next()) {
                        var bp = bad_principals_1_1.value;
                        if (p.includes(bp)) {
                            bad_count += 1;
                        }
                    }
                }
                catch (e_5_1) { e_5 = { error: e_5_1 }; }
                finally {
                    try {
                        if (bad_principals_1_1 && !bad_principals_1_1.done && (_d = bad_principals_1.return)) _d.call(bad_principals_1);
                    }
                    finally { if (e_5) throw e_5.error; }
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_j && !_j.done && (_c = _h.return)) _c.call(_h);
            }
            finally { if (e_4) throw e_4.error; }
        }
        if (bad_count > bad_limit) {
            var err = "";
            try {
                for (var _k = __values(this.principals), _l = _k.next(); !_l.done; _l = _k.next()) {
                    var p = _l.value;
                    err += p + ", ";
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (_l && !_l.done && (_e = _k.return)) _e.call(_k);
                }
                finally { if (e_6) throw e_6.error; }
            }
            throw "Bad labels: " + err;
        }
        return this;
    };
    // -------------------------------------------------------------------------- 
    Label.prototype.glb = function () {
        var e_7, _a, e_8, _b;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        try {
            for (var args_2 = __values(args), args_2_1 = args_2.next(); !args_2_1.done; args_2_1 = args_2.next()) {
                var l = args_2_1.value;
                if (l.principals === Top.Top) {
                    continue;
                }
                if (this.principals === Top.Top) {
                    this.principals = new Set(l.principals);
                    continue;
                }
                try {
                    for (var _c = __values(l.principals), _d = _c.next(); !_d.done; _d = _c.next()) {
                        var p = _d.value;
                        this.principals.add(p);
                    }
                }
                catch (e_8_1) { e_8 = { error: e_8_1 }; }
                finally {
                    try {
                        if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                    }
                    finally { if (e_8) throw e_8.error; }
                }
            }
        }
        catch (e_7_1) { e_7 = { error: e_7_1 }; }
        finally {
            try {
                if (args_2_1 && !args_2_1.done && (_a = args_2.return)) _a.call(args_2);
            }
            finally { if (e_7) throw e_7.error; }
        }
        return this;
    };
    // -------------------------------------------------------------------------- 
    Label.prototype.equals = function (l) {
        var e_9, _a, e_10, _b;
        var A = this.principals;
        var B = l.principals;
        if (A === Top.Top || B === Top.Top) {
            return A === B;
        }
        try {
            for (var A_1 = __values(A), A_1_1 = A_1.next(); !A_1_1.done; A_1_1 = A_1.next()) {
                var p = A_1_1.value;
                if (!B.has(p)) {
                    return false;
                }
            }
        }
        catch (e_9_1) { e_9 = { error: e_9_1 }; }
        finally {
            try {
                if (A_1_1 && !A_1_1.done && (_a = A_1.return)) _a.call(A_1);
            }
            finally { if (e_9) throw e_9.error; }
        }
        try {
            for (var B_1 = __values(B), B_1_1 = B_1.next(); !B_1_1.done; B_1_1 = B_1.next()) {
                var p = B_1_1.value;
                if (!B.has(p)) {
                    return false;
                }
            }
        }
        catch (e_10_1) { e_10 = { error: e_10_1 }; }
        finally {
            try {
                if (B_1_1 && !B_1_1.done && (_b = B_1.return)) _b.call(B_1);
            }
            finally { if (e_10) throw e_10.error; }
        }
        return true;
    };
    // -------------------------------------------------------------------------- 
    Label.prototype.le = function (l) {
        var A = this.principals;
        var B = l.principals;
        if (A === Top.Top) {
            return false;
        }
        if (B === Top.Top) {
            return true;
        }
        for (var p in A) {
            if (!B.has(p)) {
                return false;
            }
        }
        return true;
    };
    // -------------------------------------------------------------------------- 
    Label.prototype.toString = function () {
        var str = 'T';
        if (this.principals !== Top.Top) {
            str = Array.from(this.principals).join(', ');
        }
        return "<" + str + ">";
    };
    Label.bot = new Label();
    Label.top = new Label(Top.Top);
    return Label;
}());
exports.Label = Label;
// -------------------------------------------------------------------------- 
exports.top = new Label(Top.Top);
exports.bot = new Label();
// -------------------------------------------------------------------------- 
function le(l1, l2) {
    return (l1.le(l2));
}
exports.le = le;
function lub() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var l = new Label();
    l.lub.apply(l, args);
    return l;
}
exports.lub = lub;
function glb() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var l = new Label(Top.Top);
    l.glb.apply(l, args);
    return l;
}
exports.glb = glb;

},{}],61:[function(require,module,exports){
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var label = require("./label");
var values_1 = require("./values");
var ecma = require("./ecma");
var constants = require("./constants");
var function_1 = require("./function");
var ToNumber_1 = require("./Conversion/ToNumber");
// 15.8
exports.functor = function (monitor) {
    var Ecma = ecma.Ecma;
    var Label = label.Label;
    var lub = label.lub;
    var le = label.le;
    var bot = Label.bot;
    // ------------------------------------------------------------
    function allocate(host) {
        var mathObject = new MathObject(host.Math);
        return { MathObject: mathObject };
    }
    // ------------------------------------------------------------
    // The Math Object, 15.8.2
    var MathObject = /** @class */ (function (_super) {
        __extends(MathObject, _super);
        function MathObject(host) {
            var _this_1 = _super.call(this) || this;
            _this_1.Prototype = new values_1.Value(monitor.instances.FunctionPrototype, bot);
            _this_1.Class = 'Math';
            // not mandated by standard
            _this_1.Extensible = true;
            _this_1.host = host;
            ecma.DefineFFF(_this_1, constants.length, 1);
            ecma.DefineFFF(_this_1, constants.prototype, monitor.instances.ObjectPrototype);
            ecma.DefineFFF(_this_1, constants.E, _this_1.host.E);
            ecma.DefineFFF(_this_1, constants.LN10, _this_1.host.LN10);
            ecma.DefineFFF(_this_1, constants.LN2, _this_1.host.LN2);
            ecma.DefineFFF(_this_1, constants.LOG2E, _this_1.host.LOG2E);
            ecma.DefineFFF(_this_1, constants.LOG10E, _this_1.host.LOG10E);
            ecma.DefineFFF(_this_1, constants.PI, _this_1.host.PI);
            ecma.DefineFFF(_this_1, constants.SQRT1_2, _this_1.host.SQRT1_2);
            ecma.DefineFFF(_this_1, constants.SQRT2, _this_1.host.SQRT2);
            ecma.DefineTFT(_this_1, constants.abs, new function_1.BuiltinFunctionObject(abs, 1, _this_1.host.abs));
            ecma.DefineTFT(_this_1, constants.acos, new function_1.BuiltinFunctionObject(acos, 1, _this_1.host.acos));
            ecma.DefineTFT(_this_1, constants.asin, new function_1.BuiltinFunctionObject(asin, 1, _this_1.host.asin));
            ecma.DefineTFT(_this_1, constants.atan, new function_1.BuiltinFunctionObject(atan, 1, _this_1.host.atan));
            ecma.DefineTFT(_this_1, constants.atan2, new function_1.BuiltinFunctionObject(atan2, 2, _this_1.host.atan2));
            ecma.DefineTFT(_this_1, constants.ceil, new function_1.BuiltinFunctionObject(ceil, 1, _this_1.host.ceil));
            ecma.DefineTFT(_this_1, constants.cos, new function_1.BuiltinFunctionObject(cos, 1, _this_1.host.cos));
            ecma.DefineTFT(_this_1, constants.exp, new function_1.BuiltinFunctionObject(exp, 1, _this_1.host.exp));
            ecma.DefineTFT(_this_1, constants.floor, new function_1.BuiltinFunctionObject(floor, 1, _this_1.host.floor));
            ecma.DefineTFT(_this_1, constants.log, new function_1.BuiltinFunctionObject(log, 1, _this_1.host.log));
            ecma.DefineTFT(_this_1, constants.max, new function_1.BuiltinFunctionObject(max, 2, _this_1.host.max));
            ecma.DefineTFT(_this_1, constants.min, new function_1.BuiltinFunctionObject(min, 2, _this_1.host.min));
            ecma.DefineTFT(_this_1, constants.pow, new function_1.BuiltinFunctionObject(pow, 2, _this_1.host.pow));
            ecma.DefineTFT(_this_1, constants.random, new function_1.BuiltinFunctionObject(random, 0, _this_1.host.random));
            ecma.DefineTFT(_this_1, constants.round, new function_1.BuiltinFunctionObject(round, 1, _this_1.host.round));
            ecma.DefineTFT(_this_1, constants.sin, new function_1.BuiltinFunctionObject(sin, 1, _this_1.host.sin));
            ecma.DefineTFT(_this_1, constants.sqrt, new function_1.BuiltinFunctionObject(sqrt, 1, _this_1.host.sqrt));
            ecma.DefineTFT(_this_1, constants.tan, new function_1.BuiltinFunctionObject(tan, 1, _this_1.host.tan));
            return _this_1;
        }
        return MathObject;
    }(Ecma));
    // ------------------------------------------------------------
    // abs, 15.8.2.1
    var abs = function (thisArg, args) {
        var x = args[0] ? ToNumber_1.ToNumber(args[0]) : new values_1.Value(undefined, bot);
        return new values_1.Value(this.host(x.value), x.label);
    };
    // ------------------------------------------------------------
    // acos, 15.8.2.2
    var acos = function (thisArg, args) {
        var x = args[0] ? ToNumber_1.ToNumber(args[0]) : new values_1.Value(undefined, bot);
        return new values_1.Value(this.host(x.value), x.label);
    };
    // ------------------------------------------------------------
    // asin, 15.8.2.3
    var asin = function (thisArg, args) {
        var x = args[0] ? ToNumber_1.ToNumber(args[0]) : new values_1.Value(undefined, bot);
        return new values_1.Value(this.host(x.value), x.label);
    };
    // ------------------------------------------------------------
    // atan, 15.8.2.4
    var atan = function (thisArg, args) {
        var x = args[0] ? ToNumber_1.ToNumber(args[0]) : new values_1.Value(undefined, bot);
        return new values_1.Value(this.host(x.value), x.label);
    };
    // ------------------------------------------------------------
    // atan2, 15.8.2.5
    var atan2 = function (thisArg, args) {
        var _this = thisArg.value;
        var x = args[0] ? ToNumber_1.ToNumber(args[0]) : new values_1.Value(undefined, bot);
        var y = args[1] ? ToNumber_1.ToNumber(args[1]) : new values_1.Value(undefined, bot);
        return new values_1.Value(_this.host(x.value, y.value), lub(x.label, y.label));
    };
    // ------------------------------------------------------------
    // ceil, 15.8.2.6
    var ceil = function (thisArg, args) {
        var _this = thisArg.value;
        var x = args[0] ? ToNumber_1.ToNumber(args[0]) : new values_1.Value(undefined, bot);
        return new values_1.Value(_this.host(x.value), x.label);
    };
    // ------------------------------------------------------------
    // cos, 15.8.2.7
    var cos = function (thisArg, args) {
        console.log(thisArg);
        var x = args[0] ? ToNumber_1.ToNumber(args[0]) : new values_1.Value(undefined, bot);
        return new values_1.Value(this.host(x.value), x.label);
    };
    // ------------------------------------------------------------
    // exp, 15.8.2.8
    var exp = function (thisArg, args) {
        var x = args[0] ? ToNumber_1.ToNumber(args[0]) : new values_1.Value(undefined, bot);
        return new values_1.Value(this.host(x.value), x.label);
    };
    // ------------------------------------------------------------
    // floor, 15.8.2.9
    var floor = function (thisArg, args) {
        var x = args[0] ? ToNumber_1.ToNumber(args[0]) : new values_1.Value(undefined, bot);
        return new values_1.Value(this.host(x.value), x.label);
    };
    // ------------------------------------------------------------
    // log, 15.8.2.10
    var log = function (thisArg, args) {
        var x = args[0] ? ToNumber_1.ToNumber(args[0]) : new values_1.Value(undefined, bot);
        return new values_1.Value(this.host(x.value), x.label);
    };
    // ------------------------------------------------------------
    // max, 15.8.2.11
    var max = function (thisArg, args) {
        if (args.length === 0)
            return new values_1.Value(Number.NEGATIVE_INFINITY, bot);
        var myArgs = [];
        var l = bot;
        for (var i = 0; i < args.length; i++) {
            myArgs[i] = args[i].value;
            l = lub(l, args[i].label);
        }
        return new values_1.Value(this.host.apply(null, myArgs), l);
    };
    // ------------------------------------------------------------
    // min, 15.8.2.12
    var min = function (thisArg, args) {
        if (args.length === 0)
            return new values_1.Value(Number.POSITIVE_INFINITY, bot);
        var myArgs = [];
        var l = bot;
        for (var i = 0; i < args.length; i++) {
            myArgs[i] = args[i].value;
            l = lub(l, args[i].label);
        }
        return new values_1.Value(this.host.apply(null, myArgs), l);
    };
    // ------------------------------------------------------------
    // pow, 15.8.2.13
    var pow = function (thisArg, args) {
        var x = args[0] ? ToNumber_1.ToNumber(args[0]) : new values_1.Value(undefined, bot);
        var y = args[1] ? ToNumber_1.ToNumber(args[1]) : new values_1.Value(undefined, bot);
        return new values_1.Value(this.host(x.value, y.value), lub(x.label, y.label));
    };
    // ------------------------------------------------------------
    // random, 15.8.2.14
    var random = function (thisArg, args) {
        return new values_1.Value(this.host(), bot);
    };
    // ------------------------------------------------------------
    // round, 15.8.2.15
    var round = function (thisArg, args) {
        var x = args[0] ? ToNumber_1.ToNumber(args[0]) : new values_1.Value(undefined, bot);
        return new values_1.Value(this.host(x.value), x.label);
    };
    // ------------------------------------------------------------
    // sin, 15.8.2.16
    var sin = function (thisArg, args) {
        var x = args[0] ? ToNumber_1.ToNumber(args[0]) : new values_1.Value(undefined, bot);
        return new values_1.Value(this.host(x.value), x.label);
    };
    // ------------------------------------------------------------
    // sqrt, 15.8.2.17
    var sqrt = function (thisArg, args) {
        var x = args[0] ? ToNumber_1.ToNumber(args[0]) : new values_1.Value(undefined, bot);
        return new values_1.Value(this.host(x.value), x.label);
    };
    // ------------------------------------------------------------
    // tan, 15.8.2.18
    var tan = function (thisArg, args) {
        var x = args[0] ? ToNumber_1.ToNumber(args[0]) : new values_1.Value(undefined, bot);
        return new values_1.Value(this.host(x.value), x.label);
    };
    // ------------------------------------------------------------
    var module = {};
    module.allocate = allocate;
    return module;
};

},{"./Conversion/ToNumber":31,"./constants":50,"./ecma":53,"./function":57,"./label":60,"./values":75}],62:[function(require,module,exports){
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var label_1 = require("./label");
var values_1 = require("./values");
var context_1 = require("./context");
var prelude = require("./prelude");
var options_1 = require("./options");
var stack_1 = require("./stack");
var FunctionPrototype_1 = require("./Prototypes/FunctionPrototype");
var FunctionConstructor_1 = require("./Constructors/FunctionConstructor");
var ObjectConstructor_1 = require("./Constructors/ObjectConstructor");
var ObjectPrototype_1 = require("./Prototypes/ObjectPrototype");
var BooleanConstructor_1 = require("./Constructors/BooleanConstructor");
var BooleanPrototype_1 = require("./Prototypes/BooleanPrototype");
var ArrayPrototype_1 = require("./Prototypes/ArrayPrototype");
var ArrayConstructor_1 = require("./Constructors/ArrayConstructor");
var NumberPrototype_1 = require("./Prototypes/NumberPrototype");
var NumberConstructor_1 = require("./Constructors/NumberConstructor");
var imports = {
    error: require('./error'),
    string: require('./string'),
    regexp: require('./regexp'),
    date: require('./date'),
    math: require('./math'),
    json: require('./json'),
    global: require('./global'),
    exec: require('./exec')
};
var bot = label_1.Label.bot;
// --------------------------------------------------------------------------
var JSFlowError = /** @class */ (function (_super) {
    __extends(JSFlowError, _super);
    function JSFlowError(msg) {
        return _super.call(this, msg) || this;
    }
    return JSFlowError;
}(Error));
exports.JSFlowError = JSFlowError;
// --------------------------------------------------------------------------
var SecurityError = /** @class */ (function (_super) {
    __extends(SecurityError, _super);
    function SecurityError(msg) {
        return _super.call(this, msg) || this;
    }
    return SecurityError;
}(JSFlowError));
exports.SecurityError = SecurityError;
// --------------------------------------------------------------------------
var FatalError = /** @class */ (function (_super) {
    __extends(FatalError, _super);
    function FatalError(msg) {
        return _super.call(this, msg) || this;
    }
    return FatalError;
}(JSFlowError));
exports.FatalError = FatalError;
// --------------------------------------------------------------------------
var Instances = /** @class */ (function () {
    function Instances(global) {
        // pre-allocates instances, without setting them up due to circularity
        this.FunctionConstructor = new FunctionConstructor_1.FunctionConstructor(global.Function);
        this.FunctionPrototype = new FunctionPrototype_1.FunctionPrototype(Object.getPrototypeOf(global.Function));
        this.ObjectConstructor = new ObjectConstructor_1.ObjectConstructor(global.Object);
        this.ObjectPrototype = new ObjectPrototype_1.ObjectPrototype(Object.getPrototypeOf(global.Object));
        this.BooleanConstructor = new BooleanConstructor_1.BooleanConstructor(global.Boolean);
        this.BooleanPrototype = new BooleanPrototype_1.BooleanPrototype(Object.getPrototypeOf(global.Boolean));
        this.ArrayConstructor = new ArrayConstructor_1.ArrayConstructor(global.Array);
        this.ArrayPrototype = new ArrayPrototype_1.ArrayPrototype(Object.getPrototypeOf(global.Array));
        this.NumberConstructor = new NumberConstructor_1.NumberConstructor(global.Array);
        this.NumberPrototype = new NumberPrototype_1.NumberPrototype(Object.getPrototypeOf(global.Array));
    }
    Instances.prototype.Setup = function () {
        this.FunctionConstructor.Setup();
        this.FunctionPrototype.Setup();
        this.ObjectConstructor.Setup();
        this.ObjectPrototype.Setup();
        this.BooleanConstructor.Setup();
        this.BooleanPrototype.Setup();
        this.ArrayConstructor.Setup();
        this.ArrayPrototype.Setup();
        this.NumberConstructor.Setup();
        this.NumberPrototype.Setup();
    };
    return Instances;
}());
var MonitorBase = /** @class */ (function () {
    // ---
    // constructor
    function MonitorBase(global, print, log, warn, error) {
        this.contextStack = new stack_1.Stack();
        this.initialized = false;
        this.codebuffer = "";
        global.monitor = this;
        this.print = print ? print : console.log;
        this.log = log ? log : console.log;
        this.warn = warn ? warn : console.log;
        this.error = error ? error : console.log;
        this.modules = {};
        var load = [
            'error',
            'string',
            'regexp',
            'date',
            'math',
            'json',
            'global',
            'exec'
        ];
        this.setup(this.modules, load, imports);
        this.options = new options_1.Options();
        this.options.declare('monitor.taintMode', 'boolean', true, 'taint mode');
        this.options.declare('monitor.testMode', 'boolean', false, 'test mode');
        this.options.declare('monitor.observableMode', 'boolean', false, 'observable mode');
        var context = new context_1.Context(null, null, null);
        context.owner = '<monitor>';
        this.contextStack.push(context);
        this.instances = new Instances(global);
        this.instances.Setup();
        this.debug = { active: false };
    }
    Object.defineProperty(MonitorBase.prototype, "context", {
        // ---
        // accessors
        get: function () {
            return this.contextStack.peek();
        },
        enumerable: true,
        configurable: true
    });
    // ---
    // methods
    MonitorBase.prototype.setup = function (target, load, imports) {
        for (var i = 0, len = load.length; i < len; i++) {
            var name = load[i];
            var module = imports[name];
            if (typeof module.functor === 'function') {
                target[name] = module.functor(this);
            }
            else {
                target[name] = module;
            }
        }
    };
    // ---
    MonitorBase.prototype.initialize = function (global) {
        this.debug.active = false;
        var instanceList = [
            this.modules.error,
            this.modules.string,
            this.modules.regexp,
            this.modules.date,
            this.modules.math,
            this.modules.json
        ];
        for (var i = 0, len = instanceList.length; i < len; i++) {
            var instances = instanceList[i].allocate(global);
            prelude.copy(instances, this.instances);
        }
    };
    // ---
    MonitorBase.prototype.running = function () {
        return this.modules.exec.running();
    };
    ;
    // ---
    MonitorBase.prototype.execute = function (code, filename) {
        //console.log(code);
        this.codebuffer += "\n/* new command at " + (new Date().getTime()) + "*/\n";
        this.codebuffer += code;
        if (!this.initialized) {
            // TODO: throw error
        }
        var result = this.modules.exec.executeGlobalCode(code, filename);
        if (result.type === 'throw') {
            console.log("ERROR THROWN: " + this.codebuffer);
            throw new JSFlowError(result.value);
        }
        return result.value;
    };
    // ---
    MonitorBase.prototype.interactive = function (code, filename) {
        return this.modules.exec.executeGlobalCode(code, filename);
    };
    // ---
    MonitorBase.prototype.resume = function () {
        this.debug.active = false;
        return this.modules.exec.resume();
    };
    // ---
    MonitorBase.prototype.step = function () {
        return this.modules.exec.resume();
    };
    // ---
    MonitorBase.prototype.printWorkList = function () {
        monitor.log('context owner: ' + this.context.owner);
        monitor.log(String(this.context.workList));
    };
    // ---
    MonitorBase.prototype.require = function (name) {
        var path = name.split('/');
        var current = this.modules;
        for (var i = 0, len = path.length; i < len; i++) {
            if (current === undefined) {
                break;
            }
            current = current[path[i]];
        }
        if (!current) {
            this.fatal('Module ' + name + ' not found');
        }
        return current;
    };
    // ---
    // TODO: fix proper printing
    MonitorBase.prototype.fatal = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var exc = new FatalError(args.map(function (x) { return JSON.stringify(x); }).join(' '));
        exc.type = 'Fatal';
        throw exc;
    };
    // ---
    MonitorBase.prototype.stop = function (msg) {
        var exc = new Error(msg);
        exc.type = 'Stop';
        throw exc;
    };
    // ---
    MonitorBase.prototype.Throw = function (exc, msg, lbl) {
        this.assert(label_1.le(this.context.effectivePC, this.context.labels.exc), 'throw: effective pc ' + this.context.effectivePC +
            ' not below exception label ' + this.context.labels.exc);
        this.offendingTrace = this.stackTrace();
        throw new values_1.Value(new exc(new values_1.Value(msg, lbl)), lbl);
    };
    // ---
    MonitorBase.prototype.stackTrace = function () {
        return new StackTrace(this.contextStack.toArray());
    };
    // ---
    MonitorBase.prototype.securityError = function (message) {
        if (this.options.get('monitor.observableMode')) {
            this.warn("[Security violation] " + message);
        }
        else {
            var exc = new SecurityError(message);
            throw exc;
        }
    };
    // ---
    MonitorBase.prototype.assert = function (b, msg) {
        if (!b)
            this.securityError(msg);
    };
    // lifts exceptions that 
    // 1. are not JSFlow internal exceptions (indicated by subclass of JSFlowError)
    // 2. have a a JSFlow modeled counterpart
    // otherwise returns
    MonitorBase.prototype.tryRethrow = function (e, Throw) {
        if (e instanceof JSFlowError) {
            throw e;
        }
        if (e instanceof values_1.Value) {
            throw e;
        }
        if (Throw && this.modules.error.nativeTable[e.name] !== undefined) {
            this.Throw(this.modules.error.nativeTable[e.name], e.stack, bot);
        }
    };
    return MonitorBase;
}());
exports.MonitorBase = MonitorBase;
// --------------------------------------------------------------------------
var Monitor = /** @class */ (function (_super) {
    __extends(Monitor, _super);
    function Monitor(global, print, log, warn, error) {
        var _this = _super.call(this, global, print, log, warn, error) || this;
        _this.initialize(global);
        return _this;
    }
    return Monitor;
}(MonitorBase));
exports.Monitor = Monitor;
Monitor.prototype.initialize = function (global) {
    MonitorBase.prototype.initialize.call(this, global);
    var globalInstance = this.modules.global.allocate(global);
    prelude.copy(globalInstance, this.instances);
    this.modules.exec.initialize();
};
// --------------------------------------------------------------------------- 
var StackTrace = /** @class */ (function () {
    function StackTrace(stack) {
        this.trace = [];
        for (var i = 0, len = stack.length; i < len; i++) {
            var context = stack[i];
            var stmt = context.currentStatement;
            if (stmt === undefined) {
                break;
            }
            var loc = stmt.loc;
            var source = loc.source;
            this.trace.push({ owner: context.owner, source: source, loc: loc.start, stmt: stmt });
        }
    }
    return StackTrace;
}());
StackTrace.prototype.toString = function () {
    if (this.trace.length === 0) {
        return '';
    }
    var result;
    var len = this.trace.length;
    // last entry contains offending command
    var last = this.trace[len - 1];
    result = last.source + ':' + last.loc.line + ':' + last.loc.column + '\n';
    result = result + '    ' + escodegen.generate(last.stmt) + '\n\n';
    for (var i = len - 2; i >= 0; i--) {
        var tr = this.trace[i];
        if (tr.owner) {
            result = result + 'at ' + tr.owner + ' ';
        }
        result = result + '(' + tr.source + ':' + tr.loc.line + ':' + tr.loc.column + ')\n';
    }
    return result;
};

},{"./Constructors/ArrayConstructor":23,"./Constructors/BooleanConstructor":24,"./Constructors/FunctionConstructor":25,"./Constructors/NumberConstructor":26,"./Constructors/ObjectConstructor":27,"./Prototypes/ArrayPrototype":43,"./Prototypes/BooleanPrototype":44,"./Prototypes/FunctionPrototype":45,"./Prototypes/NumberPrototype":46,"./Prototypes/ObjectPrototype":47,"./context":51,"./date":52,"./error":55,"./exec":56,"./global":58,"./json":59,"./label":60,"./math":61,"./options":63,"./prelude":65,"./regexp":66,"./stack":68,"./string":69,"./values":75}],63:[function(require,module,exports){
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
var Option = /** @class */ (function () {
    function Option(type, val, desc) {
        this.type = type;
        this.set(val);
        this.def = this.value;
        this.description = desc;
    }
    Option.prototype.set = function (val) {
        var v = String(val);
        if (this.type === 'string') {
            this.value = v;
        }
        else if (this.type === 'boolean') {
            this.value = v === 'true' || v === '1';
        }
        else if (this.type === 'number') {
            this.value = Number(v);
        }
    };
    Option.prototype.getDefault = function () {
        return this.def;
    };
    Option.prototype.valueOf = function () {
        return this.value;
    };
    Option.prototype.toString = function () {
        return String(this.value);
    };
    return Option;
}());
// -------------------------------------------------------------
// Options
var Options = /** @class */ (function () {
    function Options() {
        this.options = [];
    }
    Options.prototype.declare = function (name, type, def, desc) {
        var description = desc ? desc : name;
        this.options[name] = new Option(type, def, description);
    };
    Options.prototype.has = function (name) {
        return this.options[name] !== undefined;
    };
    Options.prototype.get = function (name) {
        return this.options[name].valueOf();
    };
    Options.prototype.getOption = function (name) {
        return this.options[name];
    };
    Options.prototype.set = function (name, value) {
        this.options[name].set(value);
    };
    Options.prototype.keys = function () {
        var res = [];
        for (var x in this.options) {
            if (this.options.hasOwnProperty(x)) {
                res.push(x);
            }
        }
        return res;
    };
    return Options;
}());
exports.Options = Options;

},{}],64:[function(require,module,exports){
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
var escodegen_1 = require("escodegen");
exports.pretty = escodegen_1.generate;

},{"escodegen":2}],65:[function(require,module,exports){
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
function inherits(tgt, src) {
    for (var x in src.prototype) {
        if (src.prototype.hasOwnProperty(x) &&
            !tgt.prototype.hasOwnProperty(x)) {
            tgt.prototype[x] = src.prototype[x];
        }
    }
}
exports.inherits = inherits;
function copy(src, tgt) {
    for (var x in src) {
        if (src.hasOwnProperty(x)) {
            tgt[x] = src[x];
        }
    }
}
exports.copy = copy;

},{}],66:[function(require,module,exports){
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var label = require("./label");
var values_1 = require("./values");
var ecma = require("./ecma");
var constants = require("./constants");
var function_1 = require("./function");
var ArrayObject_1 = require("./Objects/ArrayObject");
var HasInstance_1 = require("./HasInstance");
var ToInteger_1 = require("./Conversion/ToInteger");
var ToString_1 = require("./Conversion/ToString");
exports.functor = function (monitor) {
    var Label = label.Label;
    var lub = label.lub;
    var glb = label.glb;
    var le = label.le;
    var bot = Label.bot;
    // ------------------------------------------------------------
    function allocate(host) {
        var regExpConstructor = new RegExpConstructor(host.RegExp);
        var regExpPrototype = regExpConstructor._proto;
        return { RegExpConstructor: regExpConstructor,
            RegExpPrototype: regExpPrototype
        };
    }
    // ------------------------------------------------------------
    // The RegExp Constructor, 15.10.5
    var RegExpConstructor = /** @class */ (function (_super) {
        __extends(RegExpConstructor, _super);
        function RegExpConstructor(host) {
            var _this = _super.call(this) || this;
            _this.Prototype = new values_1.Value(monitor.instances.FunctionPrototype, bot);
            _this.Class = 'Function';
            // not mandated by standard
            _this.Extensible = true;
            _this.host = host;
            _this._proto = new RegExpPrototype(_this, host.prototype);
            ecma.DefineFFF(_this, constants.length, 2);
            ecma.DefineFFF(_this, constants.prototype, _this._proto);
            return _this;
        }
        return RegExpConstructor;
    }(ecma.Ecma));
    RegExpConstructor.prototype.HasInstance = HasInstance_1.HasInstance;
    // 15.10.3.1
    RegExpConstructor.prototype.Call = function (thisArg, args) {
        var pattern = args[0] || new values_1.Value(undefined, bot);
        var flags = args[1] || new values_1.Value(undefined, bot);
        if (pattern.value &&
            typeof pattern.value === 'object' &&
            pattern.value.Class === 'RegExp' &&
            flags.value === undefined) {
            return pattern;
        }
        return RegExpConstructor.prototype.Construct(args);
    };
    // 15.10.4.1
    RegExpConstructor.prototype.Construct = function (args) {
        var c = monitor.context;
        var pattern = args[0] || new values_1.Value(undefined, bot);
        var flags = args[1] || new values_1.Value(undefined, bot);
        var P = "";
        var F = "";
        var l = lub(pattern.label, flags.label);
        c.pushPC(l);
        if (pattern.value &&
            typeof pattern.value === 'object' &&
            pattern.value.Class === 'RegExp') {
            if (flags.value === undefined) {
                var rx = pattern.value.PrimitiveValue;
                P = rx.source;
                F = (rx.global ? 'g' : '') + (rx.ignoreCase ? 'i' : '') + (rx.multiline ? 'm' : '');
            }
            else {
                monitor.Throw(monitor.modules.error.TypeErrorObject, '', bot);
            }
        }
        else {
            var _P = pattern.value === undefined ? new values_1.Value("", l) : ToString_1.ToString(pattern);
            var _F = flags.value === undefined ? new values_1.Value("", l) : ToString_1.ToString(flags);
            l = lub(l, _P.label, _F.label);
            P = _P.value;
            F = _F.value;
        }
        var res = new RegExpObject(new RegExp(P, F), l);
        c.popPC();
        return new values_1.Value(res, bot);
    };
    // ------------------------------------------------------------
    // The RegExp Prototype, 15.10.6
    var RegExpPrototype = /** @class */ (function (_super) {
        __extends(RegExpPrototype, _super);
        function RegExpPrototype(constructor, host) {
            var _this = _super.call(this) || this;
            _this.Class = 'RegExp';
            _this.Prototype = new values_1.Value(monitor.instances.ObjectPrototype, bot);
            _this.host = host;
            ecma.DefineFFF(_this, constants.source, '');
            ecma.DefineFFF(_this, constants.global, false);
            ecma.DefineFFF(_this, constants.ignoreCase, false);
            ecma.DefineFFF(_this, constants.multiline, false);
            ecma.DefineTFF(_this, constants.lastIndex, 0);
            ecma.DefineFFF(_this, constants.length, 0);
            ecma.DefineTFT(_this, constants.constructor, constructor);
            ecma.DefineTFT(_this, constants.exec, new function_1.BuiltinFunctionObject(exec, 1, RegExp.prototype.exec));
            ecma.DefineTFT(_this, constants.test, new function_1.BuiltinFunctionObject(test, 1, RegExp.prototype.test));
            ecma.DefineTFT(_this, constants.toString, new function_1.BuiltinFunctionObject(toString, 0, RegExp.prototype.toString));
            return _this;
        }
        return RegExpPrototype;
    }(ecma.Ecma));
    // ------------------------------------------------------------
    // exec, 15.10.6.2
    var exec = function (thisArg, args) {
        var string = args[0] || new values_1.Value(undefined, bot);
        var S = ToString_1.ToString(string);
        var lastIndex = ToInteger_1.ToInteger(thisArg.Get(constants.lastIndex));
        var pre = thisArg.value.PrimitiveValue;
        pre.lastIndex = lastIndex.value;
        var res = pre.exec(S.value);
        var l = lub(thisArg.label, S.label, lastIndex.label);
        if (res === null) {
            return new values_1.Value(null, l);
        }
        thisArg.Put(constants.lastIndex, new values_1.Value(pre.lastIndex, l));
        var array = ArrayObject_1.ArrayObject.fromArray(res, l, l);
        array.DefineOwnProperty(constants.index, { value: res.index,
            writable: true,
            enumerable: true,
            configurable: true,
            label: l
        });
        array.DefineOwnProperty(constants.input, { value: res.input,
            writable: true,
            enumerable: true,
            configurable: true,
            label: l
        });
        return new values_1.Value(array, bot);
    };
    // ------------------------------------------------------------
    // test, 15.10.6.3
    var test = function (thisArg, args) {
        var res = exec(thisArg, args);
        return new values_1.Value(res.value !== null, res.label);
    };
    // ------------------------------------------------------------
    // toString, 15.10.6.3
    var toString = function (thisArg, args) {
        return new values_1.Value(thisArg.value.PrimitiveValue.toString(), thisArg.label);
    };
    // ------------------------------------------------------------
    // RegExp Object, 15.10.4.1
    var RegExpObject = /** @class */ (function (_super) {
        __extends(RegExpObject, _super);
        function RegExpObject(nativeRegExp, l) {
            var _this = _super.call(this) || this;
            _this.Class = 'RegExp';
            _this.PrimitiveValue = nativeRegExp;
            _this.PrimitiveLabel = l;
            _this.Extensible = true;
            _this.Prototype = new values_1.Value(monitor.instances.RegExpPrototype, bot);
            _this.DefineOwnProperty(constants.source, { value: _this.PrimitiveValue.source,
                writable: false,
                enumerable: false,
                configurable: false,
                label: l
            });
            _this.DefineOwnProperty(constants.global, { value: _this.PrimitiveValue.global,
                writable: false,
                enumerable: false,
                configurable: false,
                label: l
            });
            _this.DefineOwnProperty(constants.ignoreCase, { value: _this.PrimitiveValue.ignoreCase,
                writable: false,
                enumerable: false,
                configurable: false,
                label: l
            });
            _this.DefineOwnProperty(constants.multiline, { value: _this.PrimitiveValue.multiline,
                writable: false,
                enumerable: false,
                configurable: false,
                label: l
            });
            _this.DefineOwnProperty(constants.lastIndex, { value: _this.PrimitiveValue.lastIndex,
                writable: true,
                enumerable: false,
                configurable: false,
                label: l
            });
            return _this;
        }
        return RegExpObject;
    }(ecma.Ecma));
    RegExpObject.prototype.toString = function () {
        var v = this.PrimitiveValue.toString();
        return v;
    };
    // ------------------------------------------------------------
    var module = {};
    module.RegExpObject = RegExpObject;
    module.allocate = allocate;
    return module;
};

},{"./Conversion/ToInteger":30,"./Conversion/ToString":34,"./HasInstance":37,"./Objects/ArrayObject":38,"./constants":50,"./ecma":53,"./function":57,"./label":60,"./values":75}],67:[function(require,module,exports){
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
function Set() {
    this.data = {};
    var toAdd = arguments;
    if (arguments.length === 1) {
        var arg = arguments[0];
        if (arg instanceof Array) {
            toAdd = arg;
        }
    }
    for (var i = 0, len = toAdd.length; i < len; i++) {
        var x = toAdd[i];
        if (x instanceof Set) {
            this.union(x);
        }
        else {
            this.add(x);
        }
    }
}
exports.Set = Set;
// -------------------------------------------------------------------------- 
Set.prototype.iter = function (f) {
    for (var e in this.data) {
        if (this.data.hasOwnProperty(e)) {
            f(e);
        }
    }
};
// -------------------------------------------------------------------------- 
Set.prototype.equals = function (x) {
    return (this.isSubset(x) && x.isSubset(this));
};
// -------------------------------------------------------------------------- 
Set.prototype.add = function (x) {
    this.data[x] = true;
};
// -------------------------------------------------------------------------- 
Set.prototype.union = function (x) {
    for (var e in x.data) {
        if (x.data.hasOwnProperty(e)) {
            this.data[e] = true;
        }
    }
};
// -------------------------------------------------------------------------- 
Set.prototype.del = function (x) {
    delete this.data[x];
};
// -------------------------------------------------------------------------- 
Set.prototype.intersect = function (x) {
    for (var e in this.data) {
        if (this.data.hasOwnProperty(e) && !x.data.hasOwnProperty(e)) {
            this.del(e);
        }
    }
};
// -------------------------------------------------------------------------- 
Set.prototype.isSubset = function (x) {
    for (var e in x.data) {
        if (x.data.hasOwnProperty(e) && !this.data.hasOwnProperty(e)) {
            return false;
        }
    }
    return true;
};
// -------------------------------------------------------------------------- 
Set.prototype.contains = function (x) {
    return this.data.hasOwnProperty(x);
};
// -------------------------------------------------------------------------- 
Set.prototype.toString = function () {
    var acc = [];
    for (var x in this.data) {
        if (this.data.hasOwnProperty(x)) {
            acc.push(x);
        }
    }
    if (acc.length === 0) {
        return '';
    }
    var str = acc[0];
    for (var i = 1, len = acc.length; i < len; i++) {
        str += ',' + acc[i];
    }
    return str;
};

},{}],68:[function(require,module,exports){
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
// TODO: make Stack generic
var Stack = /** @class */ (function () {
    function Stack() {
        this.content = [];
    }
    Stack.prototype.push = function (v) {
        this.content.push(v);
    };
    Stack.prototype.pop = function () {
        return this.content.pop();
    };
    Stack.prototype.peek = function () {
        return this.content[this.content.length - 1];
    };
    Stack.prototype.dup = function () {
        this.push(this.peek());
    };
    Stack.prototype.marker = function () {
        return { length: this.content.length };
    };
    Stack.prototype.reset = function (m) {
        this.content.length = m.length;
    };
    Stack.prototype.iter = function (f) {
        for (var i = 0, len = this.content.length; i < len; i++) {
            f(this.content[i]);
        }
    };
    Stack.prototype.map = function (f, m) {
        for (var i = m.length, len = this.content.length; i < len; i++) {
            this.content[i] = f(this.content[i]);
        }
    };
    Stack.prototype.size = function () {
        return this.content.length;
    };
    Stack.prototype.empty = function () {
        return this.content.length === 0;
    };
    Stack.prototype.toArray = function () {
        return this.content.slice(0);
    };
    return Stack;
}());
exports.Stack = Stack;

},{}],69:[function(require,module,exports){
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var label = require("./label");
var values_1 = require("./values");
var ecma = require("./ecma");
var constants = require("./constants");
var function_1 = require("./function");
var ArrayObject_1 = require("./Objects/ArrayObject");
var HasInstance_1 = require("./HasInstance");
var ToInteger_1 = require("./Conversion/ToInteger");
var ToUInt16_1 = require("./Conversion/ToUInt16");
var ToString_1 = require("./Conversion/ToString");
var CheckObjectCoercible_1 = require("./Utility/CheckObjectCoercible");
exports.functor = function (monitor) {
    var error = monitor.require('error');
    var Ecma = ecma.Ecma;
    var Label = label.Label;
    var lub = label.lub;
    var le = label.le;
    var bot = Label.bot;
    // ------------------------------------------------------------
    function allocate(host) {
        var stringConstructor = new StringConstructor(host.String);
        var stringPrototype = stringConstructor._proto;
        return { StringConstructor: stringConstructor,
            StringPrototype: stringPrototype
        };
    }
    // ------------------------------------------------------------
    // The String Constructor, 15.5.2
    var StringConstructor = /** @class */ (function (_super) {
        __extends(StringConstructor, _super);
        function StringConstructor(host) {
            var _this = _super.call(this) || this;
            _this.Prototype = new values_1.Value(monitor.instances.FunctionPrototype, bot);
            _this.Class = 'Function';
            // not mandated by standard
            _this.Extensible = true;
            _this.host = host;
            _this._proto = new StringPrototype(_this, host.prototype);
            ecma.DefineFFF(_this, constants.length, 1);
            ecma.DefineFFF(_this, constants.prototype, _this._proto);
            ecma.DefineTFT(_this, constants.fromCharCode, new function_1.BuiltinFunctionObject(fromCharCode, 1, _this.host.fromCharCode));
            return _this;
        }
        return StringConstructor;
    }(Ecma));
    StringConstructor.prototype.HasInstance = HasInstance_1.HasInstance;
    // 15.5.1.1 -----------------------------------------------------------------
    StringConstructor.prototype.Call = function (thisArg, args) {
        if (!args[0]) {
            return new values_1.Value('', bot);
        }
        var str = ToString_1.ToString(args[0]);
        return str;
    };
    // 15.5.2.1 ----------------------------------------------------------------- 
    StringConstructor.prototype.Construct = function (args) {
        var value = args[0];
        var str;
        if (value) {
            var x = ToString_1.ToString(value);
            str = new StringObject(x.value, x.label);
        }
        else {
            str = new StringObject('');
        }
        return new values_1.Value(str, bot);
    };
    // --------------------------------------------------------------------------
    // fromCharCode, 15.5.3.2 
    var fromCharCode = function (thisArg, args) {
        var lbl = new Label();
        var _args = [];
        for (var i = 0, len = args.length; i < len; i++) {
            var arg = ToUInt16_1.ToUInt16(args[i]);
            lbl.lub(arg.label);
            _args[i] = arg.value;
        }
        var _String = monitor.instances.StringConstructor.host;
        var v = _String.fromCharCode.apply(_String, _args);
        return new values_1.Value(v, lbl);
    };
    // ------------------------------------------------------------
    // The String Prototype, 15.5.4
    var StringPrototype = /** @class */ (function (_super) {
        __extends(StringPrototype, _super);
        function StringPrototype(constructor) {
            var _this = _super.call(this) || this;
            _this.Class = 'String';
            _this.PrimitiveValue = '';
            _this.PrimitiveLabel = bot;
            _this.Prototype = new values_1.Value(monitor.instances.ObjectPrototype, bot);
            _this.properties = new String('');
            _this.labels.length = {
                value: bot,
                existence: bot
            };
            _this.host = constructor.host.prototype;
            ecma.DefineTFT(_this, constants.constructor, constructor);
            ecma.DefineTFT(_this, constants.toString, new function_1.BuiltinFunctionObject(toString, 0, _this.host.toString));
            ecma.DefineTFT(_this, new values_1.Value('valueOf', bot), new function_1.BuiltinFunctionObject(valueOf, 0, _this.host.valueOf));
            ecma.DefineTFT(_this, constants.charAt, new function_1.BuiltinFunctionObject(charAt, 1, _this.host.charAt));
            ecma.DefineTFT(_this, constants.charCodeAt, new function_1.BuiltinFunctionObject(charCodeAt, 1, _this.host.charCodeAt));
            ecma.DefineTFT(_this, constants.concat, new function_1.BuiltinFunctionObject(concat, 1, _this.host.concat));
            ecma.DefineTFT(_this, constants.indexOf, new function_1.BuiltinFunctionObject(indexOf, 1, _this.host.indexOf));
            ecma.DefineTFT(_this, constants.lastIndexOf, new function_1.BuiltinFunctionObject(lastIndexOf, 1, _this.host.lastIndexOf));
            ecma.DefineTFT(_this, constants.localeCompare, new function_1.BuiltinFunctionObject(localeCompare, 1, _this.host.localeCompare));
            ecma.DefineTFT(_this, constants.match, new function_1.BuiltinFunctionObject(match, 1, _this.host.match));
            ecma.DefineTFT(_this, constants.replace, new function_1.BuiltinFunctionObject(replace, 2, _this.host.replace));
            ecma.DefineTFT(_this, constants.search, new function_1.BuiltinFunctionObject(search, 1, _this.host.search));
            ecma.DefineTFT(_this, constants.slice, new function_1.BuiltinFunctionObject(slice, 2, _this.host.slice));
            ecma.DefineTFT(_this, constants.split, new function_1.BuiltinFunctionObject(split, 2, _this.host.split));
            ecma.DefineTFT(_this, constants.substring, new function_1.BuiltinFunctionObject(substring, 2, _this.host.substring));
            ecma.DefineTFT(_this, constants.toLowerCase, new function_1.BuiltinFunctionObject(toLowerCase, 0, _this.host.toLowerCase));
            ecma.DefineTFT(_this, constants.toLocaleLowerCase, new function_1.BuiltinFunctionObject(toLocaleLowerCase, 0, _this.host.toLocaleLowerCase));
            ecma.DefineTFT(_this, constants.toUpperCase, new function_1.BuiltinFunctionObject(toUpperCase, 0, _this.host.toUpperCase));
            ecma.DefineTFT(_this, constants.toLocaleUpperCase, new function_1.BuiltinFunctionObject(toLocaleUpperCase, 0, _this.host.toLocaleUpperCase));
            ecma.DefineTFT(_this, constants.trim, new function_1.BuiltinFunctionObject(trim, 0, _this.host.trim));
            ecma.DefineTFT(_this, constants.substr, new function_1.BuiltinFunctionObject(substr, 2, _this.host.substr));
            return _this;
        }
        return StringPrototype;
    }(Ecma));
    // ------------------------------------------------------------
    // toString, 15.5.4.2
    var toString = function (thisArg, args) {
        if (typeof thisArg.value === 'string') {
            return thisArg;
        }
        if (typeof thisArg.value !== 'object' || thisArg.value.Class !== 'String') {
            monitor.Throw(error.TypeErrorObject, 'String.prototype.toString is not generic', thisArg.label);
        }
        var result = thisArg.value.PrimitiveValue.toString();
        return new values_1.Value(result, thisArg.value.PrimitiveLabel);
    };
    // ------------------------------------------------------------
    // valueOf, 15.5.4.3
    var valueOf = toString;
    // ------------------------------------------------------------
    // charAt, 15.5.4.4
    var charAt = function (thisArg, args) {
        var pos = args[0] || new values_1.Value(undefined, bot);
        CheckObjectCoercible_1.CheckObjectCoercible(thisArg);
        var S = ToString_1.ToString(thisArg);
        var position = ToInteger_1.ToInteger(pos);
        var c = S.value.charAt(position.value);
        return new values_1.Value(c, lub(position.label, S.label));
    };
    // ------------------------------------------------------------
    // charCodeAt, 15.5.4.5
    var charCodeAt = function (thisArg, args) {
        var pos = args[0] || new values_1.Value(undefined, bot);
        CheckObjectCoercible_1.CheckObjectCoercible(thisArg);
        var S = ToString_1.ToString(thisArg);
        var position = ToInteger_1.ToInteger(pos);
        var c = S.value.charCodeAt(position.value);
        return new values_1.Value(c, lub(position.label, thisArg.label));
    };
    // ------------------------------------------------------------
    // concat, 15.5.4.6
    var concat = function (thisArg, args) {
        CheckObjectCoercible_1.CheckObjectCoercible(thisArg);
        var S = ToString_1.ToString(thisArg);
        var lbl = new Label();
        var _args = [];
        for (var i = 0, len = args.length; i < len; i++) {
            var arg = ToString_1.ToString(args[i]);
            lbl.lub(arg.label);
            _args[i] = arg.value;
        }
        var str = S.value.concat.apply(S.value, _args);
        lbl.lub(thisArg.label);
        return new values_1.Value(str, lbl);
    };
    // ------------------------------------------------------------
    // indexOf, 15.5.4.7
    var indexOf = function (thisArg, args) {
        var searchString = args[0] || new values_1.Value(undefined, bot);
        var position = args[1] || new values_1.Value(0, bot);
        CheckObjectCoercible_1.CheckObjectCoercible(thisArg);
        var S = ToString_1.ToString(thisArg);
        var searchStr = ToString_1.ToString(searchString);
        var pos = ToInteger_1.ToInteger(position);
        var lbl = lub(S.label, searchStr.label, pos.label);
        var str = S.value.indexOf(searchStr.value, pos.value);
        return new values_1.Value(str, lbl);
    };
    // ------------------------------------------------------------
    // lastIndexOf, 15.5.4.8
    var lastIndexOf = function (thisArg, args) {
        var searchString = args[0] || new values_1.Value(undefined, bot);
        var position = args[1] || new values_1.Value(undefined, bot);
        CheckObjectCoercible_1.CheckObjectCoercible(thisArg);
        var S = ToString_1.ToString(thisArg);
        var searchStr = ToString_1.ToString(searchString);
        var pos = ToInteger_1.ToInteger(position);
        var lbl = lub(S.label, searchStr.label, pos.label);
        var str = S.value.lastIndexOf(searchStr.value, pos.value);
        return new values_1.Value(str, lbl);
    };
    // ------------------------------------------------------------
    // localeCompare, 15.5.4.9
    var localeCompare = function (thisArg, args) {
        var that = args[0] || new values_1.Value(undefined, bot);
        CheckObjectCoercible_1.CheckObjectCoercible(thisArg);
        var S = ToString_1.ToString(thisArg);
        that = ToString_1.ToString(that);
        var lbl = lub(S.label, that.label);
        var result = S.value.localeCompare(that.value);
        return new values_1.Value(result, lbl);
    };
    // ------------------------------------------------------------
    // match, 15.5.4.10
    var match = function (thisArg, args) {
        var regexp = args[0] || new values_1.Value(undefined, bot);
        CheckObjectCoercible_1.CheckObjectCoercible(thisArg);
        var S = ToString_1.ToString(thisArg);
        var rx = regexp;
        if (rx.value === null || typeof rx.value !== 'object' || rx.value.Class !== 'RegExp') {
            rx = monitor.instances.RegExpConstructor.Construct([regexp]);
        }
        var lbl = lub(S.label, rx.value.PrimitiveLabel);
        monitor.assert(le(rx.label, rx.value.PrimitiveLabel), 'String.prototype.match: label of regular expression object not below regular expression label');
        rx.value.PrimitiveLabel = lbl;
        var primitiveArray = S.value.match(rx.value.PrimitiveValue);
        if (primitiveArray === null) {
            return new values_1.Value(null, lbl);
        }
        var array = ArrayObject_1.ArrayObject.fromArray(primitiveArray, lbl, lbl);
        array.DefineOwnProperty(constants.index, { value: primitiveArray.index,
            writable: true,
            enumerable: true,
            configurable: true,
            label: lbl
        });
        array.DefineOwnProperty(constants.input, { value: primitiveArray.input,
            writable: true,
            enumerable: true,
            configurable: true,
            label: lbl
        });
        return new values_1.Value(array, bot);
    };
    // ------------------------------------------------------------
    // replace, 15.5.4.11
    var replace = function (thisArg, args) {
        var searchValue = args[0] || new values_1.Value(undefined, bot);
        var replaceValue = args[1] || new values_1.Value(undefined, bot);
        CheckObjectCoercible_1.CheckObjectCoercible(thisArg);
        var S = ToString_1.ToString(thisArg);
        var sV, rV;
        if (typeof searchValue.value === 'object' && searchValue.value.Class === 'RegExp') {
            sV = searchValue.value.PrimitiveValue;
        }
        else {
            searchValue = ToString_1.ToString(searchValue);
            sV = searchValue.value;
        }
        var fL = bot;
        if (typeof replaceValue.value === 'object' && replaceValue.value.Class === 'Function') {
            rV = function () {
                var l = lub(searchValue.label, replaceValue.label);
                var _args = {};
                for (var i = 0; i < arguments.length; i++) {
                    _args[i] = new values_1.Value(arguments[i], l);
                }
                _args.length = arguments.length;
                var res = replaceValue.Call(replaceValue, _args);
                fL = lub(fL, res.label);
                return res.value;
            };
        }
        else {
            replaceValue = ToString_1.ToString(replaceValue);
            rV = replaceValue.value;
        }
        var l = lub(searchValue.label, replaceValue.label);
        var res = S.value.replace(sV, rV);
        return new values_1.Value(res, lub(l, fL));
    };
    // ------------------------------------------------------------
    // search, 15.5.4.12
    var search = function (thisArg, args) {
        var regexp = args[0] || new values_1.Value(undefined, bot);
        CheckObjectCoercible_1.CheckObjectCoercible(thisArg);
        var string = ToString_1.ToString(thisArg);
        var rx = regexp;
        if (rx.value === null || typeof regexp.value !== 'object' || regexp.value.Class !== 'RegExp') {
            rx = monitor.instances.RegExpConstructor.Construct([regexp]);
        }
        var lbl = lub(string.label, rx.value.PrimitiveLabel);
        monitor.assert(le(rx.label, rx.value.PrimitiveLabel), 'String.prototype.match: label of regular expression object not below regular expression label');
        rx.value.PrimitiveLabel = lbl;
        var result = string.value.search(rx.value.PrimitiveValue);
        return new values_1.Value(result, lbl);
    };
    // ------------------------------------------------------------
    // slice, 15.5.4.13
    var slice = function (thisArg, args) {
        var c = monitor.context;
        var start = args[0] || new values_1.Value(undefined, bot);
        var end = args[1] || new values_1.Value(undefined, bot);
        CheckObjectCoercible_1.CheckObjectCoercible(thisArg);
        var S = ToString_1.ToString(thisArg);
        var len = S.value.length;
        var intStart = ToInteger_1.ToInteger(start);
        c.pushPC(end.label);
        if (end.value === undefined) {
            end = new values_1.Value(len, lub(S.label, end.label));
        }
        else {
            end = ToInteger_1.ToInteger(end);
        }
        c.popPC();
        var str = S.value.slice(start.value, end.value);
        var lbl = lub(S.label, start.label, end.label);
        return new values_1.Value(str, lbl);
    };
    // ------------------------------------------------------------
    // split, 15.5.4.14
    var split = function (thisArg, args) {
        var separator = args[0] || new values_1.Value(undefined, bot);
        var limit = args[1] || new values_1.Value(undefined, bot);
        CheckObjectCoercible_1.CheckObjectCoercible(thisArg);
        var S = ToString_1.ToString(thisArg);
        var sep;
        var lbl = lub(S.label, separator.label);
        if (separator.value && typeof separator.value === 'object' && separator.value.Class === 'RegExp') {
            sep = separator.value.PrimitiveValue;
            monitor.assert(le(separator.label, separator.value.PrimitiveLabel), 'String.prototype.split: label of regular expression object not below label of regular expression');
            separator.value.PrimitiveLabel = lbl;
        }
        else {
            separator = ToString_1.ToString(separator);
            sep = separator.value;
            lbl.lub(separator.label);
        }
        lbl.lub(limit.label);
        var primitiveArray = S.value.split(sep, limit.value);
        var array = ArrayObject_1.ArrayObject.fromArray(primitiveArray, lbl, lbl);
        return new values_1.Value(array, bot);
    };
    // ------------------------------------------------------------
    // substring, 15.5.4.15
    var substring = function (thisArg, args) {
        var start = args[0] || new values_1.Value(undefined, bot);
        var end = args[1] || new values_1.Value(undefined, bot);
        CheckObjectCoercible_1.CheckObjectCoercible(thisArg);
        var S = ToString_1.ToString(thisArg);
        start = ToInteger_1.ToInteger(start);
        var len = S.value.length;
        if (end.value === undefined) {
            end.value = len;
        }
        else {
            end = ToInteger_1.ToInteger(end);
        }
        var lbl = lub(S.label, start.label, end.label);
        var str = S.value.substring(start.value, end.value);
        return new values_1.Value(str, lbl);
    };
    // ------------------------------------------------------------
    var substr = function (thisArg, args) {
        var start = args[0] || new values_1.Value(undefined, 0);
        var length = args[1] || new values_1.Value(undefined, 0);
        CheckObjectCoercible_1.CheckObjectCoercible(thisArg);
        var S = ToString_1.ToString(thisArg);
        start = ToInteger_1.ToInteger(start);
        if (length.value === undefined) {
            length.value = len;
        }
        else {
            length = ToInteger_1.ToInteger(length);
        }
        var lbl = lub(S.label, start.label, length.label);
        var str = S.value.substr(start.value, length.value);
        return new values_1.Value(str, lbl);
    };
    // ------------------------------------------------------------
    // toLowerCase, 15.5.4.16
    var toLowerCase = function (thisArg, args) {
        CheckObjectCoercible_1.CheckObjectCoercible(thisArg);
        var S = ToString_1.ToString(thisArg);
        var L = S.value.toLowerCase();
        return new values_1.Value(L, S.label);
    };
    // ------------------------------------------------------------
    // toLocaleLowerCase, 15.5.4.17
    var toLocaleLowerCase = function (thisArg, args) {
        CheckObjectCoercible_1.CheckObjectCoercible(thisArg);
        var S = ToString_1.ToString(thisArg);
        var L = S.value.toLocaleLowerCase();
        return new values_1.Value(L, S.label);
    };
    // ------------------------------------------------------------
    // toUpperCase, 15.5.4.18
    var toUpperCase = function (thisArg, args) {
        CheckObjectCoercible_1.CheckObjectCoercible(thisArg);
        var S = ToString_1.ToString(thisArg);
        var L = S.value.toUpperCase();
        return new values_1.Value(L, S.label);
    };
    // ------------------------------------------------------------
    // toLocaleUpperCase, 15.5.4.19
    var toLocaleUpperCase = function (thisArg, args) {
        CheckObjectCoercible_1.CheckObjectCoercible(thisArg);
        var S = ToString_1.ToString(thisArg);
        var L = S.value.toLocaleUpperCase();
        return new values_1.Value(L, S.label);
    };
    // ------------------------------------------------------------
    // trim, 15.5.4.20
    var trim = function (thisArg, args) {
        CheckObjectCoercible_1.CheckObjectCoercible(thisArg);
        var S = ToString_1.ToString(thisArg);
        var T = S.value.trim();
        return new values_1.Value(T, S.label);
    };
    // ------------------------------------------------------------
    // String Object, 15.5.5
    var StringObject = /** @class */ (function (_super) {
        __extends(StringObject, _super);
        function StringObject(val, lbl) {
            var _this = _super.call(this) || this;
            _this.Class = 'String';
            _this.PrimitiveValue = val;
            lbl = lbl || bot;
            _this.PrimitiveLabel = lbl;
            _this.properties = new String(val);
            for (var i = 0, len = val.length; i < len; i++) {
                _this.labels[i] = {
                    value: lbl,
                    existence: lbl
                };
            }
            _this.labels.length = {
                value: lbl,
                existence: lbl
            };
            _this.Extensible = true;
            _this.Prototype = new values_1.Value(monitor.instances.StringPrototype, bot);
            return _this;
            // length is not modeled in this way, but by GetOwnProperty; however, e.g.,
            // delete will use the properties field for deletion. Thus, we add a fake model.
            //   ecma.DefineFFF(this, constants.length, 0);
        }
        return StringObject;
    }(Ecma));
    // ---
    // TODO: we don't copy other properties on the Strings
    /*
      StringObject.prototype.toNative = function(deep) {
        var v = new String(this.properties);
        return new Value(v, this.PrimitiveLabel);
      };
    */
    // ---
    // ------------------------------------------------------------
    var module = {};
    module.StringObject = StringObject;
    module.allocate = allocate;
    return module;
};

},{"./Conversion/ToInteger":30,"./Conversion/ToString":34,"./Conversion/ToUInt16":35,"./HasInstance":37,"./Objects/ArrayObject":38,"./Utility/CheckObjectCoercible":48,"./constants":50,"./ecma":53,"./function":57,"./label":60,"./values":75}],70:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var monitor_1 = require("../monitor");
var policy_1 = require("../policy");
var prelude = require("../../prelude");
var path = require("path");

var imports = {
    window: require('./window')
};
var ChromeMonitor = /** @class */ (function (_super) {
    __extends(ChromeMonitor, _super);
    function ChromeMonitor(global, print, log, warn, error) {
        var _this = _super.call(this, global, print, log, warn, error) || this;
        // setup dom specific modules
        _this.modules.chrome = {};
        var load = [
            'window'
        ];
        _this.setup(_this.modules.chrome, load, imports);
        _this.initialize(global);
        return _this;
    }
    ChromeMonitor.prototype.initialize = function (global) {
        _super.prototype.initialize.call(this, global);
        var policies = JSON.parse("{\n   \n}");
        this.policy = new policy_1.SecurityPolicy(policies);
        var globalInstance = this.modules.chrome.window.allocate(global);
        prelude.copy(globalInstance, this.instances);
        this.entitymap.set(this.instances.globalObject.host, this.instances.globalObject);
        this.modules.exec.initialize();
        this.initialized = true;
    };
    ;
    return ChromeMonitor;
}(monitor_1.WrapperMonitorBase));
exports.ChromeMonitor = ChromeMonitor;



},{"../../prelude":65,"../monitor":73,"../policy":74,"./window":71,"path":76}],71:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var entity_1 = require("../entity");
var ecma = require("../../ecma");
var values_1 = require("../../values");
exports.functor = function (monitor) {
    var global = monitor.require('global');
    // -------------------------------------------------------------------------- 
    function allocate(host) {
        var wo = new WindowObject(host);
        return { globalObject: wo };
    }
    function has_own_property(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    // -------------------------------------------------------------------------- 
    var WindowObject = /** @class */ (function (_super) {
        __extends(WindowObject, _super);
        function WindowObject(host) {
            var e_1, _a;
            var _this = _super.call(this, host) || this;
            _this.predefined = {};
            try {
                for (var _b = __values(Object.getOwnPropertyNames(_this.properties)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var p = _c.value;
                    _this.predefined[p] = true;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            _this.modelstate = monitor.policy.globalmodelstate;
            monitor.entitymap.set(host, _this);
            return _this;
        }
        // default policy 
        // 1. read through disabled for predefined properties
        // 2. read-through disabled for JSFlow defined properties
        WindowObject.prototype.GetOwnProperty = function (p) {
            if (!has_own_property(this.host, p.value)
                || has_own_property(this.predefined, p.value)) {
                return _super.prototype.GetOwnProperty.call(this, p);
            }
            var propertyLabeler = monitor.policy.global.GetPropertyLabeler(p.value);
            var label = propertyLabeler.Labeler.Label(this.modelstate);
            if (!has_own_property(this.labels, p.value)) {
                this.labels[p.value] = {
                    value: label,
                    existence: p.label
                };
            }
            var jsdesc = Object.getOwnPropertyDescriptor(this.host, p.value);
            if (jsdesc === undefined) {
                return new values_1.Value(undefined, label);
            }
            if (has_own_property(this.properties, p.value)
                && (ecma.IsDataDescriptor(jsdesc) && !jsdesc.writable ||
                    ecma.IsAccessorDescriptor(jsdesc) && !jsdesc.configurable)) {
                // non-writable propert or non-configurable accessor means cannot be updated
                // return what is there           
                return _super.prototype.GetOwnProperty.call(this, p);
            }
            var desc = entity_1.relabelPropertyDescriptor(jsdesc, propertyLabeler.ReadLabeler, this.modelstate);
            Object.defineProperty(this.properties, p.value, desc);
            return _super.prototype.GetOwnProperty.call(this, p);
        };
        // default policy 
        // 1. write through disabled for predefined properties
        // 2. write through disabled for JSFlow defined properties
        WindowObject.prototype.DefineOwnProperty = function (p, desc, Throw) {
            if (has_own_property(this.predefined, p.value)
                || !has_own_property(this.host, p.value)) {
                return _super.prototype.DefineOwnProperty.call(this, p, desc, Throw);
            }
            var propertyLabeler = monitor.policy.global.GetPropertyLabeler(p.value);
            if (!has_own_property(this.labels, p.value)) {
                var label = propertyLabeler.Labeler.Label(this.modelstate);
                this.labels[p.value] = {
                    value: label,
                    existence: p.label
                };
            }
            var jsdesc = entity_1.unlabelPropertyDescriptor(desc, propertyLabeler.WriteUnlabeler, this.modelstate);
            var hostResult = Object.defineProperty(this.host, p.value, jsdesc);
            var result = _super.prototype.DefineOwnProperty.call(this, p, desc, Throw);
            result.value = hostResult;
            return result;
        };
        return WindowObject;
    }(global.GlobalObject));
    var module = {};
    module.WindowObject = WindowObject;
    module.allocate = allocate;
    return module;
};

},{"../../ecma":53,"../../values":75,"../entity":72}],72:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
// temporary hack to get types in
var policy_1 = require("./policy");
var ecma_1 = require("../ecma");
var FunctionObject_1 = require("../Objects/FunctionObject");
var label_1 = require("../label");
var values_1 = require("../values");
var bot = label_1.Label.bot;
// --------------------------------------------------------------------------
function has_own_property(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
}
// --------------------------------------------------------------------------
// --- EntityObject
// --------------------------------------------------------------------------
var EntityObject = /** @class */ (function (_super) {
    __extends(EntityObject, _super);
    function EntityObject(host, labeler, outermodelstate) {
        var _this = _super.call(this) || this;
        if (labeler === undefined) {
            throw new Error('EntityObject: undefined labelmodel');
        }
        _this.modelstate = new policy_1.ModelState(outermodelstate);
        _this.Class = 'Object';
        _this.host = host;
        _this.labeler = labeler;
        return _this;
    }
    Object.defineProperty(EntityObject.prototype, "Prototype", {
        get: function () {
            if (this.labeledprototype === undefined) {
                var prototypeLabeler = this.labeler.PrototypeLabeler;
                var descLabeler = prototypeLabeler.ReadLabeler;
                var value = relabel(Object.getPrototypeOf(this.host), descLabeler.ValueLabeler, this.modelstate);
                // TODO: what about this label - should we keep it?
                var label1 = prototypeLabeler.Labeler.Label(this.modelstate);
                var label2 = descLabeler.Labeler.Label(this.modelstate);
                this.labeledprototype = new values_1.Value(value, label_1.lub(label1, label2));
            }
            return this.labeledprototype;
        },
        enumerable: true,
        configurable: true
    });
    // TODO: This one should be a lot more clever....
    EntityObject.prototype.toString = function () {
        return this.host.toString();
    };
    // ---
    EntityObject.prototype.GetOwnProperty = function (p) {
        if (!has_own_property(this.host, p.value)) {
            return _super.prototype.GetOwnProperty.call(this, p);
        }
        var propertyLabeler = this.labeler.GetPropertyLabeler(p.value);
        var label = propertyLabeler.Labeler.Label(this.modelstate);
        if (!has_own_property(this.labels, p.value)) {
            this.labels[p.value] = {
                value: label,
                existence: p.label
            };
        }
        var jsdesc = Object.getOwnPropertyDescriptor(this.host, p.value);
        if (jsdesc === undefined) {
            return new values_1.Value(undefined, label);
        }
        if (has_own_property(this.properties, p.value)
            && (ecma_1.IsDataDescriptor(jsdesc) && !jsdesc.writable ||
                ecma_1.IsAccessorDescriptor(jsdesc) && !jsdesc.configurable)) {
            // non-writable propert or non-configurable accessor means cannot be updated
            // return what is there           
            return _super.prototype.GetOwnProperty.call(this, p);
        }
        var desc = relabelPropertyDescriptor(jsdesc, propertyLabeler.ReadLabeler, this.modelstate);
        desc.label.lub(label);
        Object.defineProperty(this.properties, p.value, desc);
        return _super.prototype.GetOwnProperty.call(this, p);
    };
    // ---
    EntityObject.prototype.DefineOwnProperty = function (p, desc, Throw) {
        var propertyLabeler = this.labeler.GetPropertyLabeler(p.value);
        if (has_own_property(this.host, p.value)
            && !has_own_property(this.labels, p.value)) {
            var label = propertyLabeler.Labeler.Label(this.modelstate);
            this.labels[p.value] = {
                value: label,
                existence: label_1.lub(p.label, label)
            };
        }
        _super.prototype.DefineOwnProperty.call(this, p, desc, Throw);
        var jsdesc = unlabelPropertyDescriptor(desc, propertyLabeler.WriteUnlabeler, this.modelstate);
        Object.defineProperty(this.host, p.value, jsdesc);
        return new values_1.Value(true, bot);
    };
    // ---
    EntityObject.prototype.getOwnEnumerablePropertyNames = function (label) {
        var e_1, _a;
        var enumerables = _super.prototype.getOwnEnumerablePropertyNames.call(this, label);
        // Need this to ensure we're not pushing properties from this.host that
        // were already present in this.properties.
        var ownPropNames = Object.getOwnPropertyNames(this.properties);
        var hostNames = Object.getOwnPropertyNames(this.host);
        try {
            for (var hostNames_1 = __values(hostNames), hostNames_1_1 = hostNames_1.next(); !hostNames_1_1.done; hostNames_1_1 = hostNames_1.next()) {
                var name = hostNames_1_1.value;
                if (!ownPropNames.includes(name)) {
                    var desc = Object.getOwnPropertyDescriptor(this.host, name);
                    // @ts-ignore desc is not undefined
                    if (desc.enumerable) {
                        enumerables.push(new values_1.Value(name, label));
                    }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (hostNames_1_1 && !hostNames_1_1.done && (_a = hostNames_1.return)) _a.call(hostNames_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return enumerables;
    };
    return EntityObject;
}(ecma_1.Ecma));
exports.EntityObject = EntityObject;
// --------------------------------------------------------------------------
// --- EntityFunction
// --------------------------------------------------------------------------
var EntityFunction = /** @class */ (function (_super) {
    __extends(EntityFunction, _super);
    function EntityFunction(host, labelmodel, outermodelstate) {
        var _this = _super.call(this, host, labelmodel, outermodelstate) || this;
        _this.Class = 'Function';
        return _this;
    }
    // ---
    EntityFunction.prototype.Call = function (thisVal, args) {
        var modelstate = new policy_1.ModelState(this.modelstate);
        monitor.policy.PushModelState(modelstate);
        var argsunlabelmodels = this.labeler.ArgumentsUnlabeler;
        for (var i = 0, j = 0; i < args.length; i++, j++) {
            while (!argsunlabelmodels.GetArgumentUnlabeler(j).ModelFor(args[i])) {
                j++;
            }
            args[i] = unlabelValue(args[i], argsunlabelmodels.GetArgumentUnlabeler(j), modelstate);
        }
        var thisunlabelmodel = this.labeler.SelfUnlabeler;
        var unlabeledThis = unlabelValue(thisVal, thisunlabelmodel, modelstate);
        var result;
        try {
            result = this.host.apply(unlabeledThis, args);
        }
        catch (e) {
            // may rethrow translated excpetion, otherwise we rethrow ourselves
            monitor.tryRethrow(e, true);
            var excmodel = this.labeler.GetExceptionLabelModel(e.name);
            var le = new EntityObject(e, excmodel, this.modelstate);
            var exclabel = this.labeler.GetExceptionLabel(e.name);
            throw new values_1.Value(le, exclabel);
        }
        var returnlabelmodel = this.labeler.ReturnLabeler;
        var returnlabel = returnlabelmodel.Labeler.Label(modelstate);
        var labeledvalue = relabel(result, returnlabelmodel.ValueLabeler, modelstate);
        monitor.policy.PopModelState();
        return new values_1.Value(labeledvalue, returnlabel);
    };
    // ---
    EntityFunction.prototype.Construct = function (args) {
        var modelstate = new policy_1.ModelState(this.modelstate);
        monitor.policy.PushModelState(modelstate);
        var argsunlabelmodels = this.labeler.ArgumentsUnlabeler;
        for (var i = 0, j = 0; i < args.length; i++, j++) {
            while (!argsunlabelmodels.GetArgumentUnlabeler(j).ModelFor(args[i])) {
                j++;
            }
            args[i] = unlabelValue(args[i], argsunlabelmodels.GetArgumentUnlabeler(j), modelstate);
        }
        var stringArgs;
        for (var i = 0; i < args.length; i++) {
            if (stringArgs === undefined) {
                stringArgs = "args[" + i + "]";
            }
            else {
                stringArgs += ", args[" + i + "]";
            }
        }
        var result;
        try {
            result = eval("result = new this.host(" + stringArgs + ");");
        }
        catch (e) {
            monitor.tryRethrow(e, true);
            var excmodel = this.labeler.GetExceptionLabelModel(e.name);
            var le = new EntityObject(e, excmodel, this.modelstate);
            var exclabel = this.labeler.GetExceptionLabel(e.name);
            throw new values_1.Value(le, exclabel);
        }
        var returnlabelmodel = this.labeler.ReturnLabeler;
        var returnlabel = returnlabelmodel.Labeler.Label(modelstate);
        var labeledvalue = relabel(result, returnlabelmodel.ValueLabeler, modelstate);
        monitor.policy.PopModelState();
        return new values_1.Value(labeledvalue, returnlabel);
    };
    return EntityFunction;
}(EntityObject));
exports.EntityFunction = EntityFunction;
// --------------------------------------------------------------------------
// --- relabelPropertyDescriptor :: NativeValue -> EntityObject
// --------------------------------------------------------------------------
function relabelPropertyDescriptor(desc, descriptorLabeler, modelstate) {
    var e_2, _a;
    var jsfdesc = {
        label: descriptorLabeler.Labeler.Label(modelstate)
    };
    var boolProperties = ['configurable', 'enumerable', 'writable'];
    try {
        for (var boolProperties_1 = __values(boolProperties), boolProperties_1_1 = boolProperties_1.next(); !boolProperties_1_1.done; boolProperties_1_1 = boolProperties_1.next()) {
            var key = boolProperties_1_1.value;
            if (desc[key] !== undefined) {
                jsfdesc[key] = desc[key];
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (boolProperties_1_1 && !boolProperties_1_1.done && (_a = boolProperties_1.return)) _a.call(boolProperties_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    if (ecma_1.IsAccessorDescriptor(desc)) {
        if (desc.get) {
            var Get_1 = new EntityFunction(desc.get, descriptorLabeler.GetterLabeler, modelstate);
            jsfdesc.get = function () { return Get_1.Call(new values_1.Value(this, bot), []); };
            // @ts-ignore
            jsfdesc.get.actualFunction = Get_1;
        }
        if (desc.set) {
            var Set_1 = new EntityFunction(desc.set, descriptorLabeler.SetterLabeler, modelstate);
            jsfdesc.set = function (v) { return Set_1.Call(new values_1.Value(this, bot), [v]); };
            // @ts-ignore
            jsfdesc.set.actualFunction = Set_1;
        }
    }
    else if (ecma_1.IsDataDescriptor(desc)) {
        jsfdesc.value = relabel(desc.value, descriptorLabeler.ValueLabeler, modelstate);
    }
    else {
        monitor.Throw(monitor.modules.error.ErrorObject, 'Entity.relabelPropertyDescriptor: got something that is not a descriptor!', bot);
    }
    return jsfdesc;
}
exports.relabelPropertyDescriptor = relabelPropertyDescriptor;
// ---
function MkValue(value, valueLabeler, modelstate) {
    var label = valueLabeler.Labeler.Label(modelstate);
    var labeledvalue = relabel(value, valueLabeler.ValueLabeler, modelstate);
    return new values_1.Value(labeledvalue, label);
}
// --------------------------------------------------------------------------
// --- relabel :: EntityObject -> Policy -> NativeValue -> EntityObject
// --------------------------------------------------------------------------
// We don't want to return a value, since relabel is used in, e.g., descriptors
function relabel(value, labeler, modelstate) {
    if (typeof value === 'string' ||
        typeof value === 'number' ||
        typeof value === 'undefined' ||
        typeof value === 'boolean') {
        return value;
    }
    if (value === null) {
        return null;
    }
    if (monitor.entitymap.has(value)) {
        return monitor.entitymap.get(value);
    }
    var res;
    if (value instanceof Function) {
        res = new EntityFunction(value, labeler, modelstate);
    }
    else {
        res = new EntityObject(value, labeler, modelstate);
    }
    try {
        monitor.entitymap.set(value, res);
    }
    catch (e) {
        monitor.warn('Cannot map ', value.toString());
    }
    return res;
}
exports.relabel = relabel;
// --------------------------------------------------------------------------
// --- unlabelPropertyDescriptor :: EntityObject -> NativeValue
// --------------------------------------------------------------------------
function unlabelPropertyDescriptor(jsflowdesc, unlabelmodel, modelstate) {
    var e_3, _a;
    var boolProperties = ['configurable', 'enumerable', 'writable'];
    var desc = {};
    try {
        for (var boolProperties_2 = __values(boolProperties), boolProperties_2_1 = boolProperties_2.next(); !boolProperties_2_1.done; boolProperties_2_1 = boolProperties_2.next()) {
            var key = boolProperties_2_1.value;
            if (jsflowdesc[key] !== undefined) {
                desc[key] = jsflowdesc[key];
            }
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (boolProperties_2_1 && !boolProperties_2_1.done && (_a = boolProperties_2.return)) _a.call(boolProperties_2);
        }
        finally { if (e_3) throw e_3.error; }
    }
    if (ecma_1.IsAccessorDescriptor(jsflowdesc)) {
        if (jsflowdesc.get) {
            desc.get = unlabel(jsflowdesc.get, unlabelmodel.GetterUnlabeler, modelstate);
        }
        if (jsflowdesc.set) {
            desc.set = unlabel(jsflowdesc.set, unlabelmodel.SetterUnlabeler, modelstate);
        }
    }
    else if (ecma_1.IsDataDescriptor(jsflowdesc)) {
        var valueUnlabeler = desc.value = unlabel(jsflowdesc.value, unlabelmodel.ValueUnlabeler, modelstate);
    }
    else {
        monitor.Throw(monitor.modules.error.ErrorObject, 'Entity.unlabelPropertyDescriptor: got something that is not a descriptor!', bot);
    }
    return desc;
}
exports.unlabelPropertyDescriptor = unlabelPropertyDescriptor;
// --------------------------------------------------------------------------
// --- unlabel :: EntityObject -> Policy -> NativeValue
// --------------------------------------------------------------------------
// TODO: how to handle non-standard interactions (Object.X, Reflect.X, __protot__, instanceof)
function handler(jsflowobject, abstractname) {
    if (abstractname === undefined) {
        monitor.fatal('exec.js, handler, undefined abstract name');
    }
    if (typeof abstractname !== 'string') {
        monitor.fatal('unlabel handler, abstract name is not a string but', abstractname);
    }
    return {
        // ---
        // Object.getPrototypeOf(), Reflect.getPrototypeOf(), __proto__, Object.prototype.isPrototypeOf(), instanceof
        getPrototypeOf: function (target) {
            var modelstate = monitor.policy.CurrentModelState;
            var unlabeler = modelstate.GetModel(abstractname);
            var prototypeUnlabeler = unlabeler.PrototypeUnlabeler;
            var prototype = prototypeUnlabeler.Unlabeler.Unlabel(jsflowobject.Prototype, modelstate);
            var descLabeler = prototypeUnlabeler.ReadUnlabeler;
            var jsprototype = unlabel(prototype, descLabeler.ValueUnlabeler, modelstate);
            return jsprototype;
        },
        // ---
        // Object.setPrototypeOf(), Reflect.setPrototypeOf()
        setPrototypeOf: function (target, prototype) {
            monitor.Throw(monitor.modules.error.ErrorObject, 'Proxy.setPrototypeOf: setPrototypeOf is ES6 standard.', bot);
            return false;
        },
        // ---
        // Object.isExtensible(), Reflect.isExtensible() 
        isExtensible: function (target) {
            var modelstate = monitor.policy.CurrentModelState;
            var unlabeler = modelstate.GetModel(abstractname);
            var targetValue = new values_1.Value(jsflowobject, bot);
            var isExtensible = monitor.instances.ObjectConstructor.properties.isExtensible.Call(jsflowobject, [targetValue]);
            var jsIsExtensible = unlabeler.Unlabeler.Unlabel(isExtensible, modelstate);
            return jsIsExtensible;
        },
        // ---
        // Object.preventExtensions(), Reflect.preventExtensions()
        preventExtensions: function (target) {
            var modelstate = monitor.policy.CurrentModelState;
            var model = modelstate.GetModel(abstractname);
            // TODO: unlabel model here; write context
            var targetValue = new values_1.Value(jsflowobject, bot);
            monitor.instances.ObjectConstructor.properties.preventExtensions.Call(jsflowobject, [targetValue]);
            return true;
        },
        // ---
        // Object.getOwnPropertyDescriptor(), Reflect.getOwnPropertyDescriptor()
        getOwnPropertyDescriptor: function (target, prop) {
            if (typeof prop === 'symbol') {
                monitor.warn("handler.getOwnPropertyDescriptor, forwarding " + prop.toString() + " to prototype");
                return target.__proto__[prop];
            }
            var modelstate = monitor.policy.CurrentModelState;
            var unlabeler = modelstate.GetModel(abstractname);
            var propertyUnlabeler = unlabeler.GetPropertyUnlabeler(prop);
            var labeledResult = jsflowobject.GetOwnProperty(new values_1.Value(prop, bot));
            var result = propertyUnlabeler.Unlabeler.Unlabel(labeledResult, modelstate);
            var jsresult = unlabelPropertyDescriptor(result, propertyUnlabeler.ReadUnlabeler, modelstate);
            return jsresult;
        },
        // ---
        // Object.defineProperty, Reflect.defineProperty()
        defineProperty: function (target, prop, jsdesc) {
            if (typeof prop === 'symbol') {
                throw new TypeError('handler.defineProperty, defining symbol properties not supported ' + prop.toString());
            }
            var modelstate = monitor.policy.CurrentModelState;
            var unlabeler = modelstate.GetModel(abstractname);
            var propertyUnlabeler = unlabeler.GetPropertyUnlabeler(prop);
            // TODO: we should get a write context from the unlabeler, or the propertyUnlabeler
            var contextLabel = bot;
            var desc = relabelPropertyDescriptor(jsdesc, propertyUnlabeler.WriteLabeler, modelstate);
            monitor.context.pushPC(contextLabel);
            var x = jsflowobject.DefineOwnProperty(new values_1.Value(prop, bot), desc, true);
            monitor.context.popPC();
            // TODO: should share model with set
            return true;
        },
        // ---
        // the in operator
        has: function (target, prop) {
            if (typeof prop === 'symbol') {
                // TODO: should never get symbols?
                throw new TypeError('handler.has,  symbol properties not supported ' + prop.toString());
            }
            var modelstate = monitor.policy.CurrentModelState;
            var unlabeler = modelstate.GetModel(abstractname);
            var propertyUnlabeler = unlabeler.GetPropertyUnlabeler(prop);
            // TODO: where should we get the label for the prop? and where should we store the label for the in?
            // must be on the object
            var result = jsflowobject.HasProperty(new values_1.Value(prop, bot));
            return result.value;
        },
        // ---
        //
        get: function (target, prop, receiver) {
            if (typeof prop === 'symbol') {
                monitor.warn("handler.get, forwarding " + prop.toString() + " to prototype");
                return target.__proto__[prop];
            }
            var modelstate = monitor.policy.CurrentModelState;
            var unlabeler = modelstate.GetModel(abstractname);
            var propertyUnlabeler = unlabeler.GetPropertyUnlabeler(prop);
            var descUnlabeler = propertyUnlabeler.ReadUnlabeler;
            var jsfresult = jsflowobject.Get(new values_1.Value(prop, bot));
            var result = descUnlabeler.Unlabeler.Unlabel(jsfresult, modelstate);
            return unlabel(result, descUnlabeler.ValueUnlabeler, modelstate);
        },
        // --
        // 
        set: function (target, prop, value, receiver) {
            if (typeof prop === 'symbol') {
                throw new TypeError('handler.set, setting symbol properties not supported ' + prop.toString());
            }
            var modelstate = monitor.policy.CurrentModelState;
            var unlabeler = modelstate.GetModel(abstractname);
            var propertyUnlabeler = unlabeler.GetPropertyUnlabeler(prop);
            var descLabeler = propertyUnlabeler.WriteLabeler;
            var jsfvalue = relabel(value, descLabeler.ValueLabeler, modelstate);
            var valueLabel = descLabeler.ValueLabeler.Labeler.Label(modelstate);
            // TODO: we should re-add context at some point.
            var contextLabel = bot;
            monitor.context.pushPC(contextLabel);
            jsflowobject.Put(new values_1.Value(prop, bot), new values_1.Value(jsfvalue, valueLabel));
            monitor.context.popPC();
            // NOTE: encodes that set always works.
            return true;
        },
        // --
        // TODO: lacks label model connection
        deleteProperty: function (target, prop) {
            if (typeof prop === 'symbol') {
                throw new TypeError('handler.deleteProperty, deleting symbol properties not supported ' + prop.toString());
            }
            var result = jsflowobject.Delete(new values_1.Value(prop, bot));
            return result.value;
        },
        // --
        // TODO: unfinnished!
        ownKeys: function (target) {
            var keys = monitor.instances.ObjectConstructor.properties.getOwnPropertyNames.Call(jsflowobject, [new values_1.Value(jsflowobject, bot)]);
            return Object.getOwnPropertyNames(target); //unlabel(keys);
        },
        // --
        //
        apply: function (target, thisArg, args) {
            var modelstate = monitor.policy.CurrentModelState;
            if (abstractname[0] === '@' || modelstate === undefined) {
                // event listener model indicated by @ 
                // or execution in the empty model state stack inidicating call initialted from library
                // the assumption is that event listeners are only called
                modelstate = monitor.policy.eventmodelstate;
            }
            // TODO: Cast - should add check!
            var unlabeler = modelstate.GetModel(abstractname);
            var labeledThis = MkValue(thisArg, unlabeler.SelfLabeler, modelstate);
            var labeledArgs = [];
            var argslabelmodels = unlabeler.ArgumentsLabeler;
            for (var i = 0, j = 0; i < args.length; i++, j++) {
                while (!argslabelmodels.GetLabeler(j).ModelFor(args[i])) {
                    j++;
                }
                labeledArgs[i] = MkValue(args[i], argslabelmodels.GetLabeler(j), modelstate);
            }
            var result = jsflowobject.Call(labeledThis, labeledArgs);
            return unlabelValue(result, unlabeler.ReturnUnlabeler, modelstate);
        },
        // ---
        //
        construct: function (target, args, receiver) {
            var modelstate = monitor.policy.CurrentModelState;
            var unlabeler = modelstate.GetModel(abstractname);
            var labeledArgs = [];
            var argslabelmodels = unlabeler.ArgumentsLabeler;
            for (var i = 0, j = 0; i < args.length; i++, j++) {
                while (!argslabelmodels.GetLabeler(j).ModelFor(args[i])) {
                    j++;
                }
                labeledArgs[i] = MkValue(args[i], argslabelmodels.GetLabeler(j), modelstate);
            }
            var result = jsflowobject.Construct(labeledArgs);
            return unlabelValue(result, unlabeler.ReturnUnlabeler, modelstate);
        }
    };
}
// ---
function unlabelValue(labeledValue, valueUnlabeler, modelstate) {
    var value = valueUnlabeler.Unlabeler.Unlabel(labeledValue, modelstate);
    var jsvalue = unlabel(value, valueUnlabeler.AbstractName, modelstate);
    return jsvalue;
}
// ---
// unlabel
// --- ----------------------------------------------------------------------
function unlabel(value, abstractname, modelstate) {
    var e_4, _a;
    if (value === null) {
        return null;
    }
    var valType = typeof value;
    if (valType === 'string' ||
        valType === 'number' ||
        valType === 'boolean' ||
        valType === 'undefined') {
        return value;
    }
    // BiFo, EntityFunction, EntityObject, all Prototypes and Constructors
    if (value.host !== undefined) {
        return value.host;
    }
    // to be callable, the proxied object must be a function
    // thus, we copy the properties to a function
    // those properties are not used, but they must be present.
    // the handler interacts with the original object 
    if (value instanceof FunctionObject_1.FunctionObject) {
        var fun = function () { };
        try {
            for (var _b = __values(Object.getOwnPropertyNames(value.properties)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var key = _c.value;
                // We cannot copy the arguments, since its not writable or configurable on function objects
                if (key !== 'arguments') {
                    // guaranteed to be present
                    var desc = Object.getOwnPropertyDescriptor(value.properties, key);
                    Object.defineProperty(fun, key, desc);
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_4) throw e_4.error; }
        }
        return new Proxy(fun, handler(value, abstractname));
    }
    return new Proxy(value.properties, handler(value, abstractname));
}

},{"../Objects/FunctionObject":40,"../ecma":53,"../label":60,"../values":75,"./policy":74}],73:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var monitor_1 = require("../monitor");
var WrapperMonitorBase = /** @class */ (function (_super) {
    __extends(WrapperMonitorBase, _super);
    function WrapperMonitorBase(global, print, log, warn, error) {
        var _this = _super.call(this, global, print, log, warn, error) || this;
        _this.entitymap = new WeakMap();
        return _this;
    }
    WrapperMonitorBase.prototype.initialize = function (global) {
        _super.prototype.initialize.call(this, global);
        /*
        this.entitymap.set(
          this.instances.ObjectPrototype.host,
          this.instances.ObjectPrototype
        );
        this.entitymap.set(
          this.instances.FunctionPrototype.host,
          this.instances.FunctionPrototype
        );
        this.entitymap.set(
          this.instances.ArrayPrototype.host,
          this.instances.ArrayPrototype
        );
        this.entitymap.set(
          this.instances.StringPrototype.host,
          this.instances.StringPrototype
        );
        this.entitymap.set(
          this.instances.BooleanPrototype.host,
          this.instances.BooleanPrototype
        );
        this.entitymap.set(
          this.instances.NumberPrototype.host,
          this.instances.NumberPrototype
        );
        this.entitymap.set(
          this.instances.DatePrototype.host,
          this.instances.DatePrototype
        );
        this.entitymap.set(
          this.instances.RegExpPrototype.host,
          this.instances.RegExpPrototype
        );
        this.entitymap.set(
          this.instances.ErrorPrototype.host,
          this.instances.ErrorPrototype
        );
        this.entitymap.set(
          this.instances.FunctionPrototype.host,
          this.instances.FunctionPrototype
        );
        */
    };
    return WrapperMonitorBase;
}(monitor_1.MonitorBase));
exports.WrapperMonitorBase = WrapperMonitorBase;

},{"../monitor":62}],74:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var label_1 = require("../label");
var bot = label_1.Label.bot;
var full_access_path = true;
// ---
function has_own_property(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
}
exports.has_own_property = has_own_property;
// ---
var SecurityPolicy = /** @class */ (function () {
    function SecurityPolicy(policy) {
        // model state stack - sometimes jsflow causes unlabeling without calling a labeled  export function
        // e.g., this occurs if checking instanceof on a wrapped jsflow object
        // for now we let those spill into a top-level model-state
        this.labelmodelmap = {};
        this.unlabelmodelmap = {};
        this.modelstatestack = [new ToplevelModelState(null)];
        for (var name in policy.labelmodels) {
            this.labelmodelmap[name] = TranformerFactory.MakeObjectLabeler(policy.labelmodels[name], name);
        }
        for (var name in policy.unlabelmodels) {
            this.unlabelmodelmap[name] = TranformerFactory.MakeObjectUnlabeler(policy.unlabelmodels[name], name);
        }
        this.global = new ObjectLabeler(policy.global, "global");
        this.pathmodelmap = {};
        for (var name in policy.pathmodels) {
            this.pathmodelmap[name] = policy.pathmodels[name];
        }
        // model states
        this.globalmodelstate = new ModelState(null);
        // event model state
        this.eventmodelstate = new ModelState(null);
        for (var name in policy.events) {
            this.eventmodelstate.SetModel(name, TranformerFactory.MakeObjectUnlabeler(policy.events[name], name));
        }
    }
    // --- 
    // model state stack handling
    SecurityPolicy.prototype.PushModelState = function (modelstate) {
        this.modelstatestack.unshift(modelstate);
    };
    SecurityPolicy.prototype.PopModelState = function () {
        if (this.modelstatestack.length === 1) {
            monitor.fatal("Trying to pop toplevel modelstate");
        }
        return this.modelstatestack.shift();
    };
    Object.defineProperty(SecurityPolicy.prototype, "CurrentModelState", {
        get: function () {
            return this.modelstatestack[0];
        },
        enumerable: true,
        configurable: true
    });
    // ---
    // export class name to models
    SecurityPolicy.prototype.GetLabeler = function (name) {
        if (!this.labelmodelmap[name]) {
            monitor.fatal('No label model for ' + name);
        }
        return this.labelmodelmap[name];
    };
    SecurityPolicy.prototype.GetUnlabeler = function (name) {
        if (!this.unlabelmodelmap[name]) {
            monitor.fatal('No unlabel model for ' + name);
        }
        return this.unlabelmodelmap[name];
    };
    return SecurityPolicy;
}());
exports.SecurityPolicy = SecurityPolicy;
// ---
var TranformerFactory = /** @class */ (function () {
    function TranformerFactory() {
    }
    TranformerFactory.MakeObjectLabeler = function (model, path) {
        if (model === undefined) {
            return new UnknownLabeler(path);
        }
        switch (model.kind) {
            case 'ObjectLabelModel': return new ObjectLabeler(model, path);
            case 'FunctionLabelModel': return new FunctionLabeler(model, path);
            case 'ArrayLabelModel': return new ArrayLabeler(model, path);
        }
        if (isNamedLabelModel(model)) {
            return monitor.policy.GetLabeler(model.name);
        }
        return monitor.fatal('Unknown label model type ' + model.kind);
    };
    TranformerFactory.MakeObjectUnlabeler = function (model, path) {
        if (model === undefined) {
            return new UnknownUnlabeler(path);
        }
        switch (model.kind) {
            case 'ObjectUnlabelModel': return new ObjectUnlabeler(model, path);
            case 'FunctionUnlabelModel': return new FunctionUnlabeler(model, path);
            case 'ArrayUnlabelModel': return new ArrayUnlabeler(model, path);
        }
        if (isNamedUnlabelModel(model)) {
            return monitor.policy.GetUnlabeler(model.name);
        }
        return monitor.fatal('Unknown unlabel model type ' + model.kind);
    };
    return TranformerFactory;
}());
exports.TranformerFactory = TranformerFactory;
// --- ----------------------------------------------------------------------
var ModelState = /** @class */ (function () {
    function ModelState(parent) {
        this.labelState = {};
        this.modelState = {};
        this.parent = parent;
    }
    /* expects
     * label description (string, [string])
     * if beginning with @ then label variable
     * else label string
     *
     * returns lub of descriptions
     */
    ModelState.prototype.label = function (labelmodels) {
        var e_1, _a;
        if (labelmodels === undefined || labelmodels === "") {
            return bot;
        }
        if (typeof labelmodels === 'string') {
            labelmodels = [labelmodels];
        }
        var label = new label_1.Label();
        try {
            for (var labelmodels_1 = __values(labelmodels), labelmodels_1_1 = labelmodels_1.next(); !labelmodels_1_1.done; labelmodels_1_1 = labelmodels_1.next()) {
                var labelmodel = labelmodels_1_1.value;
                if (labelmodel[0] === '@') {
                    label.lub(this.get(labelmodel));
                }
                else {
                    label.lub(new label_1.Label(labelmodel));
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (labelmodels_1_1 && !labelmodels_1_1.done && (_a = labelmodels_1.return)) _a.call(labelmodels_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return label;
    };
    // ---
    // label var handling
    ModelState.prototype.get = function (labelvar) {
        if (labelvar in this.labelState) {
            return this.labelState[labelvar];
        }
        if (this.parent !== null) {
            return this.parent.get(labelvar);
        }
        return monitor.fatal("ModelState: label variable " + labelvar + " not found");
    };
    ModelState.prototype.set = function (labelvar, label) {
        this.labelState[labelvar] = label;
    };
    // abstract name mapping; should not traverse model state hierarchy
    ModelState.prototype.GetModel = function (abstractname) {
        if (typeof abstractname !== 'string') {
            monitor.fatal('GetModel abstract name is not a string but', abstractname);
        }
        if (!has_own_property(this.labelState, abstractname)) {
            monitor.warn('no unlabel model for', abstractname);
            this.modelState[abstractname] = new UnknownUnlabeler(abstractname);
        }
        return this.modelState[abstractname];
    };
    ModelState.prototype.SetModel = function (abstractname, model) {
        if (typeof abstractname !== 'string') {
            monitor.fatal('SetModel abstract name is not a string but', abstractname);
        }
        this.modelState[abstractname] = model;
    };
    return ModelState;
}());
exports.ModelState = ModelState;
// --- ----------------------------------------------------------------------
var ToplevelModelState = /** @class */ (function (_super) {
    __extends(ToplevelModelState, _super);
    function ToplevelModelState(parent) {
        return _super.call(this, parent) || this;
    }
    ToplevelModelState.prototype.label = function (labelmodels) {
        monitor.warn('ToplevelModelState, out-of-context label of', labelmodels, 'triggered');
        return _super.prototype.label.call(this, labelmodels);
    };
    ToplevelModelState.prototype.get = function (labelvar) {
        monitor.warn('ToplevelModelState, out-of-context get of', labelvar, 'triggered');
        return _super.prototype.get.call(this, labelvar);
    };
    ToplevelModelState.prototype.set = function (labelvar, label) {
        monitor.warn('ToplevelModelState, out-of-context set of', labelvar, 'triggered');
        return _super.prototype.set.call(this, labelvar, label);
    };
    ToplevelModelState.prototype.GetModel = function (abstractname) {
        monitor.warn('ToplevelModelState, out-of-context GetModel of', abstractname, 'triggered');
        return _super.prototype.GetModel.call(this, abstractname);
    };
    ToplevelModelState.prototype.SetModel = function (abstractname, model) {
        monitor.warn('ToplevelModelState, out-of-context SetModel of', abstractname, 'triggered');
        return _super.prototype.SetModel.call(this, abstractname, model);
    };
    return ToplevelModelState;
}(ModelState));
exports.ToplevelModelState = ToplevelModelState;
function isObjectLabelModel(model) {
    return model.kind === 'ObjectLabelModel';
}
exports.isObjectLabelModel = isObjectLabelModel;
function isObjectUnlabelModel(model) {
    return model.kind === 'ObjectUnlabelModel';
}
exports.isObjectUnlabelModel = isObjectUnlabelModel;
function isNamedLabelModel(model) {
    return model.kind === 'NamedLabelModel';
}
exports.isNamedLabelModel = isNamedLabelModel;
function isNamedUnlabelModel(model) {
    return model.kind === 'NamedUnlabelModel';
}
exports.isNamedUnlabelModel = isNamedUnlabelModel;
// --- ----------------------------------------------------------------------
// Labelers
var PrimitiveLabeler = /** @class */ (function () {
    function PrimitiveLabeler(labelmodel) {
        this.labelmodel = labelmodel;
    }
    PrimitiveLabeler.prototype.Label = function (modelstate) {
        return modelstate.label(this.labelmodel);
    };
    PrimitiveLabeler.prototype.Extract = function () {
        return this.labelmodel;
    };
    return PrimitiveLabeler;
}());
exports.PrimitiveLabeler = PrimitiveLabeler;
// --- ----------------------------------------------------------------------
var ValueLabeler = /** @class */ (function () {
    function ValueLabeler(labelmodel, path) {
        if (labelmodel === undefined) {
            monitor.warn('undefined value label model for', path);
        }
        this.labelmodel = labelmodel || { label: undefined, model: undefined };
        this.path = path;
    }
    Object.defineProperty(ValueLabeler.prototype, "Labeler", {
        get: function () {
            if (this.label === undefined) {
                this.label = new PrimitiveLabeler(this.labelmodel.label);
            }
            return this.label;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ValueLabeler.prototype, "ValueLabeler", {
        get: function () {
            if (this.value === undefined) {
                this.value = TranformerFactory.MakeObjectLabeler(this.labelmodel.model, this.path);
            }
            return this.value;
        },
        enumerable: true,
        configurable: true
    });
    return ValueLabeler;
}());
exports.ValueLabeler = ValueLabeler;
// --- ----------------------------------------------------------------------
var ArgumentLabeler = /** @class */ (function (_super) {
    __extends(ArgumentLabeler, _super);
    function ArgumentLabeler(labelmodel, path) {
        var _this = this;
        if (labelmodel === undefined) {
            monitor.warn('undefined argument label model for', path);
        }
        _this = _super.call(this, labelmodel, path) || this;
        // @ts-ignore initialized by super call
        _this.optional = _this.labelmodel.optional;
        return _this;
    }
    ArgumentLabeler.prototype.ModelFor = function (value) {
        if (this.labelmodel.optional === undefined) {
            return true;
        }
        return typeof value === this.labelmodel.optional;
    };
    return ArgumentLabeler;
}(ValueLabeler));
exports.ArgumentLabeler = ArgumentLabeler;
// ---
var ArgumentsLabeler = /** @class */ (function () {
    function ArgumentsLabeler(labelmodel, path) {
        if (labelmodel !== undefined && !(labelmodel instanceof Array)) {
            monitor.fatal('ArgumentsLabelModel, expected undefined or array, for', path, 'but got', labelmodel);
        }
        this.labelmodel = labelmodel || [];
        this.path = path;
        this.argslabelmodels = [];
    }
    ArgumentsLabeler.prototype.GetLabeler = function (i) {
        if (!has_own_property(this.argslabelmodels, i)) {
            this.argslabelmodels[i] = new ArgumentLabeler(this.labelmodel[i], this.path + "[" + i + "]");
        }
        return this.argslabelmodels[i];
    };
    return ArgumentsLabeler;
}());
exports.ArgumentsLabeler = ArgumentsLabeler;
// --- ----------------------------------------------------------------------
var DescriptorLabeler = /** @class */ (function () {
    function DescriptorLabeler(labelmodel, path) {
        this.labelmodel = labelmodel || {};
        this.path = path;
    }
    Object.defineProperty(DescriptorLabeler.prototype, "Labeler", {
        get: function () {
            if (this.label === undefined) {
                this.label = new PrimitiveLabeler(this.labelmodel.label);
            }
            return this.label;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DescriptorLabeler.prototype, "ValueLabeler", {
        get: function () {
            if (this.value === undefined) {
                this.value = TranformerFactory.MakeObjectLabeler(this.labelmodel.value, this.path);
            }
            return this.value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DescriptorLabeler.prototype, "GetterLabeler", {
        get: function () {
            if (this.getter === undefined) {
                this.getter = new FunctionLabeler(this.labelmodel.getter, this.path);
            }
            return this.getter;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DescriptorLabeler.prototype, "SetterLabeler", {
        get: function () {
            if (this.setter === undefined) {
                this.setter = new FunctionLabeler(this.labelmodel.setter, this.path);
            }
            return this.setter;
        },
        enumerable: true,
        configurable: true
    });
    return DescriptorLabeler;
}());
exports.DescriptorLabeler = DescriptorLabeler;
// ---
var DescriptorUnlabeler = /** @class */ (function () {
    function DescriptorUnlabeler(unlabelmodel, path) {
        this.unlabelmodel = unlabelmodel || {};
        this.path = path;
    }
    Object.defineProperty(DescriptorUnlabeler.prototype, "Unlabeler", {
        get: function () {
            if (this.label === undefined) {
                this.label = new PrimitiveUnlabeler(this.unlabelmodel.label);
            }
            return this.label;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DescriptorUnlabeler.prototype, "ValueUnlabeler", {
        get: function () {
            if (this.value === undefined) {
                this.value = this.unlabelmodel.value || this.path;
            }
            return this.value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DescriptorUnlabeler.prototype, "GetterUnlabeler", {
        get: function () {
            if (this.getter === undefined) {
                this.getter = this.unlabelmodel.getter || this.path;
            }
            return this.getter;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DescriptorUnlabeler.prototype, "SetterUnlabeler", {
        get: function () {
            if (this.setter === undefined) {
                this.setter = this.unlabelmodel.setter || this.path;
            }
            return this.setter;
        },
        enumerable: true,
        configurable: true
    });
    return DescriptorUnlabeler;
}());
exports.DescriptorUnlabeler = DescriptorUnlabeler;
// ---
var PropertyLabeler = /** @class */ (function () {
    function PropertyLabeler(labelmodel, path) {
        if (labelmodel === undefined) {
            // selected path based
            // let label = monitor.policy.pathmodelmap[path];
            var label = path.replace(/\.prototype/g, '');
            if (label !== undefined) {
                monitor.warn("autolabeling \"" + path + "\" : \"" + label + "\"");
                labelmodel = { label: label };
            }
            else {
                monitor.warn('undefined property label model for', path);
            }
        }
        this.labelmodel = labelmodel || {};
        this.path = path;
    }
    Object.defineProperty(PropertyLabeler.prototype, "Labeler", {
        get: function () {
            if (this.label === undefined) {
                this.label = new PrimitiveLabeler(this.labelmodel.label);
            }
            return this.label;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PropertyLabeler.prototype, "ReadLabeler", {
        get: function () {
            if (this.read === undefined) {
                this.read = new DescriptorLabeler(this.labelmodel.read, this.path);
            }
            return this.read;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PropertyLabeler.prototype, "WriteUnlabeler", {
        get: function () {
            if (this.write === undefined) {
                this.write = new DescriptorUnlabeler(this.labelmodel.write, this.path);
            }
            return this.write;
        },
        enumerable: true,
        configurable: true
    });
    return PropertyLabeler;
}());
exports.PropertyLabeler = PropertyLabeler;
// --- ----------------------------------------------------------------------
var ObjectLabeler = /** @class */ (function () {
    function ObjectLabeler(labelmodel, path) {
        if (labelmodel === undefined) {
            monitor.warn('undefined object label model for', path);
        }
        this.labelmodel = labelmodel || { kind: 'ObjectLabelModel' };
        this.path = path;
        this.properties = {};
    }
    Object.defineProperty(ObjectLabeler.prototype, "PrototypeLabeler", {
        get: function () {
            if (this.prototype === undefined) {
                this.prototype = new PropertyLabeler(this.labelmodel.prototype, this.path + '.prototype');
            }
            return this.prototype;
        },
        enumerable: true,
        configurable: true
    });
    ObjectLabeler.prototype.GetPropertyLabeler = function (propertyname) {
        if (!has_own_property(this.properties, propertyname)) {
            var propertyModel = this.labelmodel.properties && this.labelmodel.properties[propertyname];
            this.properties[propertyname] = new PropertyLabeler(propertyModel, this.path + '.' + propertyname);
        }
        return this.properties[propertyname];
    };
    Object.defineProperty(ObjectLabeler.prototype, "Labeler", {
        get: function () {
            if (this.label === undefined) {
                this.label = new PrimitiveLabeler(this.labelmodel.label);
            }
            return this.label;
        },
        enumerable: true,
        configurable: true
    });
    return ObjectLabeler;
}());
exports.ObjectLabeler = ObjectLabeler;
// --- ----------------------------------------------------------------------
// TODO: effects
var FunctionLabeler = /** @class */ (function (_super) {
    __extends(FunctionLabeler, _super);
    function FunctionLabeler(labelmodel, path) {
        var _this = this;
        if (labelmodel === undefined) {
            monitor.warn('undefined export function label model for', path);
        }
        // @ts-ignore initialized by super call
        _this = _super.call(this, labelmodel, path) || this;
        return _this;
    }
    Object.defineProperty(FunctionLabeler.prototype, "ArgumentsUnlabeler", {
        get: function () {
            if (this.args === undefined) {
                this.args = new ArgumentsUnlabeler(this.labelmodel.args, this.path);
            }
            return this.args;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FunctionLabeler.prototype, "SelfUnlabeler", {
        get: function () {
            if (this.self === undefined) {
                if (full_access_path)
                    monitor.log(this.path + '[Call]');
                this.self = new ValueUnlabeler(this.labelmodel.self, this.path);
            }
            return this.self;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FunctionLabeler.prototype, "ReturnLabeler", {
        get: function () {
            if (this.ret === undefined) {
                if (full_access_path)
                    monitor.log(this.path + '[ReturnValue]');
                this.ret = new ValueLabeler(this.labelmodel.ret, this.path);
            }
            return this.ret;
        },
        enumerable: true,
        configurable: true
    });
    // TODO: Issue #35, https://bitbucket.org/chalmerslbs/jsflow/issues/35/support-for-exceptions
    FunctionLabeler.prototype.GetExceptionLabelModel = function (name) {
        return new UnknownLabeler(name);
    };
    // TODO: Issue #35, https://bitbucket.org/chalmerslbs/jsflow/issues/35/support-for-exceptions
    FunctionLabeler.prototype.GetExceptionLabel = function (name) {
        return bot;
    };
    return FunctionLabeler;
}(ObjectLabeler));
exports.FunctionLabeler = FunctionLabeler;
// --- ----------------------------------------------------------------------
// TODO: arrays should fall back on objects
var ArrayLabeler = /** @class */ (function (_super) {
    __extends(ArrayLabeler, _super);
    function ArrayLabeler(labelmodel, path) {
        var _this = this;
        if (labelmodel === undefined) {
            monitor.warn('undefined array label model for', path);
        }
        // @ts-ignore initialized by super call
        _this = _super.call(this, labelmodel, path) || this;
        return _this;
    }
    ArrayLabeler.prototype.GetPropertyLabelModel = function (propertyname) {
        if (this.element === undefined) {
            // TODO: create the right type
            this.element = new PropertyLabeler(this.labelmodel.element, this.path + '.' + propertyname);
        }
        return this.element;
    };
    return ArrayLabeler;
}(ObjectLabeler));
exports.ArrayLabeler = ArrayLabeler;
// --- ----------------------------------------------------------------------
// Merge between all other models. TODO: Add export function and constructor support.
var UnknownLabeler = /** @class */ (function () {
    function UnknownLabeler(path) {
        this.path = path;
        this.properties = {};
    }
    Object.defineProperty(UnknownLabeler.prototype, "PrototypeLabeler", {
        get: function () {
            if (this.prototype === undefined) {
                this.prototype = new PropertyLabeler(undefined, this.path + '.prototype');
            }
            return this.prototype;
        },
        enumerable: true,
        configurable: true
    });
    UnknownLabeler.prototype.GetPropertyLabeler = function (propertyname) {
        if (!has_own_property(this.properties, propertyname)) {
            this.properties[propertyname] = new PropertyLabeler(undefined, this.path + '.' + propertyname);
        }
        return this.properties[propertyname];
    };
    UnknownLabeler.prototype.GetStructLabel = function (modelstate) {
        return bot;
    };
    // exception support
    // TODO: Issue #35, https://bitbucket.org/chalmerslbs/jsflow/issues/35/support-for-exceptions
    UnknownLabeler.prototype.GetExceptionLabelModel = function (name) {
        return new UnknownLabeler(name);
    };
    // TODO: Issue #35, https://bitbucket.org/chalmerslbs/jsflow/issues/35/support-for-exceptions
    UnknownLabeler.prototype.GetExceptionLabel = function (name) {
        return bot;
    };
    Object.defineProperty(UnknownLabeler.prototype, "ArgumentsUnlabeler", {
        get: function () {
            if (this.args === undefined) {
                if (full_access_path)
                    monitor.log(this.path + '[args]');
                this.args = new ArgumentsUnlabeler(undefined, this.path);
            }
            return this.args;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UnknownLabeler.prototype, "SelfUnlabeler", {
        get: function () {
            if (this.self === undefined) {
                if (full_access_path)
                    monitor.log(this.path + '[this]');
                this.self = new ValueUnlabeler(undefined, this.path);
            }
            return this.self;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UnknownLabeler.prototype, "ReturnLabeler", {
        get: function () {
            if (this.ret === undefined) {
                if (full_access_path)
                    monitor.log(this.path + '[ret]');
                this.ret = new ValueLabeler(undefined, this.path);
            }
            return this.ret;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UnknownLabeler.prototype, "Effects", {
        get: function () {
            return [];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UnknownLabeler.prototype, "Labeler", {
        get: function () {
            if (this.label === undefined) {
                this.label = new PrimitiveLabeler(undefined);
            }
            return this.label;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UnknownLabeler.prototype, "ReadLabeler", {
        // for reading
        get: function () {
            if (this.read === undefined) {
                this.read = new DescriptorLabeler(undefined, this.path);
            }
            return this.read;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UnknownLabeler.prototype, "WriteUnlabeler", {
        // for writing
        get: function () {
            if (this.write === undefined) {
                this.write = new DescriptorUnlabeler(undefined, this.path);
            }
            return this.write;
        },
        enumerable: true,
        configurable: true
    });
    return UnknownLabeler;
}());
exports.UnknownLabeler = UnknownLabeler;
// --- -----------------------------------------------------------------------------------------------------
// unlabel models
var PrimitiveUnlabeler = /** @class */ (function () {
    function PrimitiveUnlabeler(labelvar) {
        this.variable = labelvar;
        if (labelvar !== undefined && typeof labelvar !== 'string') {
            monitor.fatal('PrimitiveUnlabelModel, expecting label variable, got', labelvar);
        }
    }
    /* expects
     *  Value
     */
    PrimitiveUnlabeler.prototype.Unlabel = function (value, modelstate) {
        if (this.variable != undefined) {
            modelstate.set(this.variable, value.label);
        }
        return value.value;
    };
    return PrimitiveUnlabeler;
}());
exports.PrimitiveUnlabeler = PrimitiveUnlabeler;
// --- -----------------------------------------------------------------------------------------------------
var ValueUnlabeler = /** @class */ (function () {
    function ValueUnlabeler(unlabelmodel, path) {
        if (unlabelmodel === undefined) {
            monitor.warn('undefined value unlabel model for', path);
        }
        this.unlabelmodel = unlabelmodel || {};
        this.path = path;
    }
    Object.defineProperty(ValueUnlabeler.prototype, "Unlabeler", {
        get: function () {
            if (this.unlabeler === undefined) {
                this.unlabeler = new PrimitiveUnlabeler(this.unlabelmodel.label);
            }
            return this.unlabeler;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ValueUnlabeler.prototype, "AbstractName", {
        // undefined or abstract name
        get: function () {
            if (this.abstractname === undefined) {
                this.abstractname = this.unlabelmodel.model || this.path;
            }
            return this.abstractname;
        },
        enumerable: true,
        configurable: true
    });
    return ValueUnlabeler;
}());
exports.ValueUnlabeler = ValueUnlabeler;
// --- -----------------------------------------------------------------------------------------------------
var ArgumentUnlabeler = /** @class */ (function (_super) {
    __extends(ArgumentUnlabeler, _super);
    // ---
    function ArgumentUnlabeler(unlabelmodel, path) {
        var _this = this;
        if (unlabelmodel === undefined) {
            monitor.warn('undefined argument unlabel model for', path);
        }
        _this = _super.call(this, unlabelmodel, path) || this;
        // @ts-ignore initialized by super call
        _this.optional = _this.unlabelmodel.optional;
        return _this;
    }
    // ---
    ArgumentUnlabeler.prototype.ModelFor = function (labeledvalue) {
        if (this.optional === undefined) {
            return true;
        }
        switch (typeof labeledvalue.value) {
            case 'undefined': return this.optional === 'undefined';
            case 'boolean': return this.optional === 'boolean';
            case 'number': return this.optional === 'number';
            case 'string': return this.optional === 'string';
        }
        if (labeledvalue.value === null) {
            this.optional === 'null';
        }
        // labeledvalue.value must a JSFlow object - use the Class property
        switch (labeledvalue.value.Class) {
            case 'Object': return this.optional === 'object';
            case 'Function': return this.optional === 'export function';
        }
        return monitor.fatal("ArgumentUnlabelModel:ModelFor: don't know how to handle", labeledvalue.value);
    };
    return ArgumentUnlabeler;
}(ValueUnlabeler));
exports.ArgumentUnlabeler = ArgumentUnlabeler;
// --- -----------------------------------------------------------------------------------------------------
var ArgumentsUnlabeler = /** @class */ (function () {
    function ArgumentsUnlabeler(unlabelmodel, path) {
        if (unlabelmodel !== undefined && !(unlabelmodel instanceof Array)) {
            monitor.fatal('ArgumentsUnlabelModel, expecting undefined or array, got', unlabelmodel);
        }
        this.unlabelmodel = unlabelmodel || [];
        this.path = path;
        this.args = [];
    }
    ArgumentsUnlabeler.prototype.GetArgumentUnlabeler = function (i) {
        if (!has_own_property(this.args, i)) {
            this.args[i] = new ArgumentUnlabeler(this.unlabelmodel[i], this.path + "[" + i + "]");
        }
        return this.args[i];
    };
    return ArgumentsUnlabeler;
}());
exports.ArgumentsUnlabeler = ArgumentsUnlabeler;
// --- -----------------------------------------------------------------------------------------------------
var PropertyUnlabeler = /** @class */ (function () {
    function PropertyUnlabeler(unlabelmodel, path) {
        if (unlabelmodel === undefined) {
            monitor.warn('undefined property unlabel model for', path);
        }
        this.unlabelmodel = unlabelmodel || {};
        this.name = path;
    }
    Object.defineProperty(PropertyUnlabeler.prototype, "Unlabeler", {
        get: function () {
            if (this.label === undefined) {
                this.label = new PrimitiveUnlabeler(this.unlabelmodel.label);
            }
            return this.label;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PropertyUnlabeler.prototype, "ReadUnlabeler", {
        get: function () {
            if (this.read === undefined) {
                this.read = new DescriptorUnlabeler(this.unlabelmodel.read, this.name);
            }
            return this.read;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PropertyUnlabeler.prototype, "WriteLabeler", {
        get: function () {
            if (this.write === undefined) {
                this.write = new DescriptorLabeler(this.unlabelmodel.write, this.name);
            }
            return this.write;
        },
        enumerable: true,
        configurable: true
    });
    return PropertyUnlabeler;
}());
exports.PropertyUnlabeler = PropertyUnlabeler;
// --- -----------------------------------------------------------------------------------------------------
// TODO: handling of struct, isExstensible and other traps
var ObjectUnlabeler = /** @class */ (function () {
    function ObjectUnlabeler(unlabelmodel, path) {
        if (unlabelmodel === undefined) {
            monitor.warn('undefined object unlabel model for', path);
        }
        this.unlabelmodel = unlabelmodel || { kind: 'ObjectUnlabelModel' };
        this.path = path;
        this.properties = {};
    }
    Object.defineProperty(ObjectUnlabeler.prototype, "Unlabeler", {
        get: function () {
            if (this.label === undefined) {
                this.label = new PrimitiveUnlabeler(this.unlabelmodel.label);
            }
            return this.label;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ObjectUnlabeler.prototype, "PrototypeUnlabeler", {
        get: function () {
            if (this.prototype === undefined) {
                this.prototype = new PropertyUnlabeler(this.unlabelmodel.prototype, this.path + '.prototype');
            }
            return this.prototype;
        },
        enumerable: true,
        configurable: true
    });
    ObjectUnlabeler.prototype.GetPropertyUnlabeler = function (propertyname) {
        if (!has_own_property(this.properties, propertyname)) {
            var propertyUnlabelModel = this.unlabelmodel.properties && this.unlabelmodel.properties[propertyname];
            this.properties[propertyname] = new PropertyUnlabeler(propertyUnlabelModel, this.path + '.' + propertyname);
        }
        return this.properties[propertyname];
    };
    return ObjectUnlabeler;
}());
exports.ObjectUnlabeler = ObjectUnlabeler;
// --- -----------------------------------------------------------------------------------------------------
var FunctionUnlabeler = /** @class */ (function (_super) {
    __extends(FunctionUnlabeler, _super);
    function FunctionUnlabeler(unlabelmodel, path) {
        var _this = this;
        if (unlabelmodel === undefined) {
            monitor.warn('undefined export function unlabel model for', path);
        }
        // @ts-ignore initialized by super call
        _this = _super.call(this, unlabelmodel, path) || this;
        return _this;
    }
    Object.defineProperty(FunctionUnlabeler.prototype, "ArgumentsLabeler", {
        get: function () {
            if (this.args === undefined) {
                this.args = new ArgumentsLabeler(this.unlabelmodel.args, this.path);
            }
            return this.args;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FunctionUnlabeler.prototype, "SelfLabeler", {
        get: function () {
            if (this.self === undefined) {
                if (full_access_path)
                    monitor.log(this.path + '[Call]');
                this.self = new ValueLabeler(this.unlabelmodel.self, this.path);
            }
            return this.self;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FunctionUnlabeler.prototype, "ReturnUnlabeler", {
        get: function () {
            if (this.ret == undefined) {
                if (full_access_path)
                    monitor.log(this.path + '[ReturnValue]');
                this.ret = new ValueUnlabeler(this.unlabelmodel.ret, this.path);
            }
            return this.ret;
        },
        enumerable: true,
        configurable: true
    });
    return FunctionUnlabeler;
}(ObjectUnlabeler));
exports.FunctionUnlabeler = FunctionUnlabeler;
// ---
// TODO: This array label model does not take into account that arrays are objects.
//    Should inherit ObjectUnlabelModel in the same whay FunctionUnlabelModel does?
// TODO: unlabeling of the struct label
// ---
var ArrayUnlabeler = /** @class */ (function (_super) {
    __extends(ArrayUnlabeler, _super);
    function ArrayUnlabeler(unlabelmodel, path) {
        var _this = this;
        if (unlabelmodel === undefined) {
            monitor.warn('undefined array unlabel model for', path);
        }
        // @ts-ignore initialized by super call
        _this = _super.call(this, unlabelmodel, path) || this;
        return _this;
    }
    ArrayUnlabeler.prototype.GetPropertyUnlabeler = function (propertyname) {
        if (this.element === undefined) {
            this.element = new PropertyUnlabeler(this.unlabelmodel.element, this.path + '.' + propertyname);
        }
        return this.element;
    };
    return ArrayUnlabeler;
}(ObjectUnlabeler));
exports.ArrayUnlabeler = ArrayUnlabeler;
// --- -----------------------------------------------------------------------------------------------------
// TODO: Object | Function | (TODO) Array ...
var UnknownUnlabeler = /** @class */ (function () {
    function UnknownUnlabeler(path) {
        this.path = path;
        this.properties = {};
    }
    Object.defineProperty(UnknownUnlabeler.prototype, "PrototypeUnlabeler", {
        get: function () {
            if (this.prototype === undefined) {
                this.prototype = new PropertyUnlabeler(undefined, this.path + '.prototype');
            }
            return this.prototype;
        },
        enumerable: true,
        configurable: true
    });
    UnknownUnlabeler.prototype.GetPropertyUnlabeler = function (propertyname) {
        if (!has_own_property(this.properties, propertyname)) {
            this.properties[propertyname] = new PropertyUnlabeler(undefined, this.path + '.' + propertyname);
        }
        return this.properties[propertyname];
    };
    Object.defineProperty(UnknownUnlabeler.prototype, "ArgumentsLabeler", {
        get: function () {
            if (this.args === undefined) {
                if (full_access_path)
                    monitor.log(this.path + '[args]');
                this.args = new ArgumentsLabeler(undefined, this.path);
            }
            return this.args;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UnknownUnlabeler.prototype, "SelfLabeler", {
        get: function () {
            if (this.self === undefined) {
                if (full_access_path)
                    monitor.log(this.path + '[self]');
                this.self = new ValueLabeler(undefined, this.path);
            }
            return this.self;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UnknownUnlabeler.prototype, "ReturnUnlabeler", {
        get: function () {
            if (this.ret === undefined) {
                if (full_access_path)
                    monitor.log(this.path + '[ret]');
                this.ret = new ValueUnlabeler(undefined, this.path);
            }
            return this.ret;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UnknownUnlabeler.prototype, "Unlabeler", {
        get: function () {
            if (this.value === undefined) {
                this.value = new PrimitiveUnlabeler(undefined);
            }
            return this.value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UnknownUnlabeler.prototype, "ReadUnlabeler", {
        get: function () {
            if (this.read === undefined) {
                this.read = new DescriptorUnlabeler(undefined, this.path);
            }
            return this.read;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UnknownUnlabeler.prototype, "WriteLabeler", {
        get: function () {
            if (this.write === undefined) {
                this.write = new DescriptorLabeler(undefined, this.path);
            }
            return this.write;
        },
        enumerable: true,
        configurable: true
    });
    return UnknownUnlabeler;
}());
exports.UnknownUnlabeler = UnknownUnlabeler;

},{"../label":60}],75:[function(require,module,exports){
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
var label_1 = require("./label");
// ------------------------------------------------------------
function InContext(l, f) {
    monitor.context.pushPC(l);
    var res = f();
    monitor.context.popPC();
    if (res instanceof Value) {
        res.raise(l);
    }
    return res;
}
// ------------------------------------------------------------
// Value - labeled values
var Value = /** @class */ (function () {
    function Value(value, label) {
        this.value = value;
        this.label = label;
    }
    // ------------------------------------------------------------
    Value.prototype.raise = function (l) {
        this.label = label_1.lub(this.label, l);
    };
    // ------------------------------------------------------------
    Value.prototype.clone = function () {
        return new Value(this.value, this.label);
    };
    // ------------------------------------------------------------
    Value.prototype.toString = function () {
        if (typeof this.value === 'string') {
            return "'" + this.value + "'_" + this.label;
        }
        else {
            return this.value + "_" + this.label;
        }
    };
    // ------------------------------------------------------------
    // Ecma
    Value.prototype.GetOwnProperty = function (s) {
        var value = this.value;
        return InContext(this.label, function () { return value.GetOwnProperty(s); });
    };
    Value.prototype.GetProperty = function (s) {
        var value = this.value;
        return InContext(this.label, function () { return value.GetProperty(s); });
    };
    Value.prototype.Get = function (s) {
        var value = this.value;
        return InContext(this.label, function () { return value.Get(s); });
    };
    Value.prototype.CanPut = function (p) {
        var value = this.value;
        return InContext(this.label, function () { return value.CanPut(p); });
    };
    Value.prototype.Put = function (s, v, Throw) {
        var value = this.value;
        return InContext(this.label, function () { return value.Put(s, v); });
    };
    Value.prototype.HasProperty = function (s) {
        var value = this.value;
        return InContext(this.label, function () { return value.HasProperty(s); });
    };
    Value.prototype.Delete = function (s, Throw) {
        var value = this.value;
        return InContext(this.label, function () { return value.Delete(s, Throw); });
    };
    Value.prototype.DefaultValue = function (hint) {
        var value = this.value;
        return InContext(this.label, function () { return value.DefaultValue(hint); });
    };
    Value.prototype.DefineOwnProperty = function (s, desc, Throw) {
        var value = this.value;
        return InContext(this.label, function () { return value.DefineOwnProperty(s, desc, Throw); });
    };
    // ---
    // Function
    Value.prototype.HasInstance = function (V) {
        var value = this.value;
        return InContext(this.label, function () { return value.HasInstance(V); });
    };
    Value.prototype.Call = function (thisArg, args) {
        var value = this.value;
        return InContext(this.label, function () { return value.Call(thisArg, args); });
    };
    Value.prototype.Construct = function (args) {
        var value = this.value;
        return InContext(this.label, function () { return value.Construct(args); });
    };
    // ---
    // ObjectEnvironmentRecord, DeclarativeEnvironmentRecord
    Value.prototype.HasBinding = function (p) {
        var value = this.value;
        return InContext(this.label, function () { return value.HasBinding(p); });
    };
    Value.prototype.CreateMutableBinding = function (p, d) {
        var value = this.value;
        return InContext(this.label, function () { return value.CreateMutableBinding(p, d); });
    };
    Value.prototype.GetBindingValue = function (p, s) {
        var value = this.value;
        return InContext(this.label, function () { return value.GetBindingValue(p, s); });
    };
    Value.prototype.SetMutableBinding = function (p, v, s) {
        var value = this.value;
        return InContext(this.label, function () { return value.SetMutableBinding(p, v, s); });
    };
    Value.prototype.DeleteBinding = function (p) {
        var value = this.value;
        return InContext(this.label, function () { return value.DeleteBinding(p); });
    };
    Value.prototype.ImplicitThisValue = function () {
        var value = this.value;
        return InContext(this.label, function () { return value.ImplicitThisValue(); });
    };
    // DeclarativeEnvironmentRecord
    Value.prototype.CreateImmutableBinding = function (p) {
        var value = this.value;
        return InContext(this.label, function () { return value.CreateImmutableBinding(p); });
    };
    Value.prototype.InitializeImmutableBinding = function (p, v) {
        var value = this.value;
        return InContext(this.label, function () { return value.InitializeImmutableBinding(p, v); });
    };
    return Value;
}());
exports.Value = Value;
function isDefinedPrimitiveValue(value) {
    return typeof value.value === 'boolean' || typeof value.value === 'string' || typeof value.value === 'number';
}
exports.isDefinedPrimitiveValue = isDefinedPrimitiveValue;
var Reference = /** @class */ (function () {
    function Reference(base, propertyName) {
        this.base = base;
        this.propertyName = propertyName;
    }
    Reference.prototype.GetBase = function () {
        return this.base;
    };
    Reference.prototype.GetReferencedName = function () {
        return this.propertyName;
    };
    Reference.prototype.HasPrimitiveBase = function () {
        var x = typeof this.base.value;
        return (x === 'boolean' || x === 'string' || x === 'number');
    };
    Reference.prototype.IsPropertyReference = function () {
        return (this.base.value.Class !== undefined || this.HasPrimitiveBase());
    };
    Reference.prototype.IsUnresolvableReference = function () {
        return (this.base.value === undefined);
    };
    Reference.prototype.toString = function () {
        return ('@(' + this.base + ',' + this.propertyName + ')');
    };
    return Reference;
}());
exports.Reference = Reference;

},{"./label":60}],76:[function(require,module,exports){
(function (process){
// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47 /*/*/;
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }
  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';

  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
}

// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename = function (path, ext) {
  var f = basename(path);
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;
  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }
    if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
    } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
      // We saw a non-dot character immediately before the dot
      preDotState === 0 ||
      // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }
  return path.slice(startDot, end);
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":77}],77:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Vzci9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsImRlcGxveS9jaHJvbWUtbW9uaXRvci5qcyIsIm5vZGVfbW9kdWxlcy9lc2NvZGVnZW4vZXNjb2RlZ2VuLmpzIiwibm9kZV9tb2R1bGVzL2VzY29kZWdlbi9ub2RlX21vZHVsZXMvZXN1dGlscy9saWIvYXN0LmpzIiwibm9kZV9tb2R1bGVzL2VzY29kZWdlbi9ub2RlX21vZHVsZXMvZXN1dGlscy9saWIvY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9lc2NvZGVnZW4vbm9kZV9tb2R1bGVzL2VzdXRpbHMvbGliL2tleXdvcmQuanMiLCJub2RlX21vZHVsZXMvZXNjb2RlZ2VuL25vZGVfbW9kdWxlcy9lc3V0aWxzL2xpYi91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9lc2NvZGVnZW4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL2FycmF5LXNldC5qcyIsIm5vZGVfbW9kdWxlcy9lc2NvZGVnZW4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL2Jhc2U2NC12bHEuanMiLCJub2RlX21vZHVsZXMvZXNjb2RlZ2VuL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9iYXNlNjQuanMiLCJub2RlX21vZHVsZXMvZXNjb2RlZ2VuL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9iaW5hcnktc2VhcmNoLmpzIiwibm9kZV9tb2R1bGVzL2VzY29kZWdlbi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvbWFwcGluZy1saXN0LmpzIiwibm9kZV9tb2R1bGVzL2VzY29kZWdlbi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvcXVpY2stc29ydC5qcyIsIm5vZGVfbW9kdWxlcy9lc2NvZGVnZW4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAtY29uc3VtZXIuanMiLCJub2RlX21vZHVsZXMvZXNjb2RlZ2VuL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwLWdlbmVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9lc2NvZGVnZW4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1ub2RlLmpzIiwibm9kZV9tb2R1bGVzL2VzY29kZWdlbi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9lc2NvZGVnZW4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvc291cmNlLW1hcC5qcyIsIm5vZGVfbW9kdWxlcy9lc2NvZGVnZW4vcGFja2FnZS5qc29uIiwibm9kZV9tb2R1bGVzL2VzcHJpbWEvZXNwcmltYS5qcyIsIm5vZGVfbW9kdWxlcy9lc3RyYXZlcnNlL2VzdHJhdmVyc2UuanMiLCJub2RlX21vZHVsZXMvZXN0cmF2ZXJzZS9wYWNrYWdlLmpzb24iLCJub2RlX21vZHVsZXMvdW5kZXJzY29yZS91bmRlcnNjb3JlLmpzIiwib3V0L0NvbnN0cnVjdG9ycy9BcnJheUNvbnN0cnVjdG9yLmpzIiwib3V0L0NvbnN0cnVjdG9ycy9Cb29sZWFuQ29uc3RydWN0b3IuanMiLCJvdXQvQ29uc3RydWN0b3JzL0Z1bmN0aW9uQ29uc3RydWN0b3IuanMiLCJvdXQvQ29uc3RydWN0b3JzL051bWJlckNvbnN0cnVjdG9yLmpzIiwib3V0L0NvbnN0cnVjdG9ycy9PYmplY3RDb25zdHJ1Y3Rvci5qcyIsIm91dC9Db252ZXJzaW9uL1RvQm9vbGVhbi5qcyIsIm91dC9Db252ZXJzaW9uL1RvSW50MzIuanMiLCJvdXQvQ29udmVyc2lvbi9Ub0ludGVnZXIuanMiLCJvdXQvQ29udmVyc2lvbi9Ub051bWJlci5qcyIsIm91dC9Db252ZXJzaW9uL1RvT2JqZWN0LmpzIiwib3V0L0NvbnZlcnNpb24vVG9QcmltaXRpdmUuanMiLCJvdXQvQ29udmVyc2lvbi9Ub1N0cmluZy5qcyIsIm91dC9Db252ZXJzaW9uL1RvVUludDE2LmpzIiwib3V0L0NvbnZlcnNpb24vVG9VSW50MzIuanMiLCJvdXQvSGFzSW5zdGFuY2UuanMiLCJvdXQvT2JqZWN0cy9BcnJheU9iamVjdC5qcyIsIm91dC9PYmplY3RzL0Jvb2xlYW5PYmplY3QuanMiLCJvdXQvT2JqZWN0cy9GdW5jdGlvbk9iamVjdC5qcyIsIm91dC9PYmplY3RzL051bWJlck9iamVjdC5qcyIsIm91dC9PYmplY3RzL09iamVjdE9iamVjdC5qcyIsIm91dC9Qcm90b3R5cGVzL0FycmF5UHJvdG90eXBlLmpzIiwib3V0L1Byb3RvdHlwZXMvQm9vbGVhblByb3RvdHlwZS5qcyIsIm91dC9Qcm90b3R5cGVzL0Z1bmN0aW9uUHJvdG90eXBlLmpzIiwib3V0L1Byb3RvdHlwZXMvTnVtYmVyUHJvdG90eXBlLmpzIiwib3V0L1Byb3RvdHlwZXMvT2JqZWN0UHJvdG90eXBlLmpzIiwib3V0L1V0aWxpdHkvQ2hlY2tPYmplY3RDb2VyY2libGUuanMiLCJvdXQvVXRpbGl0eS9Jc0NhbGxhYmxlLmpzIiwiL2RhdGEvY2hhbG1lcnMvcHJvamVjdC9qc2Zsb3cvb3V0L2NvbnN0YW50cy5qcyIsIm91dC9jb250ZXh0LmpzIiwiL2RhdGEvY2hhbG1lcnMvcHJvamVjdC9qc2Zsb3cvb3V0L2RhdGUuanMiLCJvdXQvZWNtYS5qcyIsIm91dC9lbnYuanMiLCJvdXQvZXJyb3IuanMiLCJvdXQvZXhlYy5qcyIsIm91dC9mdW5jdGlvbi5qcyIsIm91dC9nbG9iYWwuanMiLCJvdXQvanNvbi5qcyIsIm91dC9sYWJlbC5qcyIsIm91dC9tYXRoLmpzIiwib3V0L21vbml0b3IuanMiLCJvdXQvb3B0aW9ucy5qcyIsIm91dC9wcC5qcyIsIm91dC9wcmVsdWRlLmpzIiwib3V0L3JlZ2V4cC5qcyIsIm91dC9zZXQuanMiLCJvdXQvc3RhY2suanMiLCJvdXQvc3RyaW5nLmpzIiwiL2RhdGEvY2hhbG1lcnMvcHJvamVjdC9qc2Zsb3cvb3V0L3RvcGxldmVsL2Nocm9tZS9tb25pdG9yLmpzIiwib3V0L3RvcGxldmVsL2Nocm9tZS93aW5kb3cuanMiLCJvdXQvdG9wbGV2ZWwvZW50aXR5LmpzIiwib3V0L3RvcGxldmVsL21vbml0b3IuanMiLCJvdXQvdG9wbGV2ZWwvcG9saWN5LmpzIiwib3V0L3ZhbHVlcy5qcyIsIi4uLy4uLy4uLy4uL3Vzci9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIi4uLy4uLy4uLy4uL3Vzci9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzaUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3puQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3phQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4ZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1bUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2oxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzVwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9YQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDejlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkEsTUFBTSxlQUFlLENBQUMsT0FBTyxFQUFFLFlBQVksRUFBRSxFQUFFLE9BQU8sSUFBSSxFQUFFLENBQUMsQ0FBQztBQUM5RCxJQUFJLFVBQVUsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQ2pDLElBQUksV0FBVyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUM7QUFDbkMsT0FBTyxNQUFNLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxPQUFPLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUN6RCxPQUFPLE1BQU0sR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLE9BQU8sRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQ3pELE9BQU8sTUFBTSxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsT0FBTyxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDekQsT0FBTyxTQUFTLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxVQUFVLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUMvRCxPQUFPLFdBQVcsR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLFlBQVksRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQ25FLE9BQU8sYUFBYSxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsY0FBYyxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDdkUsT0FBTyxJQUFJLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxLQUFLLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUNyRCxPQUFPLElBQUksR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLEtBQUssRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQ3JELE9BQU8sTUFBTSxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsT0FBTyxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDekQsT0FBTyxRQUFRLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxTQUFTLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUM3RCxPQUFPLE1BQU0sR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLE9BQU8sRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQ3pELE9BQU8sSUFBSSxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsS0FBSyxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDckQsT0FBTyxVQUFVLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxXQUFXLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUNqRSxPQUFPLFlBQVksR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLGFBQWEsRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQ3JFLE9BQU8sT0FBTyxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsUUFBUSxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDM0QsT0FBTyxVQUFVLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxXQUFXLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUNqRSxPQUFPLElBQUksR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLEtBQUssRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQ3JELE9BQU8sS0FBSyxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsTUFBTSxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDdkQsT0FBTyxLQUFLLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxNQUFNLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUN2RCxPQUFPLEtBQUssR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLE1BQU0sRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQ3ZELE9BQU8sZUFBZSxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsZ0JBQWdCLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUMzRSxPQUFPLHlCQUF5QixHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsMEJBQTBCLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUMvRixPQUFPLG9CQUFvQixHQUFHLElBQUksUUFBUSxNQUFNLENBQUMscUJBQXFCLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUNyRixPQUFPLE9BQU8sR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLFFBQVEsRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQzNELE9BQU8sUUFBUSxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsU0FBUyxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDN0QsT0FBTyxlQUFlLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxnQkFBZ0IsRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQzNFLE9BQU8saUJBQWlCLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxrQkFBa0IsRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQy9FLE9BQU8sS0FBSyxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsTUFBTSxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDdkQsT0FBTyxPQUFPLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxRQUFRLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUMzRCxPQUFPLGtCQUFrQixHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsbUJBQW1CLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUNqRixPQUFPLFNBQVMsR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLFVBQVUsRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQy9ELE9BQU8sU0FBUyxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsVUFBVSxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDL0QsT0FBTyxhQUFhLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxjQUFjLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUN2RSxPQUFPLEtBQUssR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLE1BQU0sRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQ3ZELE9BQU8sU0FBUyxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsVUFBVSxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDL0QsT0FBTyxlQUFlLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxnQkFBZ0IsRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQzNFLE9BQU8sUUFBUSxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsU0FBUyxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDN0QsT0FBTyxlQUFlLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxnQkFBZ0IsRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQzNFLE9BQU8sY0FBYyxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsZUFBZSxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDekUsT0FBTyxxQkFBcUIsR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLHNCQUFzQixFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDdkYsT0FBTyxNQUFNLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxPQUFPLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUN6RCxPQUFPLEtBQUssR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLE1BQU0sRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQ3ZELE9BQU8sT0FBTyxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsUUFBUSxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDM0QsT0FBTyxLQUFLLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxNQUFNLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUN2RCxPQUFPLElBQUksR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLEtBQUssRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQ3JELE9BQU8sU0FBUyxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsVUFBVSxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDL0QsT0FBTyxVQUFVLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxXQUFXLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUNqRSxPQUFPLEtBQUssR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLE1BQU0sRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQ3ZELE9BQU8sU0FBUyxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsVUFBVSxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDL0QsT0FBTyxXQUFXLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxZQUFZLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUNuRSxPQUFPLE1BQU0sR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLE9BQU8sRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQ3pELE9BQU8sU0FBUyxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsVUFBVSxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDL0QsT0FBTyxVQUFVLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxXQUFXLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUNqRSxPQUFPLG1CQUFtQixHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsb0JBQW9CLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUNuRixPQUFPLFVBQVUsR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLFdBQVcsRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQ2pFLE9BQU8sbUJBQW1CLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxvQkFBb0IsRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQ25GLE9BQU8sT0FBTyxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsUUFBUSxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDM0QsT0FBTyxTQUFTLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxVQUFVLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUMvRCxPQUFPLE1BQU0sR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLE9BQU8sRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQ3pELE9BQU8sT0FBTyxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsUUFBUSxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDM0QsT0FBTyxRQUFRLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxTQUFTLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUM3RCxPQUFPLE9BQU8sR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLFFBQVEsRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQzNELE9BQU8sS0FBSyxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsTUFBTSxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDdkQsT0FBTyxPQUFPLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxRQUFRLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUMzRCxPQUFPLE1BQU0sR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLE9BQU8sRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQ3pELE9BQU8sVUFBVSxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsV0FBVyxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDakUsT0FBTyxXQUFXLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxZQUFZLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUNuRSxPQUFPLGVBQWUsR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLGdCQUFnQixFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDM0UsT0FBTyxZQUFZLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxhQUFhLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUNyRSxPQUFPLFVBQVUsR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLFdBQVcsRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQ2pFLE9BQU8sU0FBUyxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsVUFBVSxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDL0QsT0FBTyxLQUFLLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxNQUFNLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUN2RCxPQUFPLEtBQUssR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLE1BQU0sRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQ3ZELE9BQU8sTUFBTSxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsT0FBTyxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDekQsT0FBTyxVQUFVLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxXQUFXLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUNqRSxPQUFPLEtBQUssR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLE1BQU0sRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQ3ZELE9BQU8sUUFBUSxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsU0FBUyxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDN0QsT0FBTyxRQUFRLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxTQUFTLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUM3RCxPQUFPLE9BQU8sR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLFFBQVEsRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQzNELE9BQU8sS0FBSyxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsTUFBTSxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDdkQsT0FBTyxJQUFJLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxLQUFLLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUNyRCxPQUFPLEtBQUssR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLE1BQU0sRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQ3ZELE9BQU8sUUFBUSxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsU0FBUyxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDN0QsT0FBTyxNQUFNLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxPQUFPLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUN6RCxPQUFPLE1BQU0sR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLE9BQU8sRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQ3pELE9BQU8sS0FBSyxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsTUFBTSxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDdkQsT0FBTyxPQUFPLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxRQUFRLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUMzRCxPQUFPLFFBQVEsR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLFNBQVMsRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQzdELE9BQU8sUUFBUSxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsU0FBUyxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDN0QsT0FBTyxZQUFZLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxhQUFhLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUNyRSxPQUFPLE1BQU0sR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLE9BQU8sRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQ3pELE9BQU8sS0FBSyxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsTUFBTSxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDdkQsT0FBTyxRQUFRLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxTQUFTLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUM3RCxPQUFPLElBQUksR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLEtBQUssRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQ3JELE9BQU8sT0FBTyxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsUUFBUSxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDM0QsT0FBTyxPQUFPLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxRQUFRLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUMzRCxPQUFPLFlBQVksR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLGFBQWEsRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQ3JFLE9BQU8sYUFBYSxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsY0FBYyxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDdkUsT0FBTyxPQUFPLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxRQUFRLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUMzRCxPQUFPLFdBQVcsR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLFlBQVksRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQ25FLE9BQU8sY0FBYyxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsZUFBZSxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDekUsT0FBTyxNQUFNLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxPQUFPLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUN6RCxPQUFPLFFBQVEsR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLFNBQVMsRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQzdELE9BQU8sT0FBTyxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsUUFBUSxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDM0QsT0FBTyxNQUFNLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxPQUFPLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUN6RCxPQUFPLFVBQVUsR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLFdBQVcsRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQ2pFLE9BQU8sT0FBTyxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsUUFBUSxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDM0QsT0FBTyxZQUFZLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxhQUFhLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUNyRSxPQUFPLGtCQUFrQixHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsbUJBQW1CLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUNqRixPQUFPLFlBQVksR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLGFBQWEsRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQ3JFLE9BQU8sa0JBQWtCLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxtQkFBbUIsRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQ2pGLE9BQU8sS0FBSyxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsTUFBTSxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDdkQsT0FBTyxVQUFVLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxXQUFXLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUNqRSxPQUFPLFVBQVUsR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLFdBQVcsRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQ2pFLE9BQU8sa0JBQWtCLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxtQkFBbUIsRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQ2pGLE9BQU8sa0JBQWtCLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxtQkFBbUIsRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQ2pGLE9BQU8sUUFBUSxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsU0FBUyxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDN0QsT0FBTyxjQUFjLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxlQUFlLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUN6RSxPQUFPLFlBQVksR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLGFBQWEsRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQ3JFLE9BQU8sRUFBRSxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsR0FBRyxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDakQsT0FBTyxLQUFLLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxNQUFNLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUN2RCxPQUFPLElBQUksR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLEtBQUssRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQ3JELE9BQU8sTUFBTSxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsT0FBTyxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDekQsT0FBTyxPQUFPLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxRQUFRLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUMzRCxPQUFPLEdBQUcsR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLElBQUksRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQ25ELE9BQU8sUUFBUSxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsU0FBUyxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDN0QsT0FBTyxNQUFNLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxPQUFPLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUN6RCxPQUFPLElBQUksR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLEtBQUssRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQ3JELE9BQU8sS0FBSyxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsTUFBTSxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDdkQsT0FBTyxLQUFLLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxNQUFNLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUN2RCxPQUFPLEtBQUssR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLE1BQU0sRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQ3ZELE9BQU8sTUFBTSxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsT0FBTyxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDekQsT0FBTyxLQUFLLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxNQUFNLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUN2RCxPQUFPLElBQUksR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLEtBQUssRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQ3JELE9BQU8sSUFBSSxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsS0FBSyxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDckQsT0FBTyxNQUFNLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxPQUFPLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUN6RCxPQUFPLElBQUksR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLEtBQUssRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQ3JELE9BQU8sSUFBSSxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsS0FBSyxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDckQsT0FBTyxJQUFJLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxLQUFLLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUNyRCxPQUFPLElBQUksR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLEtBQUssRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQ3JELE9BQU8sT0FBTyxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsUUFBUSxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDM0QsT0FBTyxNQUFNLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxPQUFPLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUN6RCxPQUFPLElBQUksR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLEtBQUssRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQ3JELE9BQU8sS0FBSyxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsTUFBTSxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDdkQsT0FBTyxJQUFJLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxLQUFLLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUNyRCxPQUFPLGFBQWEsR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLGNBQWMsRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQ3ZFLE9BQU8sYUFBYSxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsY0FBYyxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDdkUsT0FBTyxtQkFBbUIsR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLG9CQUFvQixFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDbkYsT0FBTyxtQkFBbUIsR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLG9CQUFvQixFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDbkYsT0FBTyxRQUFRLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxTQUFTLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUM3RCxPQUFPLFlBQVksR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLGFBQWEsRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQ3JFLE9BQU8sZUFBZSxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsZ0JBQWdCLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUMzRSxPQUFPLFNBQVMsR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLFVBQVUsRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQy9ELE9BQU8sWUFBWSxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsYUFBYSxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDckUsT0FBTyxRQUFRLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxTQUFTLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUM3RCxPQUFPLFdBQVcsR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLFlBQVksRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQ25FLE9BQU8sT0FBTyxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsUUFBUSxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDM0QsT0FBTyxVQUFVLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxXQUFXLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUNqRSxPQUFPLFNBQVMsR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLFVBQVUsRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQy9ELE9BQU8sWUFBWSxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsYUFBYSxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDckUsT0FBTyxXQUFXLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxZQUFZLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUNuRSxPQUFPLGNBQWMsR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLGVBQWUsRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQ3pFLE9BQU8sV0FBVyxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsWUFBWSxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDbkUsT0FBTyxjQUFjLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxlQUFlLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUN6RSxPQUFPLGdCQUFnQixHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsaUJBQWlCLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUM3RSxPQUFPLG1CQUFtQixHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsb0JBQW9CLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUNuRixPQUFPLGtCQUFrQixHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsbUJBQW1CLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUNqRixPQUFPLFFBQVEsR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLFNBQVMsRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQzdELE9BQU8sZ0JBQWdCLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxpQkFBaUIsRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQzdFLE9BQU8sbUJBQW1CLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxvQkFBb0IsRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQ25GLE9BQU8sV0FBVyxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsWUFBWSxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDbkUsT0FBTyxjQUFjLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxlQUFlLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUN6RSxPQUFPLFdBQVcsR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLFlBQVksRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQ25FLE9BQU8sY0FBYyxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsZUFBZSxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDekUsT0FBTyxTQUFTLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxVQUFVLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUMvRCxPQUFPLFlBQVksR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLGFBQWEsRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQ3JFLE9BQU8sUUFBUSxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsU0FBUyxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDN0QsT0FBTyxXQUFXLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxZQUFZLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUNuRSxPQUFPLFNBQVMsR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLFVBQVUsRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQy9ELE9BQU8sWUFBWSxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsYUFBYSxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDckUsT0FBTyxZQUFZLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxhQUFhLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUNyRSxPQUFPLGVBQWUsR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLGdCQUFnQixFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDM0UsT0FBTyxZQUFZLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxhQUFhLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUNyRSxPQUFPLFlBQVksR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLGFBQWEsRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQ3JFLE9BQU8sT0FBTyxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsUUFBUSxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDM0QsT0FBTyxNQUFNLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxPQUFPLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUN6RCxPQUFPLElBQUksR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLEtBQUssRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQ3JELE9BQU8sSUFBSSxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsS0FBSyxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDckQsT0FBTyxLQUFLLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxNQUFNLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUN2RCxPQUFPLEtBQUssR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLE1BQU0sRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQ3ZELE9BQU8sT0FBTyxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsUUFBUSxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDM0QsT0FBTyxPQUFPLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxRQUFRLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUMzRCxPQUFPLFdBQVcsR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLFlBQVksRUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDO0FBQ25FLE9BQU8sVUFBVSxHQUFHLElBQUksUUFBUSxNQUFNLENBQUMsV0FBVyxFQUFFLE9BQU8sSUFBSSxDQUFDLENBQUM7QUFDakUsT0FBTyxVQUFVLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxXQUFXLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JNakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BRQTs7O0FBR0EsSUFBSSxZQUFZLENBQUMsSUFBSSxJQUFJLElBQUksVUFBVSxLQUFLLENBQUMsWUFBWTtJQUNyRCxJQUFJLGdCQUFnQixnQkFBZ0I7UUFDaEMsZ0JBQWdCLE1BQU0sZUFBZTthQUNoQyxFQUFFLFdBQVcsRUFBRSxFQUFFLFlBQVksS0FBSyxJQUFJLGdCQUFnQixFQUFFLENBQUMsVUFBVSxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUM7WUFDNUUsZ0JBQWdCLEVBQUUsS0FBSyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztRQUMvRSxPQUFPLGFBQWEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7S0FDOUIsQ0FBQztJQUNGLE9BQU8sZ0JBQWdCO1FBQ25CLGFBQWEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDcEIsY0FBYyxFQUFFLElBQUksWUFBWSxHQUFHLENBQUMsQ0FBQyxFQUFFO1FBQ3ZDLENBQUMsVUFBVSxHQUFHLENBQUMsS0FBSyxJQUFJLEdBQUcsTUFBTSxPQUFPLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxVQUFVLEdBQUcsQ0FBQyxVQUFVLEVBQUUsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0tBQ3hGLENBQUM7Q0FDTCxHQUFHLENBQUM7QUFDTCxNQUFNLGVBQWUsQ0FBQyxPQUFPLEVBQUUsWUFBWSxFQUFFLEVBQUUsT0FBTyxJQUFJLEVBQUUsQ0FBQyxDQUFDO0FBQzlELElBQUksUUFBUSxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7QUFDL0IsSUFBSSxXQUFXLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUNuQyxJQUFJLE9BQU8sT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQzdCLElBQUksWUFBWSxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUM7QUFDdkMsSUFBSSxhQUFhLE9BQU8sQ0FBQyxZQUFZLENBQUMsQ0FBQztBQUN2QyxJQUFJLGdCQUFnQixPQUFPLENBQUMsZUFBZSxDQUFDLENBQUM7QUFDN0MsSUFBSSxnQkFBZ0IsT0FBTyxDQUFDLDBCQUEwQixDQUFDLENBQUM7QUFDeEQsSUFBSSxhQUFhLE9BQU8sQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO0FBQ2xELElBQUksYUFBYSxPQUFPLENBQUMsdUJBQXVCLENBQUMsQ0FBQztBQUNsRCxPQUFPLFFBQVEsR0FBRyxtQkFBbUI7SUFDakMsSUFBSSxRQUFRLE9BQU8sUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ3JDLElBQUksT0FBTyxJQUFJLEtBQUssQ0FBQztJQUNyQixJQUFJLFFBQVEsS0FBSyxNQUFNLENBQUM7SUFDeEIsSUFBSSxNQUFNLEtBQUssSUFBSSxDQUFDO0lBQ3BCLElBQUksS0FBSyxLQUFLLEdBQUcsQ0FBQztJQUNsQixJQUFJLE1BQU0sS0FBSyxJQUFJLENBQUM7SUFDcEIsSUFBSSxNQUFNLEtBQUssSUFBSSxDQUFDOztJQUVwQix3QkFBd0I7UUFDcEIsSUFBSSxrQkFBa0IsSUFBSSxlQUFlLENBQUMsSUFBSSxLQUFLLENBQUMsQ0FBQztRQUNyRCxJQUFJLGdCQUFnQixlQUFlLE9BQU8sQ0FBQztRQUMzQyxPQUFPLEVBQUUsaUJBQWlCLGVBQWU7WUFDckMsZUFBZSxhQUFhO1NBQy9CLENBQUM7S0FDTDs7O0lBR0QsSUFBSSxpQ0FBaUMsa0JBQWtCO1FBQ25ELFNBQVMsQ0FBQyxlQUFlLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDbkMsK0JBQStCO1lBQzNCLElBQUksUUFBUSxNQUFNLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxJQUFJLENBQUM7WUFDdEMsS0FBSyxVQUFVLEdBQUcsSUFBSSxRQUFRLE1BQU0sQ0FBQyxPQUFPLFVBQVUsa0JBQWtCLEVBQUUsR0FBRyxDQUFDLENBQUM7WUFDL0UsS0FBSyxNQUFNLEdBQUcsVUFBVSxDQUFDO1lBQ3pCLEtBQUssV0FBVyxHQUFHLElBQUksQ0FBQztZQUN4QixLQUFLLE9BQU8sR0FBRyxJQUFJLGFBQWEsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUM7WUFDOUMsS0FBSyxLQUFLLEdBQUcsSUFBSSxDQUFDO1lBQ2xCLElBQUksVUFBVSxDQUFDLEtBQUssRUFBRSxTQUFTLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQztZQUMzQyxJQUFJLFVBQVUsQ0FBQyxLQUFLLEVBQUUsU0FBUyxVQUFVLEVBQUUsS0FBSyxPQUFPLENBQUMsQ0FBQztZQUN6RCxJQUFJLFVBQVUsQ0FBQyxLQUFLLEVBQUUsU0FBUyxNQUFNLEVBQUUsSUFBSSxVQUFVLHNCQUFzQixDQUFDLEtBQUssRUFBRSxDQUFDLEVBQUUsSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUFDO1lBQ25HLElBQUksVUFBVSxDQUFDLEtBQUssRUFBRSxTQUFTLElBQUksRUFBRSxJQUFJLFVBQVUsc0JBQXNCLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUM7WUFDN0YsSUFBSSxVQUFVLENBQUMsS0FBSyxFQUFFLFNBQVMsSUFBSSxFQUFFLElBQUksVUFBVSxzQkFBc0IsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQztZQUM3RixPQUFPLEtBQUssQ0FBQztTQUNoQjtRQUNELE9BQU8sZUFBZSxDQUFDO0tBQzFCLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUNULGVBQWUsVUFBVSxZQUFZLEdBQUcsYUFBYSxZQUFZLENBQUM7OztJQUdsRSxlQUFlLFVBQVUsS0FBSyxHQUFHLHlCQUF5QjtRQUN0RCxJQUFJLE1BQU0sT0FBTyxVQUFVLGdCQUFnQixLQUFLLEVBQUUsQ0FBQztRQUNuRCxPQUFPLElBQUksUUFBUSxNQUFNLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0tBQ3ZDLENBQUM7OztJQUdGLGVBQWUsVUFBVSxVQUFVLEdBQUcsZ0JBQWdCO1FBQ2xELElBQUksUUFBUSxFQUFFLENBQUM7UUFDZixJQUFJLFFBQVEsSUFBSSxLQUFLLEVBQUUsQ0FBQztRQUN4QixJQUFJLEdBQUcsQ0FBQztRQUNSLElBQUksUUFBUSxPQUFPLFVBQVUsZ0JBQWdCLEtBQUssQ0FBQztRQUNuRCxRQUFRLElBQUksT0FBTztpQkFDVixDQUFDO2dCQUNGLE1BQU0sSUFBSSxVQUFVLENBQUMsSUFBSSxLQUFLLEVBQUUsRUFBRSxJQUFJLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO2dCQUNyRCxNQUFNO2lCQUNMLENBQUM7Z0JBQ0YsSUFBSSxJQUFJLGFBQWEsWUFBWSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUMzQyxJQUFJLE9BQU8sQ0FBQyxNQUFNLEtBQUssUUFBUSxFQUFFO29CQUM3QixJQUFJLFVBQVUsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO2lCQUM5QjtnQkFDRCxNQUFNLElBQUksVUFBVSxDQUFDLElBQUksS0FBSyxDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsQ0FBQztnQkFDbEQsTUFBTTs7Z0JBRU4sS0FBSyxJQUFJLElBQUksQ0FBQyxFQUFFLE1BQU0sSUFBSSxPQUFPLEVBQUUsQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRTtvQkFDN0MsSUFBSSxNQUFNLFVBQVUsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUN2QyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxNQUFNLENBQUM7b0JBQ3JCLEtBQUssSUFBSSxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUM7aUJBQ3hCO2dCQUNELElBQUksR0FBRyxJQUFJLENBQUMsRUFBRTtvQkFDVixLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO2lCQUNoQjtnQkFDRCxPQUFPLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7b0JBQ2YsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztpQkFDaEI7Z0JBQ0QsSUFBSSxPQUFPLElBQUksS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUMzRixNQUFNLElBQUksVUFBVSxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztTQUN6QztRQUNELE9BQU8sSUFBSSxRQUFRLE1BQU0sQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7S0FDdkMsQ0FBQzs7O0lBR0YsOEJBQThCO1FBQzFCLElBQUksU0FBUyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksSUFBSSxRQUFRLE1BQU0sQ0FBQyxTQUFTLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDM0QsU0FBUyxVQUFVLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUNyQyxJQUFJLFNBQVMsT0FBTyxVQUFVLGdCQUFnQixLQUFLLE1BQU0sQ0FBQyxNQUFNLE1BQU0sQ0FBQyxDQUFDO1FBQ3hFLE9BQU8sSUFBSSxRQUFRLE1BQU0sQ0FBQyxNQUFNLEVBQUUsTUFBTSxNQUFNLENBQUMsQ0FBQztLQUNuRDs7O0lBR0QsNEJBQTRCO1FBQ3hCLElBQUksUUFBUSxFQUFFLENBQUM7UUFDZixJQUFJLFFBQVEsSUFBSSxLQUFLLEVBQUUsQ0FBQztRQUN4QixLQUFLLElBQUksSUFBSSxDQUFDLEVBQUUsTUFBTSxJQUFJLE9BQU8sRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQzdDLElBQUksTUFBTSxVQUFVLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN2QyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxNQUFNLENBQUM7WUFDckIsS0FBSyxJQUFJLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQztTQUN4QjtRQUNELElBQUksU0FBUyxPQUFPLFVBQVUsZ0JBQWdCLEtBQUssSUFBSSxNQUFNLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQzNFLE9BQU8sSUFBSSxRQUFRLE1BQU0sQ0FBQyxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUM7S0FDNUM7OztJQUdELDRCQUE0QjtRQUN4QixJQUFJLFNBQVMsT0FBTyxVQUFVLGdCQUFnQixLQUFLLElBQUksRUFBRSxDQUFDO1FBQzFELE9BQU8sSUFBSSxRQUFRLE1BQU0sQ0FBQyxNQUFNLEVBQUUsR0FBRyxTQUFTLENBQUM7S0FDbEQ7OztJQUdELElBQUksK0JBQStCLGtCQUFrQjtRQUNqRCxTQUFTLENBQUMsYUFBYSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ2pDLDJDQUEyQztZQUN2QyxJQUFJLFFBQVEsTUFBTSxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDO1lBQ3RDLEtBQUssTUFBTSxHQUFHLE1BQU0sQ0FBQztZQUNyQixLQUFLLGVBQWUsR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztZQUNwRCxLQUFLLFVBQVUsR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLE9BQU8sVUFBVSxnQkFBZ0IsRUFBRSxHQUFHLENBQUMsQ0FBQztZQUM3RSxLQUFLLEtBQUssR0FBRyxLQUFLLFVBQVUsQ0FBQztZQUM3QixJQUFJLFVBQVUsQ0FBQyxLQUFLLEVBQUUsU0FBUyxPQUFPLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDM0MsSUFBSSxVQUFVLENBQUMsS0FBSyxFQUFFLFNBQVMsWUFBWSxFQUFFLFdBQVcsQ0FBQyxDQUFDO1lBQzFELElBQUksVUFBVSxDQUFDLEtBQUssRUFBRSxTQUFTLFNBQVMsRUFBRSxJQUFJLFVBQVUsc0JBQXNCLENBQUMsUUFBUSxFQUFFLENBQUMsRUFBRSxLQUFLLFVBQVUsU0FBUyxDQUFDLENBQUMsQ0FBQztZQUN2SCxJQUFJLFVBQVUsQ0FBQyxLQUFLLEVBQUUsU0FBUyxhQUFhLEVBQUUsSUFBSSxVQUFVLHNCQUFzQixDQUFDLFlBQVksRUFBRSxDQUFDLEVBQUUsS0FBSyxVQUFVLGFBQWEsQ0FBQyxDQUFDLENBQUM7WUFDbkksSUFBSSxVQUFVLENBQUMsS0FBSyxFQUFFLFNBQVMsYUFBYSxFQUFFLElBQUksVUFBVSxzQkFBc0IsQ0FBQyxZQUFZLEVBQUUsQ0FBQyxFQUFFLEtBQUssVUFBVSxhQUFhLENBQUMsQ0FBQyxDQUFDO1lBQ25JLElBQUksVUFBVSxDQUFDLEtBQUssRUFBRSxTQUFTLGVBQWUsRUFBRSxJQUFJLFVBQVUsc0JBQXNCLENBQUMsY0FBYyxFQUFFLENBQUMsRUFBRSxLQUFLLFVBQVUsZUFBZSxDQUFDLENBQUMsQ0FBQztZQUN6SSxJQUFJLFVBQVUsQ0FBQyxLQUFLLEVBQUUsU0FBUyxtQkFBbUIsRUFBRSxJQUFJLFVBQVUsc0JBQXNCLENBQUMsa0JBQWtCLEVBQUUsQ0FBQyxFQUFFLEtBQUssVUFBVSxtQkFBbUIsQ0FBQyxDQUFDLENBQUM7WUFDckosSUFBSSxVQUFVLENBQUMsS0FBSyxFQUFFLFNBQVMsbUJBQW1CLEVBQUUsSUFBSSxVQUFVLHNCQUFzQixDQUFDLGtCQUFrQixFQUFFLENBQUMsRUFBRSxLQUFLLFVBQVUsbUJBQW1CLENBQUMsQ0FBQyxDQUFDO1lBQ3JKLElBQUksVUFBVSxDQUFDLEtBQUssRUFBRSxJQUFJLFFBQVEsTUFBTSxDQUFDLFNBQVMsRUFBRSxHQUFHLENBQUMsRUFBRSxJQUFJLFVBQVUsc0JBQXNCLENBQUMsT0FBTyxFQUFFLENBQUMsRUFBRSxLQUFLLFVBQVUsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUNySSxJQUFJLFVBQVUsQ0FBQyxLQUFLLEVBQUUsU0FBUyxRQUFRLEVBQUUsSUFBSSxVQUFVLHNCQUFzQixDQUFDLE9BQU8sRUFBRSxDQUFDLEVBQUUsS0FBSyxVQUFVLFFBQVEsQ0FBQyxDQUFDLENBQUM7WUFDcEgsSUFBSSxVQUFVLENBQUMsS0FBSyxFQUFFLFNBQVMsWUFBWSxFQUFFLElBQUksVUFBVSxzQkFBc0IsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxFQUFFLEtBQUssVUFBVSxZQUFZLENBQUMsQ0FBQyxDQUFDO1lBQ2hJLElBQUksVUFBVSxDQUFDLEtBQUssRUFBRSxTQUFTLGVBQWUsRUFBRSxJQUFJLFVBQVUsc0JBQXNCLENBQUMsY0FBYyxFQUFFLENBQUMsRUFBRSxLQUFLLFVBQVUsZUFBZSxDQUFDLENBQUMsQ0FBQztZQUN6SSxJQUFJLFVBQVUsQ0FBQyxLQUFLLEVBQUUsU0FBUyxTQUFTLEVBQUUsSUFBSSxVQUFVLHNCQUFzQixDQUFDLFFBQVEsRUFBRSxDQUFDLEVBQUUsS0FBSyxVQUFVLFNBQVMsQ0FBQyxDQUFDLENBQUM7WUFDdkgsSUFBSSxVQUFVLENBQUMsS0FBSyxFQUFFLFNBQVMsWUFBWSxFQUFFLElBQUksVUFBVSxzQkFBc0IsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxFQUFFLEtBQUssVUFBVSxZQUFZLENBQUMsQ0FBQyxDQUFDO1lBQ2hJLElBQUksVUFBVSxDQUFDLEtBQUssRUFBRSxTQUFTLFFBQVEsRUFBRSxJQUFJLFVBQVUsc0JBQXNCLENBQUMsT0FBTyxFQUFFLENBQUMsRUFBRSxLQUFLLFVBQVUsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUNwSCxJQUFJLFVBQVUsQ0FBQyxLQUFLLEVBQUUsU0FBUyxXQUFXLEVBQUUsSUFBSSxVQUFVLHNCQUFzQixDQUFDLFVBQVUsRUFBRSxDQUFDLEVBQUUsS0FBSyxVQUFVLFdBQVcsQ0FBQyxDQUFDLENBQUM7WUFDN0gsSUFBSSxVQUFVLENBQUMsS0FBSyxFQUFFLFNBQVMsT0FBTyxFQUFFLElBQUksVUFBVSxzQkFBc0IsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEtBQUssVUFBVSxPQUFPLENBQUMsQ0FBQyxDQUFDO1lBQ2pILElBQUksVUFBVSxDQUFDLEtBQUssRUFBRSxTQUFTLFVBQVUsRUFBRSxJQUFJLFVBQVUsc0JBQXNCLENBQUMsU0FBUyxFQUFFLENBQUMsRUFBRSxLQUFLLFVBQVUsVUFBVSxDQUFDLENBQUMsQ0FBQztZQUMxSCxJQUFJLFVBQVUsQ0FBQyxLQUFLLEVBQUUsU0FBUyxTQUFTLEVBQUUsSUFBSSxVQUFVLHNCQUFzQixDQUFDLFFBQVEsRUFBRSxDQUFDLEVBQUUsS0FBSyxVQUFVLFNBQVMsQ0FBQyxDQUFDLENBQUM7WUFDdkgsSUFBSSxVQUFVLENBQUMsS0FBSyxFQUFFLFNBQVMsWUFBWSxFQUFFLElBQUksVUFBVSxzQkFBc0IsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxFQUFFLEtBQUssVUFBVSxZQUFZLENBQUMsQ0FBQyxDQUFDO1lBQ2hJLElBQUksVUFBVSxDQUFDLEtBQUssRUFBRSxTQUFTLFdBQVcsRUFBRSxJQUFJLFVBQVUsc0JBQXNCLENBQUMsVUFBVSxFQUFFLENBQUMsRUFBRSxLQUFLLFVBQVUsV0FBVyxDQUFDLENBQUMsQ0FBQztZQUM3SCxJQUFJLFVBQVUsQ0FBQyxLQUFLLEVBQUUsU0FBUyxjQUFjLEVBQUUsSUFBSSxVQUFVLHNCQUFzQixDQUFDLGFBQWEsRUFBRSxDQUFDLEVBQUUsS0FBSyxVQUFVLGNBQWMsQ0FBQyxDQUFDLENBQUM7WUFDdEksSUFBSSxVQUFVLENBQUMsS0FBSyxFQUFFLFNBQVMsV0FBVyxFQUFFLElBQUksVUFBVSxzQkFBc0IsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxFQUFFLEtBQUssVUFBVSxXQUFXLENBQUMsQ0FBQyxDQUFDO1lBQzdILElBQUksVUFBVSxDQUFDLEtBQUssRUFBRSxTQUFTLGNBQWMsRUFBRSxJQUFJLFVBQVUsc0JBQXNCLENBQUMsYUFBYSxFQUFFLENBQUMsRUFBRSxLQUFLLFVBQVUsY0FBYyxDQUFDLENBQUMsQ0FBQztZQUN0SSxJQUFJLFVBQVUsQ0FBQyxLQUFLLEVBQUUsU0FBUyxnQkFBZ0IsRUFBRSxJQUFJLFVBQVUsc0JBQXNCLENBQUMsZUFBZSxFQUFFLENBQUMsRUFBRSxLQUFLLFVBQVUsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDO1lBQzVJLElBQUksVUFBVSxDQUFDLEtBQUssRUFBRSxTQUFTLG1CQUFtQixFQUFFLElBQUksVUFBVSxzQkFBc0IsQ0FBQyxrQkFBa0IsRUFBRSxDQUFDLEVBQUUsS0FBSyxVQUFVLG1CQUFtQixDQUFDLENBQUMsQ0FBQztZQUNySixJQUFJLFVBQVUsQ0FBQyxLQUFLLEVBQUUsU0FBUyxrQkFBa0IsRUFBRSxJQUFJLFVBQVUsc0JBQXNCLENBQUMsaUJBQWlCLEVBQUUsQ0FBQyxFQUFFLEtBQUssVUFBVSxrQkFBa0IsQ0FBQyxDQUFDLENBQUM7WUFDbEosSUFBSSxVQUFVLENBQUMsS0FBSyxFQUFFLFNBQVMsUUFBUSxFQUFFLElBQUksVUFBVSxzQkFBc0IsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxFQUFFLEtBQUssVUFBVSxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ3BILElBQUksVUFBVSxDQUFDLEtBQUssRUFBRSxTQUFTLGdCQUFnQixFQUFFLElBQUksVUFBVSxzQkFBc0IsQ0FBQyxlQUFlLEVBQUUsQ0FBQyxFQUFFLEtBQUssVUFBVSxnQkFBZ0IsQ0FBQyxDQUFDLENBQUM7WUFDNUksSUFBSSxVQUFVLENBQUMsS0FBSyxFQUFFLFNBQVMsbUJBQW1CLEVBQUUsSUFBSSxVQUFVLHNCQUFzQixDQUFDLGtCQUFrQixFQUFFLENBQUMsRUFBRSxLQUFLLFVBQVUsbUJBQW1CLENBQUMsQ0FBQyxDQUFDO1lBQ3JKLElBQUksVUFBVSxDQUFDLEtBQUssRUFBRSxTQUFTLFdBQVcsRUFBRSxJQUFJLFVBQVUsc0JBQXNCLENBQUMsVUFBVSxFQUFFLENBQUMsRUFBRSxLQUFLLFVBQVUsV0FBVyxDQUFDLENBQUMsQ0FBQztZQUM3SCxJQUFJLFVBQVUsQ0FBQyxLQUFLLEVBQUUsU0FBUyxjQUFjLEVBQUUsSUFBSSxVQUFVLHNCQUFzQixDQUFDLGFBQWEsRUFBRSxDQUFDLEVBQUUsS0FBSyxVQUFVLGNBQWMsQ0FBQyxDQUFDLENBQUM7WUFDdEksSUFBSSxVQUFVLENBQUMsS0FBSyxFQUFFLFNBQVMsV0FBVyxFQUFFLElBQUksVUFBVSxzQkFBc0IsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxFQUFFLEtBQUssVUFBVSxXQUFXLENBQUMsQ0FBQyxDQUFDO1lBQzdILElBQUksVUFBVSxDQUFDLEtBQUssRUFBRSxTQUFTLGNBQWMsRUFBRSxJQUFJLFVBQVUsc0JBQXNCLENBQUMsYUFBYSxFQUFFLENBQUMsRUFBRSxLQUFLLFVBQVUsY0FBYyxDQUFDLENBQUMsQ0FBQztZQUN0SSxJQUFJLFVBQVUsQ0FBQyxLQUFLLEVBQUUsU0FBUyxTQUFTLEVBQUUsSUFBSSxVQUFVLHNCQUFzQixDQUFDLFFBQVEsRUFBRSxDQUFDLEVBQUUsS0FBSyxVQUFVLFNBQVMsQ0FBQyxDQUFDLENBQUM7WUFDdkgsSUFBSSxVQUFVLENBQUMsS0FBSyxFQUFFLFNBQVMsWUFBWSxFQUFFLElBQUksVUFBVSxzQkFBc0IsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxFQUFFLEtBQUssVUFBVSxZQUFZLENBQUMsQ0FBQyxDQUFDO1lBQ2hJLElBQUksVUFBVSxDQUFDLEtBQUssRUFBRSxTQUFTLFFBQVEsRUFBRSxJQUFJLFVBQVUsc0JBQXNCLENBQUMsT0FBTyxFQUFFLENBQUMsRUFBRSxLQUFLLFVBQVUsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUNwSCxJQUFJLFVBQVUsQ0FBQyxLQUFLLEVBQUUsU0FBUyxXQUFXLEVBQUUsSUFBSSxVQUFVLHNCQUFzQixDQUFDLFVBQVUsRUFBRSxDQUFDLEVBQUUsS0FBSyxVQUFVLFdBQVcsQ0FBQyxDQUFDLENBQUM7WUFDN0gsSUFBSSxVQUFVLENBQUMsS0FBSyxFQUFFLFNBQVMsU0FBUyxFQUFFLElBQUksVUFBVSxzQkFBc0IsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxFQUFFLEtBQUssVUFBVSxTQUFTLENBQUMsQ0FBQyxDQUFDO1lBQ3ZILElBQUksVUFBVSxDQUFDLEtBQUssRUFBRSxTQUFTLFlBQVksRUFBRSxJQUFJLFVBQVUsc0JBQXNCLENBQUMsV0FBVyxFQUFFLENBQUMsRUFBRSxLQUFLLFVBQVUsWUFBWSxDQUFDLENBQUMsQ0FBQztZQUNoSSxJQUFJLFVBQVUsQ0FBQyxLQUFLLEVBQUUsU0FBUyxZQUFZLEVBQUUsSUFBSSxVQUFVLHNCQUFzQixDQUFDLFdBQVcsRUFBRSxDQUFDLEVBQUUsS0FBSyxVQUFVLFlBQVksQ0FBQyxDQUFDLENBQUM7WUFDaEksSUFBSSxVQUFVLENBQUMsS0FBSyxFQUFFLFNBQVMsZUFBZSxFQUFFLElBQUksVUFBVSxzQkFBc0IsQ0FBQyxjQUFjLEVBQUUsQ0FBQyxFQUFFLEtBQUssVUFBVSxlQUFlLENBQUMsQ0FBQyxDQUFDO1lBQ3pJLElBQUksVUFBVSxDQUFDLEtBQUssRUFBRSxTQUFTLFlBQVksRUFBRSxJQUFJLFVBQVUsc0JBQXNCLENBQUMsV0FBVyxFQUFFLENBQUMsRUFBRSxLQUFLLFVBQVUsWUFBWSxDQUFDLENBQUMsQ0FBQztZQUNoSSxJQUFJLFVBQVUsQ0FBQyxLQUFLLEVBQUUsU0FBUyxZQUFZLEVBQUUsSUFBSSxVQUFVLHNCQUFzQixDQUFDLFdBQVcsRUFBRSxDQUFDLEVBQUUsS0FBSyxVQUFVLFlBQVksQ0FBQyxDQUFDLENBQUM7WUFDaEksSUFBSSxVQUFVLENBQUMsS0FBSyxFQUFFLFNBQVMsT0FBTyxFQUFFLElBQUksVUFBVSxzQkFBc0IsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEtBQUssVUFBVSxPQUFPLENBQUMsQ0FBQyxDQUFDOztZQUVqSCxJQUFJLFVBQVUsQ0FBQyxLQUFLLEVBQUUsSUFBSSxRQUFRLE1BQU0sQ0FBQyxhQUFhLEVBQUUsR0FBRyxDQUFDLEVBQUUsSUFBSSxVQUFVLHNCQUFzQixDQUFDLFdBQVcsRUFBRSxDQUFDLEVBQUUsS0FBSyxVQUFVLFlBQVksQ0FBQyxDQUFDLENBQUM7WUFDakosT0FBTyxLQUFLLENBQUM7U0FDaEI7UUFDRCxPQUFPLGFBQWEsQ0FBQztLQUN4QixDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7SUFDVCwrQkFBK0I7UUFDM0IsSUFBSSxDQUFDLE1BQU0sS0FBSyxJQUFJLElBQUksT0FBTyxDQUFDLE1BQU0sS0FBSyxRQUFRLElBQUksQ0FBQyxNQUFNLE1BQU0sS0FBSyxNQUFNLEVBQUU7WUFDN0UsT0FBTyxRQUFRLE9BQU8sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQ2hDLE9BQU8sTUFBTSxDQUFDLE9BQU8sUUFBUSxNQUFNLGdCQUFnQixFQUFFLE1BQU0sR0FBRyxpQkFBaUIsRUFBRSxHQUFHLENBQUMsQ0FBQztTQUN6RjtLQUNKOztJQUVELDZCQUE2QjtRQUN6QixPQUFPLHlCQUF5QjtZQUM1QixVQUFVLENBQUMsT0FBTyxFQUFFLEtBQUssQ0FBQyxDQUFDO1lBQzNCLElBQUksUUFBUSxHQUFHLENBQUMsT0FBTyxNQUFNLEVBQUUsT0FBTyxNQUFNLGVBQWUsQ0FBQyxDQUFDO1lBQzdELElBQUksT0FBTyxPQUFPLE1BQU0sZUFBZSxDQUFDO1lBQ3hDLElBQUksUUFBUSxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNuQyxPQUFPLElBQUksUUFBUSxNQUFNLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDO1NBQzNDLENBQUM7S0FDTDs7SUFFRCw2QkFBNkI7UUFDekIsT0FBTyx5QkFBeUI7WUFDNUIsVUFBVSxDQUFDLE9BQU8sRUFBRSxLQUFLLENBQUMsQ0FBQztZQUMzQixJQUFJLFVBQVUsR0FBRyxDQUFDLE9BQU8sTUFBTSxFQUFFLE9BQU8sUUFBUSxZQUFZLENBQUMsQ0FBQztZQUM5RCxPQUFPLE9BQU8sQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLE9BQU8sTUFBTSxlQUFlLENBQUMsRUFBRSxLQUFLLEdBQUcsWUFBWSxHQUFHLE9BQU8sR0FBRyx3Q0FBd0MsR0FBRyxPQUFPLE1BQU0sZUFBZSxDQUFDLENBQUM7WUFDcEssSUFBSSxRQUFRLEVBQUUsQ0FBQztZQUNmLElBQUksUUFBUSxJQUFJLEtBQUssRUFBRSxDQUFDO1lBQ3hCLEtBQUssSUFBSSxJQUFJLENBQUMsRUFBRSxNQUFNLElBQUksT0FBTyxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQzdDLElBQUksSUFBSSxVQUFVLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDckMsS0FBSyxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQztnQkFDbkIsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDO2FBQ3RCO1lBQ0QsT0FBTyxNQUFNLGVBQWUsR0FBRyxHQUFHLENBQUMsT0FBTyxNQUFNLGVBQWUsRUFBRSxLQUFLLENBQUMsQ0FBQztZQUN4RSxRQUFRLEdBQUcsQ0FBQyxPQUFPLE1BQU0sRUFBRSxPQUFPLE1BQU0sZUFBZSxDQUFDLENBQUM7WUFDekQsSUFBSSxPQUFPLE9BQU8sTUFBTSxlQUFlLENBQUM7WUFDeEMsSUFBSSxRQUFRLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztZQUMzQyxPQUFPLElBQUksUUFBUSxNQUFNLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDO1NBQzNDLENBQUM7S0FDTDs7O0lBR0QsSUFBSSxjQUFjLFlBQVksQ0FBQyxhQUFhLENBQUMsQ0FBQzs7O0lBRzlDLElBQUksV0FBVyxZQUFZLENBQUMsVUFBVSxDQUFDLENBQUM7OztJQUd4QyxJQUFJLGVBQWUsWUFBWSxDQUFDLGNBQWMsQ0FBQyxDQUFDOzs7SUFHaEQsSUFBSSxlQUFlLFlBQVksQ0FBQyxjQUFjLENBQUMsQ0FBQzs7O0lBR2hELElBQUksaUJBQWlCLFlBQVksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDOzs7SUFHcEQsSUFBSSxxQkFBcUIsWUFBWSxDQUFDLG9CQUFvQixDQUFDLENBQUM7OztJQUc1RCxJQUFJLHFCQUFxQixZQUFZLENBQUMsb0JBQW9CLENBQUMsQ0FBQzs7O0lBRzVELGdDQUFnQztRQUM1QixVQUFVLENBQUMsT0FBTyxFQUFFLFNBQVMsQ0FBQyxDQUFDO1FBQy9CLE9BQU8sSUFBSSxRQUFRLE1BQU0sQ0FBQyxPQUFPLE1BQU0sZUFBZSxRQUFRLEVBQUUsRUFBRSxPQUFPLE1BQU0sQ0FBQyxDQUFDO0tBQ3BGOzs7SUFHRCxJQUFJLFVBQVUsWUFBWSxDQUFDLFNBQVMsQ0FBQyxDQUFDOzs7SUFHdEMsSUFBSSxjQUFjLFlBQVksQ0FBQyxhQUFhLENBQUMsQ0FBQzs7O0lBRzlDLElBQUksaUJBQWlCLFlBQVksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDOzs7SUFHcEQsSUFBSSxXQUFXLFlBQVksQ0FBQyxVQUFVLENBQUMsQ0FBQzs7O0lBR3hDLElBQUksY0FBYyxZQUFZLENBQUMsYUFBYSxDQUFDLENBQUM7OztJQUc5QyxJQUFJLFVBQVUsWUFBWSxDQUFDLFNBQVMsQ0FBQyxDQUFDOzs7SUFHdEMsSUFBSSxhQUFhLFlBQVksQ0FBQyxZQUFZLENBQUMsQ0FBQzs7O0lBRzVDLElBQUksU0FBUyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUM7OztJQUdwQyxJQUFJLFlBQVksWUFBWSxDQUFDLFdBQVcsQ0FBQyxDQUFDOzs7SUFHMUMsSUFBSSxXQUFXLFlBQVksQ0FBQyxVQUFVLENBQUMsQ0FBQzs7O0lBR3hDLElBQUksY0FBYyxZQUFZLENBQUMsYUFBYSxDQUFDLENBQUM7OztJQUc5QyxJQUFJLGFBQWEsWUFBWSxDQUFDLFlBQVksQ0FBQyxDQUFDOzs7SUFHNUMsSUFBSSxnQkFBZ0IsWUFBWSxDQUFDLGVBQWUsQ0FBQyxDQUFDOzs7SUFHbEQsSUFBSSxhQUFhLFlBQVksQ0FBQyxZQUFZLENBQUMsQ0FBQzs7O0lBRzVDLElBQUksZ0JBQWdCLFlBQVksQ0FBQyxlQUFlLENBQUMsQ0FBQzs7O0lBR2xELElBQUksa0JBQWtCLFlBQVksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDOzs7SUFHdEQsSUFBSSxxQkFBcUIsWUFBWSxDQUFDLG9CQUFvQixDQUFDLENBQUM7OztJQUc1RCxJQUFJLG9CQUFvQixZQUFZLENBQUMsbUJBQW1CLENBQUMsQ0FBQzs7O0lBRzFELElBQUksVUFBVSxZQUFZLENBQUMsU0FBUyxDQUFDLENBQUM7OztJQUd0QyxJQUFJLGtCQUFrQixZQUFZLENBQUMsaUJBQWlCLENBQUMsQ0FBQzs7O0lBR3RELElBQUkscUJBQXFCLFlBQVksQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDOzs7SUFHNUQsSUFBSSxhQUFhLFlBQVksQ0FBQyxZQUFZLENBQUMsQ0FBQzs7O0lBRzVDLElBQUksZ0JBQWdCLFlBQVksQ0FBQyxlQUFlLENBQUMsQ0FBQzs7O0lBR2xELElBQUksYUFBYSxZQUFZLENBQUMsWUFBWSxDQUFDLENBQUM7OztJQUc1QyxJQUFJLGdCQUFnQixZQUFZLENBQUMsZUFBZSxDQUFDLENBQUM7OztJQUdsRCxJQUFJLFdBQVcsWUFBWSxDQUFDLFVBQVUsQ0FBQyxDQUFDOzs7SUFHeEMsSUFBSSxjQUFjLFlBQVksQ0FBQyxhQUFhLENBQUMsQ0FBQzs7O0lBRzlDLElBQUksVUFBVSxZQUFZLENBQUMsU0FBUyxDQUFDLENBQUM7OztJQUd0QyxJQUFJLGFBQWEsWUFBWSxDQUFDLFlBQVksQ0FBQyxDQUFDOzs7SUFHNUMsSUFBSSxXQUFXLFlBQVksQ0FBQyxVQUFVLENBQUMsQ0FBQzs7O0lBR3hDLElBQUksY0FBYyxZQUFZLENBQUMsYUFBYSxDQUFDLENBQUM7OztJQUc5QyxJQUFJLGNBQWMsWUFBWSxDQUFDLGFBQWEsQ0FBQyxDQUFDOzs7SUFHOUMsSUFBSSxpQkFBaUIsWUFBWSxDQUFDLGdCQUFnQixDQUFDLENBQUM7OztJQUdwRCxJQUFJLGNBQWMsWUFBWSxDQUFDLGFBQWEsQ0FBQyxDQUFDOzs7SUFHOUMsSUFBSSxTQUFTLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FBQzs7O0lBR3BDLElBQUksNEJBQTRCLGtCQUFrQjtRQUM5QyxTQUFTLENBQUMsVUFBVSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQzlCLGlDQUFpQztZQUM3QixJQUFJLFFBQVEsTUFBTSxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDO1lBQ3RDLEtBQUssTUFBTSxHQUFHLE1BQU0sQ0FBQztZQUNyQixLQUFLLGVBQWUsR0FBRyxJQUFJLENBQUM7WUFDNUIsS0FBSyxlQUFlLEdBQUcsS0FBSyxDQUFDO1lBQzdCLEtBQUssV0FBVyxHQUFHLElBQUksQ0FBQztZQUN4QixLQUFLLFVBQVUsR0FBRyxJQUFJLFFBQVEsTUFBTSxDQUFDLE9BQU8sVUFBVSxjQUFjLEVBQUUsR0FBRyxDQUFDLENBQUM7WUFDM0UsT0FBTyxLQUFLLENBQUM7U0FDaEI7UUFDRCxPQUFPLFVBQVUsQ0FBQztLQUNyQixDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7O0lBRVQsSUFBSSxTQUFTLEVBQUUsQ0FBQztJQUNoQixNQUFNLFdBQVcsR0FBRyxVQUFVLENBQUM7SUFDL0IsTUFBTSxTQUFTLEdBQUcsUUFBUSxDQUFDO0lBQzNCLE9BQU8sTUFBTSxDQUFDO0NBQ2pCLENBQUM7Ozs7O0FDNVhGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbGFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbHZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4V0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5WEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNXdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDak5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9kQSxJQUFJLFlBQVksQ0FBQyxJQUFJLElBQUksSUFBSSxVQUFVLEtBQUssQ0FBQyxZQUFZO0lBQ3JELElBQUksZ0JBQWdCLGdCQUFnQjtRQUNoQyxnQkFBZ0IsTUFBTSxlQUFlO2FBQ2hDLEVBQUUsV0FBVyxFQUFFLEVBQUUsWUFBWSxLQUFLLElBQUksZ0JBQWdCLEVBQUUsQ0FBQyxVQUFVLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQztZQUM1RSxnQkFBZ0IsRUFBRSxLQUFLLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO1FBQy9FLE9BQU8sYUFBYSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztLQUM5QixDQUFDO0lBQ0YsT0FBTyxnQkFBZ0I7UUFDbkIsYUFBYSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUNwQixjQUFjLEVBQUUsSUFBSSxZQUFZLEdBQUcsQ0FBQyxDQUFDLEVBQUU7UUFDdkMsQ0FBQyxVQUFVLEdBQUcsQ0FBQyxLQUFLLElBQUksR0FBRyxNQUFNLE9BQU8sQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLFVBQVUsR0FBRyxDQUFDLFVBQVUsRUFBRSxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUM7S0FDeEYsQ0FBQztDQUNMLEdBQUcsQ0FBQztBQUNMLE1BQU0sZUFBZSxDQUFDLE9BQU8sRUFBRSxZQUFZLEVBQUUsRUFBRSxPQUFPLElBQUksRUFBRSxDQUFDLENBQUM7QUFDOUQsSUFBSSxZQUFZLE9BQU8sQ0FBQyxZQUFZLENBQUMsQ0FBQztBQUN0QyxJQUFJLFdBQVcsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0FBQ3BDLElBQUksVUFBVSxPQUFPLENBQUMsZUFBZSxDQUFDLENBQUM7QUFDdkMsSUFBSSxPQUFPLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUMzQixBQUF1QjtBQUN2QixJQUFJLFVBQVU7SUFDVixRQUFRLE9BQU8sQ0FBQyxVQUFVLENBQUM7Q0FDOUIsQ0FBQztBQUNGLElBQUksK0JBQStCLGtCQUFrQjtJQUNqRCxTQUFTLENBQUMsYUFBYSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQ2pDLHdEQUF3RDtRQUNwRCxJQUFJLFFBQVEsTUFBTSxLQUFLLENBQUMsSUFBSSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRSxLQUFLLENBQUMsSUFBSSxJQUFJLENBQUM7O1FBRXZFLEtBQUssUUFBUSxPQUFPLEdBQUcsRUFBRSxDQUFDO1FBQzFCLElBQUksT0FBTztZQUNQLFFBQVE7U0FDWCxDQUFDO1FBQ0YsS0FBSyxNQUFNLENBQUMsS0FBSyxRQUFRLE9BQU8sRUFBRSxJQUFJLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFDakQsS0FBSyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDekIsT0FBTyxLQUFLLENBQUM7S0FDaEI7SUFDRCxhQUFhLFVBQVUsV0FBVyxHQUFHLGtCQUFrQjtRQUNuRCxNQUFNLFVBQVUsV0FBVyxLQUFLLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQy9DLElBQUksV0FBVyxJQUFJLE1BQU0sQ0FBQyxXQUFxRixDQUFDLENBQUM7UUFDakgsSUFBSSxPQUFPLEdBQUcsSUFBSSxRQUFRLGVBQWUsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUNwRCxJQUFJLGlCQUFpQixJQUFJLFFBQVEsT0FBTyxPQUFPLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUNqRSxPQUFPLEtBQUssQ0FBQyxjQUFjLEVBQUUsSUFBSSxVQUFVLENBQUMsQ0FBQztRQUM3QyxJQUFJLFVBQVUsSUFBSSxDQUFDLElBQUksVUFBVSxhQUFhLEtBQUssRUFBRSxJQUFJLFVBQVUsYUFBYSxDQUFDLENBQUM7UUFDbEYsSUFBSSxRQUFRLEtBQUssV0FBVyxFQUFFLENBQUM7UUFDL0IsSUFBSSxZQUFZLEdBQUcsSUFBSSxDQUFDO0tBQzNCLENBQUM7SUFDRixDQUFDO0lBQ0QsT0FBTyxhQUFhLENBQUM7Q0FDeEIsQ0FBQyxTQUFTLG1CQUFtQixDQUFDLENBQUMsQ0FBQztBQUNqQyxPQUFPLGNBQWMsR0FBRyxhQUFhLENBQUM7Ozs7O0FDaER0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcGxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsInZhciBqc2Zsb3cgPSB7fTtcbmpzZmxvdy5Nb25pdG9yID0gcmVxdWlyZSgnLi4vb3V0L3RvcGxldmVsL2Nocm9tZS9tb25pdG9yJykuQ2hyb21lTW9uaXRvcjtcblxudmFyIGdsb2JhbCA9IChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pKCk7XG5cbndpbmRvdy5qc2Zsb3cgPSBuZXcganNmbG93Lk1vbml0b3IoZ2xvYmFsKTtcbiIsIi8qXG4gIENvcHlyaWdodCAoQykgMjAxMi0yMDE0IFl1c3VrZSBTdXp1a2kgPHV0YXRhbmUudGVhQGdtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDE1IEluZ3ZhciBTdGVwYW55YW4gPG1lQHJyZXZlcnNlci5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxNCBJdmFuIE5pa3VsaW4gPGlmYWFhbkBnbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMi0yMDEzIE1pY2hhZWwgRmljYXJyYSA8ZXNjb2RlZ2VuLmNvcHlyaWdodEBtaWNoYWVsLmZpY2FycmEubWU+XG4gIENvcHlyaWdodCAoQykgMjAxMi0yMDEzIE1hdGhpYXMgQnluZW5zIDxtYXRoaWFzQHFpd2kuYmU+XG4gIENvcHlyaWdodCAoQykgMjAxMyBJcmFrbGkgR296YWxpc2h2aWxpIDxyZm9iaWNAZ21haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgUm9iZXJ0IEd1c3QtQmFyZG9uIDxkb25hdGVAcm9iZXJ0Lmd1c3QtYmFyZG9uLm9yZz5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIEpvaG4gRnJlZW1hbiA8amZyZWVtYW4wOEBnbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMS0yMDEyIEFyaXlhIEhpZGF5YXQgPGFyaXlhLmhpZGF5YXRAZ21haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgSm9vc3QtV2ltIEJvZWtlc3RlaWpuIDxqb29zdC13aW1AYm9la2VzdGVpam4ubmw+XG4gIENvcHlyaWdodCAoQykgMjAxMiBLcmlzIEtvd2FsIDxrcmlzLmtvd2FsQGNpeGFyLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIEFycGFkIEJvcnNvcyA8YXJwYWQuYm9yc29zQGdvb2dsZW1haWwuY29tPlxuXG4gIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIDxDT1BZUklHSFQgSE9MREVSPiBCRSBMSUFCTEUgRk9SIEFOWVxuICBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuICAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4gIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuICBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0ZcbiAgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG5cbi8qZ2xvYmFsIGV4cG9ydHM6dHJ1ZSwgcmVxdWlyZTp0cnVlLCBnbG9iYWw6dHJ1ZSovXG4oZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBTeW50YXgsXG4gICAgICAgIFByZWNlZGVuY2UsXG4gICAgICAgIEJpbmFyeVByZWNlZGVuY2UsXG4gICAgICAgIFNvdXJjZU5vZGUsXG4gICAgICAgIGVzdHJhdmVyc2UsXG4gICAgICAgIGVzdXRpbHMsXG4gICAgICAgIGJhc2UsXG4gICAgICAgIGluZGVudCxcbiAgICAgICAganNvbixcbiAgICAgICAgcmVudW1iZXIsXG4gICAgICAgIGhleGFkZWNpbWFsLFxuICAgICAgICBxdW90ZXMsXG4gICAgICAgIGVzY2FwZWxlc3MsXG4gICAgICAgIG5ld2xpbmUsXG4gICAgICAgIHNwYWNlLFxuICAgICAgICBwYXJlbnRoZXNlcyxcbiAgICAgICAgc2VtaWNvbG9ucyxcbiAgICAgICAgc2FmZUNvbmNhdGVuYXRpb24sXG4gICAgICAgIGRpcmVjdGl2ZSxcbiAgICAgICAgZXh0cmEsXG4gICAgICAgIHBhcnNlLFxuICAgICAgICBzb3VyY2VNYXAsXG4gICAgICAgIHNvdXJjZUNvZGUsXG4gICAgICAgIHByZXNlcnZlQmxhbmtMaW5lcyxcbiAgICAgICAgRk9STUFUX01JTklGWSxcbiAgICAgICAgRk9STUFUX0RFRkFVTFRTO1xuXG4gICAgZXN0cmF2ZXJzZSA9IHJlcXVpcmUoJ2VzdHJhdmVyc2UnKTtcbiAgICBlc3V0aWxzID0gcmVxdWlyZSgnZXN1dGlscycpO1xuXG4gICAgU3ludGF4ID0gZXN0cmF2ZXJzZS5TeW50YXg7XG5cbiAgICAvLyBHZW5lcmF0aW9uIGlzIGRvbmUgYnkgZ2VuZXJhdGVFeHByZXNzaW9uLlxuICAgIGZ1bmN0aW9uIGlzRXhwcmVzc2lvbihub2RlKSB7XG4gICAgICAgIHJldHVybiBDb2RlR2VuZXJhdG9yLkV4cHJlc3Npb24uaGFzT3duUHJvcGVydHkobm9kZS50eXBlKTtcbiAgICB9XG5cbiAgICAvLyBHZW5lcmF0aW9uIGlzIGRvbmUgYnkgZ2VuZXJhdGVTdGF0ZW1lbnQuXG4gICAgZnVuY3Rpb24gaXNTdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICByZXR1cm4gQ29kZUdlbmVyYXRvci5TdGF0ZW1lbnQuaGFzT3duUHJvcGVydHkobm9kZS50eXBlKTtcbiAgICB9XG5cbiAgICBQcmVjZWRlbmNlID0ge1xuICAgICAgICBTZXF1ZW5jZTogMCxcbiAgICAgICAgWWllbGQ6IDEsXG4gICAgICAgIEF3YWl0OiAxLFxuICAgICAgICBBc3NpZ25tZW50OiAxLFxuICAgICAgICBDb25kaXRpb25hbDogMixcbiAgICAgICAgQXJyb3dGdW5jdGlvbjogMixcbiAgICAgICAgTG9naWNhbE9SOiAzLFxuICAgICAgICBMb2dpY2FsQU5EOiA0LFxuICAgICAgICBCaXR3aXNlT1I6IDUsXG4gICAgICAgIEJpdHdpc2VYT1I6IDYsXG4gICAgICAgIEJpdHdpc2VBTkQ6IDcsXG4gICAgICAgIEVxdWFsaXR5OiA4LFxuICAgICAgICBSZWxhdGlvbmFsOiA5LFxuICAgICAgICBCaXR3aXNlU0hJRlQ6IDEwLFxuICAgICAgICBBZGRpdGl2ZTogMTEsXG4gICAgICAgIE11bHRpcGxpY2F0aXZlOiAxMixcbiAgICAgICAgVW5hcnk6IDEzLFxuICAgICAgICBQb3N0Zml4OiAxNCxcbiAgICAgICAgQ2FsbDogMTUsXG4gICAgICAgIE5ldzogMTYsXG4gICAgICAgIFRhZ2dlZFRlbXBsYXRlOiAxNyxcbiAgICAgICAgTWVtYmVyOiAxOCxcbiAgICAgICAgUHJpbWFyeTogMTlcbiAgICB9O1xuXG4gICAgQmluYXJ5UHJlY2VkZW5jZSA9IHtcbiAgICAgICAgJ3x8JzogUHJlY2VkZW5jZS5Mb2dpY2FsT1IsXG4gICAgICAgICcmJic6IFByZWNlZGVuY2UuTG9naWNhbEFORCxcbiAgICAgICAgJ3wnOiBQcmVjZWRlbmNlLkJpdHdpc2VPUixcbiAgICAgICAgJ14nOiBQcmVjZWRlbmNlLkJpdHdpc2VYT1IsXG4gICAgICAgICcmJzogUHJlY2VkZW5jZS5CaXR3aXNlQU5ELFxuICAgICAgICAnPT0nOiBQcmVjZWRlbmNlLkVxdWFsaXR5LFxuICAgICAgICAnIT0nOiBQcmVjZWRlbmNlLkVxdWFsaXR5LFxuICAgICAgICAnPT09JzogUHJlY2VkZW5jZS5FcXVhbGl0eSxcbiAgICAgICAgJyE9PSc6IFByZWNlZGVuY2UuRXF1YWxpdHksXG4gICAgICAgICdpcyc6IFByZWNlZGVuY2UuRXF1YWxpdHksXG4gICAgICAgICdpc250JzogUHJlY2VkZW5jZS5FcXVhbGl0eSxcbiAgICAgICAgJzwnOiBQcmVjZWRlbmNlLlJlbGF0aW9uYWwsXG4gICAgICAgICc+JzogUHJlY2VkZW5jZS5SZWxhdGlvbmFsLFxuICAgICAgICAnPD0nOiBQcmVjZWRlbmNlLlJlbGF0aW9uYWwsXG4gICAgICAgICc+PSc6IFByZWNlZGVuY2UuUmVsYXRpb25hbCxcbiAgICAgICAgJ2luJzogUHJlY2VkZW5jZS5SZWxhdGlvbmFsLFxuICAgICAgICAnaW5zdGFuY2VvZic6IFByZWNlZGVuY2UuUmVsYXRpb25hbCxcbiAgICAgICAgJzw8JzogUHJlY2VkZW5jZS5CaXR3aXNlU0hJRlQsXG4gICAgICAgICc+Pic6IFByZWNlZGVuY2UuQml0d2lzZVNISUZULFxuICAgICAgICAnPj4+JzogUHJlY2VkZW5jZS5CaXR3aXNlU0hJRlQsXG4gICAgICAgICcrJzogUHJlY2VkZW5jZS5BZGRpdGl2ZSxcbiAgICAgICAgJy0nOiBQcmVjZWRlbmNlLkFkZGl0aXZlLFxuICAgICAgICAnKic6IFByZWNlZGVuY2UuTXVsdGlwbGljYXRpdmUsXG4gICAgICAgICclJzogUHJlY2VkZW5jZS5NdWx0aXBsaWNhdGl2ZSxcbiAgICAgICAgJy8nOiBQcmVjZWRlbmNlLk11bHRpcGxpY2F0aXZlXG4gICAgfTtcblxuICAgIC8vRmxhZ3NcbiAgICB2YXIgRl9BTExPV19JTiA9IDEsXG4gICAgICAgIEZfQUxMT1dfQ0FMTCA9IDEgPDwgMSxcbiAgICAgICAgRl9BTExPV19VTlBBUkFUSF9ORVcgPSAxIDw8IDIsXG4gICAgICAgIEZfRlVOQ19CT0RZID0gMSA8PCAzLFxuICAgICAgICBGX0RJUkVDVElWRV9DVFggPSAxIDw8IDQsXG4gICAgICAgIEZfU0VNSUNPTE9OX09QVCA9IDEgPDwgNTtcblxuICAgIC8vRXhwcmVzc2lvbiBmbGFnIHNldHNcbiAgICAvL05PVEU6IEZsYWcgb3JkZXI6XG4gICAgLy8gRl9BTExPV19JTlxuICAgIC8vIEZfQUxMT1dfQ0FMTFxuICAgIC8vIEZfQUxMT1dfVU5QQVJBVEhfTkVXXG4gICAgdmFyIEVfRlRUID0gRl9BTExPV19DQUxMIHwgRl9BTExPV19VTlBBUkFUSF9ORVcsXG4gICAgICAgIEVfVFRGID0gRl9BTExPV19JTiB8IEZfQUxMT1dfQ0FMTCxcbiAgICAgICAgRV9UVFQgPSBGX0FMTE9XX0lOIHwgRl9BTExPV19DQUxMIHwgRl9BTExPV19VTlBBUkFUSF9ORVcsXG4gICAgICAgIEVfVEZGID0gRl9BTExPV19JTixcbiAgICAgICAgRV9GRlQgPSBGX0FMTE9XX1VOUEFSQVRIX05FVyxcbiAgICAgICAgRV9URlQgPSBGX0FMTE9XX0lOIHwgRl9BTExPV19VTlBBUkFUSF9ORVc7XG5cbiAgICAvL1N0YXRlbWVudCBmbGFnIHNldHNcbiAgICAvL05PVEU6IEZsYWcgb3JkZXI6XG4gICAgLy8gRl9BTExPV19JTlxuICAgIC8vIEZfRlVOQ19CT0RZXG4gICAgLy8gRl9ESVJFQ1RJVkVfQ1RYXG4gICAgLy8gRl9TRU1JQ09MT05fT1BUXG4gICAgdmFyIFNfVEZGRiA9IEZfQUxMT1dfSU4sXG4gICAgICAgIFNfVEZGVCA9IEZfQUxMT1dfSU4gfCBGX1NFTUlDT0xPTl9PUFQsXG4gICAgICAgIFNfRkZGRiA9IDB4MDAsXG4gICAgICAgIFNfVEZURiA9IEZfQUxMT1dfSU4gfCBGX0RJUkVDVElWRV9DVFgsXG4gICAgICAgIFNfVFRGRiA9IEZfQUxMT1dfSU4gfCBGX0ZVTkNfQk9EWTtcblxuICAgIGZ1bmN0aW9uIGdldERlZmF1bHRPcHRpb25zKCkge1xuICAgICAgICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGluZGVudDogbnVsbCxcbiAgICAgICAgICAgIGJhc2U6IG51bGwsXG4gICAgICAgICAgICBwYXJzZTogbnVsbCxcbiAgICAgICAgICAgIGNvbW1lbnQ6IGZhbHNlLFxuICAgICAgICAgICAgZm9ybWF0OiB7XG4gICAgICAgICAgICAgICAgaW5kZW50OiB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiAnICAgICcsXG4gICAgICAgICAgICAgICAgICAgIGJhc2U6IDAsXG4gICAgICAgICAgICAgICAgICAgIGFkanVzdE11bHRpbGluZUNvbW1lbnQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBuZXdsaW5lOiAnXFxuJyxcbiAgICAgICAgICAgICAgICBzcGFjZTogJyAnLFxuICAgICAgICAgICAgICAgIGpzb246IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJlbnVtYmVyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBoZXhhZGVjaW1hbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcXVvdGVzOiAnc2luZ2xlJyxcbiAgICAgICAgICAgICAgICBlc2NhcGVsZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb21wYWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBwYXJlbnRoZXNlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzZW1pY29sb25zOiB0cnVlLFxuICAgICAgICAgICAgICAgIHNhZmVDb25jYXRlbmF0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBwcmVzZXJ2ZUJsYW5rTGluZXM6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbW96OiB7XG4gICAgICAgICAgICAgICAgY29tcHJlaGVuc2lvbkV4cHJlc3Npb25TdGFydHNXaXRoQXNzaWdubWVudDogZmFsc2UsXG4gICAgICAgICAgICAgICAgc3Rhcmxlc3NHZW5lcmF0b3I6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc291cmNlTWFwOiBudWxsLFxuICAgICAgICAgICAgc291cmNlTWFwUm9vdDogbnVsbCxcbiAgICAgICAgICAgIHNvdXJjZU1hcFdpdGhDb2RlOiBmYWxzZSxcbiAgICAgICAgICAgIGRpcmVjdGl2ZTogZmFsc2UsXG4gICAgICAgICAgICByYXc6IHRydWUsXG4gICAgICAgICAgICB2ZXJiYXRpbTogbnVsbCxcbiAgICAgICAgICAgIHNvdXJjZUNvZGU6IG51bGxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdHJpbmdSZXBlYXQoc3RyLCBudW0pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuXG4gICAgICAgIGZvciAobnVtIHw9IDA7IG51bSA+IDA7IG51bSA+Pj49IDEsIHN0ciArPSBzdHIpIHtcbiAgICAgICAgICAgIGlmIChudW0gJiAxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHN0cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFzTGluZVRlcm1pbmF0b3Ioc3RyKSB7XG4gICAgICAgIHJldHVybiAoL1tcXHJcXG5dL2cpLnRlc3Qoc3RyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbmRzV2l0aExpbmVUZXJtaW5hdG9yKHN0cikge1xuICAgICAgICB2YXIgbGVuID0gc3RyLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGxlbiAmJiBlc3V0aWxzLmNvZGUuaXNMaW5lVGVybWluYXRvcihzdHIuY2hhckNvZGVBdChsZW4gLSAxKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWVyZ2UodGFyZ2V0LCBvdmVycmlkZSkge1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGtleSBpbiBvdmVycmlkZSkge1xuICAgICAgICAgICAgaWYgKG92ZXJyaWRlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IG92ZXJyaWRlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVEZWVwbHkodGFyZ2V0LCBvdmVycmlkZSkge1xuICAgICAgICB2YXIga2V5LCB2YWw7XG5cbiAgICAgICAgZnVuY3Rpb24gaXNIYXNoT2JqZWN0KHRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB0YXJnZXQgPT09ICdvYmplY3QnICYmIHRhcmdldCBpbnN0YW5jZW9mIE9iamVjdCAmJiAhKHRhcmdldCBpbnN0YW5jZW9mIFJlZ0V4cCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGtleSBpbiBvdmVycmlkZSkge1xuICAgICAgICAgICAgaWYgKG92ZXJyaWRlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBvdmVycmlkZVtrZXldO1xuICAgICAgICAgICAgICAgIGlmIChpc0hhc2hPYmplY3QodmFsKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNIYXNoT2JqZWN0KHRhcmdldFtrZXldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlRGVlcGx5KHRhcmdldFtrZXldLCB2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSB1cGRhdGVEZWVwbHkoe30sIHZhbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZU51bWJlcih2YWx1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0LCBwb2ludCwgdGVtcCwgZXhwb25lbnQsIHBvcztcblxuICAgICAgICBpZiAodmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ051bWVyaWMgbGl0ZXJhbCB3aG9zZSB2YWx1ZSBpcyBOYU4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOdW1lcmljIGxpdGVyYWwgd2hvc2UgdmFsdWUgaXMgbmVnYXRpdmUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gMSAvIDApIHtcbiAgICAgICAgICAgIHJldHVybiBqc29uID8gJ251bGwnIDogcmVudW1iZXIgPyAnMWU0MDAnIDogJzFlKzQwMCc7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSAnJyArIHZhbHVlO1xuICAgICAgICBpZiAoIXJlbnVtYmVyIHx8IHJlc3VsdC5sZW5ndGggPCAzKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgcG9pbnQgPSByZXN1bHQuaW5kZXhPZignLicpO1xuICAgICAgICBpZiAoIWpzb24gJiYgcmVzdWx0LmNoYXJDb2RlQXQoMCkgPT09IDB4MzAgIC8qIDAgKi8gJiYgcG9pbnQgPT09IDEpIHtcbiAgICAgICAgICAgIHBvaW50ID0gMDtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICB0ZW1wID0gcmVzdWx0O1xuICAgICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZSgnZSsnLCAnZScpO1xuICAgICAgICBleHBvbmVudCA9IDA7XG4gICAgICAgIGlmICgocG9zID0gdGVtcC5pbmRleE9mKCdlJykpID4gMCkge1xuICAgICAgICAgICAgZXhwb25lbnQgPSArdGVtcC5zbGljZShwb3MgKyAxKTtcbiAgICAgICAgICAgIHRlbXAgPSB0ZW1wLnNsaWNlKDAsIHBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvaW50ID49IDApIHtcbiAgICAgICAgICAgIGV4cG9uZW50IC09IHRlbXAubGVuZ3RoIC0gcG9pbnQgLSAxO1xuICAgICAgICAgICAgdGVtcCA9ICsodGVtcC5zbGljZSgwLCBwb2ludCkgKyB0ZW1wLnNsaWNlKHBvaW50ICsgMSkpICsgJyc7XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gMDtcbiAgICAgICAgd2hpbGUgKHRlbXAuY2hhckNvZGVBdCh0ZW1wLmxlbmd0aCArIHBvcyAtIDEpID09PSAweDMwICAvKiAwICovKSB7XG4gICAgICAgICAgICAtLXBvcztcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zICE9PSAwKSB7XG4gICAgICAgICAgICBleHBvbmVudCAtPSBwb3M7XG4gICAgICAgICAgICB0ZW1wID0gdGVtcC5zbGljZSgwLCBwb3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHBvbmVudCAhPT0gMCkge1xuICAgICAgICAgICAgdGVtcCArPSAnZScgKyBleHBvbmVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHRlbXAubGVuZ3RoIDwgcmVzdWx0Lmxlbmd0aCB8fFxuICAgICAgICAgICAgICAgICAgICAoaGV4YWRlY2ltYWwgJiYgdmFsdWUgPiAxZTEyICYmIE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZSAmJiAodGVtcCA9ICcweCcgKyB2YWx1ZS50b1N0cmluZygxNikpLmxlbmd0aCA8IHJlc3VsdC5sZW5ndGgpKSAmJlxuICAgICAgICAgICAgICAgICt0ZW1wID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGVtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gR2VuZXJhdGUgdmFsaWQgUmVnRXhwIGV4cHJlc3Npb24uXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vQ29uc3RlbGxhdGlvbi9pdiBFbmdpbmVcblxuICAgIGZ1bmN0aW9uIGVzY2FwZVJlZ0V4cENoYXJhY3RlcihjaCwgcHJldmlvdXNJc0JhY2tzbGFzaCkge1xuICAgICAgICAvLyBub3QgaGFuZGxpbmcgJ1xcJyBhbmQgaGFuZGxpbmcgXFx1MjAyOCBvciBcXHUyMDI5IHRvIHVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlXG4gICAgICAgIGlmICgoY2ggJiB+MSkgPT09IDB4MjAyOCkge1xuICAgICAgICAgICAgcmV0dXJuIChwcmV2aW91c0lzQmFja3NsYXNoID8gJ3UnIDogJ1xcXFx1JykgKyAoKGNoID09PSAweDIwMjgpID8gJzIwMjgnIDogJzIwMjknKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gMTAgfHwgY2ggPT09IDEzKSB7ICAvLyBcXG4sIFxcclxuICAgICAgICAgICAgcmV0dXJuIChwcmV2aW91c0lzQmFja3NsYXNoID8gJycgOiAnXFxcXCcpICsgKChjaCA9PT0gMTApID8gJ24nIDogJ3InKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVSZWdFeHAocmVnKSB7XG4gICAgICAgIHZhciBtYXRjaCwgcmVzdWx0LCBmbGFncywgaSwgaXosIGNoLCBjaGFyYWN0ZXJJbkJyYWNrLCBwcmV2aW91c0lzQmFja3NsYXNoO1xuXG4gICAgICAgIHJlc3VsdCA9IHJlZy50b1N0cmluZygpO1xuXG4gICAgICAgIGlmIChyZWcuc291cmNlKSB7XG4gICAgICAgICAgICAvLyBleHRyYWN0IGZsYWcgZnJvbSB0b1N0cmluZyByZXN1bHRcbiAgICAgICAgICAgIG1hdGNoID0gcmVzdWx0Lm1hdGNoKC9cXC8oW14vXSopJC8pO1xuICAgICAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZsYWdzID0gbWF0Y2hbMV07XG4gICAgICAgICAgICByZXN1bHQgPSAnJztcblxuICAgICAgICAgICAgY2hhcmFjdGVySW5CcmFjayA9IGZhbHNlO1xuICAgICAgICAgICAgcHJldmlvdXNJc0JhY2tzbGFzaCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgaXogPSByZWcuc291cmNlLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICBjaCA9IHJlZy5zb3VyY2UuY2hhckNvZGVBdChpKTtcblxuICAgICAgICAgICAgICAgIGlmICghcHJldmlvdXNJc0JhY2tzbGFzaCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhcmFjdGVySW5CcmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSA5MykgeyAgLy8gXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJhY3RlckluQnJhY2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gNDcpIHsgIC8vIC9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ1xcXFwnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gOTEpIHsgIC8vIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFyYWN0ZXJJbkJyYWNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gZXNjYXBlUmVnRXhwQ2hhcmFjdGVyKGNoLCBwcmV2aW91c0lzQmFja3NsYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNJc0JhY2tzbGFzaCA9IGNoID09PSA5MjsgIC8vIFxcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgbmV3IFJlZ0V4cChcIlxcXFxcXG4nKSBpcyBwcm92aWRlZCwgY3JlYXRlIC9cXG4vXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBlc2NhcGVSZWdFeHBDaGFyYWN0ZXIoY2gsIHByZXZpb3VzSXNCYWNrc2xhc2gpO1xuICAgICAgICAgICAgICAgICAgICAvLyBwcmV2ZW50IGxpa2UgL1xcXFxbL10vXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzSXNCYWNrc2xhc2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAnLycgKyByZXN1bHQgKyAnLycgKyBmbGFncztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXNjYXBlQWxsb3dlZENoYXJhY3Rlcihjb2RlLCBuZXh0KSB7XG4gICAgICAgIHZhciBoZXg7XG5cbiAgICAgICAgaWYgKGNvZGUgPT09IDB4MDggIC8qIFxcYiAqLykge1xuICAgICAgICAgICAgcmV0dXJuICdcXFxcYic7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29kZSA9PT0gMHgwQyAgLyogXFxmICovKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1xcXFxmJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb2RlID09PSAweDA5ICAvKiBcXHQgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiAnXFxcXHQnO1xuICAgICAgICB9XG5cbiAgICAgICAgaGV4ID0gY29kZS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICAgICAgaWYgKGpzb24gfHwgY29kZSA+IDB4RkYpIHtcbiAgICAgICAgICAgIHJldHVybiAnXFxcXHUnICsgJzAwMDAnLnNsaWNlKGhleC5sZW5ndGgpICsgaGV4O1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDAwMCAmJiAhZXN1dGlscy5jb2RlLmlzRGVjaW1hbERpZ2l0KG5leHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1xcXFwwJztcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwMEIgIC8qIFxcdiAqLykgeyAvLyAnXFx2J1xuICAgICAgICAgICAgcmV0dXJuICdcXFxceDBCJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAnXFxcXHgnICsgJzAwJy5zbGljZShoZXgubGVuZ3RoKSArIGhleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVzY2FwZURpc2FsbG93ZWRDaGFyYWN0ZXIoY29kZSkge1xuICAgICAgICBpZiAoY29kZSA9PT0gMHg1QyAgLyogXFwgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiAnXFxcXFxcXFwnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvZGUgPT09IDB4MEEgIC8qIFxcbiAqLykge1xuICAgICAgICAgICAgcmV0dXJuICdcXFxcbic7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29kZSA9PT0gMHgwRCAgLyogXFxyICovKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1xcXFxyJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb2RlID09PSAweDIwMjgpIHtcbiAgICAgICAgICAgIHJldHVybiAnXFxcXHUyMDI4JztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb2RlID09PSAweDIwMjkpIHtcbiAgICAgICAgICAgIHJldHVybiAnXFxcXHUyMDI5JztcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0bHkgY2xhc3NpZmllZCBjaGFyYWN0ZXInKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlc2NhcGVEaXJlY3RpdmUoc3RyKSB7XG4gICAgICAgIHZhciBpLCBpeiwgY29kZSwgcXVvdGU7XG5cbiAgICAgICAgcXVvdGUgPSBxdW90ZXMgPT09ICdkb3VibGUnID8gJ1wiJyA6ICdcXCcnO1xuICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IHN0ci5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gMHgyNyAgLyogJyAqLykge1xuICAgICAgICAgICAgICAgIHF1b3RlID0gJ1wiJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgyMiAgLyogXCIgKi8pIHtcbiAgICAgICAgICAgICAgICBxdW90ZSA9ICdcXCcnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDVDICAvKiBcXCAqLykge1xuICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBxdW90ZSArIHN0ciArIHF1b3RlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVzY2FwZVN0cmluZyhzdHIpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnLCBpLCBsZW4sIGNvZGUsIHNpbmdsZVF1b3RlcyA9IDAsIGRvdWJsZVF1b3RlcyA9IDAsIHNpbmdsZSwgcXVvdGU7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gc3RyLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gMHgyNyAgLyogJyAqLykge1xuICAgICAgICAgICAgICAgICsrc2luZ2xlUXVvdGVzO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDIyICAvKiBcIiAqLykge1xuICAgICAgICAgICAgICAgICsrZG91YmxlUXVvdGVzO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDJGICAvKiAvICovICYmIGpzb24pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ1xcXFwnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlc3V0aWxzLmNvZGUuaXNMaW5lVGVybWluYXRvcihjb2RlKSB8fCBjb2RlID09PSAweDVDICAvKiBcXCAqLykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBlc2NhcGVEaXNhbGxvd2VkQ2hhcmFjdGVyKGNvZGUpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghZXN1dGlscy5jb2RlLmlzSWRlbnRpZmllclBhcnRFUzUoY29kZSkgJiYgKGpzb24gJiYgY29kZSA8IDB4MjAgIC8qIFNQICovIHx8ICFqc29uICYmICFlc2NhcGVsZXNzICYmIChjb2RlIDwgMHgyMCAgLyogU1AgKi8gfHwgY29kZSA+IDB4N0UgIC8qIH4gKi8pKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBlc2NhcGVBbGxvd2VkQ2hhcmFjdGVyKGNvZGUsIHN0ci5jaGFyQ29kZUF0KGkgKyAxKSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNpbmdsZSA9ICEocXVvdGVzID09PSAnZG91YmxlJyB8fCAocXVvdGVzID09PSAnYXV0bycgJiYgZG91YmxlUXVvdGVzIDwgc2luZ2xlUXVvdGVzKSk7XG4gICAgICAgIHF1b3RlID0gc2luZ2xlID8gJ1xcJycgOiAnXCInO1xuXG4gICAgICAgIGlmICghKHNpbmdsZSA/IHNpbmdsZVF1b3RlcyA6IGRvdWJsZVF1b3RlcykpIHtcbiAgICAgICAgICAgIHJldHVybiBxdW90ZSArIHJlc3VsdCArIHF1b3RlO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RyID0gcmVzdWx0O1xuICAgICAgICByZXN1bHQgPSBxdW90ZTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBzdHIubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmICgoY29kZSA9PT0gMHgyNyAgLyogJyAqLyAmJiBzaW5nbGUpIHx8IChjb2RlID09PSAweDIyICAvKiBcIiAqLyAmJiAhc2luZ2xlKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnXFxcXCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQgKyBxdW90ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBmbGF0dGVuIGFuIGFycmF5IHRvIGEgc3RyaW5nLCB3aGVyZSB0aGUgYXJyYXkgY2FuIGNvbnRhaW5cbiAgICAgKiBlaXRoZXIgc3RyaW5ncyBvciBuZXN0ZWQgYXJyYXlzXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdHRlblRvU3RyaW5nKGFycikge1xuICAgICAgICB2YXIgaSwgaXosIGVsZW0sIHJlc3VsdCA9ICcnO1xuICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IGFyci5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICBlbGVtID0gYXJyW2ldO1xuICAgICAgICAgICAgcmVzdWx0ICs9IEFycmF5LmlzQXJyYXkoZWxlbSkgPyBmbGF0dGVuVG9TdHJpbmcoZWxlbSkgOiBlbGVtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY29udmVydCBnZW5lcmF0ZWQgdG8gYSBTb3VyY2VOb2RlIHdoZW4gc291cmNlIG1hcHMgYXJlIGVuYWJsZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChnZW5lcmF0ZWQsIG5vZGUpIHtcbiAgICAgICAgaWYgKCFzb3VyY2VNYXApIHtcbiAgICAgICAgICAgIC8vIHdpdGggbm8gc291cmNlIG1hcHMsIGdlbmVyYXRlZCBpcyBlaXRoZXIgYW5cbiAgICAgICAgICAgIC8vIGFycmF5IG9yIGEgc3RyaW5nLiAgaWYgYW4gYXJyYXksIGZsYXR0ZW4gaXQuXG4gICAgICAgICAgICAvLyBpZiBhIHN0cmluZywganVzdCByZXR1cm4gaXRcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGdlbmVyYXRlZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmxhdHRlblRvU3RyaW5nKGdlbmVyYXRlZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGdlbmVyYXRlZCBpbnN0YW5jZW9mIFNvdXJjZU5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUubG9jID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU291cmNlTm9kZShudWxsLCBudWxsLCBzb3VyY2VNYXAsIGdlbmVyYXRlZCwgbm9kZS5uYW1lIHx8IG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU291cmNlTm9kZShub2RlLmxvYy5zdGFydC5saW5lLCBub2RlLmxvYy5zdGFydC5jb2x1bW4sIChzb3VyY2VNYXAgPT09IHRydWUgPyBub2RlLmxvYy5zb3VyY2UgfHwgbnVsbCA6IHNvdXJjZU1hcCksIGdlbmVyYXRlZCwgbm9kZS5uYW1lIHx8IG51bGwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vRW1wdHlTcGFjZSgpIHtcbiAgICAgICAgcmV0dXJuIChzcGFjZSkgPyBzcGFjZSA6ICcgJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBqb2luKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHZhciBsZWZ0U291cmNlLFxuICAgICAgICAgICAgcmlnaHRTb3VyY2UsXG4gICAgICAgICAgICBsZWZ0Q2hhckNvZGUsXG4gICAgICAgICAgICByaWdodENoYXJDb2RlO1xuXG4gICAgICAgIGxlZnRTb3VyY2UgPSB0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKGxlZnQpLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChsZWZ0U291cmNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtyaWdodF07XG4gICAgICAgIH1cblxuICAgICAgICByaWdodFNvdXJjZSA9IHRvU291cmNlTm9kZVdoZW5OZWVkZWQocmlnaHQpLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChyaWdodFNvdXJjZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbbGVmdF07XG4gICAgICAgIH1cblxuICAgICAgICBsZWZ0Q2hhckNvZGUgPSBsZWZ0U291cmNlLmNoYXJDb2RlQXQobGVmdFNvdXJjZS5sZW5ndGggLSAxKTtcbiAgICAgICAgcmlnaHRDaGFyQ29kZSA9IHJpZ2h0U291cmNlLmNoYXJDb2RlQXQoMCk7XG5cbiAgICAgICAgaWYgKChsZWZ0Q2hhckNvZGUgPT09IDB4MkIgIC8qICsgKi8gfHwgbGVmdENoYXJDb2RlID09PSAweDJEICAvKiAtICovKSAmJiBsZWZ0Q2hhckNvZGUgPT09IHJpZ2h0Q2hhckNvZGUgfHxcbiAgICAgICAgICAgIGVzdXRpbHMuY29kZS5pc0lkZW50aWZpZXJQYXJ0RVM1KGxlZnRDaGFyQ29kZSkgJiYgZXN1dGlscy5jb2RlLmlzSWRlbnRpZmllclBhcnRFUzUocmlnaHRDaGFyQ29kZSkgfHxcbiAgICAgICAgICAgIGxlZnRDaGFyQ29kZSA9PT0gMHgyRiAgLyogLyAqLyAmJiByaWdodENoYXJDb2RlID09PSAweDY5ICAvKiBpICovKSB7IC8vIGluZml4IHdvcmQgb3BlcmF0b3JzIGFsbCBzdGFydCB3aXRoIGBpYFxuICAgICAgICAgICAgcmV0dXJuIFtsZWZ0LCBub0VtcHR5U3BhY2UoKSwgcmlnaHRdO1xuICAgICAgICB9IGVsc2UgaWYgKGVzdXRpbHMuY29kZS5pc1doaXRlU3BhY2UobGVmdENoYXJDb2RlKSB8fCBlc3V0aWxzLmNvZGUuaXNMaW5lVGVybWluYXRvcihsZWZ0Q2hhckNvZGUpIHx8XG4gICAgICAgICAgICAgICAgZXN1dGlscy5jb2RlLmlzV2hpdGVTcGFjZShyaWdodENoYXJDb2RlKSB8fCBlc3V0aWxzLmNvZGUuaXNMaW5lVGVybWluYXRvcihyaWdodENoYXJDb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtsZWZ0LCByaWdodF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtsZWZ0LCBzcGFjZSwgcmlnaHRdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZEluZGVudChzdG10KSB7XG4gICAgICAgIHJldHVybiBbYmFzZSwgc3RtdF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2l0aEluZGVudChmbikge1xuICAgICAgICB2YXIgcHJldmlvdXNCYXNlO1xuICAgICAgICBwcmV2aW91c0Jhc2UgPSBiYXNlO1xuICAgICAgICBiYXNlICs9IGluZGVudDtcbiAgICAgICAgZm4oYmFzZSk7XG4gICAgICAgIGJhc2UgPSBwcmV2aW91c0Jhc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlU3BhY2VzKHN0cikge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yIChpID0gc3RyLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICBpZiAoZXN1dGlscy5jb2RlLmlzTGluZVRlcm1pbmF0b3Ioc3RyLmNoYXJDb2RlQXQoaSkpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChzdHIubGVuZ3RoIC0gMSkgLSBpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkanVzdE11bHRpbGluZUNvbW1lbnQodmFsdWUsIHNwZWNpYWxCYXNlKSB7XG4gICAgICAgIHZhciBhcnJheSwgaSwgbGVuLCBsaW5lLCBqLCBzcGFjZXMsIHByZXZpb3VzQmFzZSwgc247XG5cbiAgICAgICAgYXJyYXkgPSB2YWx1ZS5zcGxpdCgvXFxyXFxufFtcXHJcXG5dLyk7XG4gICAgICAgIHNwYWNlcyA9IE51bWJlci5NQVhfVkFMVUU7XG5cbiAgICAgICAgLy8gZmlyc3QgbGluZSBkb2Vzbid0IGhhdmUgaW5kZW50YXRpb25cbiAgICAgICAgZm9yIChpID0gMSwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIGxpbmUgPSBhcnJheVtpXTtcbiAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGogPCBsaW5lLmxlbmd0aCAmJiBlc3V0aWxzLmNvZGUuaXNXaGl0ZVNwYWNlKGxpbmUuY2hhckNvZGVBdChqKSkpIHtcbiAgICAgICAgICAgICAgICArK2o7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3BhY2VzID4gaikge1xuICAgICAgICAgICAgICAgIHNwYWNlcyA9IGo7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHNwZWNpYWxCYXNlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgLy8gcGF0dGVybiBsaWtlXG4gICAgICAgICAgICAvLyB7XG4gICAgICAgICAgICAvLyAgIHZhciB0ID0gMjA7ICAvKlxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICogdGhpcyBpcyBjb21tZW50XG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIHByZXZpb3VzQmFzZSA9IGJhc2U7XG4gICAgICAgICAgICBpZiAoYXJyYXlbMV1bc3BhY2VzXSA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgc3BlY2lhbEJhc2UgKz0gJyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmFzZSA9IHNwZWNpYWxCYXNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNwYWNlcyAmIDEpIHtcbiAgICAgICAgICAgICAgICAvLyAvKlxuICAgICAgICAgICAgICAgIC8vICAqXG4gICAgICAgICAgICAgICAgLy8gICovXG4gICAgICAgICAgICAgICAgLy8gSWYgc3BhY2VzIGFyZSBvZGQgbnVtYmVyLCBhYm92ZSBwYXR0ZXJuIGlzIGNvbnNpZGVyZWQuXG4gICAgICAgICAgICAgICAgLy8gV2Ugd2FzdGUgMSBzcGFjZS5cbiAgICAgICAgICAgICAgICAtLXNwYWNlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZpb3VzQmFzZSA9IGJhc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAxLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgc24gPSB0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKGFkZEluZGVudChhcnJheVtpXS5zbGljZShzcGFjZXMpKSk7XG4gICAgICAgICAgICBhcnJheVtpXSA9IHNvdXJjZU1hcCA/IHNuLmpvaW4oJycpIDogc247XG4gICAgICAgIH1cblxuICAgICAgICBiYXNlID0gcHJldmlvdXNCYXNlO1xuXG4gICAgICAgIHJldHVybiBhcnJheS5qb2luKCdcXG4nKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUNvbW1lbnQoY29tbWVudCwgc3BlY2lhbEJhc2UpIHtcbiAgICAgICAgaWYgKGNvbW1lbnQudHlwZSA9PT0gJ0xpbmUnKSB7XG4gICAgICAgICAgICBpZiAoZW5kc1dpdGhMaW5lVGVybWluYXRvcihjb21tZW50LnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnLy8nICsgY29tbWVudC52YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQWx3YXlzIHVzZSBMaW5lVGVybWluYXRvclxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSAnLy8nICsgY29tbWVudC52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIXByZXNlcnZlQmxhbmtMaW5lcykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ1xcbic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4dHJhLmZvcm1hdC5pbmRlbnQuYWRqdXN0TXVsdGlsaW5lQ29tbWVudCAmJiAvW1xcblxccl0vLnRlc3QoY29tbWVudC52YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBhZGp1c3RNdWx0aWxpbmVDb21tZW50KCcvKicgKyBjb21tZW50LnZhbHVlICsgJyovJywgc3BlY2lhbEJhc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnLyonICsgY29tbWVudC52YWx1ZSArICcqLyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkQ29tbWVudHMoc3RtdCwgcmVzdWx0KSB7XG4gICAgICAgIHZhciBpLCBsZW4sIGNvbW1lbnQsIHNhdmUsIHRhaWxpbmdUb1N0YXRlbWVudCwgc3BlY2lhbEJhc2UsIGZyYWdtZW50LFxuICAgICAgICAgICAgZXh0UmFuZ2UsIHJhbmdlLCBwcmV2UmFuZ2UsIHByZWZpeCwgaW5maXgsIHN1ZmZpeCwgY291bnQ7XG5cbiAgICAgICAgaWYgKHN0bXQubGVhZGluZ0NvbW1lbnRzICYmIHN0bXQubGVhZGluZ0NvbW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHNhdmUgPSByZXN1bHQ7XG5cbiAgICAgICAgICAgIGlmIChwcmVzZXJ2ZUJsYW5rTGluZXMpIHtcbiAgICAgICAgICAgICAgICBjb21tZW50ID0gc3RtdC5sZWFkaW5nQ29tbWVudHNbMF07XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgICAgICAgICAgICBleHRSYW5nZSA9IGNvbW1lbnQuZXh0ZW5kZWRSYW5nZTtcbiAgICAgICAgICAgICAgICByYW5nZSA9IGNvbW1lbnQucmFuZ2U7XG5cbiAgICAgICAgICAgICAgICBwcmVmaXggPSBzb3VyY2VDb2RlLnN1YnN0cmluZyhleHRSYW5nZVswXSwgcmFuZ2VbMF0pO1xuICAgICAgICAgICAgICAgIGNvdW50ID0gKHByZWZpeC5tYXRjaCgvXFxuL2cpIHx8IFtdKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzdHJpbmdSZXBlYXQoJ1xcbicsIGNvdW50KSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFkZEluZGVudChnZW5lcmF0ZUNvbW1lbnQoY29tbWVudCkpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChwcmVmaXgpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChnZW5lcmF0ZUNvbW1lbnQoY29tbWVudCkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHByZXZSYW5nZSA9IHJhbmdlO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMSwgbGVuID0gc3RtdC5sZWFkaW5nQ29tbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudCA9IHN0bXQubGVhZGluZ0NvbW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICByYW5nZSA9IGNvbW1lbnQucmFuZ2U7XG5cbiAgICAgICAgICAgICAgICAgICAgaW5maXggPSBzb3VyY2VDb2RlLnN1YnN0cmluZyhwcmV2UmFuZ2VbMV0sIHJhbmdlWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgY291bnQgPSAoaW5maXgubWF0Y2goL1xcbi9nKSB8fCBbXSkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzdHJpbmdSZXBlYXQoJ1xcbicsIGNvdW50KSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFkZEluZGVudChnZW5lcmF0ZUNvbW1lbnQoY29tbWVudCkpKTtcblxuICAgICAgICAgICAgICAgICAgICBwcmV2UmFuZ2UgPSByYW5nZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzdWZmaXggPSBzb3VyY2VDb2RlLnN1YnN0cmluZyhyYW5nZVsxXSwgZXh0UmFuZ2VbMV0pO1xuICAgICAgICAgICAgICAgIGNvdW50ID0gKHN1ZmZpeC5tYXRjaCgvXFxuL2cpIHx8IFtdKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3RyaW5nUmVwZWF0KCdcXG4nLCBjb3VudCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb21tZW50ID0gc3RtdC5sZWFkaW5nQ29tbWVudHNbMF07XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgaWYgKHNhZmVDb25jYXRlbmF0aW9uICYmIHN0bXQudHlwZSA9PT0gU3ludGF4LlByb2dyYW0gJiYgc3RtdC5ib2R5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGdlbmVyYXRlQ29tbWVudChjb21tZW50KSk7XG4gICAgICAgICAgICAgICAgaWYgKCFlbmRzV2l0aExpbmVUZXJtaW5hdG9yKHRvU291cmNlTm9kZVdoZW5OZWVkZWQocmVzdWx0KS50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMSwgbGVuID0gc3RtdC5sZWFkaW5nQ29tbWVudHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudCA9IHN0bXQubGVhZGluZ0NvbW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudCA9IFtnZW5lcmF0ZUNvbW1lbnQoY29tbWVudCldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVuZHNXaXRoTGluZVRlcm1pbmF0b3IodG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChmcmFnbWVudCkudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50LnB1c2goJ1xcbicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFkZEluZGVudChmcmFnbWVudCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0LnB1c2goYWRkSW5kZW50KHNhdmUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdG10LnRyYWlsaW5nQ29tbWVudHMpIHtcblxuICAgICAgICAgICAgaWYgKHByZXNlcnZlQmxhbmtMaW5lcykge1xuICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBzdG10LnRyYWlsaW5nQ29tbWVudHNbMF07XG4gICAgICAgICAgICAgICAgZXh0UmFuZ2UgPSBjb21tZW50LmV4dGVuZGVkUmFuZ2U7XG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBjb21tZW50LnJhbmdlO1xuXG4gICAgICAgICAgICAgICAgcHJlZml4ID0gc291cmNlQ29kZS5zdWJzdHJpbmcoZXh0UmFuZ2VbMF0sIHJhbmdlWzBdKTtcbiAgICAgICAgICAgICAgICBjb3VudCA9IChwcmVmaXgubWF0Y2goL1xcbi9nKSB8fCBbXSkubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzdHJpbmdSZXBlYXQoJ1xcbicsIGNvdW50KSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFkZEluZGVudChnZW5lcmF0ZUNvbW1lbnQoY29tbWVudCkpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChwcmVmaXgpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChnZW5lcmF0ZUNvbW1lbnQoY29tbWVudCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFpbGluZ1RvU3RhdGVtZW50ID0gIWVuZHNXaXRoTGluZVRlcm1pbmF0b3IodG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChyZXN1bHQpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIHNwZWNpYWxCYXNlID0gc3RyaW5nUmVwZWF0KCcgJywgY2FsY3VsYXRlU3BhY2VzKHRvU291cmNlTm9kZVdoZW5OZWVkZWQoW2Jhc2UsIHJlc3VsdCwgaW5kZW50XSkudG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHN0bXQudHJhaWxpbmdDb21tZW50cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBjb21tZW50ID0gc3RtdC50cmFpbGluZ0NvbW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFpbGluZ1RvU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBhc3N1bWUgdGFyZ2V0IGxpa2UgZm9sbG93aW5nIHNjcmlwdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZhciB0ID0gMjA7ICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgKiBUaGlzIGlzIGNvbW1lbnQgb2YgdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmaXJzdCBjYXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gW3Jlc3VsdCwgaW5kZW50XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gW3Jlc3VsdCwgc3BlY2lhbEJhc2VdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZ2VuZXJhdGVDb21tZW50KGNvbW1lbnQsIHNwZWNpYWxCYXNlKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBbcmVzdWx0LCBhZGRJbmRlbnQoZ2VuZXJhdGVDb21tZW50KGNvbW1lbnQpKV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT09IGxlbiAtIDEgJiYgIWVuZHNXaXRoTGluZVRlcm1pbmF0b3IodG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChyZXN1bHQpLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBbcmVzdWx0LCAnXFxuJ107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlQmxhbmtMaW5lcyhzdGFydCwgZW5kLCByZXN1bHQpIHtcbiAgICAgICAgdmFyIGosIG5ld2xpbmVDb3VudCA9IDA7XG5cbiAgICAgICAgZm9yIChqID0gc3RhcnQ7IGogPCBlbmQ7IGorKykge1xuICAgICAgICAgICAgaWYgKHNvdXJjZUNvZGVbal0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgbmV3bGluZUNvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGogPSAxOyBqIDwgbmV3bGluZUNvdW50OyBqKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld2xpbmUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyZW50aGVzaXplKHRleHQsIGN1cnJlbnQsIHNob3VsZCkge1xuICAgICAgICBpZiAoY3VycmVudCA8IHNob3VsZCkge1xuICAgICAgICAgICAgcmV0dXJuIFsnKCcsIHRleHQsICcpJ107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVWZXJiYXRpbVN0cmluZyhzdHJpbmcpIHtcbiAgICAgICAgdmFyIGksIGl6LCByZXN1bHQ7XG4gICAgICAgIHJlc3VsdCA9IHN0cmluZy5zcGxpdCgvXFxyXFxufFxcbi8pO1xuICAgICAgICBmb3IgKGkgPSAxLCBpeiA9IHJlc3VsdC5sZW5ndGg7IGkgPCBpejsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHRbaV0gPSBuZXdsaW5lICsgYmFzZSArIHJlc3VsdFtpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlVmVyYmF0aW0oZXhwciwgcHJlY2VkZW5jZSkge1xuICAgICAgICB2YXIgdmVyYmF0aW0sIHJlc3VsdCwgcHJlYztcbiAgICAgICAgdmVyYmF0aW0gPSBleHByW2V4dHJhLnZlcmJhdGltXTtcblxuICAgICAgICBpZiAodHlwZW9mIHZlcmJhdGltID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmVzdWx0ID0gcGFyZW50aGVzaXplKGdlbmVyYXRlVmVyYmF0aW1TdHJpbmcodmVyYmF0aW0pLCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBwcmVjZWRlbmNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHZlcmJhdGltIGlzIG9iamVjdFxuICAgICAgICAgICAgcmVzdWx0ID0gZ2VuZXJhdGVWZXJiYXRpbVN0cmluZyh2ZXJiYXRpbS5jb250ZW50KTtcbiAgICAgICAgICAgIHByZWMgPSAodmVyYmF0aW0ucHJlY2VkZW5jZSAhPSBudWxsKSA/IHZlcmJhdGltLnByZWNlZGVuY2UgOiBQcmVjZWRlbmNlLlNlcXVlbmNlO1xuICAgICAgICAgICAgcmVzdWx0ID0gcGFyZW50aGVzaXplKHJlc3VsdCwgcHJlYywgcHJlY2VkZW5jZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChyZXN1bHQsIGV4cHIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIENvZGVHZW5lcmF0b3IoKSB7XG4gICAgfVxuXG4gICAgLy8gSGVscGVycy5cblxuICAgIENvZGVHZW5lcmF0b3IucHJvdG90eXBlLm1heWJlQmxvY2sgPSBmdW5jdGlvbihzdG10LCBmbGFncykge1xuICAgICAgICB2YXIgcmVzdWx0LCBub0xlYWRpbmdDb21tZW50LCB0aGF0ID0gdGhpcztcblxuICAgICAgICBub0xlYWRpbmdDb21tZW50ID0gIWV4dHJhLmNvbW1lbnQgfHwgIXN0bXQubGVhZGluZ0NvbW1lbnRzO1xuXG4gICAgICAgIGlmIChzdG10LnR5cGUgPT09IFN5bnRheC5CbG9ja1N0YXRlbWVudCAmJiBub0xlYWRpbmdDb21tZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gW3NwYWNlLCB0aGlzLmdlbmVyYXRlU3RhdGVtZW50KHN0bXQsIGZsYWdzKV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RtdC50eXBlID09PSBTeW50YXguRW1wdHlTdGF0ZW1lbnQgJiYgbm9MZWFkaW5nQ29tbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuICc7JztcbiAgICAgICAgfVxuXG4gICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gW1xuICAgICAgICAgICAgICAgIG5ld2xpbmUsXG4gICAgICAgICAgICAgICAgYWRkSW5kZW50KHRoYXQuZ2VuZXJhdGVTdGF0ZW1lbnQoc3RtdCwgZmxhZ3MpKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgQ29kZUdlbmVyYXRvci5wcm90b3R5cGUubWF5YmVCbG9ja1N1ZmZpeCA9IGZ1bmN0aW9uIChzdG10LCByZXN1bHQpIHtcbiAgICAgICAgdmFyIGVuZHMgPSBlbmRzV2l0aExpbmVUZXJtaW5hdG9yKHRvU291cmNlTm9kZVdoZW5OZWVkZWQocmVzdWx0KS50b1N0cmluZygpKTtcbiAgICAgICAgaWYgKHN0bXQudHlwZSA9PT0gU3ludGF4LkJsb2NrU3RhdGVtZW50ICYmICghZXh0cmEuY29tbWVudCB8fCAhc3RtdC5sZWFkaW5nQ29tbWVudHMpICYmICFlbmRzKSB7XG4gICAgICAgICAgICByZXR1cm4gW3Jlc3VsdCwgc3BhY2VdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmRzKSB7XG4gICAgICAgICAgICByZXR1cm4gW3Jlc3VsdCwgYmFzZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtyZXN1bHQsIG5ld2xpbmUsIGJhc2VdO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUlkZW50aWZpZXIobm9kZSkge1xuICAgICAgICByZXR1cm4gdG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChub2RlLm5hbWUsIG5vZGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlQXN5bmNQcmVmaXgobm9kZSwgc3BhY2VSZXF1aXJlZCkge1xuICAgICAgICByZXR1cm4gbm9kZS5hc3luYyA/ICdhc3luYycgKyAoc3BhY2VSZXF1aXJlZCA/IG5vRW1wdHlTcGFjZSgpIDogc3BhY2UpIDogJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVTdGFyU3VmZml4KG5vZGUpIHtcbiAgICAgICAgdmFyIGlzR2VuZXJhdG9yID0gbm9kZS5nZW5lcmF0b3IgJiYgIWV4dHJhLm1vei5zdGFybGVzc0dlbmVyYXRvcjtcbiAgICAgICAgcmV0dXJuIGlzR2VuZXJhdG9yID8gJyonICsgc3BhY2UgOiAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZU1ldGhvZFByZWZpeChwcm9wKSB7XG4gICAgICAgIHZhciBmdW5jID0gcHJvcC52YWx1ZSwgcHJlZml4ID0gJyc7XG4gICAgICAgIGlmIChmdW5jLmFzeW5jKSB7XG4gICAgICAgICAgICBwcmVmaXggKz0gZ2VuZXJhdGVBc3luY1ByZWZpeChmdW5jLCAhcHJvcC5jb21wdXRlZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZ1bmMuZ2VuZXJhdG9yKSB7XG4gICAgICAgICAgICAvLyBhdm9pZCBzcGFjZSBiZWZvcmUgbWV0aG9kIG5hbWVcbiAgICAgICAgICAgIHByZWZpeCArPSBnZW5lcmF0ZVN0YXJTdWZmaXgoZnVuYykgPyAnKicgOiAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJlZml4O1xuICAgIH1cblxuICAgIENvZGVHZW5lcmF0b3IucHJvdG90eXBlLmdlbmVyYXRlUGF0dGVybiA9IGZ1bmN0aW9uIChub2RlLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICBpZiAobm9kZS50eXBlID09PSBTeW50YXguSWRlbnRpZmllcikge1xuICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlSWRlbnRpZmllcihub2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24obm9kZSwgcHJlY2VkZW5jZSwgZmxhZ3MpO1xuICAgIH07XG5cbiAgICBDb2RlR2VuZXJhdG9yLnByb3RvdHlwZS5nZW5lcmF0ZUZ1bmN0aW9uUGFyYW1zID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIGksIGl6LCByZXN1bHQsIGhhc0RlZmF1bHQ7XG5cbiAgICAgICAgaGFzRGVmYXVsdCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IFN5bnRheC5BcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbiAmJlxuICAgICAgICAgICAgICAgICFub2RlLnJlc3QgJiYgKCFub2RlLmRlZmF1bHRzIHx8IG5vZGUuZGVmYXVsdHMubGVuZ3RoID09PSAwKSAmJlxuICAgICAgICAgICAgICAgIG5vZGUucGFyYW1zLmxlbmd0aCA9PT0gMSAmJiBub2RlLnBhcmFtc1swXS50eXBlID09PSBTeW50YXguSWRlbnRpZmllcikge1xuICAgICAgICAgICAgLy8gYXJnID0+IHsgfSBjYXNlXG4gICAgICAgICAgICByZXN1bHQgPSBbZ2VuZXJhdGVBc3luY1ByZWZpeChub2RlLCB0cnVlKSwgZ2VuZXJhdGVJZGVudGlmaWVyKG5vZGUucGFyYW1zWzBdKV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBub2RlLnR5cGUgPT09IFN5bnRheC5BcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbiA/IFtnZW5lcmF0ZUFzeW5jUHJlZml4KG5vZGUsIGZhbHNlKV0gOiBbXTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcoJyk7XG4gICAgICAgICAgICBpZiAobm9kZS5kZWZhdWx0cykge1xuICAgICAgICAgICAgICAgIGhhc0RlZmF1bHQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChpID0gMCwgaXogPSBub2RlLnBhcmFtcy5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc0RlZmF1bHQgJiYgbm9kZS5kZWZhdWx0c1tpXSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgZGVmYXVsdCB2YWx1ZXMuXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuZ2VuZXJhdGVBc3NpZ25tZW50KG5vZGUucGFyYW1zW2ldLCBub2RlLmRlZmF1bHRzW2ldLCAnPScsIFByZWNlZGVuY2UuQXNzaWdubWVudCwgRV9UVFQpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmdlbmVyYXRlUGF0dGVybihub2RlLnBhcmFtc1tpXSwgUHJlY2VkZW5jZS5Bc3NpZ25tZW50LCBFX1RUVCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaSArIDEgPCBpeikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLCcgKyBzcGFjZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobm9kZS5yZXN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUucGFyYW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLCcgKyBzcGFjZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcuLi4nKTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChnZW5lcmF0ZUlkZW50aWZpZXIobm9kZS5yZXN0KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcpJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICBDb2RlR2VuZXJhdG9yLnByb3RvdHlwZS5nZW5lcmF0ZUZ1bmN0aW9uQm9keSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciByZXN1bHQsIGV4cHI7XG5cbiAgICAgICAgcmVzdWx0ID0gdGhpcy5nZW5lcmF0ZUZ1bmN0aW9uUGFyYW1zKG5vZGUpO1xuXG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IFN5bnRheC5BcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbikge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goc3BhY2UpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goJz0+Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobm9kZS5leHByZXNzaW9uKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChzcGFjZSk7XG4gICAgICAgICAgICBleHByID0gdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24obm9kZS5ib2R5LCBQcmVjZWRlbmNlLkFzc2lnbm1lbnQsIEVfVFRUKTtcbiAgICAgICAgICAgIGlmIChleHByLnRvU3RyaW5nKCkuY2hhckF0KDApID09PSAneycpIHtcbiAgICAgICAgICAgICAgICBleHByID0gWycoJywgZXhwciwgJyknXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGV4cHIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5tYXliZUJsb2NrKG5vZGUuYm9keSwgU19UVEZGKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICBDb2RlR2VuZXJhdG9yLnByb3RvdHlwZS5nZW5lcmF0ZUl0ZXJhdGlvbkZvclN0YXRlbWVudCA9IGZ1bmN0aW9uIChvcGVyYXRvciwgc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFsnZm9yJyArIHNwYWNlICsgKHN0bXQuYXdhaXQgPyAnYXdhaXQnICsgc3BhY2UgOiAnJykgKyAnKCddLCB0aGF0ID0gdGhpcztcbiAgICAgICAgd2l0aEluZGVudChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoc3RtdC5sZWZ0LnR5cGUgPT09IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgd2l0aEluZGVudChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHN0bXQubGVmdC5raW5kICsgbm9FbXB0eVNwYWNlKCkpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGF0LmdlbmVyYXRlU3RhdGVtZW50KHN0bXQubGVmdC5kZWNsYXJhdGlvbnNbMF0sIFNfRkZGRikpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGF0LmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LmxlZnQsIFByZWNlZGVuY2UuQ2FsbCwgRV9UVFQpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIG9wZXJhdG9yKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IFtqb2luKFxuICAgICAgICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICAgICAgICB0aGF0LmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LnJpZ2h0LCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVClcbiAgICAgICAgICAgICksICcpJ107XG4gICAgICAgIH0pO1xuICAgICAgICByZXN1bHQucHVzaCh0aGlzLm1heWJlQmxvY2soc3RtdC5ib2R5LCBmbGFncykpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICBDb2RlR2VuZXJhdG9yLnByb3RvdHlwZS5nZW5lcmF0ZVByb3BlcnR5S2V5ID0gZnVuY3Rpb24gKGV4cHIsIGNvbXB1dGVkKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICBpZiAoY29tcHV0ZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCdbJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQucHVzaCh0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCkpO1xuXG4gICAgICAgIGlmIChjb21wdXRlZCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goJ10nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIENvZGVHZW5lcmF0b3IucHJvdG90eXBlLmdlbmVyYXRlQXNzaWdubWVudCA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCwgb3BlcmF0b3IsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgIGlmIChQcmVjZWRlbmNlLkFzc2lnbm1lbnQgPCBwcmVjZWRlbmNlKSB7XG4gICAgICAgICAgICBmbGFncyB8PSBGX0FMTE9XX0lOO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcmVudGhlc2l6ZShcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihsZWZ0LCBQcmVjZWRlbmNlLkNhbGwsIGZsYWdzKSxcbiAgICAgICAgICAgICAgICBzcGFjZSArIG9wZXJhdG9yICsgc3BhY2UsXG4gICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24ocmlnaHQsIFByZWNlZGVuY2UuQXNzaWdubWVudCwgZmxhZ3MpXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgUHJlY2VkZW5jZS5Bc3NpZ25tZW50LFxuICAgICAgICAgICAgcHJlY2VkZW5jZVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICBDb2RlR2VuZXJhdG9yLnByb3RvdHlwZS5zZW1pY29sb24gPSBmdW5jdGlvbiAoZmxhZ3MpIHtcbiAgICAgICAgaWYgKCFzZW1pY29sb25zICYmIGZsYWdzICYgRl9TRU1JQ09MT05fT1BUKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICc7JztcbiAgICB9O1xuXG4gICAgLy8gU3RhdGVtZW50cy5cblxuICAgIENvZGVHZW5lcmF0b3IuU3RhdGVtZW50ID0ge1xuXG4gICAgICAgIEJsb2NrU3RhdGVtZW50OiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByYW5nZSwgY29udGVudCwgcmVzdWx0ID0gWyd7JywgbmV3bGluZV0sIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICB3aXRoSW5kZW50KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgZnVuY3Rpb25zIHdpdGhvdXQgYW55IGNvZGVcbiAgICAgICAgICAgICAgICBpZiAoc3RtdC5ib2R5Lmxlbmd0aCA9PT0gMCAmJiBwcmVzZXJ2ZUJsYW5rTGluZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSBzdG10LnJhbmdlO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2VbMV0gLSByYW5nZVswXSA+IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBzb3VyY2VDb2RlLnN1YnN0cmluZyhyYW5nZVswXSArIDEsIHJhbmdlWzFdIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudFswXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBbJ3snXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGksIGl6LCBmcmFnbWVudCwgYm9keUZsYWdzO1xuICAgICAgICAgICAgICAgIGJvZHlGbGFncyA9IFNfVEZGRjtcbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MgJiBGX0ZVTkNfQk9EWSkge1xuICAgICAgICAgICAgICAgICAgICBib2R5RmxhZ3MgfD0gRl9ESVJFQ1RJVkVfQ1RYO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGl6ID0gc3RtdC5ib2R5Lmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXNlcnZlQmxhbmtMaW5lcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlIHNwYWNlcyBiZWZvcmUgdGhlIGZpcnN0IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0bXQuYm9keVswXS5sZWFkaW5nQ29tbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSBzdG10LmJvZHlbMF0ubGVhZGluZ0NvbW1lbnRzWzBdLmV4dGVuZGVkUmFuZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBzb3VyY2VDb2RlLnN1YnN0cmluZyhyYW5nZVswXSwgcmFuZ2VbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudFswXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFsneyddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3RtdC5ib2R5WzBdLmxlYWRpbmdDb21tZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZUJsYW5rTGluZXMoc3RtdC5yYW5nZVswXSwgc3RtdC5ib2R5WzBdLnJhbmdlWzBdLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlIHNwYWNlcyBiZXR3ZWVuIGxpbmVzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN0bXQuYm9keVtpIC0gMV0udHJhaWxpbmdDb21tZW50cyAgJiYgIXN0bXQuYm9keVtpXS5sZWFkaW5nQ29tbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVCbGFua0xpbmVzKHN0bXQuYm9keVtpIC0gMV0ucmFuZ2VbMV0sIHN0bXQuYm9keVtpXS5yYW5nZVswXSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gaXogLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5RmxhZ3MgfD0gRl9TRU1JQ09MT05fT1BUO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0bXQuYm9keVtpXS5sZWFkaW5nQ29tbWVudHMgJiYgcHJlc2VydmVCbGFua0xpbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFnbWVudCA9IHRoYXQuZ2VuZXJhdGVTdGF0ZW1lbnQoc3RtdC5ib2R5W2ldLCBib2R5RmxhZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBhZGRJbmRlbnQodGhhdC5nZW5lcmF0ZVN0YXRlbWVudChzdG10LmJvZHlbaV0sIGJvZHlGbGFncykpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVuZHNXaXRoTGluZVRlcm1pbmF0b3IodG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChmcmFnbWVudCkudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVzZXJ2ZUJsYW5rTGluZXMgJiYgaSA8IGl6IC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IGFkZCBhIG5ldyBsaW5lIGlmIHRoZXJlIGFyZSBsZWFkaW5nIGNvbWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiB0aGUgbmV4dCBzdGF0ZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN0bXQuYm9keVtpICsgMV0ubGVhZGluZ0NvbW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld2xpbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAocHJlc2VydmVCbGFua0xpbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBoYW5kbGUgc3BhY2VzIGFmdGVyIHRoZSBsYXN0IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBpeiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN0bXQuYm9keVtpXS50cmFpbGluZ0NvbW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlQmxhbmtMaW5lcyhzdG10LmJvZHlbaV0ucmFuZ2VbMV0sIHN0bXQucmFuZ2VbMV0sIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFkZEluZGVudCgnfScpKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQnJlYWtTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgaWYgKHN0bXQubGFiZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2JyZWFrICcgKyBzdG10LmxhYmVsLm5hbWUgKyB0aGlzLnNlbWljb2xvbihmbGFncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJ2JyZWFrJyArIHRoaXMuc2VtaWNvbG9uKGZsYWdzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBDb250aW51ZVN0YXRlbWVudDogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICBpZiAoc3RtdC5sYWJlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnY29udGludWUgJyArIHN0bXQubGFiZWwubmFtZSArIHRoaXMuc2VtaWNvbG9uKGZsYWdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnY29udGludWUnICsgdGhpcy5zZW1pY29sb24oZmxhZ3MpO1xuICAgICAgICB9LFxuXG4gICAgICAgIENsYXNzQm9keTogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gWyAneycsIG5ld2xpbmVdLCB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgd2l0aEluZGVudChmdW5jdGlvbiAoaW5kZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGksIGl6O1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaXogPSBzdG10LmJvZHkubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpbmRlbnQpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGF0LmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LmJvZHlbaV0sIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICsgMSA8IGl6KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIWVuZHNXaXRoTGluZVRlcm1pbmF0b3IodG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChyZXN1bHQpLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChiYXNlKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCd9Jyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIENsYXNzRGVjbGFyYXRpb246IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgZnJhZ21lbnQ7XG4gICAgICAgICAgICByZXN1bHQgID0gWydjbGFzcyddO1xuICAgICAgICAgICAgaWYgKHN0bXQuaWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5pZCwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdG10LnN1cGVyQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICBmcmFnbWVudCA9IGpvaW4oJ2V4dGVuZHMnLCB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LnN1cGVyQ2xhc3MsIFByZWNlZGVuY2UuQXNzaWdubWVudCwgRV9UVFQpKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goc3BhY2UpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5nZW5lcmF0ZVN0YXRlbWVudChzdG10LmJvZHksIFNfVEZGVCkpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBEaXJlY3RpdmVTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgaWYgKGV4dHJhLnJhdyAmJiBzdG10LnJhdykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdG10LnJhdyArIHRoaXMuc2VtaWNvbG9uKGZsYWdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlc2NhcGVEaXJlY3RpdmUoc3RtdC5kaXJlY3RpdmUpICsgdGhpcy5zZW1pY29sb24oZmxhZ3MpO1xuICAgICAgICB9LFxuXG4gICAgICAgIERvV2hpbGVTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgLy8gQmVjYXVzZSBgZG8gNDIgd2hpbGUgKGNvbmQpYCBpcyBTeW50YXggRXJyb3IuIFdlIG5lZWQgc2VtaWNvbG9uLlxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGpvaW4oJ2RvJywgdGhpcy5tYXliZUJsb2NrKHN0bXQuYm9keSwgU19URkZGKSk7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLm1heWJlQmxvY2tTdWZmaXgoc3RtdC5ib2R5LCByZXN1bHQpO1xuICAgICAgICAgICAgcmV0dXJuIGpvaW4ocmVzdWx0LCBbXG4gICAgICAgICAgICAgICAgJ3doaWxlJyArIHNwYWNlICsgJygnLFxuICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQudGVzdCwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpLFxuICAgICAgICAgICAgICAgICcpJyArIHRoaXMuc2VtaWNvbG9uKGZsYWdzKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQ2F0Y2hDbGF1c2U6IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICB3aXRoSW5kZW50KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ3VhcmQ7XG5cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbXG4gICAgICAgICAgICAgICAgICAgICdjYXRjaCcgKyBzcGFjZSArICcoJyxcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5wYXJhbSwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpLFxuICAgICAgICAgICAgICAgICAgICAnKSdcbiAgICAgICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICAgICAgaWYgKHN0bXQuZ3VhcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3VhcmQgPSB0aGF0LmdlbmVyYXRlRXhwcmVzc2lvbihzdG10Lmd1YXJkLCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zcGxpY2UoMiwgMCwgJyBpZiAnLCBndWFyZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLm1heWJlQmxvY2soc3RtdC5ib2R5LCBTX1RGRkYpKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRGVidWdnZXJTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgcmV0dXJuICdkZWJ1Z2dlcicgKyB0aGlzLnNlbWljb2xvbihmbGFncyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRW1wdHlTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgcmV0dXJuICc7JztcbiAgICAgICAgfSxcblxuICAgICAgICBFeHBvcnREZWZhdWx0RGVjbGFyYXRpb246IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFsgJ2V4cG9ydCcgXSwgYm9keUZsYWdzO1xuXG4gICAgICAgICAgICBib2R5RmxhZ3MgPSAoZmxhZ3MgJiBGX1NFTUlDT0xPTl9PUFQpID8gU19URkZUIDogU19URkZGO1xuXG4gICAgICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCBIb2lzdGFibGVEZWNsYXJhdGlvbltEZWZhdWx0XVxuICAgICAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQgQXNzaWdubWVudEV4cHJlc3Npb25bSW5dIDtcbiAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCAnZGVmYXVsdCcpO1xuICAgICAgICAgICAgaWYgKGlzU3RhdGVtZW50KHN0bXQuZGVjbGFyYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIHRoaXMuZ2VuZXJhdGVTdGF0ZW1lbnQoc3RtdC5kZWNsYXJhdGlvbiwgYm9keUZsYWdzKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LmRlY2xhcmF0aW9uLCBQcmVjZWRlbmNlLkFzc2lnbm1lbnQsIEVfVFRUKSArIHRoaXMuc2VtaWNvbG9uKGZsYWdzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIEV4cG9ydE5hbWVkRGVjbGFyYXRpb246IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFsgJ2V4cG9ydCcgXSwgYm9keUZsYWdzLCB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgYm9keUZsYWdzID0gKGZsYWdzICYgRl9TRU1JQ09MT05fT1BUKSA/IFNfVEZGVCA6IFNfVEZGRjtcblxuICAgICAgICAgICAgLy8gZXhwb3J0IFZhcmlhYmxlU3RhdGVtZW50XG4gICAgICAgICAgICAvLyBleHBvcnQgRGVjbGFyYXRpb25bRGVmYXVsdF1cbiAgICAgICAgICAgIGlmIChzdG10LmRlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGpvaW4ocmVzdWx0LCB0aGlzLmdlbmVyYXRlU3RhdGVtZW50KHN0bXQuZGVjbGFyYXRpb24sIGJvZHlGbGFncykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBleHBvcnQgRXhwb3J0Q2xhdXNlW05vUmVmZXJlbmNlXSBGcm9tQ2xhdXNlIDtcbiAgICAgICAgICAgIC8vIGV4cG9ydCBFeHBvcnRDbGF1c2UgO1xuICAgICAgICAgICAgaWYgKHN0bXQuc3BlY2lmaWVycykge1xuICAgICAgICAgICAgICAgIGlmIChzdG10LnNwZWNpZmllcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCAneycgKyBzcGFjZSArICd9Jyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdG10LnNwZWNpZmllcnNbMF0udHlwZSA9PT0gU3ludGF4LkV4cG9ydEJhdGNoU3BlY2lmaWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LnNwZWNpZmllcnNbMF0sIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsICd7Jyk7XG4gICAgICAgICAgICAgICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKGluZGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGksIGl6O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IHN0bXQuc3BlY2lmaWVycy5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaW5kZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGF0LmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LnNwZWNpZmllcnNbaV0sIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgKyAxIDwgaXopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJywnICsgbmV3bGluZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlbmRzV2l0aExpbmVUZXJtaW5hdG9yKHRvU291cmNlTm9kZVdoZW5OZWVkZWQocmVzdWx0KS50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYmFzZSArICd9Jyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHN0bXQuc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnZnJvbScgKyBzcGFjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1vZHVsZVNwZWNpZmllclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5zb3VyY2UsIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VtaWNvbG9uKGZsYWdzKVxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLnNlbWljb2xvbihmbGFncykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRXhwb3J0QWxsRGVjbGFyYXRpb246IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgLy8gZXhwb3J0ICogRnJvbUNsYXVzZSA7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICdleHBvcnQnICsgc3BhY2UsXG4gICAgICAgICAgICAgICAgJyonICsgc3BhY2UsXG4gICAgICAgICAgICAgICAgJ2Zyb20nICsgc3BhY2UsXG4gICAgICAgICAgICAgICAgLy8gTW9kdWxlU3BlY2lmaWVyXG4gICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5zb3VyY2UsIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSxcbiAgICAgICAgICAgICAgICB0aGlzLnNlbWljb2xvbihmbGFncylcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgRXhwcmVzc2lvblN0YXRlbWVudDogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBmcmFnbWVudDtcblxuICAgICAgICAgICAgZnVuY3Rpb24gaXNDbGFzc1ByZWZpeGVkKGZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvZGU7XG4gICAgICAgICAgICAgICAgaWYgKGZyYWdtZW50LnNsaWNlKDAsIDUpICE9PSAnY2xhc3MnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29kZSA9IGZyYWdtZW50LmNoYXJDb2RlQXQoNSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvZGUgPT09IDB4N0IgIC8qICd7JyAqLyB8fCBlc3V0aWxzLmNvZGUuaXNXaGl0ZVNwYWNlKGNvZGUpIHx8IGVzdXRpbHMuY29kZS5pc0xpbmVUZXJtaW5hdG9yKGNvZGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uUHJlZml4ZWQoZnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29kZTtcbiAgICAgICAgICAgICAgICBpZiAoZnJhZ21lbnQuc2xpY2UoMCwgOCkgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb2RlID0gZnJhZ21lbnQuY2hhckNvZGVBdCg4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29kZSA9PT0gMHgyOCAvKiAnKCcgKi8gfHwgZXN1dGlscy5jb2RlLmlzV2hpdGVTcGFjZShjb2RlKSB8fCBjb2RlID09PSAweDJBICAvKiAnKicgKi8gfHwgZXN1dGlscy5jb2RlLmlzTGluZVRlcm1pbmF0b3IoY29kZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzQXN5bmNQcmVmaXhlZChmcmFnbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBjb2RlLCBpLCBpejtcbiAgICAgICAgICAgICAgICBpZiAoZnJhZ21lbnQuc2xpY2UoMCwgNSkgIT09ICdhc3luYycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWVzdXRpbHMuY29kZS5pc1doaXRlU3BhY2UoZnJhZ21lbnQuY2hhckNvZGVBdCg1KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSA2LCBpeiA9IGZyYWdtZW50Lmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlc3V0aWxzLmNvZGUuaXNXaGl0ZVNwYWNlKGZyYWdtZW50LmNoYXJDb2RlQXQoaSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gaXopIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZnJhZ21lbnQuc2xpY2UoaSwgaSArIDgpICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29kZSA9IGZyYWdtZW50LmNoYXJDb2RlQXQoaSArIDgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2RlID09PSAweDI4IC8qICcoJyAqLyB8fCBlc3V0aWxzLmNvZGUuaXNXaGl0ZVNwYWNlKGNvZGUpIHx8IGNvZGUgPT09IDB4MkEgIC8qICcqJyAqLyB8fCBlc3V0aWxzLmNvZGUuaXNMaW5lVGVybWluYXRvcihjb2RlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0ID0gW3RoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQuZXhwcmVzc2lvbiwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpXTtcbiAgICAgICAgICAgIC8vIDEyLjQgJ3snLCAnZnVuY3Rpb24nLCAnY2xhc3MnIGlzIG5vdCBhbGxvd2VkIGluIHRoaXMgcG9zaXRpb24uXG4gICAgICAgICAgICAvLyB3cmFwIGV4cHJlc3Npb24gd2l0aCBwYXJlbnRoZXNlc1xuICAgICAgICAgICAgZnJhZ21lbnQgPSB0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKHJlc3VsdCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGlmIChmcmFnbWVudC5jaGFyQ29kZUF0KDApID09PSAweDdCICAvKiAneycgKi8gfHwgIC8vIE9iamVjdEV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgaXNDbGFzc1ByZWZpeGVkKGZyYWdtZW50KSB8fFxuICAgICAgICAgICAgICAgICAgICBpc0Z1bmN0aW9uUHJlZml4ZWQoZnJhZ21lbnQpIHx8XG4gICAgICAgICAgICAgICAgICAgIGlzQXN5bmNQcmVmaXhlZChmcmFnbWVudCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGRpcmVjdGl2ZSAmJiAoZmxhZ3MgJiBGX0RJUkVDVElWRV9DVFgpICYmIHN0bXQuZXhwcmVzc2lvbi50eXBlID09PSBTeW50YXguTGl0ZXJhbCAmJiB0eXBlb2Ygc3RtdC5leHByZXNzaW9uLnZhbHVlID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbJygnLCByZXN1bHQsICcpJyArIHRoaXMuc2VtaWNvbG9uKGZsYWdzKV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuc2VtaWNvbG9uKGZsYWdzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIEltcG9ydERlY2xhcmF0aW9uOiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIC8vIEVTNjogMTUuMi4xIHZhbGlkIGltcG9ydCBkZWNsYXJhdGlvbnM6XG4gICAgICAgICAgICAvLyAgICAgLSBpbXBvcnQgSW1wb3J0Q2xhdXNlIEZyb21DbGF1c2UgO1xuICAgICAgICAgICAgLy8gICAgIC0gaW1wb3J0IE1vZHVsZVNwZWNpZmllciA7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBjdXJzb3IsIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICAvLyBJZiBubyBJbXBvcnRDbGF1c2UgaXMgcHJlc2VudCxcbiAgICAgICAgICAgIC8vIHRoaXMgc2hvdWxkIGJlIGBpbXBvcnQgTW9kdWxlU3BlY2lmaWVyYCBzbyBza2lwIGBmcm9tYFxuICAgICAgICAgICAgLy8gTW9kdWxlU3BlY2lmaWVyIGlzIFN0cmluZ0xpdGVyYWwuXG4gICAgICAgICAgICBpZiAoc3RtdC5zcGVjaWZpZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIGltcG9ydCBNb2R1bGVTcGVjaWZpZXIgO1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICdpbXBvcnQnLFxuICAgICAgICAgICAgICAgICAgICBzcGFjZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gTW9kdWxlU3BlY2lmaWVyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQuc291cmNlLCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VtaWNvbG9uKGZsYWdzKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGltcG9ydCBJbXBvcnRDbGF1c2UgRnJvbUNsYXVzZSA7XG4gICAgICAgICAgICByZXN1bHQgPSBbXG4gICAgICAgICAgICAgICAgJ2ltcG9ydCdcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBjdXJzb3IgPSAwO1xuXG4gICAgICAgICAgICAvLyBJbXBvcnRlZEJpbmRpbmdcbiAgICAgICAgICAgIGlmIChzdG10LnNwZWNpZmllcnNbY3Vyc29yXS50eXBlID09PSBTeW50YXguSW1wb3J0RGVmYXVsdFNwZWNpZmllcikge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LnNwZWNpZmllcnNbY3Vyc29yXSwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgKytjdXJzb3I7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdG10LnNwZWNpZmllcnNbY3Vyc29yXSkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJzb3IgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJywnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc3RtdC5zcGVjaWZpZXJzW2N1cnNvcl0udHlwZSA9PT0gU3ludGF4LkltcG9ydE5hbWVzcGFjZVNwZWNpZmllcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBOYW1lU3BhY2VJbXBvcnRcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LnNwZWNpZmllcnNbY3Vyc29yXSwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5hbWVkSW1wb3J0c1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzcGFjZSArICd7Jyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKChzdG10LnNwZWNpZmllcnMubGVuZ3RoIC0gY3Vyc29yKSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW1wb3J0IHsgLi4uIH0gZnJvbSBcIi4uLlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3BhY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5zcGVjaWZpZXJzW2N1cnNvcl0sIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzcGFjZSArICd9JyArIHNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGltcG9ydCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAuLi4sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAuLi4sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB9IGZyb20gXCIuLi5cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKGluZGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpLCBpejtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSBjdXJzb3IsIGl6ID0gc3RtdC5zcGVjaWZpZXJzLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaW5kZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhhdC5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5zcGVjaWZpZXJzW2ldLCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSArIDEgPCBpeikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJywnICsgbmV3bGluZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZW5kc1dpdGhMaW5lVGVybWluYXRvcih0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKHJlc3VsdCkudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJhc2UgKyAnfScgKyBzcGFjZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCBbXG4gICAgICAgICAgICAgICAgJ2Zyb20nICsgc3BhY2UsXG4gICAgICAgICAgICAgICAgLy8gTW9kdWxlU3BlY2lmaWVyXG4gICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5zb3VyY2UsIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSxcbiAgICAgICAgICAgICAgICB0aGlzLnNlbWljb2xvbihmbGFncylcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBWYXJpYWJsZURlY2xhcmF0b3I6IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgdmFyIGl0ZW1GbGFncyA9IChmbGFncyAmIEZfQUxMT1dfSU4pID8gRV9UVFQgOiBFX0ZUVDtcbiAgICAgICAgICAgIGlmIChzdG10LmluaXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LmlkLCBQcmVjZWRlbmNlLkFzc2lnbm1lbnQsIGl0ZW1GbGFncyksXG4gICAgICAgICAgICAgICAgICAgIHNwYWNlLFxuICAgICAgICAgICAgICAgICAgICAnPScsXG4gICAgICAgICAgICAgICAgICAgIHNwYWNlLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LmluaXQsIFByZWNlZGVuY2UuQXNzaWdubWVudCwgaXRlbUZsYWdzKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZVBhdHRlcm4oc3RtdC5pZCwgUHJlY2VkZW5jZS5Bc3NpZ25tZW50LCBpdGVtRmxhZ3MpO1xuICAgICAgICB9LFxuXG4gICAgICAgIFZhcmlhYmxlRGVjbGFyYXRpb246IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgLy8gVmFyaWFibGVEZWNsYXJhdG9yIGlzIHR5cGVkIGFzIFN0YXRlbWVudCxcbiAgICAgICAgICAgIC8vIGJ1dCBqb2luZWQgd2l0aCBjb21tYSAobm90IExpbmVUZXJtaW5hdG9yKS5cbiAgICAgICAgICAgIC8vIFNvIGlmIGNvbW1lbnQgaXMgYXR0YWNoZWQgdG8gdGFyZ2V0IG5vZGUsIHdlIHNob3VsZCBzcGVjaWFsaXplLlxuICAgICAgICAgICAgdmFyIHJlc3VsdCwgaSwgaXosIG5vZGUsIGJvZHlGbGFncywgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIHJlc3VsdCA9IFsgc3RtdC5raW5kIF07XG5cbiAgICAgICAgICAgIGJvZHlGbGFncyA9IChmbGFncyAmIEZfQUxMT1dfSU4pID8gU19URkZGIDogU19GRkZGO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBibG9jaygpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gc3RtdC5kZWNsYXJhdGlvbnNbMF07XG4gICAgICAgICAgICAgICAgaWYgKGV4dHJhLmNvbW1lbnQgJiYgbm9kZS5sZWFkaW5nQ29tbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJ1xcbicpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhZGRJbmRlbnQodGhhdC5nZW5lcmF0ZVN0YXRlbWVudChub2RlLCBib2R5RmxhZ3MpKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobm9FbXB0eVNwYWNlKCkpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGF0LmdlbmVyYXRlU3RhdGVtZW50KG5vZGUsIGJvZHlGbGFncykpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDEsIGl6ID0gc3RtdC5kZWNsYXJhdGlvbnMubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gc3RtdC5kZWNsYXJhdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHRyYS5jb21tZW50ICYmIG5vZGUubGVhZGluZ0NvbW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLCcgKyBuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFkZEluZGVudCh0aGF0LmdlbmVyYXRlU3RhdGVtZW50KG5vZGUsIGJvZHlGbGFncykpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcsJyArIHNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoYXQuZ2VuZXJhdGVTdGF0ZW1lbnQobm9kZSwgYm9keUZsYWdzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdG10LmRlY2xhcmF0aW9ucy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgd2l0aEluZGVudChibG9jayk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJsb2NrKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuc2VtaWNvbG9uKGZsYWdzKSk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgVGhyb3dTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgcmV0dXJuIFtqb2luKFxuICAgICAgICAgICAgICAgICd0aHJvdycsXG4gICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5hcmd1bWVudCwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpXG4gICAgICAgICAgICApLCB0aGlzLnNlbWljb2xvbihmbGFncyldO1xuICAgICAgICB9LFxuXG4gICAgICAgIFRyeVN0YXRlbWVudDogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBpLCBpeiwgZ3VhcmRlZEhhbmRsZXJzO1xuXG4gICAgICAgICAgICByZXN1bHQgPSBbJ3RyeScsIHRoaXMubWF5YmVCbG9jayhzdG10LmJsb2NrLCBTX1RGRkYpXTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMubWF5YmVCbG9ja1N1ZmZpeChzdG10LmJsb2NrLCByZXN1bHQpO1xuXG4gICAgICAgICAgICBpZiAoc3RtdC5oYW5kbGVycykge1xuICAgICAgICAgICAgICAgIC8vIG9sZCBpbnRlcmZhY2VcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IHN0bXQuaGFuZGxlcnMubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgdGhpcy5nZW5lcmF0ZVN0YXRlbWVudChzdG10LmhhbmRsZXJzW2ldLCBTX1RGRkYpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0bXQuZmluYWxpemVyIHx8IGkgKyAxICE9PSBpeikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5tYXliZUJsb2NrU3VmZml4KHN0bXQuaGFuZGxlcnNbaV0uYm9keSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ3VhcmRlZEhhbmRsZXJzID0gc3RtdC5ndWFyZGVkSGFuZGxlcnMgfHwgW107XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IGd1YXJkZWRIYW5kbGVycy5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCB0aGlzLmdlbmVyYXRlU3RhdGVtZW50KGd1YXJkZWRIYW5kbGVyc1tpXSwgU19URkZGKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdG10LmZpbmFsaXplciB8fCBpICsgMSAhPT0gaXopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMubWF5YmVCbG9ja1N1ZmZpeChndWFyZGVkSGFuZGxlcnNbaV0uYm9keSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIG5ldyBpbnRlcmZhY2VcbiAgICAgICAgICAgICAgICBpZiAoc3RtdC5oYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHN0bXQuaGFuZGxlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGl6ID0gc3RtdC5oYW5kbGVyLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgdGhpcy5nZW5lcmF0ZVN0YXRlbWVudChzdG10LmhhbmRsZXJbaV0sIFNfVEZGRikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdG10LmZpbmFsaXplciB8fCBpICsgMSAhPT0gaXopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5tYXliZUJsb2NrU3VmZml4KHN0bXQuaGFuZGxlcltpXS5ib2R5LCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCB0aGlzLmdlbmVyYXRlU3RhdGVtZW50KHN0bXQuaGFuZGxlciwgU19URkZGKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RtdC5maW5hbGl6ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLm1heWJlQmxvY2tTdWZmaXgoc3RtdC5oYW5kbGVyLmJvZHksIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RtdC5maW5hbGl6ZXIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgWydmaW5hbGx5JywgdGhpcy5tYXliZUJsb2NrKHN0bXQuZmluYWxpemVyLCBTX1RGRkYpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIFN3aXRjaFN0YXRlbWVudDogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBmcmFnbWVudCwgaSwgaXosIGJvZHlGbGFncywgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICB3aXRoSW5kZW50KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbXG4gICAgICAgICAgICAgICAgICAgICdzd2l0Y2gnICsgc3BhY2UgKyAnKCcsXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQuZGlzY3JpbWluYW50LCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCksXG4gICAgICAgICAgICAgICAgICAgICcpJyArIHNwYWNlICsgJ3snICsgbmV3bGluZVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChzdG10LmNhc2VzKSB7XG4gICAgICAgICAgICAgICAgYm9keUZsYWdzID0gU19URkZGO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGl6ID0gc3RtdC5jYXNlcy5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBpeiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlGbGFncyB8PSBGX1NFTUlDT0xPTl9PUFQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBhZGRJbmRlbnQodGhpcy5nZW5lcmF0ZVN0YXRlbWVudChzdG10LmNhc2VzW2ldLCBib2R5RmxhZ3MpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVuZHNXaXRoTGluZVRlcm1pbmF0b3IodG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChmcmFnbWVudCkudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld2xpbmUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goYWRkSW5kZW50KCd9JykpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBTd2l0Y2hDYXNlOiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIGZyYWdtZW50LCBpLCBpeiwgYm9keUZsYWdzLCB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChzdG10LnRlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgam9pbignY2FzZScsIHRoYXQuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQudGVzdCwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICc6J1xuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFsnZGVmYXVsdDonXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgICBpeiA9IHN0bXQuY29uc2VxdWVudC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGl6ICYmIHN0bXQuY29uc2VxdWVudFswXS50eXBlID09PSBTeW50YXguQmxvY2tTdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSB0aGF0Lm1heWJlQmxvY2soc3RtdC5jb25zZXF1ZW50WzBdLCBTX1RGRkYpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGkgPSAxO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpICE9PSBpeiAmJiAhZW5kc1dpdGhMaW5lVGVybWluYXRvcih0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKHJlc3VsdCkudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYm9keUZsYWdzID0gU19URkZGO1xuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gaXogLSAxICYmIGZsYWdzICYgRl9TRU1JQ09MT05fT1BUKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5RmxhZ3MgfD0gRl9TRU1JQ09MT05fT1BUO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gYWRkSW5kZW50KHRoYXQuZ2VuZXJhdGVTdGF0ZW1lbnQoc3RtdC5jb25zZXF1ZW50W2ldLCBib2R5RmxhZ3MpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSArIDEgIT09IGl6ICYmICFlbmRzV2l0aExpbmVUZXJtaW5hdG9yKHRvU291cmNlTm9kZVdoZW5OZWVkZWQoZnJhZ21lbnQpLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBJZlN0YXRlbWVudDogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBib2R5RmxhZ3MsIHNlbWljb2xvbk9wdGlvbmFsLCB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtcbiAgICAgICAgICAgICAgICAgICAgJ2lmJyArIHNwYWNlICsgJygnLFxuICAgICAgICAgICAgICAgICAgICB0aGF0LmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LnRlc3QsIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSxcbiAgICAgICAgICAgICAgICAgICAgJyknXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VtaWNvbG9uT3B0aW9uYWwgPSBmbGFncyAmIEZfU0VNSUNPTE9OX09QVDtcbiAgICAgICAgICAgIGJvZHlGbGFncyA9IFNfVEZGRjtcbiAgICAgICAgICAgIGlmIChzZW1pY29sb25PcHRpb25hbCkge1xuICAgICAgICAgICAgICAgIGJvZHlGbGFncyB8PSBGX1NFTUlDT0xPTl9PUFQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RtdC5hbHRlcm5hdGUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLm1heWJlQmxvY2soc3RtdC5jb25zZXF1ZW50LCBTX1RGRkYpKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLm1heWJlQmxvY2tTdWZmaXgoc3RtdC5jb25zZXF1ZW50LCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIGlmIChzdG10LmFsdGVybmF0ZS50eXBlID09PSBTeW50YXguSWZTdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIFsnZWxzZSAnLCB0aGlzLmdlbmVyYXRlU3RhdGVtZW50KHN0bXQuYWx0ZXJuYXRlLCBib2R5RmxhZ3MpXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIGpvaW4oJ2Vsc2UnLCB0aGlzLm1heWJlQmxvY2soc3RtdC5hbHRlcm5hdGUsIGJvZHlGbGFncykpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMubWF5YmVCbG9jayhzdG10LmNvbnNlcXVlbnQsIGJvZHlGbGFncykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBGb3JTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICB3aXRoSW5kZW50KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbJ2ZvcicgKyBzcGFjZSArICcoJ107XG4gICAgICAgICAgICAgICAgaWYgKHN0bXQuaW5pdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RtdC5pbml0LnR5cGUgPT09IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGF0LmdlbmVyYXRlU3RhdGVtZW50KHN0bXQuaW5pdCwgU19GRkZGKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGX0FMTE9XX0lOIGJlY29tZXMgZmFsc2UuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGF0LmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LmluaXQsIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfRlRUKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnOycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJzsnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc3RtdC50ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhhdC5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC50ZXN0LCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCkpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnOycpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCc7Jyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHN0bXQudXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhhdC5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC51cGRhdGUsIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcpJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJyknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5tYXliZUJsb2NrKHN0bXQuYm9keSwgZmxhZ3MgJiBGX1NFTUlDT0xPTl9PUFQgPyBTX1RGRlQgOiBTX1RGRkYpKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRm9ySW5TdGF0ZW1lbnQ6IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVJdGVyYXRpb25Gb3JTdGF0ZW1lbnQoJ2luJywgc3RtdCwgZmxhZ3MgJiBGX1NFTUlDT0xPTl9PUFQgPyBTX1RGRlQgOiBTX1RGRkYpO1xuICAgICAgICB9LFxuXG4gICAgICAgIEZvck9mU3RhdGVtZW50OiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlSXRlcmF0aW9uRm9yU3RhdGVtZW50KCdvZicsIHN0bXQsIGZsYWdzICYgRl9TRU1JQ09MT05fT1BUID8gU19URkZUIDogU19URkZGKTtcbiAgICAgICAgfSxcblxuICAgICAgICBMYWJlbGVkU3RhdGVtZW50OiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBbc3RtdC5sYWJlbC5uYW1lICsgJzonLCB0aGlzLm1heWJlQmxvY2soc3RtdC5ib2R5LCBmbGFncyAmIEZfU0VNSUNPTE9OX09QVCA/IFNfVEZGVCA6IFNfVEZGRildO1xuICAgICAgICB9LFxuXG4gICAgICAgIFByb2dyYW06IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgZnJhZ21lbnQsIGksIGl6LCBib2R5RmxhZ3M7XG4gICAgICAgICAgICBpeiA9IHN0bXQuYm9keS5sZW5ndGg7XG4gICAgICAgICAgICByZXN1bHQgPSBbc2FmZUNvbmNhdGVuYXRpb24gJiYgaXogPiAwID8gJ1xcbicgOiAnJ107XG4gICAgICAgICAgICBib2R5RmxhZ3MgPSBTX1RGVEY7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmICghc2FmZUNvbmNhdGVuYXRpb24gJiYgaSA9PT0gaXogLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHlGbGFncyB8PSBGX1NFTUlDT0xPTl9PUFQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHByZXNlcnZlQmxhbmtMaW5lcykge1xuICAgICAgICAgICAgICAgICAgICAvLyBoYW5kbGUgc3BhY2VzIGJlZm9yZSB0aGUgZmlyc3QgbGluZVxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdG10LmJvZHlbMF0ubGVhZGluZ0NvbW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVCbGFua0xpbmVzKHN0bXQucmFuZ2VbMF0sIHN0bXQuYm9keVtpXS5yYW5nZVswXSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBzcGFjZXMgYmV0d2VlbiBsaW5lc1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3RtdC5ib2R5W2kgLSAxXS50cmFpbGluZ0NvbW1lbnRzICYmICFzdG10LmJvZHlbaV0ubGVhZGluZ0NvbW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVCbGFua0xpbmVzKHN0bXQuYm9keVtpIC0gMV0ucmFuZ2VbMV0sIHN0bXQuYm9keVtpXS5yYW5nZVswXSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gYWRkSW5kZW50KHRoaXMuZ2VuZXJhdGVTdGF0ZW1lbnQoc3RtdC5ib2R5W2ldLCBib2R5RmxhZ3MpKTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKGkgKyAxIDwgaXogJiYgIWVuZHNXaXRoTGluZVRlcm1pbmF0b3IodG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChmcmFnbWVudCkudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXNlcnZlQmxhbmtMaW5lcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdG10LmJvZHlbaSArIDFdLmxlYWRpbmdDb21tZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld2xpbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocHJlc2VydmVCbGFua0xpbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBzcGFjZXMgYWZ0ZXIgdGhlIGxhc3QgbGluZVxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gaXogLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN0bXQuYm9keVtpXS50cmFpbGluZ0NvbW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVCbGFua0xpbmVzKHN0bXQuYm9keVtpXS5yYW5nZVsxXSwgc3RtdC5yYW5nZVsxXSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRnVuY3Rpb25EZWNsYXJhdGlvbjogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIGdlbmVyYXRlQXN5bmNQcmVmaXgoc3RtdCwgdHJ1ZSksXG4gICAgICAgICAgICAgICAgJ2Z1bmN0aW9uJyxcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZVN0YXJTdWZmaXgoc3RtdCkgfHwgbm9FbXB0eVNwYWNlKCksXG4gICAgICAgICAgICAgICAgc3RtdC5pZCA/IGdlbmVyYXRlSWRlbnRpZmllcihzdG10LmlkKSA6ICcnLFxuICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVGdW5jdGlvbkJvZHkoc3RtdClcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgUmV0dXJuU3RhdGVtZW50OiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIGlmIChzdG10LmFyZ3VtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtqb2luKFxuICAgICAgICAgICAgICAgICAgICAncmV0dXJuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5hcmd1bWVudCwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpXG4gICAgICAgICAgICAgICAgKSwgdGhpcy5zZW1pY29sb24oZmxhZ3MpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbJ3JldHVybicgKyB0aGlzLnNlbWljb2xvbihmbGFncyldO1xuICAgICAgICB9LFxuXG4gICAgICAgIFdoaWxlU3RhdGVtZW50OiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgd2l0aEluZGVudChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW1xuICAgICAgICAgICAgICAgICAgICAnd2hpbGUnICsgc3BhY2UgKyAnKCcsXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQudGVzdCwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpLFxuICAgICAgICAgICAgICAgICAgICAnKSdcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLm1heWJlQmxvY2soc3RtdC5ib2R5LCBmbGFncyAmIEZfU0VNSUNPTE9OX09QVCA/IFNfVEZGVCA6IFNfVEZGRikpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBXaXRoU3RhdGVtZW50OiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgd2l0aEluZGVudChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW1xuICAgICAgICAgICAgICAgICAgICAnd2l0aCcgKyBzcGFjZSArICcoJyxcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5vYmplY3QsIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSxcbiAgICAgICAgICAgICAgICAgICAgJyknXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5tYXliZUJsb2NrKHN0bXQuYm9keSwgZmxhZ3MgJiBGX1NFTUlDT0xPTl9PUFQgPyBTX1RGRlQgOiBTX1RGRkYpKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBtZXJnZShDb2RlR2VuZXJhdG9yLnByb3RvdHlwZSwgQ29kZUdlbmVyYXRvci5TdGF0ZW1lbnQpO1xuXG4gICAgLy8gRXhwcmVzc2lvbnMuXG5cbiAgICBDb2RlR2VuZXJhdG9yLkV4cHJlc3Npb24gPSB7XG5cbiAgICAgICAgU2VxdWVuY2VFeHByZXNzaW9uOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIGksIGl6O1xuICAgICAgICAgICAgaWYgKFByZWNlZGVuY2UuU2VxdWVuY2UgPCBwcmVjZWRlbmNlKSB7XG4gICAgICAgICAgICAgICAgZmxhZ3MgfD0gRl9BTExPV19JTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgaXogPSBleHByLmV4cHJlc3Npb25zLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLmV4cHJlc3Npb25zW2ldLCBQcmVjZWRlbmNlLkFzc2lnbm1lbnQsIGZsYWdzKSk7XG4gICAgICAgICAgICAgICAgaWYgKGkgKyAxIDwgaXopIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJywnICsgc3BhY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRoZXNpemUocmVzdWx0LCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBwcmVjZWRlbmNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBBc3NpZ25tZW50RXhwcmVzc2lvbjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZUFzc2lnbm1lbnQoZXhwci5sZWZ0LCBleHByLnJpZ2h0LCBleHByLm9wZXJhdG9yLCBwcmVjZWRlbmNlLCBmbGFncyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQXJyb3dGdW5jdGlvbkV4cHJlc3Npb246IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudGhlc2l6ZSh0aGlzLmdlbmVyYXRlRnVuY3Rpb25Cb2R5KGV4cHIpLCBQcmVjZWRlbmNlLkFycm93RnVuY3Rpb24sIHByZWNlZGVuY2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIENvbmRpdGlvbmFsRXhwcmVzc2lvbjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICBpZiAoUHJlY2VkZW5jZS5Db25kaXRpb25hbCA8IHByZWNlZGVuY2UpIHtcbiAgICAgICAgICAgICAgICBmbGFncyB8PSBGX0FMTE9XX0lOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudGhlc2l6ZShcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIudGVzdCwgUHJlY2VkZW5jZS5Mb2dpY2FsT1IsIGZsYWdzKSxcbiAgICAgICAgICAgICAgICAgICAgc3BhY2UgKyAnPycgKyBzcGFjZSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5jb25zZXF1ZW50LCBQcmVjZWRlbmNlLkFzc2lnbm1lbnQsIGZsYWdzKSxcbiAgICAgICAgICAgICAgICAgICAgc3BhY2UgKyAnOicgKyBzcGFjZSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5hbHRlcm5hdGUsIFByZWNlZGVuY2UuQXNzaWdubWVudCwgZmxhZ3MpXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBQcmVjZWRlbmNlLkNvbmRpdGlvbmFsLFxuICAgICAgICAgICAgICAgIHByZWNlZGVuY2VcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgTG9naWNhbEV4cHJlc3Npb246IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuQmluYXJ5RXhwcmVzc2lvbihleHByLCBwcmVjZWRlbmNlLCBmbGFncyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQmluYXJ5RXhwcmVzc2lvbjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBjdXJyZW50UHJlY2VkZW5jZSwgZnJhZ21lbnQsIGxlZnRTb3VyY2U7XG4gICAgICAgICAgICBjdXJyZW50UHJlY2VkZW5jZSA9IEJpbmFyeVByZWNlZGVuY2VbZXhwci5vcGVyYXRvcl07XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50UHJlY2VkZW5jZSA8IHByZWNlZGVuY2UpIHtcbiAgICAgICAgICAgICAgICBmbGFncyB8PSBGX0FMTE9XX0lOO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmcmFnbWVudCA9IHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIubGVmdCwgY3VycmVudFByZWNlZGVuY2UsIGZsYWdzKTtcblxuICAgICAgICAgICAgbGVmdFNvdXJjZSA9IGZyYWdtZW50LnRvU3RyaW5nKCk7XG5cbiAgICAgICAgICAgIGlmIChsZWZ0U291cmNlLmNoYXJDb2RlQXQobGVmdFNvdXJjZS5sZW5ndGggLSAxKSA9PT0gMHgyRiAvKiAvICovICYmIGVzdXRpbHMuY29kZS5pc0lkZW50aWZpZXJQYXJ0RVM1KGV4cHIub3BlcmF0b3IuY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbZnJhZ21lbnQsIG5vRW1wdHlTcGFjZSgpLCBleHByLm9wZXJhdG9yXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihmcmFnbWVudCwgZXhwci5vcGVyYXRvcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZyYWdtZW50ID0gdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5yaWdodCwgY3VycmVudFByZWNlZGVuY2UgKyAxLCBmbGFncyk7XG5cbiAgICAgICAgICAgIGlmIChleHByLm9wZXJhdG9yID09PSAnLycgJiYgZnJhZ21lbnQudG9TdHJpbmcoKS5jaGFyQXQoMCkgPT09ICcvJyB8fFxuICAgICAgICAgICAgZXhwci5vcGVyYXRvci5zbGljZSgtMSkgPT09ICc8JyAmJiBmcmFnbWVudC50b1N0cmluZygpLnNsaWNlKDAsIDMpID09PSAnIS0tJykge1xuICAgICAgICAgICAgICAgIC8vIElmICcvJyBjb25jYXRzIHdpdGggJy8nIG9yIGA8YCBjb25jYXRzIHdpdGggYCEtLWAsIGl0IGlzIGludGVycHJldGVkIGFzIGNvbW1lbnQgc3RhcnRcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChub0VtcHR5U3BhY2UoKSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZnJhZ21lbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXhwci5vcGVyYXRvciA9PT0gJ2luJyAmJiAhKGZsYWdzICYgRl9BTExPV19JTikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWycoJywgcmVzdWx0LCAnKSddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudGhlc2l6ZShyZXN1bHQsIGN1cnJlbnRQcmVjZWRlbmNlLCBwcmVjZWRlbmNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBDYWxsRXhwcmVzc2lvbjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBpLCBpejtcbiAgICAgICAgICAgIC8vIEZfQUxMT1dfVU5QQVJBVEhfTkVXIGJlY29tZXMgZmFsc2UuXG4gICAgICAgICAgICByZXN1bHQgPSBbdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5jYWxsZWUsIFByZWNlZGVuY2UuQ2FsbCwgRV9UVEYpXTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcoJyk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IGV4cHJbJ2FyZ3VtZW50cyddLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByWydhcmd1bWVudHMnXVtpXSwgUHJlY2VkZW5jZS5Bc3NpZ25tZW50LCBFX1RUVCkpO1xuICAgICAgICAgICAgICAgIGlmIChpICsgMSA8IGl6KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcsJyArIHNwYWNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaCgnKScpO1xuXG4gICAgICAgICAgICBpZiAoIShmbGFncyAmIEZfQUxMT1dfQ0FMTCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWycoJywgcmVzdWx0LCAnKSddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudGhlc2l6ZShyZXN1bHQsIFByZWNlZGVuY2UuQ2FsbCwgcHJlY2VkZW5jZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgTmV3RXhwcmVzc2lvbjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBsZW5ndGgsIGksIGl6LCBpdGVtRmxhZ3M7XG4gICAgICAgICAgICBsZW5ndGggPSBleHByWydhcmd1bWVudHMnXS5sZW5ndGg7XG5cbiAgICAgICAgICAgIC8vIEZfQUxMT1dfQ0FMTCBiZWNvbWVzIGZhbHNlLlxuICAgICAgICAgICAgLy8gRl9BTExPV19VTlBBUkFUSF9ORVcgbWF5IGJlY29tZSBmYWxzZS5cbiAgICAgICAgICAgIGl0ZW1GbGFncyA9IChmbGFncyAmIEZfQUxMT1dfVU5QQVJBVEhfTkVXICYmICFwYXJlbnRoZXNlcyAmJiBsZW5ndGggPT09IDApID8gRV9URlQgOiBFX1RGRjtcblxuICAgICAgICAgICAgcmVzdWx0ID0gam9pbihcbiAgICAgICAgICAgICAgICAnbmV3JyxcbiAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLmNhbGxlZSwgUHJlY2VkZW5jZS5OZXcsIGl0ZW1GbGFncylcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmICghKGZsYWdzICYgRl9BTExPV19VTlBBUkFUSF9ORVcpIHx8IHBhcmVudGhlc2VzIHx8IGxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnKCcpO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGl6ID0gbGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByWydhcmd1bWVudHMnXVtpXSwgUHJlY2VkZW5jZS5Bc3NpZ25tZW50LCBFX1RUVCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSArIDEgPCBpeikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJywnICsgc3BhY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcpJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRoZXNpemUocmVzdWx0LCBQcmVjZWRlbmNlLk5ldywgcHJlY2VkZW5jZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgTWVtYmVyRXhwcmVzc2lvbjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBmcmFnbWVudDtcblxuICAgICAgICAgICAgLy8gRl9BTExPV19VTlBBUkFUSF9ORVcgYmVjb21lcyBmYWxzZS5cbiAgICAgICAgICAgIHJlc3VsdCA9IFt0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLm9iamVjdCwgUHJlY2VkZW5jZS5DYWxsLCAoZmxhZ3MgJiBGX0FMTE9XX0NBTEwpID8gRV9UVEYgOiBFX1RGRildO1xuXG4gICAgICAgICAgICBpZiAoZXhwci5jb21wdXRlZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCdbJyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5wcm9wZXJ0eSwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgZmxhZ3MgJiBGX0FMTE9XX0NBTEwgPyBFX1RUVCA6IEVfVEZUKSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJ10nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4cHIub2JqZWN0LnR5cGUgPT09IFN5bnRheC5MaXRlcmFsICYmIHR5cGVvZiBleHByLm9iamVjdC52YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSB0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKHJlc3VsdCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIGFsbCB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAvLyAgIDEuIE5vIGZsb2F0aW5nIHBvaW50XG4gICAgICAgICAgICAgICAgICAgIC8vICAgMi4gRG9uJ3QgaGF2ZSBleHBvbmVudHNcbiAgICAgICAgICAgICAgICAgICAgLy8gICAzLiBUaGUgbGFzdCBjaGFyYWN0ZXIgaXMgYSBkZWNpbWFsIGRpZ2l0XG4gICAgICAgICAgICAgICAgICAgIC8vICAgNC4gTm90IGhleGFkZWNpbWFsIE9SIG9jdGFsIG51bWJlciBsaXRlcmFsXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIHNob3VsZCBhZGQgYSBmbG9hdGluZyBwb2ludC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50LmluZGV4T2YoJy4nKSA8IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhL1tlRXhYXS8udGVzdChmcmFnbWVudCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc3V0aWxzLmNvZGUuaXNEZWNpbWFsRGlnaXQoZnJhZ21lbnQuY2hhckNvZGVBdChmcmFnbWVudC5sZW5ndGggLSAxKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhKGZyYWdtZW50Lmxlbmd0aCA+PSAyICYmIGZyYWdtZW50LmNoYXJDb2RlQXQoMCkgPT09IDQ4KSAgLy8gJzAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnICcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcuJyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZ2VuZXJhdGVJZGVudGlmaWVyKGV4cHIucHJvcGVydHkpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudGhlc2l6ZShyZXN1bHQsIFByZWNlZGVuY2UuTWVtYmVyLCBwcmVjZWRlbmNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBNZXRhUHJvcGVydHk6IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godHlwZW9mIGV4cHIubWV0YSA9PT0gXCJzdHJpbmdcIiA/IGV4cHIubWV0YSA6IGdlbmVyYXRlSWRlbnRpZmllcihleHByLm1ldGEpKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcuJyk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0eXBlb2YgZXhwci5wcm9wZXJ0eSA9PT0gXCJzdHJpbmdcIiA/IGV4cHIucHJvcGVydHkgOiBnZW5lcmF0ZUlkZW50aWZpZXIoZXhwci5wcm9wZXJ0eSkpO1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudGhlc2l6ZShyZXN1bHQsIFByZWNlZGVuY2UuTWVtYmVyLCBwcmVjZWRlbmNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBVbmFyeUV4cHJlc3Npb246IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgZnJhZ21lbnQsIHJpZ2h0Q2hhckNvZGUsIGxlZnRTb3VyY2UsIGxlZnRDaGFyQ29kZTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5hcmd1bWVudCwgUHJlY2VkZW5jZS5VbmFyeSwgRV9UVFQpO1xuXG4gICAgICAgICAgICBpZiAoc3BhY2UgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihleHByLm9wZXJhdG9yLCBmcmFnbWVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtleHByLm9wZXJhdG9yXTtcbiAgICAgICAgICAgICAgICBpZiAoZXhwci5vcGVyYXRvci5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlbGV0ZSwgdm9pZCwgdHlwZW9mXG4gICAgICAgICAgICAgICAgICAgIC8vIGdldCBgdHlwZW9mIFtdYCwgbm90IGB0eXBlb2ZbXWBcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IGluc2VydGluZyBzcGFjZXMgYmV0d2VlbiBvcGVyYXRvciBhbmQgYXJndW1lbnQgaWYgaXQgaXMgdW5uZWNlc3NhcnlcbiAgICAgICAgICAgICAgICAgICAgLy8gbGlrZSwgYCFjb25kYFxuICAgICAgICAgICAgICAgICAgICBsZWZ0U291cmNlID0gdG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChyZXN1bHQpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGxlZnRDaGFyQ29kZSA9IGxlZnRTb3VyY2UuY2hhckNvZGVBdChsZWZ0U291cmNlLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICByaWdodENoYXJDb2RlID0gZnJhZ21lbnQudG9TdHJpbmcoKS5jaGFyQ29kZUF0KDApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICgoKGxlZnRDaGFyQ29kZSA9PT0gMHgyQiAgLyogKyAqLyB8fCBsZWZ0Q2hhckNvZGUgPT09IDB4MkQgIC8qIC0gKi8pICYmIGxlZnRDaGFyQ29kZSA9PT0gcmlnaHRDaGFyQ29kZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZXN1dGlscy5jb2RlLmlzSWRlbnRpZmllclBhcnRFUzUobGVmdENoYXJDb2RlKSAmJiBlc3V0aWxzLmNvZGUuaXNJZGVudGlmaWVyUGFydEVTNShyaWdodENoYXJDb2RlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5vRW1wdHlTcGFjZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRoZXNpemUocmVzdWx0LCBQcmVjZWRlbmNlLlVuYXJ5LCBwcmVjZWRlbmNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBZaWVsZEV4cHJlc3Npb246IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgIGlmIChleHByLmRlbGVnYXRlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gJ3lpZWxkKic7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9ICd5aWVsZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXhwci5hcmd1bWVudCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4oXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5hcmd1bWVudCwgUHJlY2VkZW5jZS5ZaWVsZCwgRV9UVFQpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRoZXNpemUocmVzdWx0LCBQcmVjZWRlbmNlLllpZWxkLCBwcmVjZWRlbmNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBBd2FpdEV4cHJlc3Npb246IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGpvaW4oXG4gICAgICAgICAgICAgICAgZXhwci5hbGwgPyAnYXdhaXQqJyA6ICdhd2FpdCcsXG4gICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5hcmd1bWVudCwgUHJlY2VkZW5jZS5Bd2FpdCwgRV9UVFQpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudGhlc2l6ZShyZXN1bHQsIFByZWNlZGVuY2UuQXdhaXQsIHByZWNlZGVuY2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIFVwZGF0ZUV4cHJlc3Npb246IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgaWYgKGV4cHIucHJlZml4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudGhlc2l6ZShcbiAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwci5vcGVyYXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIuYXJndW1lbnQsIFByZWNlZGVuY2UuVW5hcnksIEVfVFRUKVxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICBQcmVjZWRlbmNlLlVuYXJ5LFxuICAgICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRoZXNpemUoXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLmFyZ3VtZW50LCBQcmVjZWRlbmNlLlBvc3RmaXgsIEVfVFRUKSxcbiAgICAgICAgICAgICAgICAgICAgZXhwci5vcGVyYXRvclxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgUHJlY2VkZW5jZS5Qb3N0Zml4LFxuICAgICAgICAgICAgICAgIHByZWNlZGVuY2VcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRnVuY3Rpb25FeHByZXNzaW9uOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVBc3luY1ByZWZpeChleHByLCB0cnVlKSxcbiAgICAgICAgICAgICAgICAnZnVuY3Rpb24nXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgaWYgKGV4cHIuaWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChnZW5lcmF0ZVN0YXJTdWZmaXgoZXhwcikgfHwgbm9FbXB0eVNwYWNlKCkpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGdlbmVyYXRlSWRlbnRpZmllcihleHByLmlkKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGdlbmVyYXRlU3RhclN1ZmZpeChleHByKSB8fCBzcGFjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmdlbmVyYXRlRnVuY3Rpb25Cb2R5KGV4cHIpKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQXJyYXlQYXR0ZXJuOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkFycmF5RXhwcmVzc2lvbihleHByLCBwcmVjZWRlbmNlLCBmbGFncywgdHJ1ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQXJyYXlFeHByZXNzaW9uOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MsIGlzUGF0dGVybikge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgbXVsdGlsaW5lLCB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIGlmICghZXhwci5lbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1tdJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG11bHRpbGluZSA9IGlzUGF0dGVybiA/IGZhbHNlIDogZXhwci5lbGVtZW50cy5sZW5ndGggPiAxO1xuICAgICAgICAgICAgcmVzdWx0ID0gWydbJywgbXVsdGlsaW5lID8gbmV3bGluZSA6ICcnXTtcbiAgICAgICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKGluZGVudCkge1xuICAgICAgICAgICAgICAgIHZhciBpLCBpejtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IGV4cHIuZWxlbWVudHMubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWV4cHIuZWxlbWVudHNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtdWx0aWxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpbmRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgKyAxID09PSBpeikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcsJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChtdWx0aWxpbmUgPyBpbmRlbnQgOiAnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGF0LmdlbmVyYXRlRXhwcmVzc2lvbihleHByLmVsZW1lbnRzW2ldLCBQcmVjZWRlbmNlLkFzc2lnbm1lbnQsIEVfVFRUKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgKyAxIDwgaXopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcsJyArIChtdWx0aWxpbmUgPyBuZXdsaW5lIDogc3BhY2UpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKG11bHRpbGluZSAmJiAhZW5kc1dpdGhMaW5lVGVybWluYXRvcih0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKHJlc3VsdCkudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG11bHRpbGluZSA/IGJhc2UgOiAnJyk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgnXScpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBSZXN0RWxlbWVudDogZnVuY3Rpb24oZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiAnLi4uJyArIHRoaXMuZ2VuZXJhdGVQYXR0ZXJuKGV4cHIuYXJndW1lbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIENsYXNzRXhwcmVzc2lvbjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBmcmFnbWVudDtcbiAgICAgICAgICAgIHJlc3VsdCA9IFsnY2xhc3MnXTtcbiAgICAgICAgICAgIGlmIChleHByLmlkKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIuaWQsIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXhwci5zdXBlckNsYXNzKSB7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBqb2luKCdleHRlbmRzJywgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5zdXBlckNsYXNzLCBQcmVjZWRlbmNlLkFzc2lnbm1lbnQsIEVfVFRUKSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNwYWNlKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuZ2VuZXJhdGVTdGF0ZW1lbnQoZXhwci5ib2R5LCBTX1RGRlQpKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgTWV0aG9kRGVmaW5pdGlvbjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBmcmFnbWVudDtcbiAgICAgICAgICAgIGlmIChleHByWydzdGF0aWMnXSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFsnc3RhdGljJyArIHNwYWNlXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXhwci5raW5kID09PSAnZ2V0JyB8fCBleHByLmtpbmQgPT09ICdzZXQnKSB7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBbXG4gICAgICAgICAgICAgICAgICAgIGpvaW4oZXhwci5raW5kLCB0aGlzLmdlbmVyYXRlUHJvcGVydHlLZXkoZXhwci5rZXksIGV4cHIuY29tcHV0ZWQpKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUZ1bmN0aW9uQm9keShleHByLnZhbHVlKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gW1xuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZU1ldGhvZFByZWZpeChleHByKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZVByb3BlcnR5S2V5KGV4cHIua2V5LCBleHByLmNvbXB1dGVkKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUZ1bmN0aW9uQm9keShleHByLnZhbHVlKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gam9pbihyZXN1bHQsIGZyYWdtZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICBQcm9wZXJ0eTogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICBpZiAoZXhwci5raW5kID09PSAnZ2V0JyB8fCBleHByLmtpbmQgPT09ICdzZXQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgZXhwci5raW5kLCBub0VtcHR5U3BhY2UoKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZVByb3BlcnR5S2V5KGV4cHIua2V5LCBleHByLmNvbXB1dGVkKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUZ1bmN0aW9uQm9keShleHByLnZhbHVlKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChleHByLnNob3J0aGFuZCkge1xuICAgICAgICAgICAgICAgIGlmIChleHByLnZhbHVlLnR5cGUgPT09IFwiQXNzaWdubWVudFBhdHRlcm5cIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5Bc3NpZ25tZW50UGF0dGVybihleHByLnZhbHVlLCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlUHJvcGVydHlLZXkoZXhwci5rZXksIGV4cHIuY29tcHV0ZWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXhwci5tZXRob2QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZU1ldGhvZFByZWZpeChleHByKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZVByb3BlcnR5S2V5KGV4cHIua2V5LCBleHByLmNvbXB1dGVkKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUZ1bmN0aW9uQm9keShleHByLnZhbHVlKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZVByb3BlcnR5S2V5KGV4cHIua2V5LCBleHByLmNvbXB1dGVkKSxcbiAgICAgICAgICAgICAgICAnOicgKyBzcGFjZSxcbiAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLnZhbHVlLCBQcmVjZWRlbmNlLkFzc2lnbm1lbnQsIEVfVFRUKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSxcblxuICAgICAgICBPYmplY3RFeHByZXNzaW9uOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciBtdWx0aWxpbmUsIHJlc3VsdCwgZnJhZ21lbnQsIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICBpZiAoIWV4cHIucHJvcGVydGllcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3t9JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG11bHRpbGluZSA9IGV4cHIucHJvcGVydGllcy5sZW5ndGggPiAxO1xuXG4gICAgICAgICAgICB3aXRoSW5kZW50KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmcmFnbWVudCA9IHRoYXQuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIucHJvcGVydGllc1swXSwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICghbXVsdGlsaW5lKSB7XG4gICAgICAgICAgICAgICAgLy8gaXNzdWVzIDRcbiAgICAgICAgICAgICAgICAvLyBEbyBub3QgdHJhbnNmb3JtIGZyb21cbiAgICAgICAgICAgICAgICAvLyAgIGRlamF2dS5DbGFzcy5kZWNsYXJlKHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICBtZXRob2QyOiBmdW5jdGlvbiAoKSB7fVxuICAgICAgICAgICAgICAgIC8vICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gdG9cbiAgICAgICAgICAgICAgICAvLyAgIGRlamF2dS5DbGFzcy5kZWNsYXJlKHttZXRob2QyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgfX0pO1xuICAgICAgICAgICAgICAgIGlmICghaGFzTGluZVRlcm1pbmF0b3IodG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChmcmFnbWVudCkudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgJ3snLCBzcGFjZSwgZnJhZ21lbnQsIHNwYWNlLCAnfScgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKGluZGVudCkge1xuICAgICAgICAgICAgICAgIHZhciBpLCBpejtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbICd7JywgbmV3bGluZSwgaW5kZW50LCBmcmFnbWVudCBdO1xuXG4gICAgICAgICAgICAgICAgaWYgKG11bHRpbGluZSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLCcgKyBuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMSwgaXogPSBleHByLnByb3BlcnRpZXMubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaW5kZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoYXQuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIucHJvcGVydGllc1tpXSwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpICsgMSA8IGl6KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJywnICsgbmV3bGluZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCFlbmRzV2l0aExpbmVUZXJtaW5hdG9yKHRvU291cmNlTm9kZVdoZW5OZWVkZWQocmVzdWx0KS50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld2xpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goYmFzZSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgnfScpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBBc3NpZ25tZW50UGF0dGVybjogZnVuY3Rpb24oZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlQXNzaWdubWVudChleHByLmxlZnQsIGV4cHIucmlnaHQsICc9JywgcHJlY2VkZW5jZSwgZmxhZ3MpO1xuICAgICAgICB9LFxuXG4gICAgICAgIE9iamVjdFBhdHRlcm46IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgaSwgaXosIG11bHRpbGluZSwgcHJvcGVydHksIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKCFleHByLnByb3BlcnRpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICd7fSc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG11bHRpbGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGV4cHIucHJvcGVydGllcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eSA9IGV4cHIucHJvcGVydGllc1swXTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydHkudmFsdWUudHlwZSAhPT0gU3ludGF4LklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlsaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGl6ID0gZXhwci5wcm9wZXJ0aWVzLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkgPSBleHByLnByb3BlcnRpZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghcHJvcGVydHkuc2hvcnRoYW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aWxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSBbJ3snLCBtdWx0aWxpbmUgPyBuZXdsaW5lIDogJycgXTtcblxuICAgICAgICAgICAgd2l0aEluZGVudChmdW5jdGlvbiAoaW5kZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGksIGl6O1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGl6ID0gZXhwci5wcm9wZXJ0aWVzLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobXVsdGlsaW5lID8gaW5kZW50IDogJycpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGF0LmdlbmVyYXRlRXhwcmVzc2lvbihleHByLnByb3BlcnRpZXNbaV0sIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICsgMSA8IGl6KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLCcgKyAobXVsdGlsaW5lID8gbmV3bGluZSA6IHNwYWNlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKG11bHRpbGluZSAmJiAhZW5kc1dpdGhMaW5lVGVybWluYXRvcih0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKHJlc3VsdCkudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG11bHRpbGluZSA/IGJhc2UgOiAnJyk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgnfScpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBUaGlzRXhwcmVzc2lvbjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3RoaXMnO1xuICAgICAgICB9LFxuXG4gICAgICAgIFN1cGVyOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiAnc3VwZXInO1xuICAgICAgICB9LFxuXG4gICAgICAgIElkZW50aWZpZXI6IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlSWRlbnRpZmllcihleHByKTtcbiAgICAgICAgfSxcblxuICAgICAgICBJbXBvcnREZWZhdWx0U3BlY2lmaWVyOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZUlkZW50aWZpZXIoZXhwci5pZCB8fCBleHByLmxvY2FsKTtcbiAgICAgICAgfSxcblxuICAgICAgICBJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXI6IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFsnKiddO1xuICAgICAgICAgICAgdmFyIGlkID0gZXhwci5pZCB8fCBleHByLmxvY2FsO1xuICAgICAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3BhY2UgKyAnYXMnICsgbm9FbXB0eVNwYWNlKCkgKyBnZW5lcmF0ZUlkZW50aWZpZXIoaWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgSW1wb3J0U3BlY2lmaWVyOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciBpbXBvcnRlZCA9IGV4cHIuaW1wb3J0ZWQ7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gWyBpbXBvcnRlZC5uYW1lIF07XG4gICAgICAgICAgICB2YXIgbG9jYWwgPSBleHByLmxvY2FsO1xuICAgICAgICAgICAgaWYgKGxvY2FsICYmIGxvY2FsLm5hbWUgIT09IGltcG9ydGVkLm5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChub0VtcHR5U3BhY2UoKSArICdhcycgKyBub0VtcHR5U3BhY2UoKSArIGdlbmVyYXRlSWRlbnRpZmllcihsb2NhbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBFeHBvcnRTcGVjaWZpZXI6IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIGxvY2FsID0gZXhwci5sb2NhbDtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbIGxvY2FsLm5hbWUgXTtcbiAgICAgICAgICAgIHZhciBleHBvcnRlZCA9IGV4cHIuZXhwb3J0ZWQ7XG4gICAgICAgICAgICBpZiAoZXhwb3J0ZWQgJiYgZXhwb3J0ZWQubmFtZSAhPT0gbG9jYWwubmFtZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5vRW1wdHlTcGFjZSgpICsgJ2FzJyArIG5vRW1wdHlTcGFjZSgpICsgZ2VuZXJhdGVJZGVudGlmaWVyKGV4cG9ydGVkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIExpdGVyYWw6IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJhdztcbiAgICAgICAgICAgIGlmIChleHByLmhhc093blByb3BlcnR5KCdyYXcnKSAmJiBwYXJzZSAmJiBleHRyYS5yYXcpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByYXcgPSBwYXJzZShleHByLnJhdykuYm9keVswXS5leHByZXNzaW9uO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmF3LnR5cGUgPT09IFN5bnRheC5MaXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmF3LnZhbHVlID09PSBleHByLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4cHIucmF3O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBub3QgdXNlIHJhdyBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGV4cHIudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4cHIudmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVzY2FwZVN0cmluZyhleHByLnZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBleHByLnZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZU51bWJlcihleHByLnZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBleHByLnZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwci52YWx1ZSA/ICd0cnVlJyA6ICdmYWxzZSc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChleHByLnJlZ2V4KSB7XG4gICAgICAgICAgICAgIHJldHVybiAnLycgKyBleHByLnJlZ2V4LnBhdHRlcm4gKyAnLycgKyBleHByLnJlZ2V4LmZsYWdzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlUmVnRXhwKGV4cHIudmFsdWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIEdlbmVyYXRvckV4cHJlc3Npb246IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuQ29tcHJlaGVuc2lvbkV4cHJlc3Npb24oZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpO1xuICAgICAgICB9LFxuXG4gICAgICAgIENvbXByZWhlbnNpb25FeHByZXNzaW9uOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIC8vIEdlbmVyYXRvckV4cHJlc3Npb24gc2hvdWxkIGJlIHBhcmVudGhlc2l6ZWQgd2l0aCAoLi4uKSwgQ29tcHJlaGVuc2lvbkV4cHJlc3Npb24gd2l0aCBbLi4uXVxuICAgICAgICAgICAgLy8gRHVlIHRvIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTg4MzQ2OCBwb3NpdGlvbiBvZiBleHByLmJvZHkgY2FuIGRpZmZlciBpbiBTcGlkZXJtb25rZXkgYW5kIEVTNlxuXG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBpLCBpeiwgZnJhZ21lbnQsIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgcmVzdWx0ID0gKGV4cHIudHlwZSA9PT0gU3ludGF4LkdlbmVyYXRvckV4cHJlc3Npb24pID8gWycoJ10gOiBbJ1snXTtcblxuICAgICAgICAgICAgaWYgKGV4dHJhLm1vei5jb21wcmVoZW5zaW9uRXhwcmVzc2lvblN0YXJ0c1dpdGhBc3NpZ25tZW50KSB7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQgPSB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLmJvZHksIFByZWNlZGVuY2UuQXNzaWdubWVudCwgRV9UVFQpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZyYWdtZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGV4cHIuYmxvY2tzKSB7XG4gICAgICAgICAgICAgICAgd2l0aEluZGVudChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGl6ID0gZXhwci5ibG9ja3MubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSB0aGF0LmdlbmVyYXRlRXhwcmVzc2lvbihleHByLmJsb2Nrc1tpXSwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiAwIHx8IGV4dHJhLm1vei5jb21wcmVoZW5zaW9uRXhwcmVzc2lvblN0YXJ0c1dpdGhBc3NpZ25tZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChleHByLmZpbHRlcikge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCAnaWYnICsgc3BhY2UpO1xuICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5maWx0ZXIsIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgWyAnKCcsIGZyYWdtZW50LCAnKScgXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZXh0cmEubW96LmNvbXByZWhlbnNpb25FeHByZXNzaW9uU3RhcnRzV2l0aEFzc2lnbm1lbnQpIHtcbiAgICAgICAgICAgICAgICBmcmFnbWVudCA9IHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIuYm9keSwgUHJlY2VkZW5jZS5Bc3NpZ25tZW50LCBFX1RUVCk7XG5cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHQucHVzaCgoZXhwci50eXBlID09PSBTeW50YXguR2VuZXJhdG9yRXhwcmVzc2lvbikgPyAnKScgOiAnXScpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBDb21wcmVoZW5zaW9uQmxvY2s6IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIGZyYWdtZW50O1xuICAgICAgICAgICAgaWYgKGV4cHIubGVmdC50eXBlID09PSBTeW50YXguVmFyaWFibGVEZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gW1xuICAgICAgICAgICAgICAgICAgICBleHByLmxlZnQua2luZCwgbm9FbXB0eVNwYWNlKCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVTdGF0ZW1lbnQoZXhwci5sZWZ0LmRlY2xhcmF0aW9uc1swXSwgU19GRkZGKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5sZWZ0LCBQcmVjZWRlbmNlLkNhbGwsIEVfVFRUKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnJhZ21lbnQgPSBqb2luKGZyYWdtZW50LCBleHByLm9mID8gJ29mJyA6ICdpbicpO1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBqb2luKGZyYWdtZW50LCB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLnJpZ2h0LCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCkpO1xuXG4gICAgICAgICAgICByZXR1cm4gWyAnZm9yJyArIHNwYWNlICsgJygnLCBmcmFnbWVudCwgJyknIF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgU3ByZWFkRWxlbWVudDogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICcuLi4nLFxuICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIuYXJndW1lbnQsIFByZWNlZGVuY2UuQXNzaWdubWVudCwgRV9UVFQpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9LFxuXG4gICAgICAgIFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgaXRlbUZsYWdzID0gRV9UVEY7XG4gICAgICAgICAgICBpZiAoIShmbGFncyAmIEZfQUxMT1dfQ0FMTCkpIHtcbiAgICAgICAgICAgICAgICBpdGVtRmxhZ3MgPSBFX1RGRjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXG4gICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci50YWcsIFByZWNlZGVuY2UuQ2FsbCwgaXRlbUZsYWdzKSxcbiAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLnF1YXNpLCBQcmVjZWRlbmNlLlByaW1hcnksIEVfRkZUKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRoZXNpemUocmVzdWx0LCBQcmVjZWRlbmNlLlRhZ2dlZFRlbXBsYXRlLCBwcmVjZWRlbmNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBUZW1wbGF0ZUVsZW1lbnQ6IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgLy8gRG9uJ3QgdXNlIFwiY29va2VkXCIuIFNpbmNlIHRhZ2dlZCB0ZW1wbGF0ZSBjYW4gdXNlIHJhdyB0ZW1wbGF0ZVxuICAgICAgICAgICAgLy8gcmVwcmVzZW50YXRpb24uIFNvIGlmIHdlIGRvIHNvLCBpdCBicmVha3MgdGhlIHNjcmlwdCBzZW1hbnRpY3MuXG4gICAgICAgICAgICByZXR1cm4gZXhwci52YWx1ZS5yYXc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgVGVtcGxhdGVMaXRlcmFsOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIGksIGl6O1xuICAgICAgICAgICAgcmVzdWx0ID0gWyAnYCcgXTtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGl6ID0gZXhwci5xdWFzaXMubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIucXVhc2lzW2ldLCBQcmVjZWRlbmNlLlByaW1hcnksIEVfVFRUKSk7XG4gICAgICAgICAgICAgICAgaWYgKGkgKyAxIDwgaXopIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJyR7JyArIHNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5leHByZXNzaW9uc1tpXSwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3BhY2UgKyAnfScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCdgJyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIE1vZHVsZVNwZWNpZmllcjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5MaXRlcmFsKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIG1lcmdlKENvZGVHZW5lcmF0b3IucHJvdG90eXBlLCBDb2RlR2VuZXJhdG9yLkV4cHJlc3Npb24pO1xuXG4gICAgQ29kZUdlbmVyYXRvci5wcm90b3R5cGUuZ2VuZXJhdGVFeHByZXNzaW9uID0gZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgIHZhciByZXN1bHQsIHR5cGU7XG5cbiAgICAgICAgdHlwZSA9IGV4cHIudHlwZSB8fCBTeW50YXguUHJvcGVydHk7XG5cbiAgICAgICAgaWYgKGV4dHJhLnZlcmJhdGltICYmIGV4cHIuaGFzT3duUHJvcGVydHkoZXh0cmEudmVyYmF0aW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVWZXJiYXRpbShleHByLCBwcmVjZWRlbmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IHRoaXNbdHlwZV0oZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpO1xuXG5cbiAgICAgICAgaWYgKGV4dHJhLmNvbW1lbnQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGFkZENvbW1lbnRzKGV4cHIsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvU291cmNlTm9kZVdoZW5OZWVkZWQocmVzdWx0LCBleHByKTtcbiAgICB9O1xuXG4gICAgQ29kZUdlbmVyYXRvci5wcm90b3R5cGUuZ2VuZXJhdGVTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICAgIGZyYWdtZW50O1xuXG4gICAgICAgIHJlc3VsdCA9IHRoaXNbc3RtdC50eXBlXShzdG10LCBmbGFncyk7XG5cbiAgICAgICAgLy8gQXR0YWNoIGNvbW1lbnRzXG5cbiAgICAgICAgaWYgKGV4dHJhLmNvbW1lbnQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGFkZENvbW1lbnRzKHN0bXQsIHJlc3VsdCk7XG4gICAgICAgIH1cblxuICAgICAgICBmcmFnbWVudCA9IHRvU291cmNlTm9kZVdoZW5OZWVkZWQocmVzdWx0KS50b1N0cmluZygpO1xuICAgICAgICBpZiAoc3RtdC50eXBlID09PSBTeW50YXguUHJvZ3JhbSAmJiAhc2FmZUNvbmNhdGVuYXRpb24gJiYgbmV3bGluZSA9PT0gJycgJiYgIGZyYWdtZW50LmNoYXJBdChmcmFnbWVudC5sZW5ndGggLSAxKSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHNvdXJjZU1hcCA/IHRvU291cmNlTm9kZVdoZW5OZWVkZWQocmVzdWx0KS5yZXBsYWNlUmlnaHQoL1xccyskLywgJycpIDogZnJhZ21lbnQucmVwbGFjZSgvXFxzKyQvLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChyZXN1bHQsIHN0bXQpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUludGVybmFsKG5vZGUpIHtcbiAgICAgICAgdmFyIGNvZGVnZW47XG5cbiAgICAgICAgY29kZWdlbiA9IG5ldyBDb2RlR2VuZXJhdG9yKCk7XG4gICAgICAgIGlmIChpc1N0YXRlbWVudChub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvZGVnZW4uZ2VuZXJhdGVTdGF0ZW1lbnQobm9kZSwgU19URkZGKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0V4cHJlc3Npb24obm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2RlZ2VuLmdlbmVyYXRlRXhwcmVzc2lvbihub2RlLCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbm9kZSB0eXBlOiAnICsgbm9kZS50eXBlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZShub2RlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBkZWZhdWx0T3B0aW9ucyA9IGdldERlZmF1bHRPcHRpb25zKCksIHJlc3VsdCwgcGFpcjtcblxuICAgICAgICBpZiAob3B0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBPYnNvbGV0ZSBvcHRpb25zXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gICBgb3B0aW9ucy5pbmRlbnRgXG4gICAgICAgICAgICAvLyAgIGBvcHRpb25zLmJhc2VgXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gSW5zdGVhZCBvZiB0aGVtLCB3ZSBjYW4gdXNlIGBvcHRpb24uZm9ybWF0LmluZGVudGAuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuaW5kZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRPcHRpb25zLmZvcm1hdC5pbmRlbnQuc3R5bGUgPSBvcHRpb25zLmluZGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5iYXNlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRPcHRpb25zLmZvcm1hdC5pbmRlbnQuYmFzZSA9IG9wdGlvbnMuYmFzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbnMgPSB1cGRhdGVEZWVwbHkoZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaW5kZW50ID0gb3B0aW9ucy5mb3JtYXQuaW5kZW50LnN0eWxlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmJhc2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgYmFzZSA9IG9wdGlvbnMuYmFzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYmFzZSA9IHN0cmluZ1JlcGVhdChpbmRlbnQsIG9wdGlvbnMuZm9ybWF0LmluZGVudC5iYXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcbiAgICAgICAgICAgIGluZGVudCA9IG9wdGlvbnMuZm9ybWF0LmluZGVudC5zdHlsZTtcbiAgICAgICAgICAgIGJhc2UgPSBzdHJpbmdSZXBlYXQoaW5kZW50LCBvcHRpb25zLmZvcm1hdC5pbmRlbnQuYmFzZSk7XG4gICAgICAgIH1cbiAgICAgICAganNvbiA9IG9wdGlvbnMuZm9ybWF0Lmpzb247XG4gICAgICAgIHJlbnVtYmVyID0gb3B0aW9ucy5mb3JtYXQucmVudW1iZXI7XG4gICAgICAgIGhleGFkZWNpbWFsID0ganNvbiA/IGZhbHNlIDogb3B0aW9ucy5mb3JtYXQuaGV4YWRlY2ltYWw7XG4gICAgICAgIHF1b3RlcyA9IGpzb24gPyAnZG91YmxlJyA6IG9wdGlvbnMuZm9ybWF0LnF1b3RlcztcbiAgICAgICAgZXNjYXBlbGVzcyA9IG9wdGlvbnMuZm9ybWF0LmVzY2FwZWxlc3M7XG4gICAgICAgIG5ld2xpbmUgPSBvcHRpb25zLmZvcm1hdC5uZXdsaW5lO1xuICAgICAgICBzcGFjZSA9IG9wdGlvbnMuZm9ybWF0LnNwYWNlO1xuICAgICAgICBpZiAob3B0aW9ucy5mb3JtYXQuY29tcGFjdCkge1xuICAgICAgICAgICAgbmV3bGluZSA9IHNwYWNlID0gaW5kZW50ID0gYmFzZSA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudGhlc2VzID0gb3B0aW9ucy5mb3JtYXQucGFyZW50aGVzZXM7XG4gICAgICAgIHNlbWljb2xvbnMgPSBvcHRpb25zLmZvcm1hdC5zZW1pY29sb25zO1xuICAgICAgICBzYWZlQ29uY2F0ZW5hdGlvbiA9IG9wdGlvbnMuZm9ybWF0LnNhZmVDb25jYXRlbmF0aW9uO1xuICAgICAgICBkaXJlY3RpdmUgPSBvcHRpb25zLmRpcmVjdGl2ZTtcbiAgICAgICAgcGFyc2UgPSBqc29uID8gbnVsbCA6IG9wdGlvbnMucGFyc2U7XG4gICAgICAgIHNvdXJjZU1hcCA9IG9wdGlvbnMuc291cmNlTWFwO1xuICAgICAgICBzb3VyY2VDb2RlID0gb3B0aW9ucy5zb3VyY2VDb2RlO1xuICAgICAgICBwcmVzZXJ2ZUJsYW5rTGluZXMgPSBvcHRpb25zLmZvcm1hdC5wcmVzZXJ2ZUJsYW5rTGluZXMgJiYgc291cmNlQ29kZSAhPT0gbnVsbDtcbiAgICAgICAgZXh0cmEgPSBvcHRpb25zO1xuXG4gICAgICAgIGlmIChzb3VyY2VNYXApIHtcbiAgICAgICAgICAgIGlmICghZXhwb3J0cy5icm93c2VyKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgYXNzdW1lIGVudmlyb25tZW50IGlzIG5vZGUuanNcbiAgICAgICAgICAgICAgICAvLyBBbmQgcHJldmVudCBmcm9tIGluY2x1ZGluZyBzb3VyY2UtbWFwIGJ5IGJyb3dzZXJpZnlcbiAgICAgICAgICAgICAgICBTb3VyY2VOb2RlID0gcmVxdWlyZSgnc291cmNlLW1hcCcpLlNvdXJjZU5vZGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIFNvdXJjZU5vZGUgPSBnbG9iYWwuc291cmNlTWFwLlNvdXJjZU5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSBnZW5lcmF0ZUludGVybmFsKG5vZGUpO1xuXG4gICAgICAgIGlmICghc291cmNlTWFwKSB7XG4gICAgICAgICAgICBwYWlyID0ge2NvZGU6IHJlc3VsdC50b1N0cmluZygpLCBtYXA6IG51bGx9O1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuc291cmNlTWFwV2l0aENvZGUgPyBwYWlyIDogcGFpci5jb2RlO1xuICAgICAgICB9XG5cblxuICAgICAgICBwYWlyID0gcmVzdWx0LnRvU3RyaW5nV2l0aFNvdXJjZU1hcCh7XG4gICAgICAgICAgICBmaWxlOiBvcHRpb25zLmZpbGUsXG4gICAgICAgICAgICBzb3VyY2VSb290OiBvcHRpb25zLnNvdXJjZU1hcFJvb3RcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc291cmNlQ29udGVudCkge1xuICAgICAgICAgICAgcGFpci5tYXAuc2V0U291cmNlQ29udGVudChvcHRpb25zLnNvdXJjZU1hcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zb3VyY2VDb250ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLnNvdXJjZU1hcFdpdGhDb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFpcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYWlyLm1hcC50b1N0cmluZygpO1xuICAgIH1cblxuICAgIEZPUk1BVF9NSU5JRlkgPSB7XG4gICAgICAgIGluZGVudDoge1xuICAgICAgICAgICAgc3R5bGU6ICcnLFxuICAgICAgICAgICAgYmFzZTogMFxuICAgICAgICB9LFxuICAgICAgICByZW51bWJlcjogdHJ1ZSxcbiAgICAgICAgaGV4YWRlY2ltYWw6IHRydWUsXG4gICAgICAgIHF1b3RlczogJ2F1dG8nLFxuICAgICAgICBlc2NhcGVsZXNzOiB0cnVlLFxuICAgICAgICBjb21wYWN0OiB0cnVlLFxuICAgICAgICBwYXJlbnRoZXNlczogZmFsc2UsXG4gICAgICAgIHNlbWljb2xvbnM6IGZhbHNlXG4gICAgfTtcblxuICAgIEZPUk1BVF9ERUZBVUxUUyA9IGdldERlZmF1bHRPcHRpb25zKCkuZm9ybWF0O1xuXG4gICAgZXhwb3J0cy52ZXJzaW9uID0gcmVxdWlyZSgnLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uO1xuICAgIGV4cG9ydHMuZ2VuZXJhdGUgPSBnZW5lcmF0ZTtcbiAgICBleHBvcnRzLmF0dGFjaENvbW1lbnRzID0gZXN0cmF2ZXJzZS5hdHRhY2hDb21tZW50cztcbiAgICBleHBvcnRzLlByZWNlZGVuY2UgPSB1cGRhdGVEZWVwbHkoe30sIFByZWNlZGVuY2UpO1xuICAgIGV4cG9ydHMuYnJvd3NlciA9IGZhbHNlO1xuICAgIGV4cG9ydHMuRk9STUFUX01JTklGWSA9IEZPUk1BVF9NSU5JRlk7XG4gICAgZXhwb3J0cy5GT1JNQVRfREVGQVVMVFMgPSBGT1JNQVRfREVGQVVMVFM7XG59KCkpO1xuLyogdmltOiBzZXQgc3c9NCB0cz00IGV0IHR3PTgwIDogKi9cbiIsIi8qXG4gIENvcHlyaWdodCAoQykgMjAxMyBZdXN1a2UgU3V6dWtpIDx1dGF0YW5lLnRlYUBnbWFpbC5jb20+XG5cbiAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyAnQVMgSVMnXG4gIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIDxDT1BZUklHSFQgSE9MREVSPiBCRSBMSUFCTEUgRk9SIEFOWVxuICBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuICAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4gIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuICBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0ZcbiAgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG5cbihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgZnVuY3Rpb24gaXNFeHByZXNzaW9uKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ0FycmF5RXhwcmVzc2lvbic6XG4gICAgICAgICAgICBjYXNlICdBc3NpZ25tZW50RXhwcmVzc2lvbic6XG4gICAgICAgICAgICBjYXNlICdCaW5hcnlFeHByZXNzaW9uJzpcbiAgICAgICAgICAgIGNhc2UgJ0NhbGxFeHByZXNzaW9uJzpcbiAgICAgICAgICAgIGNhc2UgJ0NvbmRpdGlvbmFsRXhwcmVzc2lvbic6XG4gICAgICAgICAgICBjYXNlICdGdW5jdGlvbkV4cHJlc3Npb24nOlxuICAgICAgICAgICAgY2FzZSAnSWRlbnRpZmllcic6XG4gICAgICAgICAgICBjYXNlICdMaXRlcmFsJzpcbiAgICAgICAgICAgIGNhc2UgJ0xvZ2ljYWxFeHByZXNzaW9uJzpcbiAgICAgICAgICAgIGNhc2UgJ01lbWJlckV4cHJlc3Npb24nOlxuICAgICAgICAgICAgY2FzZSAnTmV3RXhwcmVzc2lvbic6XG4gICAgICAgICAgICBjYXNlICdPYmplY3RFeHByZXNzaW9uJzpcbiAgICAgICAgICAgIGNhc2UgJ1NlcXVlbmNlRXhwcmVzc2lvbic6XG4gICAgICAgICAgICBjYXNlICdUaGlzRXhwcmVzc2lvbic6XG4gICAgICAgICAgICBjYXNlICdVbmFyeUV4cHJlc3Npb24nOlxuICAgICAgICAgICAgY2FzZSAnVXBkYXRlRXhwcmVzc2lvbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSXRlcmF0aW9uU3RhdGVtZW50KG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ0RvV2hpbGVTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnRm9ySW5TdGF0ZW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnRm9yU3RhdGVtZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ1doaWxlU3RhdGVtZW50JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnQmxvY2tTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnQnJlYWtTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnQ29udGludWVTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnRGVidWdnZXJTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnRG9XaGlsZVN0YXRlbWVudCc6XG4gICAgICAgICAgICBjYXNlICdFbXB0eVN0YXRlbWVudCc6XG4gICAgICAgICAgICBjYXNlICdFeHByZXNzaW9uU3RhdGVtZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ0ZvckluU3RhdGVtZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ0ZvclN0YXRlbWVudCc6XG4gICAgICAgICAgICBjYXNlICdJZlN0YXRlbWVudCc6XG4gICAgICAgICAgICBjYXNlICdMYWJlbGVkU3RhdGVtZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ1JldHVyblN0YXRlbWVudCc6XG4gICAgICAgICAgICBjYXNlICdTd2l0Y2hTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnVGhyb3dTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnVHJ5U3RhdGVtZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ1ZhcmlhYmxlRGVjbGFyYXRpb24nOlxuICAgICAgICAgICAgY2FzZSAnV2hpbGVTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnV2l0aFN0YXRlbWVudCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU291cmNlRWxlbWVudChub2RlKSB7XG4gICAgICByZXR1cm4gaXNTdGF0ZW1lbnQobm9kZSkgfHwgbm9kZSAhPSBudWxsICYmIG5vZGUudHlwZSA9PT0gJ0Z1bmN0aW9uRGVjbGFyYXRpb24nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyYWlsaW5nU3RhdGVtZW50KG5vZGUpIHtcbiAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnSWZTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgaWYgKG5vZGUuYWx0ZXJuYXRlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5hbHRlcm5hdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5jb25zZXF1ZW50O1xuXG4gICAgICAgIGNhc2UgJ0xhYmVsZWRTdGF0ZW1lbnQnOlxuICAgICAgICBjYXNlICdGb3JTdGF0ZW1lbnQnOlxuICAgICAgICBjYXNlICdGb3JJblN0YXRlbWVudCc6XG4gICAgICAgIGNhc2UgJ1doaWxlU3RhdGVtZW50JzpcbiAgICAgICAgY2FzZSAnV2l0aFN0YXRlbWVudCc6XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5ib2R5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzUHJvYmxlbWF0aWNJZlN0YXRlbWVudChub2RlKSB7XG4gICAgICAgIHZhciBjdXJyZW50O1xuXG4gICAgICAgIGlmIChub2RlLnR5cGUgIT09ICdJZlN0YXRlbWVudCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5hbHRlcm5hdGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSBub2RlLmNvbnNlcXVlbnQ7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50LnR5cGUgPT09ICdJZlN0YXRlbWVudCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5hbHRlcm5hdGUgPT0gbnVsbCkgIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudCA9IHRyYWlsaW5nU3RhdGVtZW50KGN1cnJlbnQpO1xuICAgICAgICB9IHdoaWxlIChjdXJyZW50KTtcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGlzRXhwcmVzc2lvbjogaXNFeHByZXNzaW9uLFxuICAgICAgICBpc1N0YXRlbWVudDogaXNTdGF0ZW1lbnQsXG4gICAgICAgIGlzSXRlcmF0aW9uU3RhdGVtZW50OiBpc0l0ZXJhdGlvblN0YXRlbWVudCxcbiAgICAgICAgaXNTb3VyY2VFbGVtZW50OiBpc1NvdXJjZUVsZW1lbnQsXG4gICAgICAgIGlzUHJvYmxlbWF0aWNJZlN0YXRlbWVudDogaXNQcm9ibGVtYXRpY0lmU3RhdGVtZW50LFxuXG4gICAgICAgIHRyYWlsaW5nU3RhdGVtZW50OiB0cmFpbGluZ1N0YXRlbWVudFxuICAgIH07XG59KCkpO1xuLyogdmltOiBzZXQgc3c9NCB0cz00IGV0IHR3PTgwIDogKi9cbiIsIi8qXG4gIENvcHlyaWdodCAoQykgMjAxMy0yMDE0IFl1c3VrZSBTdXp1a2kgPHV0YXRhbmUudGVhQGdtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDE0IEl2YW4gTmlrdWxpbiA8aWZhYWFuQGdtYWlsLmNvbT5cblxuICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuICBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCA8Q09QWVJJR0hUIEhPTERFUj4gQkUgTElBQkxFIEZPUiBBTllcbiAgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbiAgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuICBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkRcbiAgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GXG4gIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4qL1xuXG4oZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBFUzZSZWdleCwgRVM1UmVnZXgsIE5PTl9BU0NJSV9XSElURVNQQUNFUywgSURFTlRJRklFUl9TVEFSVCwgSURFTlRJRklFUl9QQVJULCBjaDtcblxuICAgIC8vIFNlZSBgdG9vbHMvZ2VuZXJhdGUtaWRlbnRpZmllci1yZWdleC5qc2AuXG4gICAgRVM1UmVnZXggPSB7XG4gICAgICAgIC8vIEVDTUFTY3JpcHQgNS4xL1VuaWNvZGUgdjcuMC4wIE5vbkFzY2lpSWRlbnRpZmllclN0YXJ0OlxuICAgICAgICBOb25Bc2NpaUlkZW50aWZpZXJTdGFydDogL1tcXHhBQVxceEI1XFx4QkFcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzdGXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDhBLVxcdTA1MkZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYyMC1cXHUwNjRBXFx1MDY2RVxcdTA2NkZcXHUwNjcxLVxcdTA2RDNcXHUwNkQ1XFx1MDZFNVxcdTA2RTZcXHUwNkVFXFx1MDZFRlxcdTA2RkEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwXFx1MDcxMi1cXHUwNzJGXFx1MDc0RC1cXHUwN0E1XFx1MDdCMVxcdTA3Q0EtXFx1MDdFQVxcdTA3RjRcXHUwN0Y1XFx1MDdGQVxcdTA4MDAtXFx1MDgxNVxcdTA4MUFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4QTAtXFx1MDhCMlxcdTA5MDQtXFx1MDkzOVxcdTA5M0RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3MS1cXHUwOTgwXFx1MDk4NS1cXHUwOThDXFx1MDk4RlxcdTA5OTBcXHUwOTkzLVxcdTA5QThcXHUwOUFBLVxcdTA5QjBcXHUwOUIyXFx1MDlCNi1cXHUwOUI5XFx1MDlCRFxcdTA5Q0VcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFMVxcdTA5RjBcXHUwOUYxXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE3Mi1cXHUwQTc0XFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJEXFx1MEFEMFxcdTBBRTBcXHUwQUUxXFx1MEIwNS1cXHUwQjBDXFx1MEIwRlxcdTBCMTBcXHUwQjEzLVxcdTBCMjhcXHUwQjJBLVxcdTBCMzBcXHUwQjMyXFx1MEIzM1xcdTBCMzUtXFx1MEIzOVxcdTBCM0RcXHUwQjVDXFx1MEI1RFxcdTBCNUYtXFx1MEI2MVxcdTBCNzFcXHUwQjgzXFx1MEI4NS1cXHUwQjhBXFx1MEI4RS1cXHUwQjkwXFx1MEI5Mi1cXHUwQjk1XFx1MEI5OVxcdTBCOUFcXHUwQjlDXFx1MEI5RVxcdTBCOUZcXHUwQkEzXFx1MEJBNFxcdTBCQTgtXFx1MEJBQVxcdTBCQUUtXFx1MEJCOVxcdTBCRDBcXHUwQzA1LVxcdTBDMENcXHUwQzBFLVxcdTBDMTBcXHUwQzEyLVxcdTBDMjhcXHUwQzJBLVxcdTBDMzlcXHUwQzNEXFx1MEM1OFxcdTBDNTlcXHUwQzYwXFx1MEM2MVxcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkRcXHUwQ0RFXFx1MENFMFxcdTBDRTFcXHUwQ0YxXFx1MENGMlxcdTBEMDUtXFx1MEQwQ1xcdTBEMEUtXFx1MEQxMFxcdTBEMTItXFx1MEQzQVxcdTBEM0RcXHUwRDRFXFx1MEQ2MFxcdTBENjFcXHUwRDdBLVxcdTBEN0ZcXHUwRDg1LVxcdTBEOTZcXHUwRDlBLVxcdTBEQjFcXHUwREIzLVxcdTBEQkJcXHUwREJEXFx1MERDMC1cXHUwREM2XFx1MEUwMS1cXHUwRTMwXFx1MEUzMlxcdTBFMzNcXHUwRTQwLVxcdTBFNDZcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg3XFx1MEU4OFxcdTBFOEFcXHUwRThEXFx1MEU5NC1cXHUwRTk3XFx1MEU5OS1cXHUwRTlGXFx1MEVBMS1cXHUwRUEzXFx1MEVBNVxcdTBFQTdcXHUwRUFBXFx1MEVBQlxcdTBFQUQtXFx1MEVCMFxcdTBFQjJcXHUwRUIzXFx1MEVCRFxcdTBFQzAtXFx1MEVDNFxcdTBFQzZcXHUwRURDLVxcdTBFREZcXHUwRjAwXFx1MEY0MC1cXHUwRjQ3XFx1MEY0OS1cXHUwRjZDXFx1MEY4OC1cXHUwRjhDXFx1MTAwMC1cXHUxMDJBXFx1MTAzRlxcdTEwNTAtXFx1MTA1NVxcdTEwNUEtXFx1MTA1RFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNkUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOEVcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEwRDAtXFx1MTBGQVxcdTEwRkMtXFx1MTI0OFxcdTEyNEEtXFx1MTI0RFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVBLVxcdTEyNURcXHUxMjYwLVxcdTEyODhcXHUxMjhBLVxcdTEyOERcXHUxMjkwLVxcdTEyQjBcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM4MC1cXHUxMzhGXFx1MTNBMC1cXHUxM0Y0XFx1MTQwMS1cXHUxNjZDXFx1MTY2Ri1cXHUxNjdGXFx1MTY4MS1cXHUxNjlBXFx1MTZBMC1cXHUxNkVBXFx1MTZFRS1cXHUxNkY4XFx1MTcwMC1cXHUxNzBDXFx1MTcwRS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZDXFx1MTc2RS1cXHUxNzcwXFx1MTc4MC1cXHUxN0IzXFx1MTdEN1xcdTE3RENcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4QThcXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFFXFx1MTk1MC1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlDMS1cXHUxOUM3XFx1MUEwMC1cXHUxQTE2XFx1MUEyMC1cXHUxQTU0XFx1MUFBN1xcdTFCMDUtXFx1MUIzM1xcdTFCNDUtXFx1MUI0QlxcdTFCODMtXFx1MUJBMFxcdTFCQUVcXHUxQkFGXFx1MUJCQS1cXHUxQkU1XFx1MUMwMC1cXHUxQzIzXFx1MUM0RC1cXHUxQzRGXFx1MUM1QS1cXHUxQzdEXFx1MUNFOS1cXHUxQ0VDXFx1MUNFRS1cXHUxQ0YxXFx1MUNGNVxcdTFDRjZcXHUxRDAwLVxcdTFEQkZcXHUxRTAwLVxcdTFGMTVcXHUxRjE4LVxcdTFGMURcXHUxRjIwLVxcdTFGNDVcXHUxRjQ4LVxcdTFGNERcXHUxRjUwLVxcdTFGNTdcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGLVxcdTFGN0RcXHUxRjgwLVxcdTFGQjRcXHUxRkI2LVxcdTFGQkNcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNi1cXHUxRkNDXFx1MUZEMC1cXHUxRkQzXFx1MUZENi1cXHUxRkRCXFx1MUZFMC1cXHUxRkVDXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZDXFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyMTAyXFx1MjEwN1xcdTIxMEEtXFx1MjExM1xcdTIxMTVcXHUyMTE5LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMkRcXHUyMTJGLVxcdTIxMzlcXHUyMTNDLVxcdTIxM0ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRFXFx1MjE2MC1cXHUyMTg4XFx1MkMwMC1cXHUyQzJFXFx1MkMzMC1cXHUyQzVFXFx1MkM2MC1cXHUyQ0U0XFx1MkNFQi1cXHUyQ0VFXFx1MkNGMlxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDgwLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUyRTJGXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5RC1cXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGQy1cXHUzMEZGXFx1MzEwNS1cXHUzMTJEXFx1MzEzMS1cXHUzMThFXFx1MzFBMC1cXHUzMUJBXFx1MzFGMC1cXHUzMUZGXFx1MzQwMC1cXHU0REI1XFx1NEUwMC1cXHU5RkNDXFx1QTAwMC1cXHVBNDhDXFx1QTREMC1cXHVBNEZEXFx1QTUwMC1cXHVBNjBDXFx1QTYxMC1cXHVBNjFGXFx1QTYyQVxcdUE2MkJcXHVBNjQwLVxcdUE2NkVcXHVBNjdGLVxcdUE2OURcXHVBNkEwLVxcdUE2RUZcXHVBNzE3LVxcdUE3MUZcXHVBNzIyLVxcdUE3ODhcXHVBNzhCLVxcdUE3OEVcXHVBNzkwLVxcdUE3QURcXHVBN0IwXFx1QTdCMVxcdUE3RjctXFx1QTgwMVxcdUE4MDMtXFx1QTgwNVxcdUE4MDctXFx1QTgwQVxcdUE4MEMtXFx1QTgyMlxcdUE4NDAtXFx1QTg3M1xcdUE4ODItXFx1QThCM1xcdUE4RjItXFx1QThGN1xcdUE4RkJcXHVBOTBBLVxcdUE5MjVcXHVBOTMwLVxcdUE5NDZcXHVBOTYwLVxcdUE5N0NcXHVBOTg0LVxcdUE5QjJcXHVBOUNGXFx1QTlFMC1cXHVBOUU0XFx1QTlFNi1cXHVBOUVGXFx1QTlGQS1cXHVBOUZFXFx1QUEwMC1cXHVBQTI4XFx1QUE0MC1cXHVBQTQyXFx1QUE0NC1cXHVBQTRCXFx1QUE2MC1cXHVBQTc2XFx1QUE3QVxcdUFBN0UtXFx1QUFBRlxcdUFBQjFcXHVBQUI1XFx1QUFCNlxcdUFBQjktXFx1QUFCRFxcdUFBQzBcXHVBQUMyXFx1QUFEQi1cXHVBQUREXFx1QUFFMC1cXHVBQUVBXFx1QUFGMi1cXHVBQUY0XFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUIzMC1cXHVBQjVBXFx1QUI1Qy1cXHVBQjVGXFx1QUI2NFxcdUFCNjVcXHVBQkMwLVxcdUFCRTJcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGQjFEXFx1RkIxRi1cXHVGQjI4XFx1RkIyQS1cXHVGQjM2XFx1RkIzOC1cXHVGQjNDXFx1RkIzRVxcdUZCNDBcXHVGQjQxXFx1RkI0M1xcdUZCNDRcXHVGQjQ2LVxcdUZCQjFcXHVGQkQzLVxcdUZEM0RcXHVGRDUwLVxcdUZEOEZcXHVGRDkyLVxcdUZEQzdcXHVGREYwLVxcdUZERkJcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkNcXHVGRjIxLVxcdUZGM0FcXHVGRjQxLVxcdUZGNUFcXHVGRjY2LVxcdUZGQkVcXHVGRkMyLVxcdUZGQzdcXHVGRkNBLVxcdUZGQ0ZcXHVGRkQyLVxcdUZGRDdcXHVGRkRBLVxcdUZGRENdLyxcbiAgICAgICAgLy8gRUNNQVNjcmlwdCA1LjEvVW5pY29kZSB2Ny4wLjAgTm9uQXNjaWlJZGVudGlmaWVyUGFydDpcbiAgICAgICAgTm9uQXNjaWlJZGVudGlmaWVyUGFydDogL1tcXHhBQVxceEI1XFx4QkFcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDMwMC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzdGXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDgzLVxcdTA0ODdcXHUwNDhBLVxcdTA1MkZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDU5MS1cXHUwNUJEXFx1MDVCRlxcdTA1QzFcXHUwNUMyXFx1MDVDNFxcdTA1QzVcXHUwNUM3XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYxMC1cXHUwNjFBXFx1MDYyMC1cXHUwNjY5XFx1MDY2RS1cXHUwNkQzXFx1MDZENS1cXHUwNkRDXFx1MDZERi1cXHUwNkU4XFx1MDZFQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTAtXFx1MDc0QVxcdTA3NEQtXFx1MDdCMVxcdTA3QzAtXFx1MDdGNVxcdTA3RkFcXHUwODAwLVxcdTA4MkRcXHUwODQwLVxcdTA4NUJcXHUwOEEwLVxcdTA4QjJcXHUwOEU0LVxcdTA5NjNcXHUwOTY2LVxcdTA5NkZcXHUwOTcxLVxcdTA5ODNcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJDLVxcdTA5QzRcXHUwOUM3XFx1MDlDOFxcdTA5Q0ItXFx1MDlDRVxcdTA5RDdcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFM1xcdTA5RTYtXFx1MDlGMVxcdTBBMDEtXFx1MEEwM1xcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEEzQ1xcdTBBM0UtXFx1MEE0MlxcdTBBNDdcXHUwQTQ4XFx1MEE0Qi1cXHUwQTREXFx1MEE1MVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTY2LVxcdTBBNzVcXHUwQTgxLVxcdTBBODNcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkMtXFx1MEFDNVxcdTBBQzctXFx1MEFDOVxcdTBBQ0ItXFx1MEFDRFxcdTBBRDBcXHUwQUUwLVxcdTBBRTNcXHUwQUU2LVxcdTBBRUZcXHUwQjAxLVxcdTBCMDNcXHUwQjA1LVxcdTBCMENcXHUwQjBGXFx1MEIxMFxcdTBCMTMtXFx1MEIyOFxcdTBCMkEtXFx1MEIzMFxcdTBCMzJcXHUwQjMzXFx1MEIzNS1cXHUwQjM5XFx1MEIzQy1cXHUwQjQ0XFx1MEI0N1xcdTBCNDhcXHUwQjRCLVxcdTBCNERcXHUwQjU2XFx1MEI1N1xcdTBCNUNcXHUwQjVEXFx1MEI1Ri1cXHUwQjYzXFx1MEI2Ni1cXHUwQjZGXFx1MEI3MVxcdTBCODJcXHUwQjgzXFx1MEI4NS1cXHUwQjhBXFx1MEI4RS1cXHUwQjkwXFx1MEI5Mi1cXHUwQjk1XFx1MEI5OVxcdTBCOUFcXHUwQjlDXFx1MEI5RVxcdTBCOUZcXHUwQkEzXFx1MEJBNFxcdTBCQTgtXFx1MEJBQVxcdTBCQUUtXFx1MEJCOVxcdTBCQkUtXFx1MEJDMlxcdTBCQzYtXFx1MEJDOFxcdTBCQ0EtXFx1MEJDRFxcdTBCRDBcXHUwQkQ3XFx1MEJFNi1cXHUwQkVGXFx1MEMwMC1cXHUwQzAzXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzM5XFx1MEMzRC1cXHUwQzQ0XFx1MEM0Ni1cXHUwQzQ4XFx1MEM0QS1cXHUwQzREXFx1MEM1NVxcdTBDNTZcXHUwQzU4XFx1MEM1OVxcdTBDNjAtXFx1MEM2M1xcdTBDNjYtXFx1MEM2RlxcdTBDODEtXFx1MEM4M1xcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkMtXFx1MENDNFxcdTBDQzYtXFx1MENDOFxcdTBDQ0EtXFx1MENDRFxcdTBDRDVcXHUwQ0Q2XFx1MENERVxcdTBDRTAtXFx1MENFM1xcdTBDRTYtXFx1MENFRlxcdTBDRjFcXHUwQ0YyXFx1MEQwMS1cXHUwRDAzXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRC1cXHUwRDQ0XFx1MEQ0Ni1cXHUwRDQ4XFx1MEQ0QS1cXHUwRDRFXFx1MEQ1N1xcdTBENjAtXFx1MEQ2M1xcdTBENjYtXFx1MEQ2RlxcdTBEN0EtXFx1MEQ3RlxcdTBEODJcXHUwRDgzXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBEQ0FcXHUwRENGLVxcdTBERDRcXHUwREQ2XFx1MEREOC1cXHUwRERGXFx1MERFNi1cXHUwREVGXFx1MERGMlxcdTBERjNcXHUwRTAxLVxcdTBFM0FcXHUwRTQwLVxcdTBFNEVcXHUwRTUwLVxcdTBFNTlcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg3XFx1MEU4OFxcdTBFOEFcXHUwRThEXFx1MEU5NC1cXHUwRTk3XFx1MEU5OS1cXHUwRTlGXFx1MEVBMS1cXHUwRUEzXFx1MEVBNVxcdTBFQTdcXHUwRUFBXFx1MEVBQlxcdTBFQUQtXFx1MEVCOVxcdTBFQkItXFx1MEVCRFxcdTBFQzAtXFx1MEVDNFxcdTBFQzZcXHUwRUM4LVxcdTBFQ0RcXHUwRUQwLVxcdTBFRDlcXHUwRURDLVxcdTBFREZcXHUwRjAwXFx1MEYxOFxcdTBGMTlcXHUwRjIwLVxcdTBGMjlcXHUwRjM1XFx1MEYzN1xcdTBGMzlcXHUwRjNFLVxcdTBGNDdcXHUwRjQ5LVxcdTBGNkNcXHUwRjcxLVxcdTBGODRcXHUwRjg2LVxcdTBGOTdcXHUwRjk5LVxcdTBGQkNcXHUwRkM2XFx1MTAwMC1cXHUxMDQ5XFx1MTA1MC1cXHUxMDlEXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzNUQtXFx1MTM1RlxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RUUtXFx1MTZGOFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxNFxcdTE3MjAtXFx1MTczNFxcdTE3NDAtXFx1MTc1M1xcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3NzJcXHUxNzczXFx1MTc4MC1cXHUxN0QzXFx1MTdEN1xcdTE3RENcXHUxN0REXFx1MTdFMC1cXHUxN0U5XFx1MTgwQi1cXHUxODBEXFx1MTgxMC1cXHUxODE5XFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFFXFx1MTkyMC1cXHUxOTJCXFx1MTkzMC1cXHUxOTNCXFx1MTk0Ni1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlCMC1cXHUxOUM5XFx1MTlEMC1cXHUxOUQ5XFx1MUEwMC1cXHUxQTFCXFx1MUEyMC1cXHUxQTVFXFx1MUE2MC1cXHUxQTdDXFx1MUE3Ri1cXHUxQTg5XFx1MUE5MC1cXHUxQTk5XFx1MUFBN1xcdTFBQjAtXFx1MUFCRFxcdTFCMDAtXFx1MUI0QlxcdTFCNTAtXFx1MUI1OVxcdTFCNkItXFx1MUI3M1xcdTFCODAtXFx1MUJGM1xcdTFDMDAtXFx1MUMzN1xcdTFDNDAtXFx1MUM0OVxcdTFDNEQtXFx1MUM3RFxcdTFDRDAtXFx1MUNEMlxcdTFDRDQtXFx1MUNGNlxcdTFDRjhcXHUxQ0Y5XFx1MUQwMC1cXHUxREY1XFx1MURGQy1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwMENcXHUyMDBEXFx1MjAzRlxcdTIwNDBcXHUyMDU0XFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyMEQwLVxcdTIwRENcXHUyMEUxXFx1MjBFNS1cXHUyMEYwXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTJEXFx1MjEyRi1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxNjAtXFx1MjE4OFxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNGM1xcdTJEMDAtXFx1MkQyNVxcdTJEMjdcXHUyRDJEXFx1MkQzMC1cXHUyRDY3XFx1MkQ2RlxcdTJEN0YtXFx1MkQ5NlxcdTJEQTAtXFx1MkRBNlxcdTJEQTgtXFx1MkRBRVxcdTJEQjAtXFx1MkRCNlxcdTJEQjgtXFx1MkRCRVxcdTJEQzAtXFx1MkRDNlxcdTJEQzgtXFx1MkRDRVxcdTJERDAtXFx1MkRENlxcdTJERDgtXFx1MkRERVxcdTJERTAtXFx1MkRGRlxcdTJFMkZcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMkZcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM0NcXHUzMDQxLVxcdTMwOTZcXHUzMDk5XFx1MzA5QVxcdTMwOUQtXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRFxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZDQ1xcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYyQlxcdUE2NDAtXFx1QTY2RlxcdUE2NzQtXFx1QTY3RFxcdUE2N0YtXFx1QTY5RFxcdUE2OUYtXFx1QTZGMVxcdUE3MTctXFx1QTcxRlxcdUE3MjItXFx1QTc4OFxcdUE3OEItXFx1QTc4RVxcdUE3OTAtXFx1QTdBRFxcdUE3QjBcXHVBN0IxXFx1QTdGNy1cXHVBODI3XFx1QTg0MC1cXHVBODczXFx1QTg4MC1cXHVBOEM0XFx1QThEMC1cXHVBOEQ5XFx1QThFMC1cXHVBOEY3XFx1QThGQlxcdUE5MDAtXFx1QTkyRFxcdUE5MzAtXFx1QTk1M1xcdUE5NjAtXFx1QTk3Q1xcdUE5ODAtXFx1QTlDMFxcdUE5Q0YtXFx1QTlEOVxcdUE5RTAtXFx1QTlGRVxcdUFBMDAtXFx1QUEzNlxcdUFBNDAtXFx1QUE0RFxcdUFBNTAtXFx1QUE1OVxcdUFBNjAtXFx1QUE3NlxcdUFBN0EtXFx1QUFDMlxcdUFBREItXFx1QUFERFxcdUFBRTAtXFx1QUFFRlxcdUFBRjItXFx1QUFGNlxcdUFCMDEtXFx1QUIwNlxcdUFCMDktXFx1QUIwRVxcdUFCMTEtXFx1QUIxNlxcdUFCMjAtXFx1QUIyNlxcdUFCMjgtXFx1QUIyRVxcdUFCMzAtXFx1QUI1QVxcdUFCNUMtXFx1QUI1RlxcdUFCNjRcXHVBQjY1XFx1QUJDMC1cXHVBQkVBXFx1QUJFQ1xcdUFCRURcXHVBQkYwLVxcdUFCRjlcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGQjFELVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFMDAtXFx1RkUwRlxcdUZFMjAtXFx1RkUyRFxcdUZFMzNcXHVGRTM0XFx1RkU0RC1cXHVGRTRGXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYxMC1cXHVGRjE5XFx1RkYyMS1cXHVGRjNBXFx1RkYzRlxcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQ10vXG4gICAgfTtcblxuICAgIEVTNlJlZ2V4ID0ge1xuICAgICAgICAvLyBFQ01BU2NyaXB0IDYvVW5pY29kZSB2Ny4wLjAgTm9uQXNjaWlJZGVudGlmaWVyU3RhcnQ6XG4gICAgICAgIE5vbkFzY2lpSWRlbnRpZmllclN0YXJ0OiAvW1xceEFBXFx4QjVcXHhCQVxceEMwLVxceEQ2XFx4RDgtXFx4RjZcXHhGOC1cXHUwMkMxXFx1MDJDNi1cXHUwMkQxXFx1MDJFMC1cXHUwMkU0XFx1MDJFQ1xcdTAyRUVcXHUwMzcwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN0EtXFx1MDM3RFxcdTAzN0ZcXHUwMzg2XFx1MDM4OC1cXHUwMzhBXFx1MDM4Q1xcdTAzOEUtXFx1MDNBMVxcdTAzQTMtXFx1MDNGNVxcdTAzRjctXFx1MDQ4MVxcdTA0OEEtXFx1MDUyRlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNUQwLVxcdTA1RUFcXHUwNUYwLVxcdTA1RjJcXHUwNjIwLVxcdTA2NEFcXHUwNjZFXFx1MDY2RlxcdTA2NzEtXFx1MDZEM1xcdTA2RDVcXHUwNkU1XFx1MDZFNlxcdTA2RUVcXHUwNkVGXFx1MDZGQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTBcXHUwNzEyLVxcdTA3MkZcXHUwNzRELVxcdTA3QTVcXHUwN0IxXFx1MDdDQS1cXHUwN0VBXFx1MDdGNFxcdTA3RjVcXHUwN0ZBXFx1MDgwMC1cXHUwODE1XFx1MDgxQVxcdTA4MjRcXHUwODI4XFx1MDg0MC1cXHUwODU4XFx1MDhBMC1cXHUwOEIyXFx1MDkwNC1cXHUwOTM5XFx1MDkzRFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTcxLVxcdTA5ODBcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJEXFx1MDlDRVxcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUxXFx1MDlGMFxcdTA5RjFcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTcyLVxcdTBBNzRcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkRcXHUwQUQwXFx1MEFFMFxcdTBBRTFcXHUwQjA1LVxcdTBCMENcXHUwQjBGXFx1MEIxMFxcdTBCMTMtXFx1MEIyOFxcdTBCMkEtXFx1MEIzMFxcdTBCMzJcXHUwQjMzXFx1MEIzNS1cXHUwQjM5XFx1MEIzRFxcdTBCNUNcXHUwQjVEXFx1MEI1Ri1cXHUwQjYxXFx1MEI3MVxcdTBCODNcXHUwQjg1LVxcdTBCOEFcXHUwQjhFLVxcdTBCOTBcXHUwQjkyLVxcdTBCOTVcXHUwQjk5XFx1MEI5QVxcdTBCOUNcXHUwQjlFXFx1MEI5RlxcdTBCQTNcXHUwQkE0XFx1MEJBOC1cXHUwQkFBXFx1MEJBRS1cXHUwQkI5XFx1MEJEMFxcdTBDMDUtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMFxcdTBDMTItXFx1MEMyOFxcdTBDMkEtXFx1MEMzOVxcdTBDM0RcXHUwQzU4XFx1MEM1OVxcdTBDNjBcXHUwQzYxXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCRFxcdTBDREVcXHUwQ0UwXFx1MENFMVxcdTBDRjFcXHUwQ0YyXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRFxcdTBENEVcXHUwRDYwXFx1MEQ2MVxcdTBEN0EtXFx1MEQ3RlxcdTBEODUtXFx1MEQ5NlxcdTBEOUEtXFx1MERCMVxcdTBEQjMtXFx1MERCQlxcdTBEQkRcXHUwREMwLVxcdTBEQzZcXHUwRTAxLVxcdTBFMzBcXHUwRTMyXFx1MEUzM1xcdTBFNDAtXFx1MEU0NlxcdTBFODFcXHUwRTgyXFx1MEU4NFxcdTBFODdcXHUwRTg4XFx1MEU4QVxcdTBFOERcXHUwRTk0LVxcdTBFOTdcXHUwRTk5LVxcdTBFOUZcXHUwRUExLVxcdTBFQTNcXHUwRUE1XFx1MEVBN1xcdTBFQUFcXHUwRUFCXFx1MEVBRC1cXHUwRUIwXFx1MEVCMlxcdTBFQjNcXHUwRUJEXFx1MEVDMC1cXHUwRUM0XFx1MEVDNlxcdTBFREMtXFx1MEVERlxcdTBGMDBcXHUwRjQwLVxcdTBGNDdcXHUwRjQ5LVxcdTBGNkNcXHUwRjg4LVxcdTBGOENcXHUxMDAwLVxcdTEwMkFcXHUxMDNGXFx1MTA1MC1cXHUxMDU1XFx1MTA1QS1cXHUxMDVEXFx1MTA2MVxcdTEwNjVcXHUxMDY2XFx1MTA2RS1cXHUxMDcwXFx1MTA3NS1cXHUxMDgxXFx1MTA4RVxcdTEwQTAtXFx1MTBDNVxcdTEwQzdcXHUxMENEXFx1MTBEMC1cXHUxMEZBXFx1MTBGQy1cXHUxMjQ4XFx1MTI0QS1cXHUxMjREXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNUEtXFx1MTI1RFxcdTEyNjAtXFx1MTI4OFxcdTEyOEEtXFx1MTI4RFxcdTEyOTAtXFx1MTJCMFxcdTEyQjItXFx1MTJCNVxcdTEyQjgtXFx1MTJCRVxcdTEyQzBcXHUxMkMyLVxcdTEyQzVcXHUxMkM4LVxcdTEyRDZcXHUxMkQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNUFcXHUxMzgwLVxcdTEzOEZcXHUxM0EwLVxcdTEzRjRcXHUxNDAxLVxcdTE2NkNcXHUxNjZGLVxcdTE2N0ZcXHUxNjgxLVxcdTE2OUFcXHUxNkEwLVxcdTE2RUFcXHUxNkVFLVxcdTE2RjhcXHUxNzAwLVxcdTE3MENcXHUxNzBFLVxcdTE3MTFcXHUxNzIwLVxcdTE3MzFcXHUxNzQwLVxcdTE3NTFcXHUxNzYwLVxcdTE3NkNcXHUxNzZFLVxcdTE3NzBcXHUxNzgwLVxcdTE3QjNcXHUxN0Q3XFx1MTdEQ1xcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThBOFxcdTE4QUFcXHUxOEIwLVxcdTE4RjVcXHUxOTAwLVxcdTE5MUVcXHUxOTUwLVxcdTE5NkRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5QUJcXHUxOUMxLVxcdTE5QzdcXHUxQTAwLVxcdTFBMTZcXHUxQTIwLVxcdTFBNTRcXHUxQUE3XFx1MUIwNS1cXHUxQjMzXFx1MUI0NS1cXHUxQjRCXFx1MUI4My1cXHUxQkEwXFx1MUJBRVxcdTFCQUZcXHUxQkJBLVxcdTFCRTVcXHUxQzAwLVxcdTFDMjNcXHUxQzRELVxcdTFDNEZcXHUxQzVBLVxcdTFDN0RcXHUxQ0U5LVxcdTFDRUNcXHUxQ0VFLVxcdTFDRjFcXHUxQ0Y1XFx1MUNGNlxcdTFEMDAtXFx1MURCRlxcdTFFMDAtXFx1MUYxNVxcdTFGMTgtXFx1MUYxRFxcdTFGMjAtXFx1MUY0NVxcdTFGNDgtXFx1MUY0RFxcdTFGNTAtXFx1MUY1N1xcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUYtXFx1MUY3RFxcdTFGODAtXFx1MUZCNFxcdTFGQjYtXFx1MUZCQ1xcdTFGQkVcXHUxRkMyLVxcdTFGQzRcXHUxRkM2LVxcdTFGQ0NcXHUxRkQwLVxcdTFGRDNcXHUxRkQ2LVxcdTFGREJcXHUxRkUwLVxcdTFGRUNcXHUxRkYyLVxcdTFGRjRcXHUxRkY2LVxcdTFGRkNcXHUyMDcxXFx1MjA3RlxcdTIwOTAtXFx1MjA5Q1xcdTIxMDJcXHUyMTA3XFx1MjEwQS1cXHUyMTEzXFx1MjExNVxcdTIxMTgtXFx1MjExRFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMkEtXFx1MjEzOVxcdTIxM0MtXFx1MjEzRlxcdTIxNDUtXFx1MjE0OVxcdTIxNEVcXHUyMTYwLVxcdTIxODhcXHUyQzAwLVxcdTJDMkVcXHUyQzMwLVxcdTJDNUVcXHUyQzYwLVxcdTJDRTRcXHUyQ0VCLVxcdTJDRUVcXHUyQ0YyXFx1MkNGM1xcdTJEMDAtXFx1MkQyNVxcdTJEMjdcXHUyRDJEXFx1MkQzMC1cXHUyRDY3XFx1MkQ2RlxcdTJEODAtXFx1MkQ5NlxcdTJEQTAtXFx1MkRBNlxcdTJEQTgtXFx1MkRBRVxcdTJEQjAtXFx1MkRCNlxcdTJEQjgtXFx1MkRCRVxcdTJEQzAtXFx1MkRDNlxcdTJEQzgtXFx1MkRDRVxcdTJERDAtXFx1MkRENlxcdTJERDgtXFx1MkRERVxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOUItXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRFxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZDQ1xcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYxRlxcdUE2MkFcXHVBNjJCXFx1QTY0MC1cXHVBNjZFXFx1QTY3Ri1cXHVBNjlEXFx1QTZBMC1cXHVBNkVGXFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBNzhFXFx1QTc5MC1cXHVBN0FEXFx1QTdCMFxcdUE3QjFcXHVBN0Y3LVxcdUE4MDFcXHVBODAzLVxcdUE4MDVcXHVBODA3LVxcdUE4MEFcXHVBODBDLVxcdUE4MjJcXHVBODQwLVxcdUE4NzNcXHVBODgyLVxcdUE4QjNcXHVBOEYyLVxcdUE4RjdcXHVBOEZCXFx1QTkwQS1cXHVBOTI1XFx1QTkzMC1cXHVBOTQ2XFx1QTk2MC1cXHVBOTdDXFx1QTk4NC1cXHVBOUIyXFx1QTlDRlxcdUE5RTAtXFx1QTlFNFxcdUE5RTYtXFx1QTlFRlxcdUE5RkEtXFx1QTlGRVxcdUFBMDAtXFx1QUEyOFxcdUFBNDAtXFx1QUE0MlxcdUFBNDQtXFx1QUE0QlxcdUFBNjAtXFx1QUE3NlxcdUFBN0FcXHVBQTdFLVxcdUFBQUZcXHVBQUIxXFx1QUFCNVxcdUFBQjZcXHVBQUI5LVxcdUFBQkRcXHVBQUMwXFx1QUFDMlxcdUFBREItXFx1QUFERFxcdUFBRTAtXFx1QUFFQVxcdUFBRjItXFx1QUFGNFxcdUFCMDEtXFx1QUIwNlxcdUFCMDktXFx1QUIwRVxcdUFCMTEtXFx1QUIxNlxcdUFCMjAtXFx1QUIyNlxcdUFCMjgtXFx1QUIyRVxcdUFCMzAtXFx1QUI1QVxcdUFCNUMtXFx1QUI1RlxcdUFCNjRcXHVBQjY1XFx1QUJDMC1cXHVBQkUyXFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQTZEXFx1RkE3MC1cXHVGQUQ5XFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkIxRFxcdUZCMUYtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYyMS1cXHVGRjNBXFx1RkY0MS1cXHVGRjVBXFx1RkY2Ni1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDXXxcXHVEODAwW1xcdURDMDAtXFx1REMwQlxcdURDMEQtXFx1REMyNlxcdURDMjgtXFx1REMzQVxcdURDM0NcXHVEQzNEXFx1REMzRi1cXHVEQzREXFx1REM1MC1cXHVEQzVEXFx1REM4MC1cXHVEQ0ZBXFx1REQ0MC1cXHVERDc0XFx1REU4MC1cXHVERTlDXFx1REVBMC1cXHVERUQwXFx1REYwMC1cXHVERjFGXFx1REYzMC1cXHVERjRBXFx1REY1MC1cXHVERjc1XFx1REY4MC1cXHVERjlEXFx1REZBMC1cXHVERkMzXFx1REZDOC1cXHVERkNGXFx1REZEMS1cXHVERkQ1XXxcXHVEODAxW1xcdURDMDAtXFx1REM5RFxcdUREMDAtXFx1REQyN1xcdUREMzAtXFx1REQ2M1xcdURFMDAtXFx1REYzNlxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY2N118XFx1RDgwMltcXHVEQzAwLVxcdURDMDVcXHVEQzA4XFx1REMwQS1cXHVEQzM1XFx1REMzN1xcdURDMzhcXHVEQzNDXFx1REMzRi1cXHVEQzU1XFx1REM2MC1cXHVEQzc2XFx1REM4MC1cXHVEQzlFXFx1REQwMC1cXHVERDE1XFx1REQyMC1cXHVERDM5XFx1REQ4MC1cXHVEREI3XFx1RERCRVxcdUREQkZcXHVERTAwXFx1REUxMC1cXHVERTEzXFx1REUxNS1cXHVERTE3XFx1REUxOS1cXHVERTMzXFx1REU2MC1cXHVERTdDXFx1REU4MC1cXHVERTlDXFx1REVDMC1cXHVERUM3XFx1REVDOS1cXHVERUU0XFx1REYwMC1cXHVERjM1XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjcyXFx1REY4MC1cXHVERjkxXXxcXHVEODAzW1xcdURDMDAtXFx1REM0OF18XFx1RDgwNFtcXHVEQzAzLVxcdURDMzdcXHVEQzgzLVxcdURDQUZcXHVEQ0QwLVxcdURDRThcXHVERDAzLVxcdUREMjZcXHVERDUwLVxcdURENzJcXHVERDc2XFx1REQ4My1cXHVEREIyXFx1RERDMS1cXHVEREM0XFx1REREQVxcdURFMDAtXFx1REUxMVxcdURFMTMtXFx1REUyQlxcdURFQjAtXFx1REVERVxcdURGMDUtXFx1REYwQ1xcdURGMEZcXHVERjEwXFx1REYxMy1cXHVERjI4XFx1REYyQS1cXHVERjMwXFx1REYzMlxcdURGMzNcXHVERjM1LVxcdURGMzlcXHVERjNEXFx1REY1RC1cXHVERjYxXXxcXHVEODA1W1xcdURDODAtXFx1RENBRlxcdURDQzRcXHVEQ0M1XFx1RENDN1xcdUREODAtXFx1RERBRVxcdURFMDAtXFx1REUyRlxcdURFNDRcXHVERTgwLVxcdURFQUFdfFxcdUQ4MDZbXFx1RENBMC1cXHVEQ0RGXFx1RENGRlxcdURFQzAtXFx1REVGOF18XFx1RDgwOFtcXHVEQzAwLVxcdURGOThdfFxcdUQ4MDlbXFx1REMwMC1cXHVEQzZFXXxbXFx1RDgwQ1xcdUQ4NDAtXFx1RDg2OFxcdUQ4NkEtXFx1RDg2Q11bXFx1REMwMC1cXHVERkZGXXxcXHVEODBEW1xcdURDMDAtXFx1REMyRV18XFx1RDgxQVtcXHVEQzAwLVxcdURFMzhcXHVERTQwLVxcdURFNUVcXHVERUQwLVxcdURFRURcXHVERjAwLVxcdURGMkZcXHVERjQwLVxcdURGNDNcXHVERjYzLVxcdURGNzdcXHVERjdELVxcdURGOEZdfFxcdUQ4MUJbXFx1REYwMC1cXHVERjQ0XFx1REY1MFxcdURGOTMtXFx1REY5Rl18XFx1RDgyQ1tcXHVEQzAwXFx1REMwMV18XFx1RDgyRltcXHVEQzAwLVxcdURDNkFcXHVEQzcwLVxcdURDN0NcXHVEQzgwLVxcdURDODhcXHVEQzkwLVxcdURDOTldfFxcdUQ4MzVbXFx1REMwMC1cXHVEQzU0XFx1REM1Ni1cXHVEQzlDXFx1REM5RVxcdURDOUZcXHVEQ0EyXFx1RENBNVxcdURDQTZcXHVEQ0E5LVxcdURDQUNcXHVEQ0FFLVxcdURDQjlcXHVEQ0JCXFx1RENCRC1cXHVEQ0MzXFx1RENDNS1cXHVERDA1XFx1REQwNy1cXHVERDBBXFx1REQwRC1cXHVERDE0XFx1REQxNi1cXHVERDFDXFx1REQxRS1cXHVERDM5XFx1REQzQi1cXHVERDNFXFx1REQ0MC1cXHVERDQ0XFx1REQ0NlxcdURENEEtXFx1REQ1MFxcdURENTItXFx1REVBNVxcdURFQTgtXFx1REVDMFxcdURFQzItXFx1REVEQVxcdURFREMtXFx1REVGQVxcdURFRkMtXFx1REYxNFxcdURGMTYtXFx1REYzNFxcdURGMzYtXFx1REY0RVxcdURGNTAtXFx1REY2RVxcdURGNzAtXFx1REY4OFxcdURGOEEtXFx1REZBOFxcdURGQUEtXFx1REZDMlxcdURGQzQtXFx1REZDQl18XFx1RDgzQVtcXHVEQzAwLVxcdURDQzRdfFxcdUQ4M0JbXFx1REUwMC1cXHVERTAzXFx1REUwNS1cXHVERTFGXFx1REUyMVxcdURFMjJcXHVERTI0XFx1REUyN1xcdURFMjktXFx1REUzMlxcdURFMzQtXFx1REUzN1xcdURFMzlcXHVERTNCXFx1REU0MlxcdURFNDdcXHVERTQ5XFx1REU0QlxcdURFNEQtXFx1REU0RlxcdURFNTFcXHVERTUyXFx1REU1NFxcdURFNTdcXHVERTU5XFx1REU1QlxcdURFNURcXHVERTVGXFx1REU2MVxcdURFNjJcXHVERTY0XFx1REU2Ny1cXHVERTZBXFx1REU2Qy1cXHVERTcyXFx1REU3NC1cXHVERTc3XFx1REU3OS1cXHVERTdDXFx1REU3RVxcdURFODAtXFx1REU4OVxcdURFOEItXFx1REU5QlxcdURFQTEtXFx1REVBM1xcdURFQTUtXFx1REVBOVxcdURFQUItXFx1REVCQl18XFx1RDg2OVtcXHVEQzAwLVxcdURFRDZcXHVERjAwLVxcdURGRkZdfFxcdUQ4NkRbXFx1REMwMC1cXHVERjM0XFx1REY0MC1cXHVERkZGXXxcXHVEODZFW1xcdURDMDAtXFx1REMxRF18XFx1RDg3RVtcXHVEQzAwLVxcdURFMURdLyxcbiAgICAgICAgLy8gRUNNQVNjcmlwdCA2L1VuaWNvZGUgdjcuMC4wIE5vbkFzY2lpSWRlbnRpZmllclBhcnQ6XG4gICAgICAgIE5vbkFzY2lpSWRlbnRpZmllclBhcnQ6IC9bXFx4QUFcXHhCNVxceEI3XFx4QkFcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDMwMC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzdGXFx1MDM4Ni1cXHUwMzhBXFx1MDM4Q1xcdTAzOEUtXFx1MDNBMVxcdTAzQTMtXFx1MDNGNVxcdTAzRjctXFx1MDQ4MVxcdTA0ODMtXFx1MDQ4N1xcdTA0OEEtXFx1MDUyRlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNTkxLVxcdTA1QkRcXHUwNUJGXFx1MDVDMVxcdTA1QzJcXHUwNUM0XFx1MDVDNVxcdTA1QzdcXHUwNUQwLVxcdTA1RUFcXHUwNUYwLVxcdTA1RjJcXHUwNjEwLVxcdTA2MUFcXHUwNjIwLVxcdTA2NjlcXHUwNjZFLVxcdTA2RDNcXHUwNkQ1LVxcdTA2RENcXHUwNkRGLVxcdTA2RThcXHUwNkVBLVxcdTA2RkNcXHUwNkZGXFx1MDcxMC1cXHUwNzRBXFx1MDc0RC1cXHUwN0IxXFx1MDdDMC1cXHUwN0Y1XFx1MDdGQVxcdTA4MDAtXFx1MDgyRFxcdTA4NDAtXFx1MDg1QlxcdTA4QTAtXFx1MDhCMlxcdTA4RTQtXFx1MDk2M1xcdTA5NjYtXFx1MDk2RlxcdTA5NzEtXFx1MDk4M1xcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkMtXFx1MDlDNFxcdTA5QzdcXHUwOUM4XFx1MDlDQi1cXHUwOUNFXFx1MDlEN1xcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUzXFx1MDlFNi1cXHUwOUYxXFx1MEEwMS1cXHUwQTAzXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTNDXFx1MEEzRS1cXHUwQTQyXFx1MEE0N1xcdTBBNDhcXHUwQTRCLVxcdTBBNERcXHUwQTUxXFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNjYtXFx1MEE3NVxcdTBBODEtXFx1MEE4M1xcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCQy1cXHUwQUM1XFx1MEFDNy1cXHUwQUM5XFx1MEFDQi1cXHUwQUNEXFx1MEFEMFxcdTBBRTAtXFx1MEFFM1xcdTBBRTYtXFx1MEFFRlxcdTBCMDEtXFx1MEIwM1xcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNDLVxcdTBCNDRcXHUwQjQ3XFx1MEI0OFxcdTBCNEItXFx1MEI0RFxcdTBCNTZcXHUwQjU3XFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjNcXHUwQjY2LVxcdTBCNkZcXHUwQjcxXFx1MEI4MlxcdTBCODNcXHUwQjg1LVxcdTBCOEFcXHUwQjhFLVxcdTBCOTBcXHUwQjkyLVxcdTBCOTVcXHUwQjk5XFx1MEI5QVxcdTBCOUNcXHUwQjlFXFx1MEI5RlxcdTBCQTNcXHUwQkE0XFx1MEJBOC1cXHUwQkFBXFx1MEJBRS1cXHUwQkI5XFx1MEJCRS1cXHUwQkMyXFx1MEJDNi1cXHUwQkM4XFx1MEJDQS1cXHUwQkNEXFx1MEJEMFxcdTBCRDdcXHUwQkU2LVxcdTBCRUZcXHUwQzAwLVxcdTBDMDNcXHUwQzA1LVxcdTBDMENcXHUwQzBFLVxcdTBDMTBcXHUwQzEyLVxcdTBDMjhcXHUwQzJBLVxcdTBDMzlcXHUwQzNELVxcdTBDNDRcXHUwQzQ2LVxcdTBDNDhcXHUwQzRBLVxcdTBDNERcXHUwQzU1XFx1MEM1NlxcdTBDNThcXHUwQzU5XFx1MEM2MC1cXHUwQzYzXFx1MEM2Ni1cXHUwQzZGXFx1MEM4MS1cXHUwQzgzXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCQy1cXHUwQ0M0XFx1MENDNi1cXHUwQ0M4XFx1MENDQS1cXHUwQ0NEXFx1MENENVxcdTBDRDZcXHUwQ0RFXFx1MENFMC1cXHUwQ0UzXFx1MENFNi1cXHUwQ0VGXFx1MENGMVxcdTBDRjJcXHUwRDAxLVxcdTBEMDNcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNELVxcdTBENDRcXHUwRDQ2LVxcdTBENDhcXHUwRDRBLVxcdTBENEVcXHUwRDU3XFx1MEQ2MC1cXHUwRDYzXFx1MEQ2Ni1cXHUwRDZGXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4MlxcdTBEODNcXHUwRDg1LVxcdTBEOTZcXHUwRDlBLVxcdTBEQjFcXHUwREIzLVxcdTBEQkJcXHUwREJEXFx1MERDMC1cXHUwREM2XFx1MERDQVxcdTBEQ0YtXFx1MERENFxcdTBERDZcXHUwREQ4LVxcdTBEREZcXHUwREU2LVxcdTBERUZcXHUwREYyXFx1MERGM1xcdTBFMDEtXFx1MEUzQVxcdTBFNDAtXFx1MEU0RVxcdTBFNTAtXFx1MEU1OVxcdTBFODFcXHUwRTgyXFx1MEU4NFxcdTBFODdcXHUwRTg4XFx1MEU4QVxcdTBFOERcXHUwRTk0LVxcdTBFOTdcXHUwRTk5LVxcdTBFOUZcXHUwRUExLVxcdTBFQTNcXHUwRUE1XFx1MEVBN1xcdTBFQUFcXHUwRUFCXFx1MEVBRC1cXHUwRUI5XFx1MEVCQi1cXHUwRUJEXFx1MEVDMC1cXHUwRUM0XFx1MEVDNlxcdTBFQzgtXFx1MEVDRFxcdTBFRDAtXFx1MEVEOVxcdTBFREMtXFx1MEVERlxcdTBGMDBcXHUwRjE4XFx1MEYxOVxcdTBGMjAtXFx1MEYyOVxcdTBGMzVcXHUwRjM3XFx1MEYzOVxcdTBGM0UtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGNzEtXFx1MEY4NFxcdTBGODYtXFx1MEY5N1xcdTBGOTktXFx1MEZCQ1xcdTBGQzZcXHUxMDAwLVxcdTEwNDlcXHUxMDUwLVxcdTEwOURcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEwRDAtXFx1MTBGQVxcdTEwRkMtXFx1MTI0OFxcdTEyNEEtXFx1MTI0RFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVBLVxcdTEyNURcXHUxMjYwLVxcdTEyODhcXHUxMjhBLVxcdTEyOERcXHUxMjkwLVxcdTEyQjBcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM1RC1cXHUxMzVGXFx1MTM2OS1cXHUxMzcxXFx1MTM4MC1cXHUxMzhGXFx1MTNBMC1cXHUxM0Y0XFx1MTQwMS1cXHUxNjZDXFx1MTY2Ri1cXHUxNjdGXFx1MTY4MS1cXHUxNjlBXFx1MTZBMC1cXHUxNkVBXFx1MTZFRS1cXHUxNkY4XFx1MTcwMC1cXHUxNzBDXFx1MTcwRS1cXHUxNzE0XFx1MTcyMC1cXHUxNzM0XFx1MTc0MC1cXHUxNzUzXFx1MTc2MC1cXHUxNzZDXFx1MTc2RS1cXHUxNzcwXFx1MTc3MlxcdTE3NzNcXHUxNzgwLVxcdTE3RDNcXHUxN0Q3XFx1MTdEQ1xcdTE3RERcXHUxN0UwLVxcdTE3RTlcXHUxODBCLVxcdTE4MERcXHUxODEwLVxcdTE4MTlcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4QUFcXHUxOEIwLVxcdTE4RjVcXHUxOTAwLVxcdTE5MUVcXHUxOTIwLVxcdTE5MkJcXHUxOTMwLVxcdTE5M0JcXHUxOTQ2LVxcdTE5NkRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5QUJcXHUxOUIwLVxcdTE5QzlcXHUxOUQwLVxcdTE5REFcXHUxQTAwLVxcdTFBMUJcXHUxQTIwLVxcdTFBNUVcXHUxQTYwLVxcdTFBN0NcXHUxQTdGLVxcdTFBODlcXHUxQTkwLVxcdTFBOTlcXHUxQUE3XFx1MUFCMC1cXHUxQUJEXFx1MUIwMC1cXHUxQjRCXFx1MUI1MC1cXHUxQjU5XFx1MUI2Qi1cXHUxQjczXFx1MUI4MC1cXHUxQkYzXFx1MUMwMC1cXHUxQzM3XFx1MUM0MC1cXHUxQzQ5XFx1MUM0RC1cXHUxQzdEXFx1MUNEMC1cXHUxQ0QyXFx1MUNENC1cXHUxQ0Y2XFx1MUNGOFxcdTFDRjlcXHUxRDAwLVxcdTFERjVcXHUxREZDLVxcdTFGMTVcXHUxRjE4LVxcdTFGMURcXHUxRjIwLVxcdTFGNDVcXHUxRjQ4LVxcdTFGNERcXHUxRjUwLVxcdTFGNTdcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGLVxcdTFGN0RcXHUxRjgwLVxcdTFGQjRcXHUxRkI2LVxcdTFGQkNcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNi1cXHUxRkNDXFx1MUZEMC1cXHUxRkQzXFx1MUZENi1cXHUxRkRCXFx1MUZFMC1cXHUxRkVDXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZDXFx1MjAwQ1xcdTIwMERcXHUyMDNGXFx1MjA0MFxcdTIwNTRcXHUyMDcxXFx1MjA3RlxcdTIwOTAtXFx1MjA5Q1xcdTIwRDAtXFx1MjBEQ1xcdTIwRTFcXHUyMEU1LVxcdTIwRjBcXHUyMTAyXFx1MjEwN1xcdTIxMEEtXFx1MjExM1xcdTIxMTVcXHUyMTE4LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMzlcXHUyMTNDLVxcdTIxM0ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRFXFx1MjE2MC1cXHUyMTg4XFx1MkMwMC1cXHUyQzJFXFx1MkMzMC1cXHUyQzVFXFx1MkM2MC1cXHUyQ0U0XFx1MkNFQi1cXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHUyRDMwLVxcdTJENjdcXHUyRDZGXFx1MkQ3Ri1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MkRFMC1cXHUyREZGXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDJGXFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5OS1cXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGQy1cXHUzMEZGXFx1MzEwNS1cXHUzMTJEXFx1MzEzMS1cXHUzMThFXFx1MzFBMC1cXHUzMUJBXFx1MzFGMC1cXHUzMUZGXFx1MzQwMC1cXHU0REI1XFx1NEUwMC1cXHU5RkNDXFx1QTAwMC1cXHVBNDhDXFx1QTREMC1cXHVBNEZEXFx1QTUwMC1cXHVBNjBDXFx1QTYxMC1cXHVBNjJCXFx1QTY0MC1cXHVBNjZGXFx1QTY3NC1cXHVBNjdEXFx1QTY3Ri1cXHVBNjlEXFx1QTY5Ri1cXHVBNkYxXFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBNzhFXFx1QTc5MC1cXHVBN0FEXFx1QTdCMFxcdUE3QjFcXHVBN0Y3LVxcdUE4MjdcXHVBODQwLVxcdUE4NzNcXHVBODgwLVxcdUE4QzRcXHVBOEQwLVxcdUE4RDlcXHVBOEUwLVxcdUE4RjdcXHVBOEZCXFx1QTkwMC1cXHVBOTJEXFx1QTkzMC1cXHVBOTUzXFx1QTk2MC1cXHVBOTdDXFx1QTk4MC1cXHVBOUMwXFx1QTlDRi1cXHVBOUQ5XFx1QTlFMC1cXHVBOUZFXFx1QUEwMC1cXHVBQTM2XFx1QUE0MC1cXHVBQTREXFx1QUE1MC1cXHVBQTU5XFx1QUE2MC1cXHVBQTc2XFx1QUE3QS1cXHVBQUMyXFx1QUFEQi1cXHVBQUREXFx1QUFFMC1cXHVBQUVGXFx1QUFGMi1cXHVBQUY2XFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUIzMC1cXHVBQjVBXFx1QUI1Qy1cXHVBQjVGXFx1QUI2NFxcdUFCNjVcXHVBQkMwLVxcdUFCRUFcXHVBQkVDXFx1QUJFRFxcdUFCRjAtXFx1QUJGOVxcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOVxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZCMUQtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkUwMC1cXHVGRTBGXFx1RkUyMC1cXHVGRTJEXFx1RkUzM1xcdUZFMzRcXHVGRTRELVxcdUZFNEZcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkNcXHVGRjEwLVxcdUZGMTlcXHVGRjIxLVxcdUZGM0FcXHVGRjNGXFx1RkY0MS1cXHVGRjVBXFx1RkY2Ni1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDXXxcXHVEODAwW1xcdURDMDAtXFx1REMwQlxcdURDMEQtXFx1REMyNlxcdURDMjgtXFx1REMzQVxcdURDM0NcXHVEQzNEXFx1REMzRi1cXHVEQzREXFx1REM1MC1cXHVEQzVEXFx1REM4MC1cXHVEQ0ZBXFx1REQ0MC1cXHVERDc0XFx1RERGRFxcdURFODAtXFx1REU5Q1xcdURFQTAtXFx1REVEMFxcdURFRTBcXHVERjAwLVxcdURGMUZcXHVERjMwLVxcdURGNEFcXHVERjUwLVxcdURGN0FcXHVERjgwLVxcdURGOURcXHVERkEwLVxcdURGQzNcXHVERkM4LVxcdURGQ0ZcXHVERkQxLVxcdURGRDVdfFxcdUQ4MDFbXFx1REMwMC1cXHVEQzlEXFx1RENBMC1cXHVEQ0E5XFx1REQwMC1cXHVERDI3XFx1REQzMC1cXHVERDYzXFx1REUwMC1cXHVERjM2XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjY3XXxcXHVEODAyW1xcdURDMDAtXFx1REMwNVxcdURDMDhcXHVEQzBBLVxcdURDMzVcXHVEQzM3XFx1REMzOFxcdURDM0NcXHVEQzNGLVxcdURDNTVcXHVEQzYwLVxcdURDNzZcXHVEQzgwLVxcdURDOUVcXHVERDAwLVxcdUREMTVcXHVERDIwLVxcdUREMzlcXHVERDgwLVxcdUREQjdcXHVEREJFXFx1RERCRlxcdURFMDAtXFx1REUwM1xcdURFMDVcXHVERTA2XFx1REUwQy1cXHVERTEzXFx1REUxNS1cXHVERTE3XFx1REUxOS1cXHVERTMzXFx1REUzOC1cXHVERTNBXFx1REUzRlxcdURFNjAtXFx1REU3Q1xcdURFODAtXFx1REU5Q1xcdURFQzAtXFx1REVDN1xcdURFQzktXFx1REVFNlxcdURGMDAtXFx1REYzNVxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY3MlxcdURGODAtXFx1REY5MV18XFx1RDgwM1tcXHVEQzAwLVxcdURDNDhdfFxcdUQ4MDRbXFx1REMwMC1cXHVEQzQ2XFx1REM2Ni1cXHVEQzZGXFx1REM3Ri1cXHVEQ0JBXFx1RENEMC1cXHVEQ0U4XFx1RENGMC1cXHVEQ0Y5XFx1REQwMC1cXHVERDM0XFx1REQzNi1cXHVERDNGXFx1REQ1MC1cXHVERDczXFx1REQ3NlxcdUREODAtXFx1RERDNFxcdURERDAtXFx1REREQVxcdURFMDAtXFx1REUxMVxcdURFMTMtXFx1REUzN1xcdURFQjAtXFx1REVFQVxcdURFRjAtXFx1REVGOVxcdURGMDEtXFx1REYwM1xcdURGMDUtXFx1REYwQ1xcdURGMEZcXHVERjEwXFx1REYxMy1cXHVERjI4XFx1REYyQS1cXHVERjMwXFx1REYzMlxcdURGMzNcXHVERjM1LVxcdURGMzlcXHVERjNDLVxcdURGNDRcXHVERjQ3XFx1REY0OFxcdURGNEItXFx1REY0RFxcdURGNTdcXHVERjVELVxcdURGNjNcXHVERjY2LVxcdURGNkNcXHVERjcwLVxcdURGNzRdfFxcdUQ4MDVbXFx1REM4MC1cXHVEQ0M1XFx1RENDN1xcdURDRDAtXFx1RENEOVxcdUREODAtXFx1RERCNVxcdUREQjgtXFx1RERDMFxcdURFMDAtXFx1REU0MFxcdURFNDRcXHVERTUwLVxcdURFNTlcXHVERTgwLVxcdURFQjdcXHVERUMwLVxcdURFQzldfFxcdUQ4MDZbXFx1RENBMC1cXHVEQ0U5XFx1RENGRlxcdURFQzAtXFx1REVGOF18XFx1RDgwOFtcXHVEQzAwLVxcdURGOThdfFxcdUQ4MDlbXFx1REMwMC1cXHVEQzZFXXxbXFx1RDgwQ1xcdUQ4NDAtXFx1RDg2OFxcdUQ4NkEtXFx1RDg2Q11bXFx1REMwMC1cXHVERkZGXXxcXHVEODBEW1xcdURDMDAtXFx1REMyRV18XFx1RDgxQVtcXHVEQzAwLVxcdURFMzhcXHVERTQwLVxcdURFNUVcXHVERTYwLVxcdURFNjlcXHVERUQwLVxcdURFRURcXHVERUYwLVxcdURFRjRcXHVERjAwLVxcdURGMzZcXHVERjQwLVxcdURGNDNcXHVERjUwLVxcdURGNTlcXHVERjYzLVxcdURGNzdcXHVERjdELVxcdURGOEZdfFxcdUQ4MUJbXFx1REYwMC1cXHVERjQ0XFx1REY1MC1cXHVERjdFXFx1REY4Ri1cXHVERjlGXXxcXHVEODJDW1xcdURDMDBcXHVEQzAxXXxcXHVEODJGW1xcdURDMDAtXFx1REM2QVxcdURDNzAtXFx1REM3Q1xcdURDODAtXFx1REM4OFxcdURDOTAtXFx1REM5OVxcdURDOURcXHVEQzlFXXxcXHVEODM0W1xcdURENjUtXFx1REQ2OVxcdURENkQtXFx1REQ3MlxcdUREN0ItXFx1REQ4MlxcdUREODUtXFx1REQ4QlxcdUREQUEtXFx1RERBRFxcdURFNDItXFx1REU0NF18XFx1RDgzNVtcXHVEQzAwLVxcdURDNTRcXHVEQzU2LVxcdURDOUNcXHVEQzlFXFx1REM5RlxcdURDQTJcXHVEQ0E1XFx1RENBNlxcdURDQTktXFx1RENBQ1xcdURDQUUtXFx1RENCOVxcdURDQkJcXHVEQ0JELVxcdURDQzNcXHVEQ0M1LVxcdUREMDVcXHVERDA3LVxcdUREMEFcXHVERDBELVxcdUREMTRcXHVERDE2LVxcdUREMUNcXHVERDFFLVxcdUREMzlcXHVERDNCLVxcdUREM0VcXHVERDQwLVxcdURENDRcXHVERDQ2XFx1REQ0QS1cXHVERDUwXFx1REQ1Mi1cXHVERUE1XFx1REVBOC1cXHVERUMwXFx1REVDMi1cXHVERURBXFx1REVEQy1cXHVERUZBXFx1REVGQy1cXHVERjE0XFx1REYxNi1cXHVERjM0XFx1REYzNi1cXHVERjRFXFx1REY1MC1cXHVERjZFXFx1REY3MC1cXHVERjg4XFx1REY4QS1cXHVERkE4XFx1REZBQS1cXHVERkMyXFx1REZDNC1cXHVERkNCXFx1REZDRS1cXHVERkZGXXxcXHVEODNBW1xcdURDMDAtXFx1RENDNFxcdURDRDAtXFx1RENENl18XFx1RDgzQltcXHVERTAwLVxcdURFMDNcXHVERTA1LVxcdURFMUZcXHVERTIxXFx1REUyMlxcdURFMjRcXHVERTI3XFx1REUyOS1cXHVERTMyXFx1REUzNC1cXHVERTM3XFx1REUzOVxcdURFM0JcXHVERTQyXFx1REU0N1xcdURFNDlcXHVERTRCXFx1REU0RC1cXHVERTRGXFx1REU1MVxcdURFNTJcXHVERTU0XFx1REU1N1xcdURFNTlcXHVERTVCXFx1REU1RFxcdURFNUZcXHVERTYxXFx1REU2MlxcdURFNjRcXHVERTY3LVxcdURFNkFcXHVERTZDLVxcdURFNzJcXHVERTc0LVxcdURFNzdcXHVERTc5LVxcdURFN0NcXHVERTdFXFx1REU4MC1cXHVERTg5XFx1REU4Qi1cXHVERTlCXFx1REVBMS1cXHVERUEzXFx1REVBNS1cXHVERUE5XFx1REVBQi1cXHVERUJCXXxcXHVEODY5W1xcdURDMDAtXFx1REVENlxcdURGMDAtXFx1REZGRl18XFx1RDg2RFtcXHVEQzAwLVxcdURGMzRcXHVERjQwLVxcdURGRkZdfFxcdUQ4NkVbXFx1REMwMC1cXHVEQzFEXXxcXHVEODdFW1xcdURDMDAtXFx1REUxRF18XFx1REI0MFtcXHVERDAwLVxcdURERUZdL1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBpc0RlY2ltYWxEaWdpdChjaCkge1xuICAgICAgICByZXR1cm4gMHgzMCA8PSBjaCAmJiBjaCA8PSAweDM5OyAgLy8gMC4uOVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSGV4RGlnaXQoY2gpIHtcbiAgICAgICAgcmV0dXJuIDB4MzAgPD0gY2ggJiYgY2ggPD0gMHgzOSB8fCAgLy8gMC4uOVxuICAgICAgICAgICAgMHg2MSA8PSBjaCAmJiBjaCA8PSAweDY2IHx8ICAgICAvLyBhLi5mXG4gICAgICAgICAgICAweDQxIDw9IGNoICYmIGNoIDw9IDB4NDY7ICAgICAgIC8vIEEuLkZcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc09jdGFsRGlnaXQoY2gpIHtcbiAgICAgICAgcmV0dXJuIGNoID49IDB4MzAgJiYgY2ggPD0gMHgzNzsgIC8vIDAuLjdcbiAgICB9XG5cbiAgICAvLyA3LjIgV2hpdGUgU3BhY2VcblxuICAgIE5PTl9BU0NJSV9XSElURVNQQUNFUyA9IFtcbiAgICAgICAgMHgxNjgwLCAweDE4MEUsXG4gICAgICAgIDB4MjAwMCwgMHgyMDAxLCAweDIwMDIsIDB4MjAwMywgMHgyMDA0LCAweDIwMDUsIDB4MjAwNiwgMHgyMDA3LCAweDIwMDgsIDB4MjAwOSwgMHgyMDBBLFxuICAgICAgICAweDIwMkYsIDB4MjA1RixcbiAgICAgICAgMHgzMDAwLFxuICAgICAgICAweEZFRkZcbiAgICBdO1xuXG4gICAgZnVuY3Rpb24gaXNXaGl0ZVNwYWNlKGNoKSB7XG4gICAgICAgIHJldHVybiBjaCA9PT0gMHgyMCB8fCBjaCA9PT0gMHgwOSB8fCBjaCA9PT0gMHgwQiB8fCBjaCA9PT0gMHgwQyB8fCBjaCA9PT0gMHhBMCB8fFxuICAgICAgICAgICAgY2ggPj0gMHgxNjgwICYmIE5PTl9BU0NJSV9XSElURVNQQUNFUy5pbmRleE9mKGNoKSA+PSAwO1xuICAgIH1cblxuICAgIC8vIDcuMyBMaW5lIFRlcm1pbmF0b3JzXG5cbiAgICBmdW5jdGlvbiBpc0xpbmVUZXJtaW5hdG9yKGNoKSB7XG4gICAgICAgIHJldHVybiBjaCA9PT0gMHgwQSB8fCBjaCA9PT0gMHgwRCB8fCBjaCA9PT0gMHgyMDI4IHx8IGNoID09PSAweDIwMjk7XG4gICAgfVxuXG4gICAgLy8gNy42IElkZW50aWZpZXIgTmFtZXMgYW5kIElkZW50aWZpZXJzXG5cbiAgICBmdW5jdGlvbiBmcm9tQ29kZVBvaW50KGNwKSB7XG4gICAgICAgIGlmIChjcCA8PSAweEZGRkYpIHsgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY3ApOyB9XG4gICAgICAgIHZhciBjdTEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKE1hdGguZmxvb3IoKGNwIC0gMHgxMDAwMCkgLyAweDQwMCkgKyAweEQ4MDApO1xuICAgICAgICB2YXIgY3UyID0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGNwIC0gMHgxMDAwMCkgJSAweDQwMCkgKyAweERDMDApO1xuICAgICAgICByZXR1cm4gY3UxICsgY3UyO1xuICAgIH1cblxuICAgIElERU5USUZJRVJfU1RBUlQgPSBuZXcgQXJyYXkoMHg4MCk7XG4gICAgZm9yKGNoID0gMDsgY2ggPCAweDgwOyArK2NoKSB7XG4gICAgICAgIElERU5USUZJRVJfU1RBUlRbY2hdID1cbiAgICAgICAgICAgIGNoID49IDB4NjEgJiYgY2ggPD0gMHg3QSB8fCAgLy8gYS4uelxuICAgICAgICAgICAgY2ggPj0gMHg0MSAmJiBjaCA8PSAweDVBIHx8ICAvLyBBLi5aXG4gICAgICAgICAgICBjaCA9PT0gMHgyNCB8fCBjaCA9PT0gMHg1RjsgIC8vICQgKGRvbGxhcikgYW5kIF8gKHVuZGVyc2NvcmUpXG4gICAgfVxuXG4gICAgSURFTlRJRklFUl9QQVJUID0gbmV3IEFycmF5KDB4ODApO1xuICAgIGZvcihjaCA9IDA7IGNoIDwgMHg4MDsgKytjaCkge1xuICAgICAgICBJREVOVElGSUVSX1BBUlRbY2hdID1cbiAgICAgICAgICAgIGNoID49IDB4NjEgJiYgY2ggPD0gMHg3QSB8fCAgLy8gYS4uelxuICAgICAgICAgICAgY2ggPj0gMHg0MSAmJiBjaCA8PSAweDVBIHx8ICAvLyBBLi5aXG4gICAgICAgICAgICBjaCA+PSAweDMwICYmIGNoIDw9IDB4MzkgfHwgIC8vIDAuLjlcbiAgICAgICAgICAgIGNoID09PSAweDI0IHx8IGNoID09PSAweDVGOyAgLy8gJCAoZG9sbGFyKSBhbmQgXyAodW5kZXJzY29yZSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0lkZW50aWZpZXJTdGFydEVTNShjaCkge1xuICAgICAgICByZXR1cm4gY2ggPCAweDgwID8gSURFTlRJRklFUl9TVEFSVFtjaF0gOiBFUzVSZWdleC5Ob25Bc2NpaUlkZW50aWZpZXJTdGFydC50ZXN0KGZyb21Db2RlUG9pbnQoY2gpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0lkZW50aWZpZXJQYXJ0RVM1KGNoKSB7XG4gICAgICAgIHJldHVybiBjaCA8IDB4ODAgPyBJREVOVElGSUVSX1BBUlRbY2hdIDogRVM1UmVnZXguTm9uQXNjaWlJZGVudGlmaWVyUGFydC50ZXN0KGZyb21Db2RlUG9pbnQoY2gpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0lkZW50aWZpZXJTdGFydEVTNihjaCkge1xuICAgICAgICByZXR1cm4gY2ggPCAweDgwID8gSURFTlRJRklFUl9TVEFSVFtjaF0gOiBFUzZSZWdleC5Ob25Bc2NpaUlkZW50aWZpZXJTdGFydC50ZXN0KGZyb21Db2RlUG9pbnQoY2gpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0lkZW50aWZpZXJQYXJ0RVM2KGNoKSB7XG4gICAgICAgIHJldHVybiBjaCA8IDB4ODAgPyBJREVOVElGSUVSX1BBUlRbY2hdIDogRVM2UmVnZXguTm9uQXNjaWlJZGVudGlmaWVyUGFydC50ZXN0KGZyb21Db2RlUG9pbnQoY2gpKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgaXNEZWNpbWFsRGlnaXQ6IGlzRGVjaW1hbERpZ2l0LFxuICAgICAgICBpc0hleERpZ2l0OiBpc0hleERpZ2l0LFxuICAgICAgICBpc09jdGFsRGlnaXQ6IGlzT2N0YWxEaWdpdCxcbiAgICAgICAgaXNXaGl0ZVNwYWNlOiBpc1doaXRlU3BhY2UsXG4gICAgICAgIGlzTGluZVRlcm1pbmF0b3I6IGlzTGluZVRlcm1pbmF0b3IsXG4gICAgICAgIGlzSWRlbnRpZmllclN0YXJ0RVM1OiBpc0lkZW50aWZpZXJTdGFydEVTNSxcbiAgICAgICAgaXNJZGVudGlmaWVyUGFydEVTNTogaXNJZGVudGlmaWVyUGFydEVTNSxcbiAgICAgICAgaXNJZGVudGlmaWVyU3RhcnRFUzY6IGlzSWRlbnRpZmllclN0YXJ0RVM2LFxuICAgICAgICBpc0lkZW50aWZpZXJQYXJ0RVM2OiBpc0lkZW50aWZpZXJQYXJ0RVM2XG4gICAgfTtcbn0oKSk7XG4vKiB2aW06IHNldCBzdz00IHRzPTQgZXQgdHc9ODAgOiAqL1xuIiwiLypcbiAgQ29weXJpZ2h0IChDKSAyMDEzIFl1c3VrZSBTdXp1a2kgPHV0YXRhbmUudGVhQGdtYWlsLmNvbT5cblxuICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuICBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCA8Q09QWVJJR0hUIEhPTERFUj4gQkUgTElBQkxFIEZPUiBBTllcbiAgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbiAgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuICBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkRcbiAgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GXG4gIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4qL1xuXG4oZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBjb2RlID0gcmVxdWlyZSgnLi9jb2RlJyk7XG5cbiAgICBmdW5jdGlvbiBpc1N0cmljdE1vZGVSZXNlcnZlZFdvcmRFUzYoaWQpIHtcbiAgICAgICAgc3dpdGNoIChpZCkge1xuICAgICAgICBjYXNlICdpbXBsZW1lbnRzJzpcbiAgICAgICAgY2FzZSAnaW50ZXJmYWNlJzpcbiAgICAgICAgY2FzZSAncGFja2FnZSc6XG4gICAgICAgIGNhc2UgJ3ByaXZhdGUnOlxuICAgICAgICBjYXNlICdwcm90ZWN0ZWQnOlxuICAgICAgICBjYXNlICdwdWJsaWMnOlxuICAgICAgICBjYXNlICdzdGF0aWMnOlxuICAgICAgICBjYXNlICdsZXQnOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0tleXdvcmRFUzUoaWQsIHN0cmljdCkge1xuICAgICAgICAvLyB5aWVsZCBzaG91bGQgbm90IGJlIHRyZWF0ZWQgYXMga2V5d29yZCB1bmRlciBub24tc3RyaWN0IG1vZGUuXG4gICAgICAgIGlmICghc3RyaWN0ICYmIGlkID09PSAneWllbGQnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzS2V5d29yZEVTNihpZCwgc3RyaWN0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0tleXdvcmRFUzYoaWQsIHN0cmljdCkge1xuICAgICAgICBpZiAoc3RyaWN0ICYmIGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZEVTNihpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChpZC5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ2lmJykgfHwgKGlkID09PSAnaW4nKSB8fCAoaWQgPT09ICdkbycpO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gKGlkID09PSAndmFyJykgfHwgKGlkID09PSAnZm9yJykgfHwgKGlkID09PSAnbmV3JykgfHwgKGlkID09PSAndHJ5Jyk7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICd0aGlzJykgfHwgKGlkID09PSAnZWxzZScpIHx8IChpZCA9PT0gJ2Nhc2UnKSB8fFxuICAgICAgICAgICAgICAgIChpZCA9PT0gJ3ZvaWQnKSB8fCAoaWQgPT09ICd3aXRoJykgfHwgKGlkID09PSAnZW51bScpO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICByZXR1cm4gKGlkID09PSAnd2hpbGUnKSB8fCAoaWQgPT09ICdicmVhaycpIHx8IChpZCA9PT0gJ2NhdGNoJykgfHxcbiAgICAgICAgICAgICAgICAoaWQgPT09ICd0aHJvdycpIHx8IChpZCA9PT0gJ2NvbnN0JykgfHwgKGlkID09PSAneWllbGQnKSB8fFxuICAgICAgICAgICAgICAgIChpZCA9PT0gJ2NsYXNzJykgfHwgKGlkID09PSAnc3VwZXInKTtcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ3JldHVybicpIHx8IChpZCA9PT0gJ3R5cGVvZicpIHx8IChpZCA9PT0gJ2RlbGV0ZScpIHx8XG4gICAgICAgICAgICAgICAgKGlkID09PSAnc3dpdGNoJykgfHwgKGlkID09PSAnZXhwb3J0JykgfHwgKGlkID09PSAnaW1wb3J0Jyk7XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICdkZWZhdWx0JykgfHwgKGlkID09PSAnZmluYWxseScpIHx8IChpZCA9PT0gJ2V4dGVuZHMnKTtcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ2Z1bmN0aW9uJykgfHwgKGlkID09PSAnY29udGludWUnKSB8fCAoaWQgPT09ICdkZWJ1Z2dlcicpO1xuICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ2luc3RhbmNlb2YnKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzUmVzZXJ2ZWRXb3JkRVM1KGlkLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGlkID09PSAnbnVsbCcgfHwgaWQgPT09ICd0cnVlJyB8fCBpZCA9PT0gJ2ZhbHNlJyB8fCBpc0tleXdvcmRFUzUoaWQsIHN0cmljdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNSZXNlcnZlZFdvcmRFUzYoaWQsIHN0cmljdCkge1xuICAgICAgICByZXR1cm4gaWQgPT09ICdudWxsJyB8fCBpZCA9PT0gJ3RydWUnIHx8IGlkID09PSAnZmFsc2UnIHx8IGlzS2V5d29yZEVTNihpZCwgc3RyaWN0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1Jlc3RyaWN0ZWRXb3JkKGlkKSB7XG4gICAgICAgIHJldHVybiBpZCA9PT0gJ2V2YWwnIHx8IGlkID09PSAnYXJndW1lbnRzJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0lkZW50aWZpZXJOYW1lRVM1KGlkKSB7XG4gICAgICAgIHZhciBpLCBpeiwgY2g7XG5cbiAgICAgICAgaWYgKGlkLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgICAgICBjaCA9IGlkLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIGlmICghY29kZS5pc0lkZW50aWZpZXJTdGFydEVTNShjaCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDEsIGl6ID0gaWQubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgY2ggPSBpZC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgaWYgKCFjb2RlLmlzSWRlbnRpZmllclBhcnRFUzUoY2gpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlY29kZVV0ZjE2KGxlYWQsIHRyYWlsKSB7XG4gICAgICAgIHJldHVybiAobGVhZCAtIDB4RDgwMCkgKiAweDQwMCArICh0cmFpbCAtIDB4REMwMCkgKyAweDEwMDAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSWRlbnRpZmllck5hbWVFUzYoaWQpIHtcbiAgICAgICAgdmFyIGksIGl6LCBjaCwgbG93Q2gsIGNoZWNrO1xuXG4gICAgICAgIGlmIChpZC5sZW5ndGggPT09IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICAgICAgY2hlY2sgPSBjb2RlLmlzSWRlbnRpZmllclN0YXJ0RVM2O1xuICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IGlkLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgIGNoID0gaWQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmICgweEQ4MDAgPD0gY2ggJiYgY2ggPD0gMHhEQkZGKSB7XG4gICAgICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgICAgIGlmIChpID49IGl6KSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgICAgICAgICAgIGxvd0NoID0gaWQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgICAgICBpZiAoISgweERDMDAgPD0gbG93Q2ggJiYgbG93Q2ggPD0gMHhERkZGKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoID0gZGVjb2RlVXRmMTYoY2gsIGxvd0NoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY2hlY2soY2gpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hlY2sgPSBjb2RlLmlzSWRlbnRpZmllclBhcnRFUzY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNJZGVudGlmaWVyRVM1KGlkLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGlzSWRlbnRpZmllck5hbWVFUzUoaWQpICYmICFpc1Jlc2VydmVkV29yZEVTNShpZCwgc3RyaWN0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0lkZW50aWZpZXJFUzYoaWQsIHN0cmljdCkge1xuICAgICAgICByZXR1cm4gaXNJZGVudGlmaWVyTmFtZUVTNihpZCkgJiYgIWlzUmVzZXJ2ZWRXb3JkRVM2KGlkLCBzdHJpY3QpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBpc0tleXdvcmRFUzU6IGlzS2V5d29yZEVTNSxcbiAgICAgICAgaXNLZXl3b3JkRVM2OiBpc0tleXdvcmRFUzYsXG4gICAgICAgIGlzUmVzZXJ2ZWRXb3JkRVM1OiBpc1Jlc2VydmVkV29yZEVTNSxcbiAgICAgICAgaXNSZXNlcnZlZFdvcmRFUzY6IGlzUmVzZXJ2ZWRXb3JkRVM2LFxuICAgICAgICBpc1Jlc3RyaWN0ZWRXb3JkOiBpc1Jlc3RyaWN0ZWRXb3JkLFxuICAgICAgICBpc0lkZW50aWZpZXJOYW1lRVM1OiBpc0lkZW50aWZpZXJOYW1lRVM1LFxuICAgICAgICBpc0lkZW50aWZpZXJOYW1lRVM2OiBpc0lkZW50aWZpZXJOYW1lRVM2LFxuICAgICAgICBpc0lkZW50aWZpZXJFUzU6IGlzSWRlbnRpZmllckVTNSxcbiAgICAgICAgaXNJZGVudGlmaWVyRVM2OiBpc0lkZW50aWZpZXJFUzZcbiAgICB9O1xufSgpKTtcbi8qIHZpbTogc2V0IHN3PTQgdHM9NCBldCB0dz04MCA6ICovXG4iLCIvKlxuICBDb3B5cmlnaHQgKEMpIDIwMTMgWXVzdWtlIFN1enVraSA8dXRhdGFuZS50ZWFAZ21haWwuY29tPlxuXG4gIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIDxDT1BZUklHSFQgSE9MREVSPiBCRSBMSUFCTEUgRk9SIEFOWVxuICBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuICAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4gIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuICBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0ZcbiAgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG5cblxuKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBleHBvcnRzLmFzdCA9IHJlcXVpcmUoJy4vYXN0Jyk7XG4gICAgZXhwb3J0cy5jb2RlID0gcmVxdWlyZSgnLi9jb2RlJyk7XG4gICAgZXhwb3J0cy5rZXl3b3JkID0gcmVxdWlyZSgnLi9rZXl3b3JkJyk7XG59KCkpO1xuLyogdmltOiBzZXQgc3c9NCB0cz00IGV0IHR3PTgwIDogKi9cbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIGhhc05hdGl2ZU1hcCA9IHR5cGVvZiBNYXAgIT09IFwidW5kZWZpbmVkXCI7XG5cbi8qKlxuICogQSBkYXRhIHN0cnVjdHVyZSB3aGljaCBpcyBhIGNvbWJpbmF0aW9uIG9mIGFuIGFycmF5IGFuZCBhIHNldC4gQWRkaW5nIGEgbmV3XG4gKiBtZW1iZXIgaXMgTygxKSwgdGVzdGluZyBmb3IgbWVtYmVyc2hpcCBpcyBPKDEpLCBhbmQgZmluZGluZyB0aGUgaW5kZXggb2YgYW5cbiAqIGVsZW1lbnQgaXMgTygxKS4gUmVtb3ZpbmcgZWxlbWVudHMgZnJvbSB0aGUgc2V0IGlzIG5vdCBzdXBwb3J0ZWQuIE9ubHlcbiAqIHN0cmluZ3MgYXJlIHN1cHBvcnRlZCBmb3IgbWVtYmVyc2hpcC5cbiAqL1xuZnVuY3Rpb24gQXJyYXlTZXQoKSB7XG4gIHRoaXMuX2FycmF5ID0gW107XG4gIHRoaXMuX3NldCA9IGhhc05hdGl2ZU1hcCA/IG5ldyBNYXAoKSA6IE9iamVjdC5jcmVhdGUobnVsbCk7XG59XG5cbi8qKlxuICogU3RhdGljIG1ldGhvZCBmb3IgY3JlYXRpbmcgQXJyYXlTZXQgaW5zdGFuY2VzIGZyb20gYW4gZXhpc3RpbmcgYXJyYXkuXG4gKi9cbkFycmF5U2V0LmZyb21BcnJheSA9IGZ1bmN0aW9uIEFycmF5U2V0X2Zyb21BcnJheShhQXJyYXksIGFBbGxvd0R1cGxpY2F0ZXMpIHtcbiAgdmFyIHNldCA9IG5ldyBBcnJheVNldCgpO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gYUFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgc2V0LmFkZChhQXJyYXlbaV0sIGFBbGxvd0R1cGxpY2F0ZXMpO1xuICB9XG4gIHJldHVybiBzZXQ7XG59O1xuXG4vKipcbiAqIFJldHVybiBob3cgbWFueSB1bmlxdWUgaXRlbXMgYXJlIGluIHRoaXMgQXJyYXlTZXQuIElmIGR1cGxpY2F0ZXMgaGF2ZSBiZWVuXG4gKiBhZGRlZCwgdGhhbiB0aG9zZSBkbyBub3QgY291bnQgdG93YXJkcyB0aGUgc2l6ZS5cbiAqXG4gKiBAcmV0dXJucyBOdW1iZXJcbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiBBcnJheVNldF9zaXplKCkge1xuICByZXR1cm4gaGFzTmF0aXZlTWFwID8gdGhpcy5fc2V0LnNpemUgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzLl9zZXQpLmxlbmd0aDtcbn07XG5cbi8qKlxuICogQWRkIHRoZSBnaXZlbiBzdHJpbmcgdG8gdGhpcyBzZXQuXG4gKlxuICogQHBhcmFtIFN0cmluZyBhU3RyXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBBcnJheVNldF9hZGQoYVN0ciwgYUFsbG93RHVwbGljYXRlcykge1xuICB2YXIgc1N0ciA9IGhhc05hdGl2ZU1hcCA/IGFTdHIgOiB1dGlsLnRvU2V0U3RyaW5nKGFTdHIpO1xuICB2YXIgaXNEdXBsaWNhdGUgPSBoYXNOYXRpdmVNYXAgPyB0aGlzLmhhcyhhU3RyKSA6IGhhcy5jYWxsKHRoaXMuX3NldCwgc1N0cik7XG4gIHZhciBpZHggPSB0aGlzLl9hcnJheS5sZW5ndGg7XG4gIGlmICghaXNEdXBsaWNhdGUgfHwgYUFsbG93RHVwbGljYXRlcykge1xuICAgIHRoaXMuX2FycmF5LnB1c2goYVN0cik7XG4gIH1cbiAgaWYgKCFpc0R1cGxpY2F0ZSkge1xuICAgIGlmIChoYXNOYXRpdmVNYXApIHtcbiAgICAgIHRoaXMuX3NldC5zZXQoYVN0ciwgaWR4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc2V0W3NTdHJdID0gaWR4O1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBJcyB0aGUgZ2l2ZW4gc3RyaW5nIGEgbWVtYmVyIG9mIHRoaXMgc2V0P1xuICpcbiAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICovXG5BcnJheVNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gQXJyYXlTZXRfaGFzKGFTdHIpIHtcbiAgaWYgKGhhc05hdGl2ZU1hcCkge1xuICAgIHJldHVybiB0aGlzLl9zZXQuaGFzKGFTdHIpO1xuICB9IGVsc2Uge1xuICAgIHZhciBzU3RyID0gdXRpbC50b1NldFN0cmluZyhhU3RyKTtcbiAgICByZXR1cm4gaGFzLmNhbGwodGhpcy5fc2V0LCBzU3RyKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXaGF0IGlzIHRoZSBpbmRleCBvZiB0aGUgZ2l2ZW4gc3RyaW5nIGluIHRoZSBhcnJheT9cbiAqXG4gKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBBcnJheVNldF9pbmRleE9mKGFTdHIpIHtcbiAgaWYgKGhhc05hdGl2ZU1hcCkge1xuICAgIHZhciBpZHggPSB0aGlzLl9zZXQuZ2V0KGFTdHIpO1xuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICByZXR1cm4gaWR4O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgc1N0ciA9IHV0aWwudG9TZXRTdHJpbmcoYVN0cik7XG4gICAgaWYgKGhhcy5jYWxsKHRoaXMuX3NldCwgc1N0cikpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZXRbc1N0cl07XG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBhU3RyICsgJ1wiIGlzIG5vdCBpbiB0aGUgc2V0LicpO1xufTtcblxuLyoqXG4gKiBXaGF0IGlzIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleD9cbiAqXG4gKiBAcGFyYW0gTnVtYmVyIGFJZHhcbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gQXJyYXlTZXRfYXQoYUlkeCkge1xuICBpZiAoYUlkeCA+PSAwICYmIGFJZHggPCB0aGlzLl9hcnJheS5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5fYXJyYXlbYUlkeF07XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdObyBlbGVtZW50IGluZGV4ZWQgYnkgJyArIGFJZHgpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBhcnJheSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHNldCAod2hpY2ggaGFzIHRoZSBwcm9wZXIgaW5kaWNlc1xuICogaW5kaWNhdGVkIGJ5IGluZGV4T2YpLiBOb3RlIHRoYXQgdGhpcyBpcyBhIGNvcHkgb2YgdGhlIGludGVybmFsIGFycmF5IHVzZWRcbiAqIGZvciBzdG9yaW5nIHRoZSBtZW1iZXJzIHNvIHRoYXQgbm8gb25lIGNhbiBtZXNzIHdpdGggaW50ZXJuYWwgc3RhdGUuXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gQXJyYXlTZXRfdG9BcnJheSgpIHtcbiAgcmV0dXJuIHRoaXMuX2FycmF5LnNsaWNlKCk7XG59O1xuXG5leHBvcnRzLkFycmF5U2V0ID0gQXJyYXlTZXQ7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICpcbiAqIEJhc2VkIG9uIHRoZSBCYXNlIDY0IFZMUSBpbXBsZW1lbnRhdGlvbiBpbiBDbG9zdXJlIENvbXBpbGVyOlxuICogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jbG9zdXJlLWNvbXBpbGVyL3NvdXJjZS9icm93c2UvdHJ1bmsvc3JjL2NvbS9nb29nbGUvZGVidWdnaW5nL3NvdXJjZW1hcC9CYXNlNjRWTFEuamF2YVxuICpcbiAqIENvcHlyaWdodCAyMDExIFRoZSBDbG9zdXJlIENvbXBpbGVyIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbiAqIG1ldDpcbiAqXG4gKiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICogICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAqICAgIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZFxuICogICAgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICogICogTmVpdGhlciB0aGUgbmFtZSBvZiBHb29nbGUgSW5jLiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogICAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkXG4gKiAgICBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuICogT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4gKiBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcbiAqIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICogVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICogKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4gKiBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCcuL2Jhc2U2NCcpO1xuXG4vLyBBIHNpbmdsZSBiYXNlIDY0IGRpZ2l0IGNhbiBjb250YWluIDYgYml0cyBvZiBkYXRhLiBGb3IgdGhlIGJhc2UgNjQgdmFyaWFibGVcbi8vIGxlbmd0aCBxdWFudGl0aWVzIHdlIHVzZSBpbiB0aGUgc291cmNlIG1hcCBzcGVjLCB0aGUgZmlyc3QgYml0IGlzIHRoZSBzaWduLFxuLy8gdGhlIG5leHQgZm91ciBiaXRzIGFyZSB0aGUgYWN0dWFsIHZhbHVlLCBhbmQgdGhlIDZ0aCBiaXQgaXMgdGhlXG4vLyBjb250aW51YXRpb24gYml0LiBUaGUgY29udGludWF0aW9uIGJpdCB0ZWxscyB1cyB3aGV0aGVyIHRoZXJlIGFyZSBtb3JlXG4vLyBkaWdpdHMgaW4gdGhpcyB2YWx1ZSBmb2xsb3dpbmcgdGhpcyBkaWdpdC5cbi8vXG4vLyAgIENvbnRpbnVhdGlvblxuLy8gICB8ICAgIFNpZ25cbi8vICAgfCAgICB8XG4vLyAgIFYgICAgVlxuLy8gICAxMDEwMTFcblxudmFyIFZMUV9CQVNFX1NISUZUID0gNTtcblxuLy8gYmluYXJ5OiAxMDAwMDBcbnZhciBWTFFfQkFTRSA9IDEgPDwgVkxRX0JBU0VfU0hJRlQ7XG5cbi8vIGJpbmFyeTogMDExMTExXG52YXIgVkxRX0JBU0VfTUFTSyA9IFZMUV9CQVNFIC0gMTtcblxuLy8gYmluYXJ5OiAxMDAwMDBcbnZhciBWTFFfQ09OVElOVUFUSU9OX0JJVCA9IFZMUV9CQVNFO1xuXG4vKipcbiAqIENvbnZlcnRzIGZyb20gYSB0d28tY29tcGxlbWVudCB2YWx1ZSB0byBhIHZhbHVlIHdoZXJlIHRoZSBzaWduIGJpdCBpc1xuICogcGxhY2VkIGluIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQuICBGb3IgZXhhbXBsZSwgYXMgZGVjaW1hbHM6XG4gKiAgIDEgYmVjb21lcyAyICgxMCBiaW5hcnkpLCAtMSBiZWNvbWVzIDMgKDExIGJpbmFyeSlcbiAqICAgMiBiZWNvbWVzIDQgKDEwMCBiaW5hcnkpLCAtMiBiZWNvbWVzIDUgKDEwMSBiaW5hcnkpXG4gKi9cbmZ1bmN0aW9uIHRvVkxRU2lnbmVkKGFWYWx1ZSkge1xuICByZXR1cm4gYVZhbHVlIDwgMFxuICAgID8gKCgtYVZhbHVlKSA8PCAxKSArIDFcbiAgICA6IChhVmFsdWUgPDwgMSkgKyAwO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHRvIGEgdHdvLWNvbXBsZW1lbnQgdmFsdWUgZnJvbSBhIHZhbHVlIHdoZXJlIHRoZSBzaWduIGJpdCBpc1xuICogcGxhY2VkIGluIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQuICBGb3IgZXhhbXBsZSwgYXMgZGVjaW1hbHM6XG4gKiAgIDIgKDEwIGJpbmFyeSkgYmVjb21lcyAxLCAzICgxMSBiaW5hcnkpIGJlY29tZXMgLTFcbiAqICAgNCAoMTAwIGJpbmFyeSkgYmVjb21lcyAyLCA1ICgxMDEgYmluYXJ5KSBiZWNvbWVzIC0yXG4gKi9cbmZ1bmN0aW9uIGZyb21WTFFTaWduZWQoYVZhbHVlKSB7XG4gIHZhciBpc05lZ2F0aXZlID0gKGFWYWx1ZSAmIDEpID09PSAxO1xuICB2YXIgc2hpZnRlZCA9IGFWYWx1ZSA+PiAxO1xuICByZXR1cm4gaXNOZWdhdGl2ZVxuICAgID8gLXNoaWZ0ZWRcbiAgICA6IHNoaWZ0ZWQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYmFzZSA2NCBWTFEgZW5jb2RlZCB2YWx1ZS5cbiAqL1xuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiBiYXNlNjRWTFFfZW5jb2RlKGFWYWx1ZSkge1xuICB2YXIgZW5jb2RlZCA9IFwiXCI7XG4gIHZhciBkaWdpdDtcblxuICB2YXIgdmxxID0gdG9WTFFTaWduZWQoYVZhbHVlKTtcblxuICBkbyB7XG4gICAgZGlnaXQgPSB2bHEgJiBWTFFfQkFTRV9NQVNLO1xuICAgIHZscSA+Pj49IFZMUV9CQVNFX1NISUZUO1xuICAgIGlmICh2bHEgPiAwKSB7XG4gICAgICAvLyBUaGVyZSBhcmUgc3RpbGwgbW9yZSBkaWdpdHMgaW4gdGhpcyB2YWx1ZSwgc28gd2UgbXVzdCBtYWtlIHN1cmUgdGhlXG4gICAgICAvLyBjb250aW51YXRpb24gYml0IGlzIG1hcmtlZC5cbiAgICAgIGRpZ2l0IHw9IFZMUV9DT05USU5VQVRJT05fQklUO1xuICAgIH1cbiAgICBlbmNvZGVkICs9IGJhc2U2NC5lbmNvZGUoZGlnaXQpO1xuICB9IHdoaWxlICh2bHEgPiAwKTtcblxuICByZXR1cm4gZW5jb2RlZDtcbn07XG5cbi8qKlxuICogRGVjb2RlcyB0aGUgbmV4dCBiYXNlIDY0IFZMUSB2YWx1ZSBmcm9tIHRoZSBnaXZlbiBzdHJpbmcgYW5kIHJldHVybnMgdGhlXG4gKiB2YWx1ZSBhbmQgdGhlIHJlc3Qgb2YgdGhlIHN0cmluZyB2aWEgdGhlIG91dCBwYXJhbWV0ZXIuXG4gKi9cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gYmFzZTY0VkxRX2RlY29kZShhU3RyLCBhSW5kZXgsIGFPdXRQYXJhbSkge1xuICB2YXIgc3RyTGVuID0gYVN0ci5sZW5ndGg7XG4gIHZhciByZXN1bHQgPSAwO1xuICB2YXIgc2hpZnQgPSAwO1xuICB2YXIgY29udGludWF0aW9uLCBkaWdpdDtcblxuICBkbyB7XG4gICAgaWYgKGFJbmRleCA+PSBzdHJMZW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIG1vcmUgZGlnaXRzIGluIGJhc2UgNjQgVkxRIHZhbHVlLlwiKTtcbiAgICB9XG5cbiAgICBkaWdpdCA9IGJhc2U2NC5kZWNvZGUoYVN0ci5jaGFyQ29kZUF0KGFJbmRleCsrKSk7XG4gICAgaWYgKGRpZ2l0ID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBiYXNlNjQgZGlnaXQ6IFwiICsgYVN0ci5jaGFyQXQoYUluZGV4IC0gMSkpO1xuICAgIH1cblxuICAgIGNvbnRpbnVhdGlvbiA9ICEhKGRpZ2l0ICYgVkxRX0NPTlRJTlVBVElPTl9CSVQpO1xuICAgIGRpZ2l0ICY9IFZMUV9CQVNFX01BU0s7XG4gICAgcmVzdWx0ID0gcmVzdWx0ICsgKGRpZ2l0IDw8IHNoaWZ0KTtcbiAgICBzaGlmdCArPSBWTFFfQkFTRV9TSElGVDtcbiAgfSB3aGlsZSAoY29udGludWF0aW9uKTtcblxuICBhT3V0UGFyYW0udmFsdWUgPSBmcm9tVkxRU2lnbmVkKHJlc3VsdCk7XG4gIGFPdXRQYXJhbS5yZXN0ID0gYUluZGV4O1xufTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIGludFRvQ2hhck1hcCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJy5zcGxpdCgnJyk7XG5cbi8qKlxuICogRW5jb2RlIGFuIGludGVnZXIgaW4gdGhlIHJhbmdlIG9mIDAgdG8gNjMgdG8gYSBzaW5nbGUgYmFzZSA2NCBkaWdpdC5cbiAqL1xuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiAobnVtYmVyKSB7XG4gIGlmICgwIDw9IG51bWJlciAmJiBudW1iZXIgPCBpbnRUb0NoYXJNYXAubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGludFRvQ2hhck1hcFtudW1iZXJdO1xuICB9XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJNdXN0IGJlIGJldHdlZW4gMCBhbmQgNjM6IFwiICsgbnVtYmVyKTtcbn07XG5cbi8qKlxuICogRGVjb2RlIGEgc2luZ2xlIGJhc2UgNjQgY2hhcmFjdGVyIGNvZGUgZGlnaXQgdG8gYW4gaW50ZWdlci4gUmV0dXJucyAtMSBvblxuICogZmFpbHVyZS5cbiAqL1xuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbiAoY2hhckNvZGUpIHtcbiAgdmFyIGJpZ0EgPSA2NTsgICAgIC8vICdBJ1xuICB2YXIgYmlnWiA9IDkwOyAgICAgLy8gJ1onXG5cbiAgdmFyIGxpdHRsZUEgPSA5NzsgIC8vICdhJ1xuICB2YXIgbGl0dGxlWiA9IDEyMjsgLy8gJ3onXG5cbiAgdmFyIHplcm8gPSA0ODsgICAgIC8vICcwJ1xuICB2YXIgbmluZSA9IDU3OyAgICAgLy8gJzknXG5cbiAgdmFyIHBsdXMgPSA0MzsgICAgIC8vICcrJ1xuICB2YXIgc2xhc2ggPSA0NzsgICAgLy8gJy8nXG5cbiAgdmFyIGxpdHRsZU9mZnNldCA9IDI2O1xuICB2YXIgbnVtYmVyT2Zmc2V0ID0gNTI7XG5cbiAgLy8gMCAtIDI1OiBBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlxuICBpZiAoYmlnQSA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSBiaWdaKSB7XG4gICAgcmV0dXJuIChjaGFyQ29kZSAtIGJpZ0EpO1xuICB9XG5cbiAgLy8gMjYgLSA1MTogYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcbiAgaWYgKGxpdHRsZUEgPD0gY2hhckNvZGUgJiYgY2hhckNvZGUgPD0gbGl0dGxlWikge1xuICAgIHJldHVybiAoY2hhckNvZGUgLSBsaXR0bGVBICsgbGl0dGxlT2Zmc2V0KTtcbiAgfVxuXG4gIC8vIDUyIC0gNjE6IDAxMjM0NTY3ODlcbiAgaWYgKHplcm8gPD0gY2hhckNvZGUgJiYgY2hhckNvZGUgPD0gbmluZSkge1xuICAgIHJldHVybiAoY2hhckNvZGUgLSB6ZXJvICsgbnVtYmVyT2Zmc2V0KTtcbiAgfVxuXG4gIC8vIDYyOiArXG4gIGlmIChjaGFyQ29kZSA9PSBwbHVzKSB7XG4gICAgcmV0dXJuIDYyO1xuICB9XG5cbiAgLy8gNjM6IC9cbiAgaWYgKGNoYXJDb2RlID09IHNsYXNoKSB7XG4gICAgcmV0dXJuIDYzO1xuICB9XG5cbiAgLy8gSW52YWxpZCBiYXNlNjQgZGlnaXQuXG4gIHJldHVybiAtMTtcbn07XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbmV4cG9ydHMuR1JFQVRFU1RfTE9XRVJfQk9VTkQgPSAxO1xuZXhwb3J0cy5MRUFTVF9VUFBFUl9CT1VORCA9IDI7XG5cbi8qKlxuICogUmVjdXJzaXZlIGltcGxlbWVudGF0aW9uIG9mIGJpbmFyeSBzZWFyY2guXG4gKlxuICogQHBhcmFtIGFMb3cgSW5kaWNlcyBoZXJlIGFuZCBsb3dlciBkbyBub3QgY29udGFpbiB0aGUgbmVlZGxlLlxuICogQHBhcmFtIGFIaWdoIEluZGljZXMgaGVyZSBhbmQgaGlnaGVyIGRvIG5vdCBjb250YWluIHRoZSBuZWVkbGUuXG4gKiBAcGFyYW0gYU5lZWRsZSBUaGUgZWxlbWVudCBiZWluZyBzZWFyY2hlZCBmb3IuXG4gKiBAcGFyYW0gYUhheXN0YWNrIFRoZSBub24tZW1wdHkgYXJyYXkgYmVpbmcgc2VhcmNoZWQuXG4gKiBAcGFyYW0gYUNvbXBhcmUgRnVuY3Rpb24gd2hpY2ggdGFrZXMgdHdvIGVsZW1lbnRzIGFuZCByZXR1cm5zIC0xLCAwLCBvciAxLlxuICogQHBhcmFtIGFCaWFzIEVpdGhlciAnYmluYXJ5U2VhcmNoLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICogICAgICdiaW5hcnlTZWFyY2guTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICovXG5mdW5jdGlvbiByZWN1cnNpdmVTZWFyY2goYUxvdywgYUhpZ2gsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKSB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gdGVybWluYXRlcyB3aGVuIG9uZSBvZiB0aGUgZm9sbG93aW5nIGlzIHRydWU6XG4gIC8vXG4gIC8vICAgMS4gV2UgZmluZCB0aGUgZXhhY3QgZWxlbWVudCB3ZSBhcmUgbG9va2luZyBmb3IuXG4gIC8vXG4gIC8vICAgMi4gV2UgZGlkIG5vdCBmaW5kIHRoZSBleGFjdCBlbGVtZW50LCBidXQgd2UgY2FuIHJldHVybiB0aGUgaW5kZXggb2ZcbiAgLy8gICAgICB0aGUgbmV4dC1jbG9zZXN0IGVsZW1lbnQuXG4gIC8vXG4gIC8vICAgMy4gV2UgZGlkIG5vdCBmaW5kIHRoZSBleGFjdCBlbGVtZW50LCBhbmQgdGhlcmUgaXMgbm8gbmV4dC1jbG9zZXN0XG4gIC8vICAgICAgZWxlbWVudCB0aGFuIHRoZSBvbmUgd2UgYXJlIHNlYXJjaGluZyBmb3IsIHNvIHdlIHJldHVybiAtMS5cbiAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGFIaWdoIC0gYUxvdykgLyAyKSArIGFMb3c7XG4gIHZhciBjbXAgPSBhQ29tcGFyZShhTmVlZGxlLCBhSGF5c3RhY2tbbWlkXSwgdHJ1ZSk7XG4gIGlmIChjbXAgPT09IDApIHtcbiAgICAvLyBGb3VuZCB0aGUgZWxlbWVudCB3ZSBhcmUgbG9va2luZyBmb3IuXG4gICAgcmV0dXJuIG1pZDtcbiAgfVxuICBlbHNlIGlmIChjbXAgPiAwKSB7XG4gICAgLy8gT3VyIG5lZWRsZSBpcyBncmVhdGVyIHRoYW4gYUhheXN0YWNrW21pZF0uXG4gICAgaWYgKGFIaWdoIC0gbWlkID4gMSkge1xuICAgICAgLy8gVGhlIGVsZW1lbnQgaXMgaW4gdGhlIHVwcGVyIGhhbGYuXG4gICAgICByZXR1cm4gcmVjdXJzaXZlU2VhcmNoKG1pZCwgYUhpZ2gsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgZXhhY3QgbmVlZGxlIGVsZW1lbnQgd2FzIG5vdCBmb3VuZCBpbiB0aGlzIGhheXN0YWNrLiBEZXRlcm1pbmUgaWZcbiAgICAvLyB3ZSBhcmUgaW4gdGVybWluYXRpb24gY2FzZSAoMykgb3IgKDIpIGFuZCByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIHRoaW5nLlxuICAgIGlmIChhQmlhcyA9PSBleHBvcnRzLkxFQVNUX1VQUEVSX0JPVU5EKSB7XG4gICAgICByZXR1cm4gYUhpZ2ggPCBhSGF5c3RhY2subGVuZ3RoID8gYUhpZ2ggOiAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1pZDtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gT3VyIG5lZWRsZSBpcyBsZXNzIHRoYW4gYUhheXN0YWNrW21pZF0uXG4gICAgaWYgKG1pZCAtIGFMb3cgPiAxKSB7XG4gICAgICAvLyBUaGUgZWxlbWVudCBpcyBpbiB0aGUgbG93ZXIgaGFsZi5cbiAgICAgIHJldHVybiByZWN1cnNpdmVTZWFyY2goYUxvdywgbWlkLCBhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlLCBhQmlhcyk7XG4gICAgfVxuXG4gICAgLy8gd2UgYXJlIGluIHRlcm1pbmF0aW9uIGNhc2UgKDMpIG9yICgyKSBhbmQgcmV0dXJuIHRoZSBhcHByb3ByaWF0ZSB0aGluZy5cbiAgICBpZiAoYUJpYXMgPT0gZXhwb3J0cy5MRUFTVF9VUFBFUl9CT1VORCkge1xuICAgICAgcmV0dXJuIG1pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFMb3cgPCAwID8gLTEgOiBhTG93O1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgYmluYXJ5IHNlYXJjaCB3aGljaCB3aWxsIGFsd2F5cyB0cnkgYW5kIHJldHVyblxuICogdGhlIGluZGV4IG9mIHRoZSBjbG9zZXN0IGVsZW1lbnQgaWYgdGhlcmUgaXMgbm8gZXhhY3QgaGl0LiBUaGlzIGlzIGJlY2F1c2VcbiAqIG1hcHBpbmdzIGJldHdlZW4gb3JpZ2luYWwgYW5kIGdlbmVyYXRlZCBsaW5lL2NvbCBwYWlycyBhcmUgc2luZ2xlIHBvaW50cyxcbiAqIGFuZCB0aGVyZSBpcyBhbiBpbXBsaWNpdCByZWdpb24gYmV0d2VlbiBlYWNoIG9mIHRoZW0sIHNvIGEgbWlzcyBqdXN0IG1lYW5zXG4gKiB0aGF0IHlvdSBhcmVuJ3Qgb24gdGhlIHZlcnkgc3RhcnQgb2YgYSByZWdpb24uXG4gKlxuICogQHBhcmFtIGFOZWVkbGUgVGhlIGVsZW1lbnQgeW91IGFyZSBsb29raW5nIGZvci5cbiAqIEBwYXJhbSBhSGF5c3RhY2sgVGhlIGFycmF5IHRoYXQgaXMgYmVpbmcgc2VhcmNoZWQuXG4gKiBAcGFyYW0gYUNvbXBhcmUgQSBmdW5jdGlvbiB3aGljaCB0YWtlcyB0aGUgbmVlZGxlIGFuZCBhbiBlbGVtZW50IGluIHRoZVxuICogICAgIGFycmF5IGFuZCByZXR1cm5zIC0xLCAwLCBvciAxIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBuZWVkbGUgaXMgbGVzc1xuICogICAgIHRoYW4sIGVxdWFsIHRvLCBvciBncmVhdGVyIHRoYW4gdGhlIGVsZW1lbnQsIHJlc3BlY3RpdmVseS5cbiAqIEBwYXJhbSBhQmlhcyBFaXRoZXIgJ2JpbmFyeVNlYXJjaC5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAqICAgICAnYmluYXJ5U2VhcmNoLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAqICAgICBEZWZhdWx0cyB0byAnYmluYXJ5U2VhcmNoLkdSRUFURVNUX0xPV0VSX0JPVU5EJy5cbiAqL1xuZXhwb3J0cy5zZWFyY2ggPSBmdW5jdGlvbiBzZWFyY2goYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpIHtcbiAgaWYgKGFIYXlzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICB2YXIgaW5kZXggPSByZWN1cnNpdmVTZWFyY2goLTEsIGFIYXlzdGFjay5sZW5ndGgsIGFOZWVkbGUsIGFIYXlzdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFDb21wYXJlLCBhQmlhcyB8fCBleHBvcnRzLkdSRUFURVNUX0xPV0VSX0JPVU5EKTtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8vIFdlIGhhdmUgZm91bmQgZWl0aGVyIHRoZSBleGFjdCBlbGVtZW50LCBvciB0aGUgbmV4dC1jbG9zZXN0IGVsZW1lbnQgdGhhblxuICAvLyB0aGUgb25lIHdlIGFyZSBzZWFyY2hpbmcgZm9yLiBIb3dldmVyLCB0aGVyZSBtYXkgYmUgbW9yZSB0aGFuIG9uZSBzdWNoXG4gIC8vIGVsZW1lbnQuIE1ha2Ugc3VyZSB3ZSBhbHdheXMgcmV0dXJuIHRoZSBzbWFsbGVzdCBvZiB0aGVzZS5cbiAgd2hpbGUgKGluZGV4IC0gMSA+PSAwKSB7XG4gICAgaWYgKGFDb21wYXJlKGFIYXlzdGFja1tpbmRleF0sIGFIYXlzdGFja1tpbmRleCAtIDFdLCB0cnVlKSAhPT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC0taW5kZXg7XG4gIH1cblxuICByZXR1cm4gaW5kZXg7XG59O1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDE0IE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4vKipcbiAqIERldGVybWluZSB3aGV0aGVyIG1hcHBpbmdCIGlzIGFmdGVyIG1hcHBpbmdBIHdpdGggcmVzcGVjdCB0byBnZW5lcmF0ZWRcbiAqIHBvc2l0aW9uLlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZWRQb3NpdGlvbkFmdGVyKG1hcHBpbmdBLCBtYXBwaW5nQikge1xuICAvLyBPcHRpbWl6ZWQgZm9yIG1vc3QgY29tbW9uIGNhc2VcbiAgdmFyIGxpbmVBID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZTtcbiAgdmFyIGxpbmVCID0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgdmFyIGNvbHVtbkEgPSBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW47XG4gIHZhciBjb2x1bW5CID0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICByZXR1cm4gbGluZUIgPiBsaW5lQSB8fCBsaW5lQiA9PSBsaW5lQSAmJiBjb2x1bW5CID49IGNvbHVtbkEgfHxcbiAgICAgICAgIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQobWFwcGluZ0EsIG1hcHBpbmdCKSA8PSAwO1xufVxuXG4vKipcbiAqIEEgZGF0YSBzdHJ1Y3R1cmUgdG8gcHJvdmlkZSBhIHNvcnRlZCB2aWV3IG9mIGFjY3VtdWxhdGVkIG1hcHBpbmdzIGluIGFcbiAqIHBlcmZvcm1hbmNlIGNvbnNjaW91cyBtYW5uZXIuIEl0IHRyYWRlcyBhIG5lZ2xpYmFibGUgb3ZlcmhlYWQgaW4gZ2VuZXJhbFxuICogY2FzZSBmb3IgYSBsYXJnZSBzcGVlZHVwIGluIGNhc2Ugb2YgbWFwcGluZ3MgYmVpbmcgYWRkZWQgaW4gb3JkZXIuXG4gKi9cbmZ1bmN0aW9uIE1hcHBpbmdMaXN0KCkge1xuICB0aGlzLl9hcnJheSA9IFtdO1xuICB0aGlzLl9zb3J0ZWQgPSB0cnVlO1xuICAvLyBTZXJ2ZXMgYXMgaW5maW11bVxuICB0aGlzLl9sYXN0ID0ge2dlbmVyYXRlZExpbmU6IC0xLCBnZW5lcmF0ZWRDb2x1bW46IDB9O1xufVxuXG4vKipcbiAqIEl0ZXJhdGUgdGhyb3VnaCBpbnRlcm5hbCBpdGVtcy4gVGhpcyBtZXRob2QgdGFrZXMgdGhlIHNhbWUgYXJndW1lbnRzIHRoYXRcbiAqIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAgdGFrZXMuXG4gKlxuICogTk9URTogVGhlIG9yZGVyIG9mIHRoZSBtYXBwaW5ncyBpcyBOT1QgZ3VhcmFudGVlZC5cbiAqL1xuTWFwcGluZ0xpc3QucHJvdG90eXBlLnVuc29ydGVkRm9yRWFjaCA9XG4gIGZ1bmN0aW9uIE1hcHBpbmdMaXN0X2ZvckVhY2goYUNhbGxiYWNrLCBhVGhpc0FyZykge1xuICAgIHRoaXMuX2FycmF5LmZvckVhY2goYUNhbGxiYWNrLCBhVGhpc0FyZyk7XG4gIH07XG5cbi8qKlxuICogQWRkIHRoZSBnaXZlbiBzb3VyY2UgbWFwcGluZy5cbiAqXG4gKiBAcGFyYW0gT2JqZWN0IGFNYXBwaW5nXG4gKi9cbk1hcHBpbmdMaXN0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBNYXBwaW5nTGlzdF9hZGQoYU1hcHBpbmcpIHtcbiAgaWYgKGdlbmVyYXRlZFBvc2l0aW9uQWZ0ZXIodGhpcy5fbGFzdCwgYU1hcHBpbmcpKSB7XG4gICAgdGhpcy5fbGFzdCA9IGFNYXBwaW5nO1xuICAgIHRoaXMuX2FycmF5LnB1c2goYU1hcHBpbmcpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX3NvcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2FycmF5LnB1c2goYU1hcHBpbmcpO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGZsYXQsIHNvcnRlZCBhcnJheSBvZiBtYXBwaW5ncy4gVGhlIG1hcHBpbmdzIGFyZSBzb3J0ZWQgYnlcbiAqIGdlbmVyYXRlZCBwb3NpdGlvbi5cbiAqXG4gKiBXQVJOSU5HOiBUaGlzIG1ldGhvZCByZXR1cm5zIGludGVybmFsIGRhdGEgd2l0aG91dCBjb3B5aW5nLCBmb3JcbiAqIHBlcmZvcm1hbmNlLiBUaGUgcmV0dXJuIHZhbHVlIG11c3QgTk9UIGJlIG11dGF0ZWQsIGFuZCBzaG91bGQgYmUgdHJlYXRlZCBhc1xuICogYW4gaW1tdXRhYmxlIGJvcnJvdy4gSWYgeW91IHdhbnQgdG8gdGFrZSBvd25lcnNoaXAsIHlvdSBtdXN0IG1ha2UgeW91ciBvd25cbiAqIGNvcHkuXG4gKi9cbk1hcHBpbmdMaXN0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gTWFwcGluZ0xpc3RfdG9BcnJheSgpIHtcbiAgaWYgKCF0aGlzLl9zb3J0ZWQpIHtcbiAgICB0aGlzLl9hcnJheS5zb3J0KHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQpO1xuICAgIHRoaXMuX3NvcnRlZCA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2FycmF5O1xufTtcblxuZXhwb3J0cy5NYXBwaW5nTGlzdCA9IE1hcHBpbmdMaXN0O1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG4vLyBJdCB0dXJucyBvdXQgdGhhdCBzb21lIChtb3N0PykgSmF2YVNjcmlwdCBlbmdpbmVzIGRvbid0IHNlbGYtaG9zdFxuLy8gYEFycmF5LnByb3RvdHlwZS5zb3J0YC4gVGhpcyBtYWtlcyBzZW5zZSBiZWNhdXNlIEMrKyB3aWxsIGxpa2VseSByZW1haW5cbi8vIGZhc3RlciB0aGFuIEpTIHdoZW4gZG9pbmcgcmF3IENQVS1pbnRlbnNpdmUgc29ydGluZy4gSG93ZXZlciwgd2hlbiB1c2luZyBhXG4vLyBjdXN0b20gY29tcGFyYXRvciBmdW5jdGlvbiwgY2FsbGluZyBiYWNrIGFuZCBmb3J0aCBiZXR3ZWVuIHRoZSBWTSdzIEMrKyBhbmRcbi8vIEpJVCdkIEpTIGlzIHJhdGhlciBzbG93ICphbmQqIGxvc2VzIEpJVCB0eXBlIGluZm9ybWF0aW9uLCByZXN1bHRpbmcgaW5cbi8vIHdvcnNlIGdlbmVyYXRlZCBjb2RlIGZvciB0aGUgY29tcGFyYXRvciBmdW5jdGlvbiB0aGFuIHdvdWxkIGJlIG9wdGltYWwuIEluXG4vLyBmYWN0LCB3aGVuIHNvcnRpbmcgd2l0aCBhIGNvbXBhcmF0b3IsIHRoZXNlIGNvc3RzIG91dHdlaWdoIHRoZSBiZW5lZml0cyBvZlxuLy8gc29ydGluZyBpbiBDKysuIEJ5IHVzaW5nIG91ciBvd24gSlMtaW1wbGVtZW50ZWQgUXVpY2sgU29ydCAoYmVsb3cpLCB3ZSBnZXRcbi8vIGEgfjM1MDBtcyBtZWFuIHNwZWVkLXVwIGluIGBiZW5jaC9iZW5jaC5odG1sYC5cblxuLyoqXG4gKiBTd2FwIHRoZSBlbGVtZW50cyBpbmRleGVkIGJ5IGB4YCBhbmQgYHlgIGluIHRoZSBhcnJheSBgYXJ5YC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnlcbiAqICAgICAgICBUaGUgYXJyYXkuXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogICAgICAgIFRoZSBpbmRleCBvZiB0aGUgZmlyc3QgaXRlbS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiAgICAgICAgVGhlIGluZGV4IG9mIHRoZSBzZWNvbmQgaXRlbS5cbiAqL1xuZnVuY3Rpb24gc3dhcChhcnksIHgsIHkpIHtcbiAgdmFyIHRlbXAgPSBhcnlbeF07XG4gIGFyeVt4XSA9IGFyeVt5XTtcbiAgYXJ5W3ldID0gdGVtcDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcmFuZG9tIGludGVnZXIgd2l0aGluIHRoZSByYW5nZSBgbG93IC4uIGhpZ2hgIGluY2x1c2l2ZS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbG93XG4gKiAgICAgICAgVGhlIGxvd2VyIGJvdW5kIG9uIHRoZSByYW5nZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBoaWdoXG4gKiAgICAgICAgVGhlIHVwcGVyIGJvdW5kIG9uIHRoZSByYW5nZS5cbiAqL1xuZnVuY3Rpb24gcmFuZG9tSW50SW5SYW5nZShsb3csIGhpZ2gpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQobG93ICsgKE1hdGgucmFuZG9tKCkgKiAoaGlnaCAtIGxvdykpKTtcbn1cblxuLyoqXG4gKiBUaGUgUXVpY2sgU29ydCBhbGdvcml0aG0uXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJ5XG4gKiAgICAgICAgQW4gYXJyYXkgdG8gc29ydC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbXBhcmF0b3JcbiAqICAgICAgICBGdW5jdGlvbiB0byB1c2UgdG8gY29tcGFyZSB0d28gaXRlbXMuXG4gKiBAcGFyYW0ge051bWJlcn0gcFxuICogICAgICAgIFN0YXJ0IGluZGV4IG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IHJcbiAqICAgICAgICBFbmQgaW5kZXggb2YgdGhlIGFycmF5XG4gKi9cbmZ1bmN0aW9uIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgcCwgcikge1xuICAvLyBJZiBvdXIgbG93ZXIgYm91bmQgaXMgbGVzcyB0aGFuIG91ciB1cHBlciBib3VuZCwgd2UgKDEpIHBhcnRpdGlvbiB0aGVcbiAgLy8gYXJyYXkgaW50byB0d28gcGllY2VzIGFuZCAoMikgcmVjdXJzZSBvbiBlYWNoIGhhbGYuIElmIGl0IGlzIG5vdCwgdGhpcyBpc1xuICAvLyB0aGUgZW1wdHkgYXJyYXkgYW5kIG91ciBiYXNlIGNhc2UuXG5cbiAgaWYgKHAgPCByKSB7XG4gICAgLy8gKDEpIFBhcnRpdGlvbmluZy5cbiAgICAvL1xuICAgIC8vIFRoZSBwYXJ0aXRpb25pbmcgY2hvb3NlcyBhIHBpdm90IGJldHdlZW4gYHBgIGFuZCBgcmAgYW5kIG1vdmVzIGFsbFxuICAgIC8vIGVsZW1lbnRzIHRoYXQgYXJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgcGl2b3QgdG8gdGhlIGJlZm9yZSBpdCwgYW5kXG4gICAgLy8gYWxsIHRoZSBlbGVtZW50cyB0aGF0IGFyZSBncmVhdGVyIHRoYW4gaXQgYWZ0ZXIgaXQuIFRoZSBlZmZlY3QgaXMgdGhhdFxuICAgIC8vIG9uY2UgcGFydGl0aW9uIGlzIGRvbmUsIHRoZSBwaXZvdCBpcyBpbiB0aGUgZXhhY3QgcGxhY2UgaXQgd2lsbCBiZSB3aGVuXG4gICAgLy8gdGhlIGFycmF5IGlzIHB1dCBpbiBzb3J0ZWQgb3JkZXIsIGFuZCBpdCB3aWxsIG5vdCBuZWVkIHRvIGJlIG1vdmVkXG4gICAgLy8gYWdhaW4uIFRoaXMgcnVucyBpbiBPKG4pIHRpbWUuXG5cbiAgICAvLyBBbHdheXMgY2hvb3NlIGEgcmFuZG9tIHBpdm90IHNvIHRoYXQgYW4gaW5wdXQgYXJyYXkgd2hpY2ggaXMgcmV2ZXJzZVxuICAgIC8vIHNvcnRlZCBkb2VzIG5vdCBjYXVzZSBPKG5eMikgcnVubmluZyB0aW1lLlxuICAgIHZhciBwaXZvdEluZGV4ID0gcmFuZG9tSW50SW5SYW5nZShwLCByKTtcbiAgICB2YXIgaSA9IHAgLSAxO1xuXG4gICAgc3dhcChhcnksIHBpdm90SW5kZXgsIHIpO1xuICAgIHZhciBwaXZvdCA9IGFyeVtyXTtcblxuICAgIC8vIEltbWVkaWF0ZWx5IGFmdGVyIGBqYCBpcyBpbmNyZW1lbnRlZCBpbiB0aGlzIGxvb3AsIHRoZSBmb2xsb3dpbmcgaG9sZFxuICAgIC8vIHRydWU6XG4gICAgLy9cbiAgICAvLyAgICogRXZlcnkgZWxlbWVudCBpbiBgYXJ5W3AgLi4gaV1gIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgcGl2b3QuXG4gICAgLy9cbiAgICAvLyAgICogRXZlcnkgZWxlbWVudCBpbiBgYXJ5W2krMSAuLiBqLTFdYCBpcyBncmVhdGVyIHRoYW4gdGhlIHBpdm90LlxuICAgIGZvciAodmFyIGogPSBwOyBqIDwgcjsgaisrKSB7XG4gICAgICBpZiAoY29tcGFyYXRvcihhcnlbal0sIHBpdm90KSA8PSAwKSB7XG4gICAgICAgIGkgKz0gMTtcbiAgICAgICAgc3dhcChhcnksIGksIGopO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3YXAoYXJ5LCBpICsgMSwgaik7XG4gICAgdmFyIHEgPSBpICsgMTtcblxuICAgIC8vICgyKSBSZWN1cnNlIG9uIGVhY2ggaGFsZi5cblxuICAgIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgcCwgcSAtIDEpO1xuICAgIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgcSArIDEsIHIpO1xuICB9XG59XG5cbi8qKlxuICogU29ydCB0aGUgZ2l2ZW4gYXJyYXkgaW4tcGxhY2Ugd2l0aCB0aGUgZ2l2ZW4gY29tcGFyYXRvciBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnlcbiAqICAgICAgICBBbiBhcnJheSB0byBzb3J0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY29tcGFyYXRvclxuICogICAgICAgIEZ1bmN0aW9uIHRvIHVzZSB0byBjb21wYXJlIHR3byBpdGVtcy5cbiAqL1xuZXhwb3J0cy5xdWlja1NvcnQgPSBmdW5jdGlvbiAoYXJ5LCBjb21wYXJhdG9yKSB7XG4gIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgMCwgYXJ5Lmxlbmd0aCAtIDEpO1xufTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBiaW5hcnlTZWFyY2ggPSByZXF1aXJlKCcuL2JpbmFyeS1zZWFyY2gnKTtcbnZhciBBcnJheVNldCA9IHJlcXVpcmUoJy4vYXJyYXktc2V0JykuQXJyYXlTZXQ7XG52YXIgYmFzZTY0VkxRID0gcmVxdWlyZSgnLi9iYXNlNjQtdmxxJyk7XG52YXIgcXVpY2tTb3J0ID0gcmVxdWlyZSgnLi9xdWljay1zb3J0JykucXVpY2tTb3J0O1xuXG5mdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcihhU291cmNlTWFwLCBhU291cmNlTWFwVVJMKSB7XG4gIHZhciBzb3VyY2VNYXAgPSBhU291cmNlTWFwO1xuICBpZiAodHlwZW9mIGFTb3VyY2VNYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgc291cmNlTWFwID0gdXRpbC5wYXJzZVNvdXJjZU1hcElucHV0KGFTb3VyY2VNYXApO1xuICB9XG5cbiAgcmV0dXJuIHNvdXJjZU1hcC5zZWN0aW9ucyAhPSBudWxsXG4gICAgPyBuZXcgSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyKHNvdXJjZU1hcCwgYVNvdXJjZU1hcFVSTClcbiAgICA6IG5ldyBCYXNpY1NvdXJjZU1hcENvbnN1bWVyKHNvdXJjZU1hcCwgYVNvdXJjZU1hcFVSTCk7XG59XG5cblNvdXJjZU1hcENvbnN1bWVyLmZyb21Tb3VyY2VNYXAgPSBmdW5jdGlvbihhU291cmNlTWFwLCBhU291cmNlTWFwVVJMKSB7XG4gIHJldHVybiBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLmZyb21Tb3VyY2VNYXAoYVNvdXJjZU1hcCwgYVNvdXJjZU1hcFVSTCk7XG59XG5cbi8qKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXBwaW5nIHNwZWMgdGhhdCB3ZSBhcmUgY29uc3VtaW5nLlxuICovXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuXG4vLyBgX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kIGBfX29yaWdpbmFsTWFwcGluZ3NgIGFyZSBhcnJheXMgdGhhdCBob2xkIHRoZVxuLy8gcGFyc2VkIG1hcHBpbmcgY29vcmRpbmF0ZXMgZnJvbSB0aGUgc291cmNlIG1hcCdzIFwibWFwcGluZ3NcIiBhdHRyaWJ1dGUuIFRoZXlcbi8vIGFyZSBsYXppbHkgaW5zdGFudGlhdGVkLCBhY2Nlc3NlZCB2aWEgdGhlIGBfZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuLy8gYF9vcmlnaW5hbE1hcHBpbmdzYCBnZXR0ZXJzIHJlc3BlY3RpdmVseSwgYW5kIHdlIG9ubHkgcGFyc2UgdGhlIG1hcHBpbmdzXG4vLyBhbmQgY3JlYXRlIHRoZXNlIGFycmF5cyBvbmNlIHF1ZXJpZWQgZm9yIGEgc291cmNlIGxvY2F0aW9uLiBXZSBqdW1wIHRocm91Z2hcbi8vIHRoZXNlIGhvb3BzIGJlY2F1c2UgdGhlcmUgY2FuIGJlIG1hbnkgdGhvdXNhbmRzIG9mIG1hcHBpbmdzLCBhbmQgcGFyc2luZ1xuLy8gdGhlbSBpcyBleHBlbnNpdmUsIHNvIHdlIG9ubHkgd2FudCB0byBkbyBpdCBpZiB3ZSBtdXN0LlxuLy9cbi8vIEVhY2ggb2JqZWN0IGluIHRoZSBhcnJheXMgaXMgb2YgdGhlIGZvcm06XG4vL1xuLy8gICAgIHtcbi8vICAgICAgIGdlbmVyYXRlZExpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIGNvZGUsXG4vLyAgICAgICBnZW5lcmF0ZWRDb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgY29kZSxcbi8vICAgICAgIHNvdXJjZTogVGhlIHBhdGggdG8gdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlIHRoYXQgZ2VuZXJhdGVkIHRoaXNcbi8vICAgICAgICAgICAgICAgY2h1bmsgb2YgY29kZSxcbi8vICAgICAgIG9yaWdpbmFsTGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UgdGhhdFxuLy8gICAgICAgICAgICAgICAgICAgICBjb3JyZXNwb25kcyB0byB0aGlzIGNodW5rIG9mIGdlbmVyYXRlZCBjb2RlLFxuLy8gICAgICAgb3JpZ2luYWxDb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UgdGhhdFxuLy8gICAgICAgICAgICAgICAgICAgICAgIGNvcnJlc3BvbmRzIHRvIHRoaXMgY2h1bmsgb2YgZ2VuZXJhdGVkIGNvZGUsXG4vLyAgICAgICBuYW1lOiBUaGUgbmFtZSBvZiB0aGUgb3JpZ2luYWwgc3ltYm9sIHdoaWNoIGdlbmVyYXRlZCB0aGlzIGNodW5rIG9mXG4vLyAgICAgICAgICAgICBjb2RlLlxuLy8gICAgIH1cbi8vXG4vLyBBbGwgcHJvcGVydGllcyBleGNlcHQgZm9yIGBnZW5lcmF0ZWRMaW5lYCBhbmQgYGdlbmVyYXRlZENvbHVtbmAgY2FuIGJlXG4vLyBgbnVsbGAuXG4vL1xuLy8gYF9nZW5lcmF0ZWRNYXBwaW5nc2AgaXMgb3JkZXJlZCBieSB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9ucy5cbi8vXG4vLyBgX29yaWdpbmFsTWFwcGluZ3NgIGlzIG9yZGVyZWQgYnkgdGhlIG9yaWdpbmFsIHBvc2l0aW9ucy5cblxuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBudWxsO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ19nZW5lcmF0ZWRNYXBwaW5ncycsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncykge1xuICAgICAgdGhpcy5fcGFyc2VNYXBwaW5ncyh0aGlzLl9tYXBwaW5ncywgdGhpcy5zb3VyY2VSb290KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzO1xuICB9XG59KTtcblxuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9fb3JpZ2luYWxNYXBwaW5ncyA9IG51bGw7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnX29yaWdpbmFsTWFwcGluZ3MnLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncykge1xuICAgICAgdGhpcy5fcGFyc2VNYXBwaW5ncyh0aGlzLl9tYXBwaW5ncywgdGhpcy5zb3VyY2VSb290KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fX29yaWdpbmFsTWFwcGluZ3M7XG4gIH1cbn0pO1xuXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX2NoYXJJc01hcHBpbmdTZXBhcmF0b3IgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9jaGFySXNNYXBwaW5nU2VwYXJhdG9yKGFTdHIsIGluZGV4KSB7XG4gICAgdmFyIGMgPSBhU3RyLmNoYXJBdChpbmRleCk7XG4gICAgcmV0dXJuIGMgPT09IFwiO1wiIHx8IGMgPT09IFwiLFwiO1xuICB9O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBtYXBwaW5ncyBpbiBhIHN0cmluZyBpbiB0byBhIGRhdGEgc3RydWN0dXJlIHdoaWNoIHdlIGNhbiBlYXNpbHlcbiAqIHF1ZXJ5ICh0aGUgb3JkZXJlZCBhcnJheXMgaW4gdGhlIGB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuICogYHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzYCBwcm9wZXJ0aWVzKS5cbiAqL1xuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9wYXJzZU1hcHBpbmdzID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfcGFyc2VNYXBwaW5ncyhhU3RyLCBhU291cmNlUm9vdCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnQgX3BhcnNlTWFwcGluZ3NcIik7XG4gIH07XG5cblNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUiA9IDE7XG5Tb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUiA9IDI7XG5cblNvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EID0gMTtcblNvdXJjZU1hcENvbnN1bWVyLkxFQVNUX1VQUEVSX0JPVU5EID0gMjtcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgZWFjaCBtYXBwaW5nIGJldHdlZW4gYW4gb3JpZ2luYWwgc291cmNlL2xpbmUvY29sdW1uIGFuZCBhXG4gKiBnZW5lcmF0ZWQgbGluZS9jb2x1bW4gaW4gdGhpcyBzb3VyY2UgbWFwLlxuICpcbiAqIEBwYXJhbSBGdW5jdGlvbiBhQ2FsbGJhY2tcbiAqICAgICAgICBUaGUgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBlYWNoIG1hcHBpbmcuXG4gKiBAcGFyYW0gT2JqZWN0IGFDb250ZXh0XG4gKiAgICAgICAgT3B0aW9uYWwuIElmIHNwZWNpZmllZCwgdGhpcyBvYmplY3Qgd2lsbCBiZSB0aGUgdmFsdWUgb2YgYHRoaXNgIGV2ZXJ5XG4gKiAgICAgICAgdGltZSB0aGF0IGBhQ2FsbGJhY2tgIGlzIGNhbGxlZC5cbiAqIEBwYXJhbSBhT3JkZXJcbiAqICAgICAgICBFaXRoZXIgYFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUmAgb3JcbiAqICAgICAgICBgU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVJgLiBTcGVjaWZpZXMgd2hldGhlciB5b3Ugd2FudCB0b1xuICogICAgICAgIGl0ZXJhdGUgb3ZlciB0aGUgbWFwcGluZ3Mgc29ydGVkIGJ5IHRoZSBnZW5lcmF0ZWQgZmlsZSdzIGxpbmUvY29sdW1uXG4gKiAgICAgICAgb3JkZXIgb3IgdGhlIG9yaWdpbmFsJ3Mgc291cmNlL2xpbmUvY29sdW1uIG9yZGVyLCByZXNwZWN0aXZlbHkuIERlZmF1bHRzIHRvXG4gKiAgICAgICAgYFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUmAuXG4gKi9cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5lYWNoTWFwcGluZyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2VhY2hNYXBwaW5nKGFDYWxsYmFjaywgYUNvbnRleHQsIGFPcmRlcikge1xuICAgIHZhciBjb250ZXh0ID0gYUNvbnRleHQgfHwgbnVsbDtcbiAgICB2YXIgb3JkZXIgPSBhT3JkZXIgfHwgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSO1xuXG4gICAgdmFyIG1hcHBpbmdzO1xuICAgIHN3aXRjaCAob3JkZXIpIHtcbiAgICBjYXNlIFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUjpcbiAgICAgIG1hcHBpbmdzID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3M7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSOlxuICAgICAgbWFwcGluZ3MgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb3JkZXIgb2YgaXRlcmF0aW9uLlwiKTtcbiAgICB9XG5cbiAgICB2YXIgc291cmNlUm9vdCA9IHRoaXMuc291cmNlUm9vdDtcbiAgICBtYXBwaW5ncy5tYXAoZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBtYXBwaW5nLnNvdXJjZSA9PT0gbnVsbCA/IG51bGwgOiB0aGlzLl9zb3VyY2VzLmF0KG1hcHBpbmcuc291cmNlKTtcbiAgICAgIHNvdXJjZSA9IHV0aWwuY29tcHV0ZVNvdXJjZVVSTChzb3VyY2VSb290LCBzb3VyY2UsIHRoaXMuX3NvdXJjZU1hcFVSTCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgZ2VuZXJhdGVkTGluZTogbWFwcGluZy5nZW5lcmF0ZWRMaW5lLFxuICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uLFxuICAgICAgICBvcmlnaW5hbExpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICBvcmlnaW5hbENvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtbixcbiAgICAgICAgbmFtZTogbWFwcGluZy5uYW1lID09PSBudWxsID8gbnVsbCA6IHRoaXMuX25hbWVzLmF0KG1hcHBpbmcubmFtZSlcbiAgICAgIH07XG4gICAgfSwgdGhpcykuZm9yRWFjaChhQ2FsbGJhY2ssIGNvbnRleHQpO1xuICB9O1xuXG4vKipcbiAqIFJldHVybnMgYWxsIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBvcmlnaW5hbCBzb3VyY2UsXG4gKiBsaW5lLCBhbmQgY29sdW1uIHByb3ZpZGVkLiBJZiBubyBjb2x1bW4gaXMgcHJvdmlkZWQsIHJldHVybnMgYWxsIG1hcHBpbmdzXG4gKiBjb3JyZXNwb25kaW5nIHRvIGEgZWl0aGVyIHRoZSBsaW5lIHdlIGFyZSBzZWFyY2hpbmcgZm9yIG9yIHRoZSBuZXh0XG4gKiBjbG9zZXN0IGxpbmUgdGhhdCBoYXMgYW55IG1hcHBpbmdzLiBPdGhlcndpc2UsIHJldHVybnMgYWxsIG1hcHBpbmdzXG4gKiBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBsaW5lIGFuZCBlaXRoZXIgdGhlIGNvbHVtbiB3ZSBhcmUgc2VhcmNoaW5nIGZvclxuICogb3IgdGhlIG5leHQgY2xvc2VzdCBjb2x1bW4gdGhhdCBoYXMgYW55IG9mZnNldHMuXG4gKlxuICogVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBzb3VyY2U6IFRoZSBmaWxlbmFtZSBvZiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLiAgVGhlIGxpbmUgbnVtYmVyIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBPcHRpb25hbC4gdGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgIFRoZSBjb2x1bW4gbnVtYmVyIGlzIDAtYmFzZWQuXG4gKlxuICogYW5kIGFuIGFycmF5IG9mIG9iamVjdHMgaXMgcmV0dXJuZWQsIGVhY2ggd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC4gIFRoZVxuICogICAgbGluZSBudW1iZXIgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICogICAgVGhlIGNvbHVtbiBudW1iZXIgaXMgMC1iYXNlZC5cbiAqL1xuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmFsbEdlbmVyYXRlZFBvc2l0aW9uc0ZvciA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2FsbEdlbmVyYXRlZFBvc2l0aW9uc0ZvcihhQXJncykge1xuICAgIHZhciBsaW5lID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyk7XG5cbiAgICAvLyBXaGVuIHRoZXJlIGlzIG5vIGV4YWN0IG1hdGNoLCBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fZmluZE1hcHBpbmdcbiAgICAvLyByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgY2xvc2VzdCBtYXBwaW5nIGxlc3MgdGhhbiB0aGUgbmVlZGxlLiBCeVxuICAgIC8vIHNldHRpbmcgbmVlZGxlLm9yaWdpbmFsQ29sdW1uIHRvIDAsIHdlIHRodXMgZmluZCB0aGUgbGFzdCBtYXBwaW5nIGZvclxuICAgIC8vIHRoZSBnaXZlbiBsaW5lLCBwcm92aWRlZCBzdWNoIGEgbWFwcGluZyBleGlzdHMuXG4gICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgIHNvdXJjZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnKSxcbiAgICAgIG9yaWdpbmFsTGluZTogbGluZSxcbiAgICAgIG9yaWdpbmFsQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicsIDApXG4gICAgfTtcblxuICAgIG5lZWRsZS5zb3VyY2UgPSB0aGlzLl9maW5kU291cmNlSW5kZXgobmVlZGxlLnNvdXJjZSk7XG4gICAgaWYgKG5lZWRsZS5zb3VyY2UgPCAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgdmFyIG1hcHBpbmdzID0gW107XG5cbiAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kTWFwcGluZyhuZWVkbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3JpZ2luYWxNYXBwaW5ncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9yaWdpbmFsTGluZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3JpZ2luYWxDb2x1bW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbmFyeVNlYXJjaC5MRUFTVF9VUFBFUl9CT1VORCk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgIGlmIChhQXJncy5jb2x1bW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgb3JpZ2luYWxMaW5lID0gbWFwcGluZy5vcmlnaW5hbExpbmU7XG5cbiAgICAgICAgLy8gSXRlcmF0ZSB1bnRpbCBlaXRoZXIgd2UgcnVuIG91dCBvZiBtYXBwaW5ncywgb3Igd2UgcnVuIGludG9cbiAgICAgICAgLy8gYSBtYXBwaW5nIGZvciBhIGRpZmZlcmVudCBsaW5lIHRoYW4gdGhlIG9uZSB3ZSBmb3VuZC4gU2luY2VcbiAgICAgICAgLy8gbWFwcGluZ3MgYXJlIHNvcnRlZCwgdGhpcyBpcyBndWFyYW50ZWVkIHRvIGZpbmQgYWxsIG1hcHBpbmdzIGZvclxuICAgICAgICAvLyB0aGUgbGluZSB3ZSBmb3VuZC5cbiAgICAgICAgd2hpbGUgKG1hcHBpbmcgJiYgbWFwcGluZy5vcmlnaW5hbExpbmUgPT09IG9yaWdpbmFsTGluZSkge1xuICAgICAgICAgIG1hcHBpbmdzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZExpbmUnLCBudWxsKSxcbiAgICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZENvbHVtbicsIG51bGwpLFxuICAgICAgICAgICAgbGFzdENvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2xhc3RHZW5lcmF0ZWRDb2x1bW4nLCBudWxsKVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbKytpbmRleF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBvcmlnaW5hbENvbHVtbiA9IG1hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgLy8gSXRlcmF0ZSB1bnRpbCBlaXRoZXIgd2UgcnVuIG91dCBvZiBtYXBwaW5ncywgb3Igd2UgcnVuIGludG9cbiAgICAgICAgLy8gYSBtYXBwaW5nIGZvciBhIGRpZmZlcmVudCBsaW5lIHRoYW4gdGhlIG9uZSB3ZSB3ZXJlIHNlYXJjaGluZyBmb3IuXG4gICAgICAgIC8vIFNpbmNlIG1hcHBpbmdzIGFyZSBzb3J0ZWQsIHRoaXMgaXMgZ3VhcmFudGVlZCB0byBmaW5kIGFsbCBtYXBwaW5ncyBmb3JcbiAgICAgICAgLy8gdGhlIGxpbmUgd2UgYXJlIHNlYXJjaGluZyBmb3IuXG4gICAgICAgIHdoaWxlIChtYXBwaW5nICYmXG4gICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gbGluZSAmJlxuICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbiA9PSBvcmlnaW5hbENvbHVtbikge1xuICAgICAgICAgIG1hcHBpbmdzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZExpbmUnLCBudWxsKSxcbiAgICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZENvbHVtbicsIG51bGwpLFxuICAgICAgICAgICAgbGFzdENvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2xhc3RHZW5lcmF0ZWRDb2x1bW4nLCBudWxsKVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbKytpbmRleF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWFwcGluZ3M7XG4gIH07XG5cbmV4cG9ydHMuU291cmNlTWFwQ29uc3VtZXIgPSBTb3VyY2VNYXBDb25zdW1lcjtcblxuLyoqXG4gKiBBIEJhc2ljU291cmNlTWFwQ29uc3VtZXIgaW5zdGFuY2UgcmVwcmVzZW50cyBhIHBhcnNlZCBzb3VyY2UgbWFwIHdoaWNoIHdlIGNhblxuICogcXVlcnkgZm9yIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvcmlnaW5hbCBmaWxlIHBvc2l0aW9ucyBieSBnaXZpbmcgaXQgYSBmaWxlXG4gKiBwb3NpdGlvbiBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAqXG4gKiBUaGUgZmlyc3QgcGFyYW1ldGVyIGlzIHRoZSByYXcgc291cmNlIG1hcCAoZWl0aGVyIGFzIGEgSlNPTiBzdHJpbmcsIG9yXG4gKiBhbHJlYWR5IHBhcnNlZCB0byBhbiBvYmplY3QpLiBBY2NvcmRpbmcgdG8gdGhlIHNwZWMsIHNvdXJjZSBtYXBzIGhhdmUgdGhlXG4gKiBmb2xsb3dpbmcgYXR0cmlidXRlczpcbiAqXG4gKiAgIC0gdmVyc2lvbjogV2hpY2ggdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcCBzcGVjIHRoaXMgbWFwIGlzIGZvbGxvd2luZy5cbiAqICAgLSBzb3VyY2VzOiBBbiBhcnJheSBvZiBVUkxzIHRvIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZXMuXG4gKiAgIC0gbmFtZXM6IEFuIGFycmF5IG9mIGlkZW50aWZpZXJzIHdoaWNoIGNhbiBiZSByZWZlcnJlbmNlZCBieSBpbmRpdmlkdWFsIG1hcHBpbmdzLlxuICogICAtIHNvdXJjZVJvb3Q6IE9wdGlvbmFsLiBUaGUgVVJMIHJvb3QgZnJvbSB3aGljaCBhbGwgc291cmNlcyBhcmUgcmVsYXRpdmUuXG4gKiAgIC0gc291cmNlc0NvbnRlbnQ6IE9wdGlvbmFsLiBBbiBhcnJheSBvZiBjb250ZW50cyBvZiB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGVzLlxuICogICAtIG1hcHBpbmdzOiBBIHN0cmluZyBvZiBiYXNlNjQgVkxRcyB3aGljaCBjb250YWluIHRoZSBhY3R1YWwgbWFwcGluZ3MuXG4gKiAgIC0gZmlsZTogT3B0aW9uYWwuIFRoZSBnZW5lcmF0ZWQgZmlsZSB0aGlzIHNvdXJjZSBtYXAgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICpcbiAqIEhlcmUgaXMgYW4gZXhhbXBsZSBzb3VyY2UgbWFwLCB0YWtlbiBmcm9tIHRoZSBzb3VyY2UgbWFwIHNwZWNbMF06XG4gKlxuICogICAgIHtcbiAqICAgICAgIHZlcnNpb24gOiAzLFxuICogICAgICAgZmlsZTogXCJvdXQuanNcIixcbiAqICAgICAgIHNvdXJjZVJvb3QgOiBcIlwiLFxuICogICAgICAgc291cmNlczogW1wiZm9vLmpzXCIsIFwiYmFyLmpzXCJdLFxuICogICAgICAgbmFtZXM6IFtcInNyY1wiLCBcIm1hcHNcIiwgXCJhcmVcIiwgXCJmdW5cIl0sXG4gKiAgICAgICBtYXBwaW5nczogXCJBQSxBQjs7QUJDREU7XCJcbiAqICAgICB9XG4gKlxuICogVGhlIHNlY29uZCBwYXJhbWV0ZXIsIGlmIGdpdmVuLCBpcyBhIHN0cmluZyB3aG9zZSB2YWx1ZSBpcyB0aGUgVVJMXG4gKiBhdCB3aGljaCB0aGUgc291cmNlIG1hcCB3YXMgZm91bmQuICBUaGlzIFVSTCBpcyB1c2VkIHRvIGNvbXB1dGUgdGhlXG4gKiBzb3VyY2VzIGFycmF5LlxuICpcbiAqIFswXTogaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vZG9jdW1lbnQvZC8xVTFSR0FlaFF3UnlwVVRvdkYxS1JscGlPRnplMGItXzJnYzZmQUgwS1kway9lZGl0P3BsaT0xI1xuICovXG5mdW5jdGlvbiBCYXNpY1NvdXJjZU1hcENvbnN1bWVyKGFTb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpIHtcbiAgdmFyIHNvdXJjZU1hcCA9IGFTb3VyY2VNYXA7XG4gIGlmICh0eXBlb2YgYVNvdXJjZU1hcCA9PT0gJ3N0cmluZycpIHtcbiAgICBzb3VyY2VNYXAgPSB1dGlsLnBhcnNlU291cmNlTWFwSW5wdXQoYVNvdXJjZU1hcCk7XG4gIH1cblxuICB2YXIgdmVyc2lvbiA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3ZlcnNpb24nKTtcbiAgdmFyIHNvdXJjZXMgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzb3VyY2VzJyk7XG4gIC8vIFNhc3MgMy4zIGxlYXZlcyBvdXQgdGhlICduYW1lcycgYXJyYXksIHNvIHdlIGRldmlhdGUgZnJvbSB0aGUgc3BlYyAod2hpY2hcbiAgLy8gcmVxdWlyZXMgdGhlIGFycmF5KSB0byBwbGF5IG5pY2UgaGVyZS5cbiAgdmFyIG5hbWVzID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnbmFtZXMnLCBbXSk7XG4gIHZhciBzb3VyY2VSb290ID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc291cmNlUm9vdCcsIG51bGwpO1xuICB2YXIgc291cmNlc0NvbnRlbnQgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzb3VyY2VzQ29udGVudCcsIG51bGwpO1xuICB2YXIgbWFwcGluZ3MgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdtYXBwaW5ncycpO1xuICB2YXIgZmlsZSA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ2ZpbGUnLCBudWxsKTtcblxuICAvLyBPbmNlIGFnYWluLCBTYXNzIGRldmlhdGVzIGZyb20gdGhlIHNwZWMgYW5kIHN1cHBsaWVzIHRoZSB2ZXJzaW9uIGFzIGFcbiAgLy8gc3RyaW5nIHJhdGhlciB0aGFuIGEgbnVtYmVyLCBzbyB3ZSB1c2UgbG9vc2UgZXF1YWxpdHkgY2hlY2tpbmcgaGVyZS5cbiAgaWYgKHZlcnNpb24gIT0gdGhpcy5fdmVyc2lvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgdmVyc2lvbjogJyArIHZlcnNpb24pO1xuICB9XG5cbiAgaWYgKHNvdXJjZVJvb3QpIHtcbiAgICBzb3VyY2VSb290ID0gdXRpbC5ub3JtYWxpemUoc291cmNlUm9vdCk7XG4gIH1cblxuICBzb3VyY2VzID0gc291cmNlc1xuICAgIC5tYXAoU3RyaW5nKVxuICAgIC8vIFNvbWUgc291cmNlIG1hcHMgcHJvZHVjZSByZWxhdGl2ZSBzb3VyY2UgcGF0aHMgbGlrZSBcIi4vZm9vLmpzXCIgaW5zdGVhZCBvZlxuICAgIC8vIFwiZm9vLmpzXCIuICBOb3JtYWxpemUgdGhlc2UgZmlyc3Qgc28gdGhhdCBmdXR1cmUgY29tcGFyaXNvbnMgd2lsbCBzdWNjZWVkLlxuICAgIC8vIFNlZSBidWd6aWwubGEvMTA5MDc2OC5cbiAgICAubWFwKHV0aWwubm9ybWFsaXplKVxuICAgIC8vIEFsd2F5cyBlbnN1cmUgdGhhdCBhYnNvbHV0ZSBzb3VyY2VzIGFyZSBpbnRlcm5hbGx5IHN0b3JlZCByZWxhdGl2ZSB0b1xuICAgIC8vIHRoZSBzb3VyY2Ugcm9vdCwgaWYgdGhlIHNvdXJjZSByb290IGlzIGFic29sdXRlLiBOb3QgZG9pbmcgdGhpcyB3b3VsZFxuICAgIC8vIGJlIHBhcnRpY3VsYXJseSBwcm9ibGVtYXRpYyB3aGVuIHRoZSBzb3VyY2Ugcm9vdCBpcyBhIHByZWZpeCBvZiB0aGVcbiAgICAvLyBzb3VyY2UgKHZhbGlkLCBidXQgd2h5Pz8pLiBTZWUgZ2l0aHViIGlzc3VlICMxOTkgYW5kIGJ1Z3ppbC5sYS8xMTg4OTgyLlxuICAgIC5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIHNvdXJjZVJvb3QgJiYgdXRpbC5pc0Fic29sdXRlKHNvdXJjZVJvb3QpICYmIHV0aWwuaXNBYnNvbHV0ZShzb3VyY2UpXG4gICAgICAgID8gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBzb3VyY2UpXG4gICAgICAgIDogc291cmNlO1xuICAgIH0pO1xuXG4gIC8vIFBhc3MgYHRydWVgIGJlbG93IHRvIGFsbG93IGR1cGxpY2F0ZSBuYW1lcyBhbmQgc291cmNlcy4gV2hpbGUgc291cmNlIG1hcHNcbiAgLy8gYXJlIGludGVuZGVkIHRvIGJlIGNvbXByZXNzZWQgYW5kIGRlZHVwbGljYXRlZCwgdGhlIFR5cGVTY3JpcHQgY29tcGlsZXJcbiAgLy8gc29tZXRpbWVzIGdlbmVyYXRlcyBzb3VyY2UgbWFwcyB3aXRoIGR1cGxpY2F0ZXMgaW4gdGhlbS4gU2VlIEdpdGh1YiBpc3N1ZVxuICAvLyAjNzIgYW5kIGJ1Z3ppbC5sYS84ODk0OTIuXG4gIHRoaXMuX25hbWVzID0gQXJyYXlTZXQuZnJvbUFycmF5KG5hbWVzLm1hcChTdHJpbmcpLCB0cnVlKTtcbiAgdGhpcy5fc291cmNlcyA9IEFycmF5U2V0LmZyb21BcnJheShzb3VyY2VzLCB0cnVlKTtcblxuICB0aGlzLl9hYnNvbHV0ZVNvdXJjZXMgPSB0aGlzLl9zb3VyY2VzLnRvQXJyYXkoKS5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICByZXR1cm4gdXRpbC5jb21wdXRlU291cmNlVVJMKHNvdXJjZVJvb3QsIHMsIGFTb3VyY2VNYXBVUkwpO1xuICB9KTtcblxuICB0aGlzLnNvdXJjZVJvb3QgPSBzb3VyY2VSb290O1xuICB0aGlzLnNvdXJjZXNDb250ZW50ID0gc291cmNlc0NvbnRlbnQ7XG4gIHRoaXMuX21hcHBpbmdzID0gbWFwcGluZ3M7XG4gIHRoaXMuX3NvdXJjZU1hcFVSTCA9IGFTb3VyY2VNYXBVUkw7XG4gIHRoaXMuZmlsZSA9IGZpbGU7XG59XG5cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUpO1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuY29uc3VtZXIgPSBTb3VyY2VNYXBDb25zdW1lcjtcblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIGZpbmQgdGhlIGluZGV4IG9mIGEgc291cmNlLiAgUmV0dXJucyAtMSBpZiBub3RcbiAqIGZvdW5kLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fZmluZFNvdXJjZUluZGV4ID0gZnVuY3Rpb24oYVNvdXJjZSkge1xuICB2YXIgcmVsYXRpdmVTb3VyY2UgPSBhU291cmNlO1xuICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICByZWxhdGl2ZVNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5zb3VyY2VSb290LCByZWxhdGl2ZVNvdXJjZSk7XG4gIH1cblxuICBpZiAodGhpcy5fc291cmNlcy5oYXMocmVsYXRpdmVTb3VyY2UpKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NvdXJjZXMuaW5kZXhPZihyZWxhdGl2ZVNvdXJjZSk7XG4gIH1cblxuICAvLyBNYXliZSBhU291cmNlIGlzIGFuIGFic29sdXRlIFVSTCBhcyByZXR1cm5lZCBieSB8c291cmNlc3wuICBJblxuICAvLyB0aGlzIGNhc2Ugd2UgY2FuJ3Qgc2ltcGx5IHVuZG8gdGhlIHRyYW5zZm9ybS5cbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLl9hYnNvbHV0ZVNvdXJjZXMubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAodGhpcy5fYWJzb2x1dGVTb3VyY2VzW2ldID09IGFTb3VyY2UpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgQmFzaWNTb3VyY2VNYXBDb25zdW1lciBmcm9tIGEgU291cmNlTWFwR2VuZXJhdG9yLlxuICpcbiAqIEBwYXJhbSBTb3VyY2VNYXBHZW5lcmF0b3IgYVNvdXJjZU1hcFxuICogICAgICAgIFRoZSBzb3VyY2UgbWFwIHRoYXQgd2lsbCBiZSBjb25zdW1lZC5cbiAqIEBwYXJhbSBTdHJpbmcgYVNvdXJjZU1hcFVSTFxuICogICAgICAgIFRoZSBVUkwgYXQgd2hpY2ggdGhlIHNvdXJjZSBtYXAgY2FuIGJlIGZvdW5kIChvcHRpb25hbClcbiAqIEByZXR1cm5zIEJhc2ljU291cmNlTWFwQ29uc3VtZXJcbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5mcm9tU291cmNlTWFwID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZnJvbVNvdXJjZU1hcChhU291cmNlTWFwLCBhU291cmNlTWFwVVJMKSB7XG4gICAgdmFyIHNtYyA9IE9iamVjdC5jcmVhdGUoQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUpO1xuXG4gICAgdmFyIG5hbWVzID0gc21jLl9uYW1lcyA9IEFycmF5U2V0LmZyb21BcnJheShhU291cmNlTWFwLl9uYW1lcy50b0FycmF5KCksIHRydWUpO1xuICAgIHZhciBzb3VyY2VzID0gc21jLl9zb3VyY2VzID0gQXJyYXlTZXQuZnJvbUFycmF5KGFTb3VyY2VNYXAuX3NvdXJjZXMudG9BcnJheSgpLCB0cnVlKTtcbiAgICBzbWMuc291cmNlUm9vdCA9IGFTb3VyY2VNYXAuX3NvdXJjZVJvb3Q7XG4gICAgc21jLnNvdXJjZXNDb250ZW50ID0gYVNvdXJjZU1hcC5fZ2VuZXJhdGVTb3VyY2VzQ29udGVudChzbWMuX3NvdXJjZXMudG9BcnJheSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc21jLnNvdXJjZVJvb3QpO1xuICAgIHNtYy5maWxlID0gYVNvdXJjZU1hcC5fZmlsZTtcbiAgICBzbWMuX3NvdXJjZU1hcFVSTCA9IGFTb3VyY2VNYXBVUkw7XG4gICAgc21jLl9hYnNvbHV0ZVNvdXJjZXMgPSBzbWMuX3NvdXJjZXMudG9BcnJheSgpLm1hcChmdW5jdGlvbiAocykge1xuICAgICAgcmV0dXJuIHV0aWwuY29tcHV0ZVNvdXJjZVVSTChzbWMuc291cmNlUm9vdCwgcywgYVNvdXJjZU1hcFVSTCk7XG4gICAgfSk7XG5cbiAgICAvLyBCZWNhdXNlIHdlIGFyZSBtb2RpZnlpbmcgdGhlIGVudHJpZXMgKGJ5IGNvbnZlcnRpbmcgc3RyaW5nIHNvdXJjZXMgYW5kXG4gICAgLy8gbmFtZXMgdG8gaW5kaWNlcyBpbnRvIHRoZSBzb3VyY2VzIGFuZCBuYW1lcyBBcnJheVNldHMpLCB3ZSBoYXZlIHRvIG1ha2VcbiAgICAvLyBhIGNvcHkgb2YgdGhlIGVudHJ5IG9yIGVsc2UgYmFkIHRoaW5ncyBoYXBwZW4uIFNoYXJlZCBtdXRhYmxlIHN0YXRlXG4gICAgLy8gc3RyaWtlcyBhZ2FpbiEgU2VlIGdpdGh1YiBpc3N1ZSAjMTkxLlxuXG4gICAgdmFyIGdlbmVyYXRlZE1hcHBpbmdzID0gYVNvdXJjZU1hcC5fbWFwcGluZ3MudG9BcnJheSgpLnNsaWNlKCk7XG4gICAgdmFyIGRlc3RHZW5lcmF0ZWRNYXBwaW5ncyA9IHNtYy5fX2dlbmVyYXRlZE1hcHBpbmdzID0gW107XG4gICAgdmFyIGRlc3RPcmlnaW5hbE1hcHBpbmdzID0gc21jLl9fb3JpZ2luYWxNYXBwaW5ncyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdlbmVyYXRlZE1hcHBpbmdzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc3JjTWFwcGluZyA9IGdlbmVyYXRlZE1hcHBpbmdzW2ldO1xuICAgICAgdmFyIGRlc3RNYXBwaW5nID0gbmV3IE1hcHBpbmc7XG4gICAgICBkZXN0TWFwcGluZy5nZW5lcmF0ZWRMaW5lID0gc3JjTWFwcGluZy5nZW5lcmF0ZWRMaW5lO1xuICAgICAgZGVzdE1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uID0gc3JjTWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG5cbiAgICAgIGlmIChzcmNNYXBwaW5nLnNvdXJjZSkge1xuICAgICAgICBkZXN0TWFwcGluZy5zb3VyY2UgPSBzb3VyY2VzLmluZGV4T2Yoc3JjTWFwcGluZy5zb3VyY2UpO1xuICAgICAgICBkZXN0TWFwcGluZy5vcmlnaW5hbExpbmUgPSBzcmNNYXBwaW5nLm9yaWdpbmFsTGluZTtcbiAgICAgICAgZGVzdE1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBzcmNNYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuXG4gICAgICAgIGlmIChzcmNNYXBwaW5nLm5hbWUpIHtcbiAgICAgICAgICBkZXN0TWFwcGluZy5uYW1lID0gbmFtZXMuaW5kZXhPZihzcmNNYXBwaW5nLm5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVzdE9yaWdpbmFsTWFwcGluZ3MucHVzaChkZXN0TWFwcGluZyk7XG4gICAgICB9XG5cbiAgICAgIGRlc3RHZW5lcmF0ZWRNYXBwaW5ncy5wdXNoKGRlc3RNYXBwaW5nKTtcbiAgICB9XG5cbiAgICBxdWlja1NvcnQoc21jLl9fb3JpZ2luYWxNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyk7XG5cbiAgICByZXR1cm4gc21jO1xuICB9O1xuXG4vKipcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwcGluZyBzcGVjIHRoYXQgd2UgYXJlIGNvbnN1bWluZy5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuXG4vKipcbiAqIFRoZSBsaXN0IG9mIG9yaWdpbmFsIHNvdXJjZXMuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ3NvdXJjZXMnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9hYnNvbHV0ZVNvdXJjZXMuc2xpY2UoKTtcbiAgfVxufSk7XG5cbi8qKlxuICogUHJvdmlkZSB0aGUgSklUIHdpdGggYSBuaWNlIHNoYXBlIC8gaGlkZGVuIGNsYXNzLlxuICovXG5mdW5jdGlvbiBNYXBwaW5nKCkge1xuICB0aGlzLmdlbmVyYXRlZExpbmUgPSAwO1xuICB0aGlzLmdlbmVyYXRlZENvbHVtbiA9IDA7XG4gIHRoaXMuc291cmNlID0gbnVsbDtcbiAgdGhpcy5vcmlnaW5hbExpbmUgPSBudWxsO1xuICB0aGlzLm9yaWdpbmFsQ29sdW1uID0gbnVsbDtcbiAgdGhpcy5uYW1lID0gbnVsbDtcbn1cblxuLyoqXG4gKiBQYXJzZSB0aGUgbWFwcGluZ3MgaW4gYSBzdHJpbmcgaW4gdG8gYSBkYXRhIHN0cnVjdHVyZSB3aGljaCB3ZSBjYW4gZWFzaWx5XG4gKiBxdWVyeSAodGhlIG9yZGVyZWQgYXJyYXlzIGluIHRoZSBgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAqIGB0aGlzLl9fb3JpZ2luYWxNYXBwaW5nc2AgcHJvcGVydGllcykuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9wYXJzZU1hcHBpbmdzID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfcGFyc2VNYXBwaW5ncyhhU3RyLCBhU291cmNlUm9vdCkge1xuICAgIHZhciBnZW5lcmF0ZWRMaW5lID0gMTtcbiAgICB2YXIgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgIHZhciBwcmV2aW91c09yaWdpbmFsTGluZSA9IDA7XG4gICAgdmFyIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSAwO1xuICAgIHZhciBwcmV2aW91c1NvdXJjZSA9IDA7XG4gICAgdmFyIHByZXZpb3VzTmFtZSA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IGFTdHIubGVuZ3RoO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGNhY2hlZFNlZ21lbnRzID0ge307XG4gICAgdmFyIHRlbXAgPSB7fTtcbiAgICB2YXIgb3JpZ2luYWxNYXBwaW5ncyA9IFtdO1xuICAgIHZhciBnZW5lcmF0ZWRNYXBwaW5ncyA9IFtdO1xuICAgIHZhciBtYXBwaW5nLCBzdHIsIHNlZ21lbnQsIGVuZCwgdmFsdWU7XG5cbiAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChhU3RyLmNoYXJBdChpbmRleCkgPT09ICc7Jykge1xuICAgICAgICBnZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgIGluZGV4Kys7XG4gICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGFTdHIuY2hhckF0KGluZGV4KSA9PT0gJywnKSB7XG4gICAgICAgIGluZGV4Kys7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbWFwcGluZyA9IG5ldyBNYXBwaW5nKCk7XG4gICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9IGdlbmVyYXRlZExpbmU7XG5cbiAgICAgICAgLy8gQmVjYXVzZSBlYWNoIG9mZnNldCBpcyBlbmNvZGVkIHJlbGF0aXZlIHRvIHRoZSBwcmV2aW91cyBvbmUsXG4gICAgICAgIC8vIG1hbnkgc2VnbWVudHMgb2Z0ZW4gaGF2ZSB0aGUgc2FtZSBlbmNvZGluZy4gV2UgY2FuIGV4cGxvaXQgdGhpc1xuICAgICAgICAvLyBmYWN0IGJ5IGNhY2hpbmcgdGhlIHBhcnNlZCB2YXJpYWJsZSBsZW5ndGggZmllbGRzIG9mIGVhY2ggc2VnbWVudCxcbiAgICAgICAgLy8gYWxsb3dpbmcgdXMgdG8gYXZvaWQgYSBzZWNvbmQgcGFyc2UgaWYgd2UgZW5jb3VudGVyIHRoZSBzYW1lXG4gICAgICAgIC8vIHNlZ21lbnQgYWdhaW4uXG4gICAgICAgIGZvciAoZW5kID0gaW5kZXg7IGVuZCA8IGxlbmd0aDsgZW5kKyspIHtcbiAgICAgICAgICBpZiAodGhpcy5fY2hhcklzTWFwcGluZ1NlcGFyYXRvcihhU3RyLCBlbmQpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RyID0gYVN0ci5zbGljZShpbmRleCwgZW5kKTtcblxuICAgICAgICBzZWdtZW50ID0gY2FjaGVkU2VnbWVudHNbc3RyXTtcbiAgICAgICAgaWYgKHNlZ21lbnQpIHtcbiAgICAgICAgICBpbmRleCArPSBzdHIubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlZ21lbnQgPSBbXTtcbiAgICAgICAgICB3aGlsZSAoaW5kZXggPCBlbmQpIHtcbiAgICAgICAgICAgIGJhc2U2NFZMUS5kZWNvZGUoYVN0ciwgaW5kZXgsIHRlbXApO1xuICAgICAgICAgICAgdmFsdWUgPSB0ZW1wLnZhbHVlO1xuICAgICAgICAgICAgaW5kZXggPSB0ZW1wLnJlc3Q7XG4gICAgICAgICAgICBzZWdtZW50LnB1c2godmFsdWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCBhIHNvdXJjZSwgYnV0IG5vIGxpbmUgYW5kIGNvbHVtbicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCBhIHNvdXJjZSBhbmQgbGluZSwgYnV0IG5vIGNvbHVtbicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhY2hlZFNlZ21lbnRzW3N0cl0gPSBzZWdtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2VuZXJhdGVkIGNvbHVtbi5cbiAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gPSBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiArIHNlZ21lbnRbMF07XG4gICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG5cbiAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID4gMSkge1xuICAgICAgICAgIC8vIE9yaWdpbmFsIHNvdXJjZS5cbiAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IHByZXZpb3VzU291cmNlICsgc2VnbWVudFsxXTtcbiAgICAgICAgICBwcmV2aW91c1NvdXJjZSArPSBzZWdtZW50WzFdO1xuXG4gICAgICAgICAgLy8gT3JpZ2luYWwgbGluZS5cbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSA9IHByZXZpb3VzT3JpZ2luYWxMaW5lICsgc2VnbWVudFsyXTtcbiAgICAgICAgICBwcmV2aW91c09yaWdpbmFsTGluZSA9IG1hcHBpbmcub3JpZ2luYWxMaW5lO1xuICAgICAgICAgIC8vIExpbmVzIGFyZSBzdG9yZWQgMC1iYXNlZFxuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lICs9IDE7XG5cbiAgICAgICAgICAvLyBPcmlnaW5hbCBjb2x1bW4uXG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbiA9IHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gKyBzZWdtZW50WzNdO1xuICAgICAgICAgIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuXG4gICAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID4gNCkge1xuICAgICAgICAgICAgLy8gT3JpZ2luYWwgbmFtZS5cbiAgICAgICAgICAgIG1hcHBpbmcubmFtZSA9IHByZXZpb3VzTmFtZSArIHNlZ21lbnRbNF07XG4gICAgICAgICAgICBwcmV2aW91c05hbWUgKz0gc2VnbWVudFs0XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBnZW5lcmF0ZWRNYXBwaW5ncy5wdXNoKG1hcHBpbmcpO1xuICAgICAgICBpZiAodHlwZW9mIG1hcHBpbmcub3JpZ2luYWxMaW5lID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIG9yaWdpbmFsTWFwcGluZ3MucHVzaChtYXBwaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHF1aWNrU29ydChnZW5lcmF0ZWRNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCk7XG4gICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzID0gZ2VuZXJhdGVkTWFwcGluZ3M7XG5cbiAgICBxdWlja1NvcnQob3JpZ2luYWxNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyk7XG4gICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MgPSBvcmlnaW5hbE1hcHBpbmdzO1xuICB9O1xuXG4vKipcbiAqIEZpbmQgdGhlIG1hcHBpbmcgdGhhdCBiZXN0IG1hdGNoZXMgdGhlIGh5cG90aGV0aWNhbCBcIm5lZWRsZVwiIG1hcHBpbmcgdGhhdFxuICogd2UgYXJlIHNlYXJjaGluZyBmb3IgaW4gdGhlIGdpdmVuIFwiaGF5c3RhY2tcIiBvZiBtYXBwaW5ncy5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX2ZpbmRNYXBwaW5nID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZmluZE1hcHBpbmcoYU5lZWRsZSwgYU1hcHBpbmdzLCBhTGluZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFDb2x1bW5OYW1lLCBhQ29tcGFyYXRvciwgYUJpYXMpIHtcbiAgICAvLyBUbyByZXR1cm4gdGhlIHBvc2l0aW9uIHdlIGFyZSBzZWFyY2hpbmcgZm9yLCB3ZSBtdXN0IGZpcnN0IGZpbmQgdGhlXG4gICAgLy8gbWFwcGluZyBmb3IgdGhlIGdpdmVuIHBvc2l0aW9uIGFuZCB0aGVuIHJldHVybiB0aGUgb3Bwb3NpdGUgcG9zaXRpb24gaXRcbiAgICAvLyBwb2ludHMgdG8uIEJlY2F1c2UgdGhlIG1hcHBpbmdzIGFyZSBzb3J0ZWQsIHdlIGNhbiB1c2UgYmluYXJ5IHNlYXJjaCB0b1xuICAgIC8vIGZpbmQgdGhlIGJlc3QgbWFwcGluZy5cblxuICAgIGlmIChhTmVlZGxlW2FMaW5lTmFtZV0gPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTGluZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxLCBnb3QgJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICArIGFOZWVkbGVbYUxpbmVOYW1lXSk7XG4gICAgfVxuICAgIGlmIChhTmVlZGxlW2FDb2x1bW5OYW1lXSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NvbHVtbiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwLCBnb3QgJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICArIGFOZWVkbGVbYUNvbHVtbk5hbWVdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmluYXJ5U2VhcmNoLnNlYXJjaChhTmVlZGxlLCBhTWFwcGluZ3MsIGFDb21wYXJhdG9yLCBhQmlhcyk7XG4gIH07XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgbGFzdCBjb2x1bW4gZm9yIGVhY2ggZ2VuZXJhdGVkIG1hcHBpbmcuIFRoZSBsYXN0IGNvbHVtbiBpc1xuICogaW5jbHVzaXZlLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5jb21wdXRlQ29sdW1uU3BhbnMgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9jb21wdXRlQ29sdW1uU3BhbnMoKSB7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzLmxlbmd0aDsgKytpbmRleCkge1xuICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgIC8vIE1hcHBpbmdzIGRvIG5vdCBjb250YWluIGEgZmllbGQgZm9yIHRoZSBsYXN0IGdlbmVyYXRlZCBjb2x1bW50LiBXZVxuICAgICAgLy8gY2FuIGNvbWUgdXAgd2l0aCBhbiBvcHRpbWlzdGljIGVzdGltYXRlLCBob3dldmVyLCBieSBhc3N1bWluZyB0aGF0XG4gICAgICAvLyBtYXBwaW5ncyBhcmUgY29udGlndW91cyAoaS5lLiBnaXZlbiB0d28gY29uc2VjdXRpdmUgbWFwcGluZ3MsIHRoZVxuICAgICAgLy8gZmlyc3QgbWFwcGluZyBlbmRzIHdoZXJlIHRoZSBzZWNvbmQgb25lIHN0YXJ0cykuXG4gICAgICBpZiAoaW5kZXggKyAxIDwgdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3MubGVuZ3RoKSB7XG4gICAgICAgIHZhciBuZXh0TWFwcGluZyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzW2luZGV4ICsgMV07XG5cbiAgICAgICAgaWYgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9PT0gbmV4dE1hcHBpbmcuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgIG1hcHBpbmcubGFzdEdlbmVyYXRlZENvbHVtbiA9IG5leHRNYXBwaW5nLmdlbmVyYXRlZENvbHVtbiAtIDE7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGxhc3QgbWFwcGluZyBmb3IgZWFjaCBsaW5lIHNwYW5zIHRoZSBlbnRpcmUgbGluZS5cbiAgICAgIG1hcHBpbmcubGFzdEdlbmVyYXRlZENvbHVtbiA9IEluZmluaXR5O1xuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UsIGxpbmUsIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBnZW5lcmF0ZWRcbiAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdFxuICogd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS4gIFRoZSBsaW5lIG51bWJlclxuICogICAgIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS4gIFRoZSBjb2x1bW5cbiAqICAgICBudW1iZXIgaXMgMC1iYXNlZC5cbiAqICAgLSBiaWFzOiBFaXRoZXIgJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICogICAgICdTb3VyY2VNYXBDb25zdW1lci5MRUFTVF9VUFBFUl9CT1VORCcuIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJldHVybiB0aGVcbiAqICAgICBjbG9zZXN0IGVsZW1lbnQgdGhhdCBpcyBzbWFsbGVyIHRoYW4gb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgd2UgYXJlXG4gKiAgICAgc2VhcmNoaW5nIGZvciwgcmVzcGVjdGl2ZWx5LCBpZiB0aGUgZXhhY3QgZWxlbWVudCBjYW5ub3QgYmUgZm91bmQuXG4gKiAgICAgRGVmYXVsdHMgdG8gJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJy5cbiAqXG4gKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBzb3VyY2U6IFRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSwgb3IgbnVsbC5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC4gIFRoZVxuICogICAgIGxpbmUgbnVtYmVyIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLiAgVGhlXG4gKiAgICAgY29sdW1uIG51bWJlciBpcyAwLWJhc2VkLlxuICogICAtIG5hbWU6IFRoZSBvcmlnaW5hbCBpZGVudGlmaWVyLCBvciBudWxsLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5vcmlnaW5hbFBvc2l0aW9uRm9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfb3JpZ2luYWxQb3NpdGlvbkZvcihhQXJncykge1xuICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICBnZW5lcmF0ZWRMaW5lOiB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKSxcbiAgICAgIGdlbmVyYXRlZENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nKVxuICAgIH07XG5cbiAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kTWFwcGluZyhcbiAgICAgIG5lZWRsZSxcbiAgICAgIHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzLFxuICAgICAgXCJnZW5lcmF0ZWRMaW5lXCIsXG4gICAgICBcImdlbmVyYXRlZENvbHVtblwiLFxuICAgICAgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCxcbiAgICAgIHV0aWwuZ2V0QXJnKGFBcmdzLCAnYmlhcycsIFNvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EKVxuICAgICk7XG5cbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgIGlmIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgPT09IG5lZWRsZS5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSB1dGlsLmdldEFyZyhtYXBwaW5nLCAnc291cmNlJywgbnVsbCk7XG4gICAgICAgIGlmIChzb3VyY2UgIT09IG51bGwpIHtcbiAgICAgICAgICBzb3VyY2UgPSB0aGlzLl9zb3VyY2VzLmF0KHNvdXJjZSk7XG4gICAgICAgICAgc291cmNlID0gdXRpbC5jb21wdXRlU291cmNlVVJMKHRoaXMuc291cmNlUm9vdCwgc291cmNlLCB0aGlzLl9zb3VyY2VNYXBVUkwpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuYW1lID0gdXRpbC5nZXRBcmcobWFwcGluZywgJ25hbWUnLCBudWxsKTtcbiAgICAgICAgaWYgKG5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICBuYW1lID0gdGhpcy5fbmFtZXMuYXQobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnb3JpZ2luYWxMaW5lJywgbnVsbCksXG4gICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnb3JpZ2luYWxDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgIGxpbmU6IG51bGwsXG4gICAgICBjb2x1bW46IG51bGwsXG4gICAgICBuYW1lOiBudWxsXG4gICAgfTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB3ZSBoYXZlIHRoZSBzb3VyY2UgY29udGVudCBmb3IgZXZlcnkgc291cmNlIGluIHRoZSBzb3VyY2VcbiAqIG1hcCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5oYXNDb250ZW50c09mQWxsU291cmNlcyA9XG4gIGZ1bmN0aW9uIEJhc2ljU291cmNlTWFwQ29uc3VtZXJfaGFzQ29udGVudHNPZkFsbFNvdXJjZXMoKSB7XG4gICAgaWYgKCF0aGlzLnNvdXJjZXNDb250ZW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50Lmxlbmd0aCA+PSB0aGlzLl9zb3VyY2VzLnNpemUoKSAmJlxuICAgICAgIXRoaXMuc291cmNlc0NvbnRlbnQuc29tZShmdW5jdGlvbiAoc2MpIHsgcmV0dXJuIHNjID09IG51bGw7IH0pO1xuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50LiBUaGUgb25seSBhcmd1bWVudCBpcyB0aGUgdXJsIG9mIHRoZVxuICogb3JpZ2luYWwgc291cmNlIGZpbGUuIFJldHVybnMgbnVsbCBpZiBubyBvcmlnaW5hbCBzb3VyY2UgY29udGVudCBpc1xuICogYXZhaWxhYmxlLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5zb3VyY2VDb250ZW50Rm9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfc291cmNlQ29udGVudEZvcihhU291cmNlLCBudWxsT25NaXNzaW5nKSB7XG4gICAgaWYgKCF0aGlzLnNvdXJjZXNDb250ZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kU291cmNlSW5kZXgoYVNvdXJjZSk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W2luZGV4XTtcbiAgICB9XG5cbiAgICB2YXIgcmVsYXRpdmVTb3VyY2UgPSBhU291cmNlO1xuICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgcmVsYXRpdmVTb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuc291cmNlUm9vdCwgcmVsYXRpdmVTb3VyY2UpO1xuICAgIH1cblxuICAgIHZhciB1cmw7XG4gICAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsXG4gICAgICAgICYmICh1cmwgPSB1dGlsLnVybFBhcnNlKHRoaXMuc291cmNlUm9vdCkpKSB7XG4gICAgICAvLyBYWFg6IGZpbGU6Ly8gVVJJcyBhbmQgYWJzb2x1dGUgcGF0aHMgbGVhZCB0byB1bmV4cGVjdGVkIGJlaGF2aW9yIGZvclxuICAgICAgLy8gbWFueSB1c2Vycy4gV2UgY2FuIGhlbHAgdGhlbSBvdXQgd2hlbiB0aGV5IGV4cGVjdCBmaWxlOi8vIFVSSXMgdG9cbiAgICAgIC8vIGJlaGF2ZSBsaWtlIGl0IHdvdWxkIGlmIHRoZXkgd2VyZSBydW5uaW5nIGEgbG9jYWwgSFRUUCBzZXJ2ZXIuIFNlZVxuICAgICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9ODg1NTk3LlxuICAgICAgdmFyIGZpbGVVcmlBYnNQYXRoID0gcmVsYXRpdmVTb3VyY2UucmVwbGFjZSgvXmZpbGU6XFwvXFwvLywgXCJcIik7XG4gICAgICBpZiAodXJsLnNjaGVtZSA9PSBcImZpbGVcIlxuICAgICAgICAgICYmIHRoaXMuX3NvdXJjZXMuaGFzKGZpbGVVcmlBYnNQYXRoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudFt0aGlzLl9zb3VyY2VzLmluZGV4T2YoZmlsZVVyaUFic1BhdGgpXVxuICAgICAgfVxuXG4gICAgICBpZiAoKCF1cmwucGF0aCB8fCB1cmwucGF0aCA9PSBcIi9cIilcbiAgICAgICAgICAmJiB0aGlzLl9zb3VyY2VzLmhhcyhcIi9cIiArIHJlbGF0aXZlU291cmNlKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudFt0aGlzLl9zb3VyY2VzLmluZGV4T2YoXCIvXCIgKyByZWxhdGl2ZVNvdXJjZSldO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCByZWN1cnNpdmVseSBmcm9tXG4gICAgLy8gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5zb3VyY2VDb250ZW50Rm9yLiBJbiB0aGF0IGNhc2UsIHdlXG4gICAgLy8gZG9uJ3Qgd2FudCB0byB0aHJvdyBpZiB3ZSBjYW4ndCBmaW5kIHRoZSBzb3VyY2UgLSB3ZSBqdXN0IHdhbnQgdG9cbiAgICAvLyByZXR1cm4gbnVsbCwgc28gd2UgcHJvdmlkZSBhIGZsYWcgdG8gZXhpdCBncmFjZWZ1bGx5LlxuICAgIGlmIChudWxsT25NaXNzaW5nKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIHJlbGF0aXZlU291cmNlICsgJ1wiIGlzIG5vdCBpbiB0aGUgU291cmNlTWFwLicpO1xuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgb3JpZ2luYWwgc291cmNlLFxuICogbGluZSwgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdCB3aXRoXG4gKiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIHNvdXJjZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuICBUaGUgbGluZSBudW1iZXJcbiAqICAgICBpcyAxLWJhc2VkLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS4gIFRoZSBjb2x1bW5cbiAqICAgICBudW1iZXIgaXMgMC1iYXNlZC5cbiAqICAgLSBiaWFzOiBFaXRoZXIgJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICogICAgICdTb3VyY2VNYXBDb25zdW1lci5MRUFTVF9VUFBFUl9CT1VORCcuIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJldHVybiB0aGVcbiAqICAgICBjbG9zZXN0IGVsZW1lbnQgdGhhdCBpcyBzbWFsbGVyIHRoYW4gb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgd2UgYXJlXG4gKiAgICAgc2VhcmNoaW5nIGZvciwgcmVzcGVjdGl2ZWx5LCBpZiB0aGUgZXhhY3QgZWxlbWVudCBjYW5ub3QgYmUgZm91bmQuXG4gKiAgICAgRGVmYXVsdHMgdG8gJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJy5cbiAqXG4gKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuICBUaGVcbiAqICAgICBsaW5lIG51bWJlciBpcyAxLWJhc2VkLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgICAgVGhlIGNvbHVtbiBudW1iZXIgaXMgMC1iYXNlZC5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuZ2VuZXJhdGVkUG9zaXRpb25Gb3IgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9nZW5lcmF0ZWRQb3NpdGlvbkZvcihhQXJncykge1xuICAgIHZhciBzb3VyY2UgPSB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScpO1xuICAgIHNvdXJjZSA9IHRoaXMuX2ZpbmRTb3VyY2VJbmRleChzb3VyY2UpO1xuICAgIGlmIChzb3VyY2UgPCAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsaW5lOiBudWxsLFxuICAgICAgICBjb2x1bW46IG51bGwsXG4gICAgICAgIGxhc3RDb2x1bW46IG51bGxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgb3JpZ2luYWxMaW5lOiB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKSxcbiAgICAgIG9yaWdpbmFsQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicpXG4gICAgfTtcblxuICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmRNYXBwaW5nKFxuICAgICAgbmVlZGxlLFxuICAgICAgdGhpcy5fb3JpZ2luYWxNYXBwaW5ncyxcbiAgICAgIFwib3JpZ2luYWxMaW5lXCIsXG4gICAgICBcIm9yaWdpbmFsQ29sdW1uXCIsXG4gICAgICB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zLFxuICAgICAgdXRpbC5nZXRBcmcoYUFyZ3MsICdiaWFzJywgU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQpXG4gICAgKTtcblxuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICBpZiAobWFwcGluZy5zb3VyY2UgPT09IG5lZWRsZS5zb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkTGluZScsIG51bGwpLFxuICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZENvbHVtbicsIG51bGwpLFxuICAgICAgICAgIGxhc3RDb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdsYXN0R2VuZXJhdGVkQ29sdW1uJywgbnVsbClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGluZTogbnVsbCxcbiAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgIGxhc3RDb2x1bW46IG51bGxcbiAgICB9O1xuICB9O1xuXG5leHBvcnRzLkJhc2ljU291cmNlTWFwQ29uc3VtZXIgPSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyO1xuXG4vKipcbiAqIEFuIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lciBpbnN0YW5jZSByZXByZXNlbnRzIGEgcGFyc2VkIHNvdXJjZSBtYXAgd2hpY2hcbiAqIHdlIGNhbiBxdWVyeSBmb3IgaW5mb3JtYXRpb24uIEl0IGRpZmZlcnMgZnJvbSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyIGluXG4gKiB0aGF0IGl0IHRha2VzIFwiaW5kZXhlZFwiIHNvdXJjZSBtYXBzIChpLmUuIG9uZXMgd2l0aCBhIFwic2VjdGlvbnNcIiBmaWVsZCkgYXNcbiAqIGlucHV0LlxuICpcbiAqIFRoZSBmaXJzdCBwYXJhbWV0ZXIgaXMgYSByYXcgc291cmNlIG1hcCAoZWl0aGVyIGFzIGEgSlNPTiBzdHJpbmcsIG9yIGFscmVhZHlcbiAqIHBhcnNlZCB0byBhbiBvYmplY3QpLiBBY2NvcmRpbmcgdG8gdGhlIHNwZWMgZm9yIGluZGV4ZWQgc291cmNlIG1hcHMsIHRoZXlcbiAqIGhhdmUgdGhlIGZvbGxvd2luZyBhdHRyaWJ1dGVzOlxuICpcbiAqICAgLSB2ZXJzaW9uOiBXaGljaCB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwIHNwZWMgdGhpcyBtYXAgaXMgZm9sbG93aW5nLlxuICogICAtIGZpbGU6IE9wdGlvbmFsLiBUaGUgZ2VuZXJhdGVkIGZpbGUgdGhpcyBzb3VyY2UgbWFwIGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAqICAgLSBzZWN0aW9uczogQSBsaXN0IG9mIHNlY3Rpb24gZGVmaW5pdGlvbnMuXG4gKlxuICogRWFjaCB2YWx1ZSB1bmRlciB0aGUgXCJzZWN0aW9uc1wiIGZpZWxkIGhhcyB0d28gZmllbGRzOlxuICogICAtIG9mZnNldDogVGhlIG9mZnNldCBpbnRvIHRoZSBvcmlnaW5hbCBzcGVjaWZpZWQgYXQgd2hpY2ggdGhpcyBzZWN0aW9uXG4gKiAgICAgICBiZWdpbnMgdG8gYXBwbHksIGRlZmluZWQgYXMgYW4gb2JqZWN0IHdpdGggYSBcImxpbmVcIiBhbmQgXCJjb2x1bW5cIlxuICogICAgICAgZmllbGQuXG4gKiAgIC0gbWFwOiBBIHNvdXJjZSBtYXAgZGVmaW5pdGlvbi4gVGhpcyBzb3VyY2UgbWFwIGNvdWxkIGFsc28gYmUgaW5kZXhlZCxcbiAqICAgICAgIGJ1dCBkb2Vzbid0IGhhdmUgdG8gYmUuXG4gKlxuICogSW5zdGVhZCBvZiB0aGUgXCJtYXBcIiBmaWVsZCwgaXQncyBhbHNvIHBvc3NpYmxlIHRvIGhhdmUgYSBcInVybFwiIGZpZWxkXG4gKiBzcGVjaWZ5aW5nIGEgVVJMIHRvIHJldHJpZXZlIGEgc291cmNlIG1hcCBmcm9tLCBidXQgdGhhdCdzIGN1cnJlbnRseVxuICogdW5zdXBwb3J0ZWQuXG4gKlxuICogSGVyZSdzIGFuIGV4YW1wbGUgc291cmNlIG1hcCwgdGFrZW4gZnJvbSB0aGUgc291cmNlIG1hcCBzcGVjWzBdLCBidXRcbiAqIG1vZGlmaWVkIHRvIG9taXQgYSBzZWN0aW9uIHdoaWNoIHVzZXMgdGhlIFwidXJsXCIgZmllbGQuXG4gKlxuICogIHtcbiAqICAgIHZlcnNpb24gOiAzLFxuICogICAgZmlsZTogXCJhcHAuanNcIixcbiAqICAgIHNlY3Rpb25zOiBbe1xuICogICAgICBvZmZzZXQ6IHtsaW5lOjEwMCwgY29sdW1uOjEwfSxcbiAqICAgICAgbWFwOiB7XG4gKiAgICAgICAgdmVyc2lvbiA6IDMsXG4gKiAgICAgICAgZmlsZTogXCJzZWN0aW9uLmpzXCIsXG4gKiAgICAgICAgc291cmNlczogW1wiZm9vLmpzXCIsIFwiYmFyLmpzXCJdLFxuICogICAgICAgIG5hbWVzOiBbXCJzcmNcIiwgXCJtYXBzXCIsIFwiYXJlXCIsIFwiZnVuXCJdLFxuICogICAgICAgIG1hcHBpbmdzOiBcIkFBQUEsRTs7QUJDREU7XCJcbiAqICAgICAgfVxuICogICAgfV0sXG4gKiAgfVxuICpcbiAqIFRoZSBzZWNvbmQgcGFyYW1ldGVyLCBpZiBnaXZlbiwgaXMgYSBzdHJpbmcgd2hvc2UgdmFsdWUgaXMgdGhlIFVSTFxuICogYXQgd2hpY2ggdGhlIHNvdXJjZSBtYXAgd2FzIGZvdW5kLiAgVGhpcyBVUkwgaXMgdXNlZCB0byBjb21wdXRlIHRoZVxuICogc291cmNlcyBhcnJheS5cbiAqXG4gKiBbMF06IGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RvY3VtZW50L2QvMVUxUkdBZWhRd1J5cFVUb3ZGMUtSbHBpT0Z6ZTBiLV8yZ2M2ZkFIMEtZMGsvZWRpdCNoZWFkaW5nPWguNTM1ZXMzeGVwcmd0XG4gKi9cbmZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcihhU291cmNlTWFwLCBhU291cmNlTWFwVVJMKSB7XG4gIHZhciBzb3VyY2VNYXAgPSBhU291cmNlTWFwO1xuICBpZiAodHlwZW9mIGFTb3VyY2VNYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgc291cmNlTWFwID0gdXRpbC5wYXJzZVNvdXJjZU1hcElucHV0KGFTb3VyY2VNYXApO1xuICB9XG5cbiAgdmFyIHZlcnNpb24gPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICd2ZXJzaW9uJyk7XG4gIHZhciBzZWN0aW9ucyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NlY3Rpb25zJyk7XG5cbiAgaWYgKHZlcnNpb24gIT0gdGhpcy5fdmVyc2lvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgdmVyc2lvbjogJyArIHZlcnNpb24pO1xuICB9XG5cbiAgdGhpcy5fc291cmNlcyA9IG5ldyBBcnJheVNldCgpO1xuICB0aGlzLl9uYW1lcyA9IG5ldyBBcnJheVNldCgpO1xuXG4gIHZhciBsYXN0T2Zmc2V0ID0ge1xuICAgIGxpbmU6IC0xLFxuICAgIGNvbHVtbjogMFxuICB9O1xuICB0aGlzLl9zZWN0aW9ucyA9IHNlY3Rpb25zLm1hcChmdW5jdGlvbiAocykge1xuICAgIGlmIChzLnVybCkge1xuICAgICAgLy8gVGhlIHVybCBmaWVsZCB3aWxsIHJlcXVpcmUgc3VwcG9ydCBmb3IgYXN5bmNocm9uaWNpdHkuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc291cmNlLW1hcC9pc3N1ZXMvMTZcbiAgICAgIHRocm93IG5ldyBFcnJvcignU3VwcG9ydCBmb3IgdXJsIGZpZWxkIGluIHNlY3Rpb25zIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgICB9XG4gICAgdmFyIG9mZnNldCA9IHV0aWwuZ2V0QXJnKHMsICdvZmZzZXQnKTtcbiAgICB2YXIgb2Zmc2V0TGluZSA9IHV0aWwuZ2V0QXJnKG9mZnNldCwgJ2xpbmUnKTtcbiAgICB2YXIgb2Zmc2V0Q29sdW1uID0gdXRpbC5nZXRBcmcob2Zmc2V0LCAnY29sdW1uJyk7XG5cbiAgICBpZiAob2Zmc2V0TGluZSA8IGxhc3RPZmZzZXQubGluZSB8fFxuICAgICAgICAob2Zmc2V0TGluZSA9PT0gbGFzdE9mZnNldC5saW5lICYmIG9mZnNldENvbHVtbiA8IGxhc3RPZmZzZXQuY29sdW1uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZWN0aW9uIG9mZnNldHMgbXVzdCBiZSBvcmRlcmVkIGFuZCBub24tb3ZlcmxhcHBpbmcuJyk7XG4gICAgfVxuICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZ2VuZXJhdGVkT2Zmc2V0OiB7XG4gICAgICAgIC8vIFRoZSBvZmZzZXQgZmllbGRzIGFyZSAwLWJhc2VkLCBidXQgd2UgdXNlIDEtYmFzZWQgaW5kaWNlcyB3aGVuXG4gICAgICAgIC8vIGVuY29kaW5nL2RlY29kaW5nIGZyb20gVkxRLlxuICAgICAgICBnZW5lcmF0ZWRMaW5lOiBvZmZzZXRMaW5lICsgMSxcbiAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBvZmZzZXRDb2x1bW4gKyAxXG4gICAgICB9LFxuICAgICAgY29uc3VtZXI6IG5ldyBTb3VyY2VNYXBDb25zdW1lcih1dGlsLmdldEFyZyhzLCAnbWFwJyksIGFTb3VyY2VNYXBVUkwpXG4gICAgfVxuICB9KTtcbn1cblxuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlKTtcbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTb3VyY2VNYXBDb25zdW1lcjtcblxuLyoqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuXG4gKi9cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuXG4vKipcbiAqIFRoZSBsaXN0IG9mIG9yaWdpbmFsIHNvdXJjZXMuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnc291cmNlcycsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNvdXJjZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuX3NlY3Rpb25zW2ldLmNvbnN1bWVyLnNvdXJjZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgc291cmNlcy5wdXNoKHRoaXMuX3NlY3Rpb25zW2ldLmNvbnN1bWVyLnNvdXJjZXNbal0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc291cmNlcztcbiAgfVxufSk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlLCBsaW5lLCBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgZ2VuZXJhdGVkXG4gKiBzb3VyY2UncyBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3RcbiAqIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuICBUaGUgbGluZSBudW1iZXJcbiAqICAgICBpcyAxLWJhc2VkLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuICBUaGUgY29sdW1uXG4gKiAgICAgbnVtYmVyIGlzIDAtYmFzZWQuXG4gKlxuICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgb3JpZ2luYWwgc291cmNlIGZpbGUsIG9yIG51bGwuXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuICBUaGVcbiAqICAgICBsaW5lIG51bWJlciBpcyAxLWJhc2VkLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC4gIFRoZVxuICogICAgIGNvbHVtbiBudW1iZXIgaXMgMC1iYXNlZC5cbiAqICAgLSBuYW1lOiBUaGUgb3JpZ2luYWwgaWRlbnRpZmllciwgb3IgbnVsbC5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5vcmlnaW5hbFBvc2l0aW9uRm9yID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX29yaWdpbmFsUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgZ2VuZXJhdGVkTGluZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyksXG4gICAgICBnZW5lcmF0ZWRDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJylcbiAgICB9O1xuXG4gICAgLy8gRmluZCB0aGUgc2VjdGlvbiBjb250YWluaW5nIHRoZSBnZW5lcmF0ZWQgcG9zaXRpb24gd2UncmUgdHJ5aW5nIHRvIG1hcFxuICAgIC8vIHRvIGFuIG9yaWdpbmFsIHBvc2l0aW9uLlxuICAgIHZhciBzZWN0aW9uSW5kZXggPSBiaW5hcnlTZWFyY2guc2VhcmNoKG5lZWRsZSwgdGhpcy5fc2VjdGlvbnMsXG4gICAgICBmdW5jdGlvbihuZWVkbGUsIHNlY3Rpb24pIHtcbiAgICAgICAgdmFyIGNtcCA9IG5lZWRsZS5nZW5lcmF0ZWRMaW5lIC0gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZTtcbiAgICAgICAgaWYgKGNtcCkge1xuICAgICAgICAgIHJldHVybiBjbXA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKG5lZWRsZS5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAgICAgICAgIHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbik7XG4gICAgICB9KTtcbiAgICB2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW3NlY3Rpb25JbmRleF07XG5cbiAgICBpZiAoIXNlY3Rpb24pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgICAgbGluZTogbnVsbCxcbiAgICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgICBuYW1lOiBudWxsXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBzZWN0aW9uLmNvbnN1bWVyLm9yaWdpbmFsUG9zaXRpb25Gb3Ioe1xuICAgICAgbGluZTogbmVlZGxlLmdlbmVyYXRlZExpbmUgLVxuICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSAtIDEpLFxuICAgICAgY29sdW1uOiBuZWVkbGUuZ2VuZXJhdGVkQ29sdW1uIC1cbiAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgPT09IG5lZWRsZS5nZW5lcmF0ZWRMaW5lXG4gICAgICAgICA/IHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbiAtIDFcbiAgICAgICAgIDogMCksXG4gICAgICBiaWFzOiBhQXJncy5iaWFzXG4gICAgfSk7XG4gIH07XG5cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgd2UgaGF2ZSB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGV2ZXJ5IHNvdXJjZSBpbiB0aGUgc291cmNlXG4gKiBtYXAsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5oYXNDb250ZW50c09mQWxsU291cmNlcyA9XG4gIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9oYXNDb250ZW50c09mQWxsU291cmNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VjdGlvbnMuZXZlcnkoZnVuY3Rpb24gKHMpIHtcbiAgICAgIHJldHVybiBzLmNvbnN1bWVyLmhhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzKCk7XG4gICAgfSk7XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlIGNvbnRlbnQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIHRoZSB1cmwgb2YgdGhlXG4gKiBvcmlnaW5hbCBzb3VyY2UgZmlsZS4gUmV0dXJucyBudWxsIGlmIG5vIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50IGlzXG4gKiBhdmFpbGFibGUuXG4gKi9cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuc291cmNlQ29udGVudEZvciA9XG4gIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9zb3VyY2VDb250ZW50Rm9yKGFTb3VyY2UsIG51bGxPbk1pc3NpbmcpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW2ldO1xuXG4gICAgICB2YXIgY29udGVudCA9IHNlY3Rpb24uY29uc3VtZXIuc291cmNlQ29udGVudEZvcihhU291cmNlLCB0cnVlKTtcbiAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobnVsbE9uTWlzc2luZykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBhU291cmNlICsgJ1wiIGlzIG5vdCBpbiB0aGUgU291cmNlTWFwLicpO1xuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgb3JpZ2luYWwgc291cmNlLFxuICogbGluZSwgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdCB3aXRoXG4gKiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIHNvdXJjZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuICBUaGUgbGluZSBudW1iZXJcbiAqICAgICBpcyAxLWJhc2VkLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS4gIFRoZSBjb2x1bW5cbiAqICAgICBudW1iZXIgaXMgMC1iYXNlZC5cbiAqXG4gKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuICBUaGVcbiAqICAgICBsaW5lIG51bWJlciBpcyAxLWJhc2VkLiBcbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICogICAgIFRoZSBjb2x1bW4gbnVtYmVyIGlzIDAtYmFzZWQuXG4gKi9cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuZ2VuZXJhdGVkUG9zaXRpb25Gb3IgPVxuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfZ2VuZXJhdGVkUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW2ldO1xuXG4gICAgICAvLyBPbmx5IGNvbnNpZGVyIHRoaXMgc2VjdGlvbiBpZiB0aGUgcmVxdWVzdGVkIHNvdXJjZSBpcyBpbiB0aGUgbGlzdCBvZlxuICAgICAgLy8gc291cmNlcyBvZiB0aGUgY29uc3VtZXIuXG4gICAgICBpZiAoc2VjdGlvbi5jb25zdW1lci5fZmluZFNvdXJjZUluZGV4KHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJykpID09PSAtMSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBnZW5lcmF0ZWRQb3NpdGlvbiA9IHNlY3Rpb24uY29uc3VtZXIuZ2VuZXJhdGVkUG9zaXRpb25Gb3IoYUFyZ3MpO1xuICAgICAgaWYgKGdlbmVyYXRlZFBvc2l0aW9uKSB7XG4gICAgICAgIHZhciByZXQgPSB7XG4gICAgICAgICAgbGluZTogZ2VuZXJhdGVkUG9zaXRpb24ubGluZSArXG4gICAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSAtIDEpLFxuICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkUG9zaXRpb24uY29sdW1uICtcbiAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lID09PSBnZW5lcmF0ZWRQb3NpdGlvbi5saW5lXG4gICAgICAgICAgICAgPyBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRDb2x1bW4gLSAxXG4gICAgICAgICAgICAgOiAwKVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBsaW5lOiBudWxsLFxuICAgICAgY29sdW1uOiBudWxsXG4gICAgfTtcbiAgfTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgbWFwcGluZ3MgaW4gYSBzdHJpbmcgaW4gdG8gYSBkYXRhIHN0cnVjdHVyZSB3aGljaCB3ZSBjYW4gZWFzaWx5XG4gKiBxdWVyeSAodGhlIG9yZGVyZWQgYXJyYXlzIGluIHRoZSBgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAqIGB0aGlzLl9fb3JpZ2luYWxNYXBwaW5nc2AgcHJvcGVydGllcykuXG4gKi9cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3BhcnNlTWFwcGluZ3MgPVxuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfcGFyc2VNYXBwaW5ncyhhU3RyLCBhU291cmNlUm9vdCkge1xuICAgIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IFtdO1xuICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uc1tpXTtcbiAgICAgIHZhciBzZWN0aW9uTWFwcGluZ3MgPSBzZWN0aW9uLmNvbnN1bWVyLl9nZW5lcmF0ZWRNYXBwaW5ncztcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2VjdGlvbk1hcHBpbmdzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBtYXBwaW5nID0gc2VjdGlvbk1hcHBpbmdzW2pdO1xuXG4gICAgICAgIHZhciBzb3VyY2UgPSBzZWN0aW9uLmNvbnN1bWVyLl9zb3VyY2VzLmF0KG1hcHBpbmcuc291cmNlKTtcbiAgICAgICAgc291cmNlID0gdXRpbC5jb21wdXRlU291cmNlVVJMKHNlY3Rpb24uY29uc3VtZXIuc291cmNlUm9vdCwgc291cmNlLCB0aGlzLl9zb3VyY2VNYXBVUkwpO1xuICAgICAgICB0aGlzLl9zb3VyY2VzLmFkZChzb3VyY2UpO1xuICAgICAgICBzb3VyY2UgPSB0aGlzLl9zb3VyY2VzLmluZGV4T2Yoc291cmNlKTtcblxuICAgICAgICB2YXIgbmFtZSA9IG51bGw7XG4gICAgICAgIGlmIChtYXBwaW5nLm5hbWUpIHtcbiAgICAgICAgICBuYW1lID0gc2VjdGlvbi5jb25zdW1lci5fbmFtZXMuYXQobWFwcGluZy5uYW1lKTtcbiAgICAgICAgICB0aGlzLl9uYW1lcy5hZGQobmFtZSk7XG4gICAgICAgICAgbmFtZSA9IHRoaXMuX25hbWVzLmluZGV4T2YobmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgbWFwcGluZ3MgY29taW5nIGZyb20gdGhlIGNvbnN1bWVyIGZvciB0aGUgc2VjdGlvbiBoYXZlXG4gICAgICAgIC8vIGdlbmVyYXRlZCBwb3NpdGlvbnMgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSBzZWN0aW9uLCBzbyB3ZVxuICAgICAgICAvLyBuZWVkIHRvIG9mZnNldCB0aGVtIHRvIGJlIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGUgY29uY2F0ZW5hdGVkXG4gICAgICAgIC8vIGdlbmVyYXRlZCBmaWxlLlxuICAgICAgICB2YXIgYWRqdXN0ZWRNYXBwaW5nID0ge1xuICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgIGdlbmVyYXRlZExpbmU6IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSArXG4gICAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSAtIDEpLFxuICAgICAgICAgIGdlbmVyYXRlZENvbHVtbjogbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gK1xuICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgPT09IG1hcHBpbmcuZ2VuZXJhdGVkTGluZVxuICAgICAgICAgICAgPyBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRDb2x1bW4gLSAxXG4gICAgICAgICAgICA6IDApLFxuICAgICAgICAgIG9yaWdpbmFsTGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgb3JpZ2luYWxDb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW4sXG4gICAgICAgICAgbmFtZTogbmFtZVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncy5wdXNoKGFkanVzdGVkTWFwcGluZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYWRqdXN0ZWRNYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncy5wdXNoKGFkanVzdGVkTWFwcGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBxdWlja1NvcnQodGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkKTtcbiAgICBxdWlja1NvcnQodGhpcy5fX29yaWdpbmFsTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuICB9O1xuXG5leHBvcnRzLkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lciA9IEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcjtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIGJhc2U2NFZMUSA9IHJlcXVpcmUoJy4vYmFzZTY0LXZscScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBBcnJheVNldCA9IHJlcXVpcmUoJy4vYXJyYXktc2V0JykuQXJyYXlTZXQ7XG52YXIgTWFwcGluZ0xpc3QgPSByZXF1aXJlKCcuL21hcHBpbmctbGlzdCcpLk1hcHBpbmdMaXN0O1xuXG4vKipcbiAqIEFuIGluc3RhbmNlIG9mIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3IgcmVwcmVzZW50cyBhIHNvdXJjZSBtYXAgd2hpY2ggaXNcbiAqIGJlaW5nIGJ1aWx0IGluY3JlbWVudGFsbHkuIFlvdSBtYXkgcGFzcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nXG4gKiBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBmaWxlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gKiAgIC0gc291cmNlUm9vdDogQSByb290IGZvciBhbGwgcmVsYXRpdmUgVVJMcyBpbiB0aGlzIHNvdXJjZSBtYXAuXG4gKi9cbmZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcihhQXJncykge1xuICBpZiAoIWFBcmdzKSB7XG4gICAgYUFyZ3MgPSB7fTtcbiAgfVxuICB0aGlzLl9maWxlID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdmaWxlJywgbnVsbCk7XG4gIHRoaXMuX3NvdXJjZVJvb3QgPSB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZVJvb3QnLCBudWxsKTtcbiAgdGhpcy5fc2tpcFZhbGlkYXRpb24gPSB1dGlsLmdldEFyZyhhQXJncywgJ3NraXBWYWxpZGF0aW9uJywgZmFsc2UpO1xuICB0aGlzLl9zb3VyY2VzID0gbmV3IEFycmF5U2V0KCk7XG4gIHRoaXMuX25hbWVzID0gbmV3IEFycmF5U2V0KCk7XG4gIHRoaXMuX21hcHBpbmdzID0gbmV3IE1hcHBpbmdMaXN0KCk7XG4gIHRoaXMuX3NvdXJjZXNDb250ZW50cyA9IG51bGw7XG59XG5cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgU291cmNlTWFwR2VuZXJhdG9yIGJhc2VkIG9uIGEgU291cmNlTWFwQ29uc3VtZXJcbiAqXG4gKiBAcGFyYW0gYVNvdXJjZU1hcENvbnN1bWVyIFRoZSBTb3VyY2VNYXAuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5mcm9tU291cmNlTWFwID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2Zyb21Tb3VyY2VNYXAoYVNvdXJjZU1hcENvbnN1bWVyKSB7XG4gICAgdmFyIHNvdXJjZVJvb3QgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlUm9vdDtcbiAgICB2YXIgZ2VuZXJhdG9yID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvcih7XG4gICAgICBmaWxlOiBhU291cmNlTWFwQ29uc3VtZXIuZmlsZSxcbiAgICAgIHNvdXJjZVJvb3Q6IHNvdXJjZVJvb3RcbiAgICB9KTtcbiAgICBhU291cmNlTWFwQ29uc3VtZXIuZWFjaE1hcHBpbmcoZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgIHZhciBuZXdNYXBwaW5nID0ge1xuICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICBsaW5lOiBtYXBwaW5nLmdlbmVyYXRlZExpbmUsXG4gICAgICAgICAgY29sdW1uOiBtYXBwaW5nLmdlbmVyYXRlZENvbHVtblxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAobWFwcGluZy5zb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICBuZXdNYXBwaW5nLnNvdXJjZSA9IG1hcHBpbmcuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgbmV3TWFwcGluZy5zb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIG5ld01hcHBpbmcuc291cmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld01hcHBpbmcub3JpZ2luYWwgPSB7XG4gICAgICAgICAgbGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgY29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG1hcHBpbmcubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgbmV3TWFwcGluZy5uYW1lID0gbWFwcGluZy5uYW1lO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGdlbmVyYXRvci5hZGRNYXBwaW5nKG5ld01hcHBpbmcpO1xuICAgIH0pO1xuICAgIGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUZpbGUpIHtcbiAgICAgIHZhciBzb3VyY2VSZWxhdGl2ZSA9IHNvdXJjZUZpbGU7XG4gICAgICBpZiAoc291cmNlUm9vdCAhPT0gbnVsbCkge1xuICAgICAgICBzb3VyY2VSZWxhdGl2ZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgc291cmNlRmlsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZ2VuZXJhdG9yLl9zb3VyY2VzLmhhcyhzb3VyY2VSZWxhdGl2ZSkpIHtcbiAgICAgICAgZ2VuZXJhdG9yLl9zb3VyY2VzLmFkZChzb3VyY2VSZWxhdGl2ZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICBpZiAoY29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIGdlbmVyYXRvci5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIGNvbnRlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH07XG5cbi8qKlxuICogQWRkIGEgc2luZ2xlIG1hcHBpbmcgZnJvbSBvcmlnaW5hbCBzb3VyY2UgbGluZSBhbmQgY29sdW1uIHRvIHRoZSBnZW5lcmF0ZWRcbiAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBmb3IgdGhpcyBzb3VyY2UgbWFwIGJlaW5nIGNyZWF0ZWQuIFRoZSBtYXBwaW5nXG4gKiBvYmplY3Qgc2hvdWxkIGhhdmUgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBnZW5lcmF0ZWQ6IEFuIG9iamVjdCB3aXRoIHRoZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucy5cbiAqICAgLSBvcmlnaW5hbDogQW4gb2JqZWN0IHdpdGggdGhlIG9yaWdpbmFsIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMuXG4gKiAgIC0gc291cmNlOiBUaGUgb3JpZ2luYWwgc291cmNlIGZpbGUgKHJlbGF0aXZlIHRvIHRoZSBzb3VyY2VSb290KS5cbiAqICAgLSBuYW1lOiBBbiBvcHRpb25hbCBvcmlnaW5hbCB0b2tlbiBuYW1lIGZvciB0aGlzIG1hcHBpbmcuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuYWRkTWFwcGluZyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9hZGRNYXBwaW5nKGFBcmdzKSB7XG4gICAgdmFyIGdlbmVyYXRlZCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnZ2VuZXJhdGVkJyk7XG4gICAgdmFyIG9yaWdpbmFsID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdvcmlnaW5hbCcsIG51bGwpO1xuICAgIHZhciBzb3VyY2UgPSB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScsIG51bGwpO1xuICAgIHZhciBuYW1lID0gdXRpbC5nZXRBcmcoYUFyZ3MsICduYW1lJywgbnVsbCk7XG5cbiAgICBpZiAoIXRoaXMuX3NraXBWYWxpZGF0aW9uKSB7XG4gICAgICB0aGlzLl92YWxpZGF0ZU1hcHBpbmcoZ2VuZXJhdGVkLCBvcmlnaW5hbCwgc291cmNlLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoc291cmNlICE9IG51bGwpIHtcbiAgICAgIHNvdXJjZSA9IFN0cmluZyhzb3VyY2UpO1xuICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzLmhhcyhzb3VyY2UpKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZXMuYWRkKHNvdXJjZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgIT0gbnVsbCkge1xuICAgICAgbmFtZSA9IFN0cmluZyhuYW1lKTtcbiAgICAgIGlmICghdGhpcy5fbmFtZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgIHRoaXMuX25hbWVzLmFkZChuYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9tYXBwaW5ncy5hZGQoe1xuICAgICAgZ2VuZXJhdGVkTGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICBnZW5lcmF0ZWRDb2x1bW46IGdlbmVyYXRlZC5jb2x1bW4sXG4gICAgICBvcmlnaW5hbExpbmU6IG9yaWdpbmFsICE9IG51bGwgJiYgb3JpZ2luYWwubGluZSxcbiAgICAgIG9yaWdpbmFsQ29sdW1uOiBvcmlnaW5hbCAhPSBudWxsICYmIG9yaWdpbmFsLmNvbHVtbixcbiAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgbmFtZTogbmFtZVxuICAgIH0pO1xuICB9O1xuXG4vKipcbiAqIFNldCB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGEgc291cmNlIGZpbGUuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuc2V0U291cmNlQ29udGVudCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9zZXRTb3VyY2VDb250ZW50KGFTb3VyY2VGaWxlLCBhU291cmNlQ29udGVudCkge1xuICAgIHZhciBzb3VyY2UgPSBhU291cmNlRmlsZTtcbiAgICBpZiAodGhpcy5fc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICBzb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuX3NvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgfVxuXG4gICAgaWYgKGFTb3VyY2VDb250ZW50ICE9IG51bGwpIHtcbiAgICAgIC8vIEFkZCB0aGUgc291cmNlIGNvbnRlbnQgdG8gdGhlIF9zb3VyY2VzQ29udGVudHMgbWFwLlxuICAgICAgLy8gQ3JlYXRlIGEgbmV3IF9zb3VyY2VzQ29udGVudHMgbWFwIGlmIHRoZSBwcm9wZXJ0eSBpcyBudWxsLlxuICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgICAgdGhpcy5fc291cmNlc0NvbnRlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSldID0gYVNvdXJjZUNvbnRlbnQ7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgIC8vIFJlbW92ZSB0aGUgc291cmNlIGZpbGUgZnJvbSB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAuXG4gICAgICAvLyBJZiB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAgaXMgZW1wdHksIHNldCB0aGUgcHJvcGVydHkgdG8gbnVsbC5cbiAgICAgIGRlbGV0ZSB0aGlzLl9zb3VyY2VzQ29udGVudHNbdXRpbC50b1NldFN0cmluZyhzb3VyY2UpXTtcbiAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLl9zb3VyY2VzQ29udGVudHMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBBcHBsaWVzIHRoZSBtYXBwaW5ncyBvZiBhIHN1Yi1zb3VyY2UtbWFwIGZvciBhIHNwZWNpZmljIHNvdXJjZSBmaWxlIHRvIHRoZVxuICogc291cmNlIG1hcCBiZWluZyBnZW5lcmF0ZWQuIEVhY2ggbWFwcGluZyB0byB0aGUgc3VwcGxpZWQgc291cmNlIGZpbGUgaXNcbiAqIHJld3JpdHRlbiB1c2luZyB0aGUgc3VwcGxpZWQgc291cmNlIG1hcC4gTm90ZTogVGhlIHJlc29sdXRpb24gZm9yIHRoZVxuICogcmVzdWx0aW5nIG1hcHBpbmdzIGlzIHRoZSBtaW5pbWl1bSBvZiB0aGlzIG1hcCBhbmQgdGhlIHN1cHBsaWVkIG1hcC5cbiAqXG4gKiBAcGFyYW0gYVNvdXJjZU1hcENvbnN1bWVyIFRoZSBzb3VyY2UgbWFwIHRvIGJlIGFwcGxpZWQuXG4gKiBAcGFyYW0gYVNvdXJjZUZpbGUgT3B0aW9uYWwuIFRoZSBmaWxlbmFtZSBvZiB0aGUgc291cmNlIGZpbGUuXG4gKiAgICAgICAgSWYgb21pdHRlZCwgU291cmNlTWFwQ29uc3VtZXIncyBmaWxlIHByb3BlcnR5IHdpbGwgYmUgdXNlZC5cbiAqIEBwYXJhbSBhU291cmNlTWFwUGF0aCBPcHRpb25hbC4gVGhlIGRpcm5hbWUgb2YgdGhlIHBhdGggdG8gdGhlIHNvdXJjZSBtYXBcbiAqICAgICAgICB0byBiZSBhcHBsaWVkLiBJZiByZWxhdGl2ZSwgaXQgaXMgcmVsYXRpdmUgdG8gdGhlIFNvdXJjZU1hcENvbnN1bWVyLlxuICogICAgICAgIFRoaXMgcGFyYW1ldGVyIGlzIG5lZWRlZCB3aGVuIHRoZSB0d28gc291cmNlIG1hcHMgYXJlbid0IGluIHRoZSBzYW1lXG4gKiAgICAgICAgZGlyZWN0b3J5LCBhbmQgdGhlIHNvdXJjZSBtYXAgdG8gYmUgYXBwbGllZCBjb250YWlucyByZWxhdGl2ZSBzb3VyY2VcbiAqICAgICAgICBwYXRocy4gSWYgc28sIHRob3NlIHJlbGF0aXZlIHNvdXJjZSBwYXRocyBuZWVkIHRvIGJlIHJld3JpdHRlblxuICogICAgICAgIHJlbGF0aXZlIHRvIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3IuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuYXBwbHlTb3VyY2VNYXAgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfYXBwbHlTb3VyY2VNYXAoYVNvdXJjZU1hcENvbnN1bWVyLCBhU291cmNlRmlsZSwgYVNvdXJjZU1hcFBhdGgpIHtcbiAgICB2YXIgc291cmNlRmlsZSA9IGFTb3VyY2VGaWxlO1xuICAgIC8vIElmIGFTb3VyY2VGaWxlIGlzIG9taXR0ZWQsIHdlIHdpbGwgdXNlIHRoZSBmaWxlIHByb3BlcnR5IG9mIHRoZSBTb3VyY2VNYXBcbiAgICBpZiAoYVNvdXJjZUZpbGUgPT0gbnVsbCkge1xuICAgICAgaWYgKGFTb3VyY2VNYXBDb25zdW1lci5maWxlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFwcGx5U291cmNlTWFwIHJlcXVpcmVzIGVpdGhlciBhbiBleHBsaWNpdCBzb3VyY2UgZmlsZSwgJyArXG4gICAgICAgICAgJ29yIHRoZSBzb3VyY2UgbWFwXFwncyBcImZpbGVcIiBwcm9wZXJ0eS4gQm90aCB3ZXJlIG9taXR0ZWQuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgc291cmNlRmlsZSA9IGFTb3VyY2VNYXBDb25zdW1lci5maWxlO1xuICAgIH1cbiAgICB2YXIgc291cmNlUm9vdCA9IHRoaXMuX3NvdXJjZVJvb3Q7XG4gICAgLy8gTWFrZSBcInNvdXJjZUZpbGVcIiByZWxhdGl2ZSBpZiBhbiBhYnNvbHV0ZSBVcmwgaXMgcGFzc2VkLlxuICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIHNvdXJjZUZpbGUpO1xuICAgIH1cbiAgICAvLyBBcHBseWluZyB0aGUgU291cmNlTWFwIGNhbiBhZGQgYW5kIHJlbW92ZSBpdGVtcyBmcm9tIHRoZSBzb3VyY2VzIGFuZFxuICAgIC8vIHRoZSBuYW1lcyBhcnJheS5cbiAgICB2YXIgbmV3U291cmNlcyA9IG5ldyBBcnJheVNldCgpO1xuICAgIHZhciBuZXdOYW1lcyA9IG5ldyBBcnJheVNldCgpO1xuXG4gICAgLy8gRmluZCBtYXBwaW5ncyBmb3IgdGhlIFwic291cmNlRmlsZVwiXG4gICAgdGhpcy5fbWFwcGluZ3MudW5zb3J0ZWRGb3JFYWNoKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICBpZiAobWFwcGluZy5zb3VyY2UgPT09IHNvdXJjZUZpbGUgJiYgbWFwcGluZy5vcmlnaW5hbExpbmUgIT0gbnVsbCkge1xuICAgICAgICAvLyBDaGVjayBpZiBpdCBjYW4gYmUgbWFwcGVkIGJ5IHRoZSBzb3VyY2UgbWFwLCB0aGVuIHVwZGF0ZSB0aGUgbWFwcGluZy5cbiAgICAgICAgdmFyIG9yaWdpbmFsID0gYVNvdXJjZU1hcENvbnN1bWVyLm9yaWdpbmFsUG9zaXRpb25Gb3Ioe1xuICAgICAgICAgIGxpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG9yaWdpbmFsLnNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gQ29weSBtYXBwaW5nXG4gICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBvcmlnaW5hbC5zb3VyY2U7XG4gICAgICAgICAgaWYgKGFTb3VyY2VNYXBQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gdXRpbC5qb2luKGFTb3VyY2VNYXBQYXRoLCBtYXBwaW5nLnNvdXJjZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIG1hcHBpbmcuc291cmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgPSBvcmlnaW5hbC5saW5lO1xuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBvcmlnaW5hbC5jb2x1bW47XG4gICAgICAgICAgaWYgKG9yaWdpbmFsLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWFwcGluZy5uYW1lID0gb3JpZ2luYWwubmFtZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZSA9IG1hcHBpbmcuc291cmNlO1xuICAgICAgaWYgKHNvdXJjZSAhPSBudWxsICYmICFuZXdTb3VyY2VzLmhhcyhzb3VyY2UpKSB7XG4gICAgICAgIG5ld1NvdXJjZXMuYWRkKHNvdXJjZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBuYW1lID0gbWFwcGluZy5uYW1lO1xuICAgICAgaWYgKG5hbWUgIT0gbnVsbCAmJiAhbmV3TmFtZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgIG5ld05hbWVzLmFkZChuYW1lKTtcbiAgICAgIH1cblxuICAgIH0sIHRoaXMpO1xuICAgIHRoaXMuX3NvdXJjZXMgPSBuZXdTb3VyY2VzO1xuICAgIHRoaXMuX25hbWVzID0gbmV3TmFtZXM7XG5cbiAgICAvLyBDb3B5IHNvdXJjZXNDb250ZW50cyBvZiBhcHBsaWVkIG1hcC5cbiAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICB2YXIgY29udGVudCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKHNvdXJjZUZpbGUpO1xuICAgICAgaWYgKGNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBpZiAoYVNvdXJjZU1hcFBhdGggIT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLmpvaW4oYVNvdXJjZU1hcFBhdGgsIHNvdXJjZUZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICBzb3VyY2VGaWxlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBzb3VyY2VGaWxlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gIH07XG5cbi8qKlxuICogQSBtYXBwaW5nIGNhbiBoYXZlIG9uZSBvZiB0aGUgdGhyZWUgbGV2ZWxzIG9mIGRhdGE6XG4gKlxuICogICAxLiBKdXN0IHRoZSBnZW5lcmF0ZWQgcG9zaXRpb24uXG4gKiAgIDIuIFRoZSBHZW5lcmF0ZWQgcG9zaXRpb24sIG9yaWdpbmFsIHBvc2l0aW9uLCBhbmQgb3JpZ2luYWwgc291cmNlLlxuICogICAzLiBHZW5lcmF0ZWQgYW5kIG9yaWdpbmFsIHBvc2l0aW9uLCBvcmlnaW5hbCBzb3VyY2UsIGFzIHdlbGwgYXMgYSBuYW1lXG4gKiAgICAgIHRva2VuLlxuICpcbiAqIFRvIG1haW50YWluIGNvbnNpc3RlbmN5LCB3ZSB2YWxpZGF0ZSB0aGF0IGFueSBuZXcgbWFwcGluZyBiZWluZyBhZGRlZCBmYWxsc1xuICogaW4gdG8gb25lIG9mIHRoZXNlIGNhdGVnb3JpZXMuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3ZhbGlkYXRlTWFwcGluZyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl92YWxpZGF0ZU1hcHBpbmcoYUdlbmVyYXRlZCwgYU9yaWdpbmFsLCBhU291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFOYW1lKSB7XG4gICAgLy8gV2hlbiBhT3JpZ2luYWwgaXMgdHJ1dGh5IGJ1dCBoYXMgZW1wdHkgdmFsdWVzIGZvciAubGluZSBhbmQgLmNvbHVtbixcbiAgICAvLyBpdCBpcyBtb3N0IGxpa2VseSBhIHByb2dyYW1tZXIgZXJyb3IuIEluIHRoaXMgY2FzZSB3ZSB0aHJvdyBhIHZlcnlcbiAgICAvLyBzcGVjaWZpYyBlcnJvciBtZXNzYWdlIHRvIHRyeSB0byBndWlkZSB0aGVtIHRoZSByaWdodCB3YXkuXG4gICAgLy8gRm9yIGV4YW1wbGU6IGh0dHBzOi8vZ2l0aHViLmNvbS9Qb2x5bWVyL3BvbHltZXItYnVuZGxlci9wdWxsLzUxOVxuICAgIGlmIChhT3JpZ2luYWwgJiYgdHlwZW9mIGFPcmlnaW5hbC5saW5lICE9PSAnbnVtYmVyJyAmJiB0eXBlb2YgYU9yaWdpbmFsLmNvbHVtbiAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ29yaWdpbmFsLmxpbmUgYW5kIG9yaWdpbmFsLmNvbHVtbiBhcmUgbm90IG51bWJlcnMgLS0geW91IHByb2JhYmx5IG1lYW50IHRvIG9taXQgJyArXG4gICAgICAgICAgICAndGhlIG9yaWdpbmFsIG1hcHBpbmcgZW50aXJlbHkgYW5kIG9ubHkgbWFwIHRoZSBnZW5lcmF0ZWQgcG9zaXRpb24uIElmIHNvLCBwYXNzICcgK1xuICAgICAgICAgICAgJ251bGwgZm9yIHRoZSBvcmlnaW5hbCBtYXBwaW5nIGluc3RlYWQgb2YgYW4gb2JqZWN0IHdpdGggZW1wdHkgb3IgbnVsbCB2YWx1ZXMuJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIGlmIChhR2VuZXJhdGVkICYmICdsaW5lJyBpbiBhR2VuZXJhdGVkICYmICdjb2x1bW4nIGluIGFHZW5lcmF0ZWRcbiAgICAgICAgJiYgYUdlbmVyYXRlZC5saW5lID4gMCAmJiBhR2VuZXJhdGVkLmNvbHVtbiA+PSAwXG4gICAgICAgICYmICFhT3JpZ2luYWwgJiYgIWFTb3VyY2UgJiYgIWFOYW1lKSB7XG4gICAgICAvLyBDYXNlIDEuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2UgaWYgKGFHZW5lcmF0ZWQgJiYgJ2xpbmUnIGluIGFHZW5lcmF0ZWQgJiYgJ2NvbHVtbicgaW4gYUdlbmVyYXRlZFxuICAgICAgICAgICAgICYmIGFPcmlnaW5hbCAmJiAnbGluZScgaW4gYU9yaWdpbmFsICYmICdjb2x1bW4nIGluIGFPcmlnaW5hbFxuICAgICAgICAgICAgICYmIGFHZW5lcmF0ZWQubGluZSA+IDAgJiYgYUdlbmVyYXRlZC5jb2x1bW4gPj0gMFxuICAgICAgICAgICAgICYmIGFPcmlnaW5hbC5saW5lID4gMCAmJiBhT3JpZ2luYWwuY29sdW1uID49IDBcbiAgICAgICAgICAgICAmJiBhU291cmNlKSB7XG4gICAgICAvLyBDYXNlcyAyIGFuZCAzLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtYXBwaW5nOiAnICsgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBnZW5lcmF0ZWQ6IGFHZW5lcmF0ZWQsXG4gICAgICAgIHNvdXJjZTogYVNvdXJjZSxcbiAgICAgICAgb3JpZ2luYWw6IGFPcmlnaW5hbCxcbiAgICAgICAgbmFtZTogYU5hbWVcbiAgICAgIH0pKTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogU2VyaWFsaXplIHRoZSBhY2N1bXVsYXRlZCBtYXBwaW5ncyBpbiB0byB0aGUgc3RyZWFtIG9mIGJhc2UgNjQgVkxRc1xuICogc3BlY2lmaWVkIGJ5IHRoZSBzb3VyY2UgbWFwIGZvcm1hdC5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fc2VyaWFsaXplTWFwcGluZ3MgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3Jfc2VyaWFsaXplTWFwcGluZ3MoKSB7XG4gICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICB2YXIgcHJldmlvdXNHZW5lcmF0ZWRMaW5lID0gMTtcbiAgICB2YXIgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IDA7XG4gICAgdmFyIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gMDtcbiAgICB2YXIgcHJldmlvdXNOYW1lID0gMDtcbiAgICB2YXIgcHJldmlvdXNTb3VyY2UgPSAwO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgbmV4dDtcbiAgICB2YXIgbWFwcGluZztcbiAgICB2YXIgbmFtZUlkeDtcbiAgICB2YXIgc291cmNlSWR4O1xuXG4gICAgdmFyIG1hcHBpbmdzID0gdGhpcy5fbWFwcGluZ3MudG9BcnJheSgpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBtYXBwaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgbWFwcGluZyA9IG1hcHBpbmdzW2ldO1xuICAgICAgbmV4dCA9ICcnXG5cbiAgICAgIGlmIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgIT09IHByZXZpb3VzR2VuZXJhdGVkTGluZSkge1xuICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICAgIHdoaWxlIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgIT09IHByZXZpb3VzR2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgIG5leHQgKz0gJzsnO1xuICAgICAgICAgIHByZXZpb3VzR2VuZXJhdGVkTGluZSsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgaWYgKCF1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKG1hcHBpbmcsIG1hcHBpbmdzW2kgLSAxXSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZXh0ICs9ICcsJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcblxuICAgICAgaWYgKG1hcHBpbmcuc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgc291cmNlSWR4ID0gdGhpcy5fc291cmNlcy5pbmRleE9mKG1hcHBpbmcuc291cmNlKTtcbiAgICAgICAgbmV4dCArPSBiYXNlNjRWTFEuZW5jb2RlKHNvdXJjZUlkeCAtIHByZXZpb3VzU291cmNlKTtcbiAgICAgICAgcHJldmlvdXNTb3VyY2UgPSBzb3VyY2VJZHg7XG5cbiAgICAgICAgLy8gbGluZXMgYXJlIHN0b3JlZCAwLWJhc2VkIGluIFNvdXJjZU1hcCBzcGVjIHZlcnNpb24gM1xuICAgICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5vcmlnaW5hbExpbmUgLSAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNPcmlnaW5hbExpbmUpO1xuICAgICAgICBwcmV2aW91c09yaWdpbmFsTGluZSA9IG1hcHBpbmcub3JpZ2luYWxMaW5lIC0gMTtcblxuICAgICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4pO1xuICAgICAgICBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gbWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICBpZiAobWFwcGluZy5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICBuYW1lSWR4ID0gdGhpcy5fbmFtZXMuaW5kZXhPZihtYXBwaW5nLm5hbWUpO1xuICAgICAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShuYW1lSWR4IC0gcHJldmlvdXNOYW1lKTtcbiAgICAgICAgICBwcmV2aW91c05hbWUgPSBuYW1lSWR4O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdCArPSBuZXh0O1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfZ2VuZXJhdGVTb3VyY2VzQ29udGVudChhU291cmNlcywgYVNvdXJjZVJvb3QpIHtcbiAgICByZXR1cm4gYVNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIGlmICghdGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGFTb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgc291cmNlID0gdXRpbC5yZWxhdGl2ZShhU291cmNlUm9vdCwgc291cmNlKTtcbiAgICAgIH1cbiAgICAgIHZhciBrZXkgPSB1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSk7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuX3NvdXJjZXNDb250ZW50cywga2V5KVxuICAgICAgICA/IHRoaXMuX3NvdXJjZXNDb250ZW50c1trZXldXG4gICAgICAgIDogbnVsbDtcbiAgICB9LCB0aGlzKTtcbiAgfTtcblxuLyoqXG4gKiBFeHRlcm5hbGl6ZSB0aGUgc291cmNlIG1hcC5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS50b0pTT04gPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfdG9KU09OKCkge1xuICAgIHZhciBtYXAgPSB7XG4gICAgICB2ZXJzaW9uOiB0aGlzLl92ZXJzaW9uLFxuICAgICAgc291cmNlczogdGhpcy5fc291cmNlcy50b0FycmF5KCksXG4gICAgICBuYW1lczogdGhpcy5fbmFtZXMudG9BcnJheSgpLFxuICAgICAgbWFwcGluZ3M6IHRoaXMuX3NlcmlhbGl6ZU1hcHBpbmdzKClcbiAgICB9O1xuICAgIGlmICh0aGlzLl9maWxlICE9IG51bGwpIHtcbiAgICAgIG1hcC5maWxlID0gdGhpcy5fZmlsZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3NvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgbWFwLnNvdXJjZVJvb3QgPSB0aGlzLl9zb3VyY2VSb290O1xuICAgIH1cbiAgICBpZiAodGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICBtYXAuc291cmNlc0NvbnRlbnQgPSB0aGlzLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KG1hcC5zb3VyY2VzLCBtYXAuc291cmNlUm9vdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcDtcbiAgfTtcblxuLyoqXG4gKiBSZW5kZXIgdGhlIHNvdXJjZSBtYXAgYmVpbmcgZ2VuZXJhdGVkIHRvIGEgc3RyaW5nLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnRvU3RyaW5nID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3RvU3RyaW5nKCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnRvSlNPTigpKTtcbiAgfTtcblxuZXhwb3J0cy5Tb3VyY2VNYXBHZW5lcmF0b3IgPSBTb3VyY2VNYXBHZW5lcmF0b3I7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciBTb3VyY2VNYXBHZW5lcmF0b3IgPSByZXF1aXJlKCcuL3NvdXJjZS1tYXAtZ2VuZXJhdG9yJykuU291cmNlTWFwR2VuZXJhdG9yO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuLy8gTWF0Y2hlcyBhIFdpbmRvd3Mtc3R5bGUgYFxcclxcbmAgbmV3bGluZSBvciBhIGBcXG5gIG5ld2xpbmUgdXNlZCBieSBhbGwgb3RoZXJcbi8vIG9wZXJhdGluZyBzeXN0ZW1zIHRoZXNlIGRheXMgKGNhcHR1cmluZyB0aGUgcmVzdWx0KS5cbnZhciBSRUdFWF9ORVdMSU5FID0gLyhcXHI/XFxuKS87XG5cbi8vIE5ld2xpbmUgY2hhcmFjdGVyIGNvZGUgZm9yIGNoYXJDb2RlQXQoKSBjb21wYXJpc29uc1xudmFyIE5FV0xJTkVfQ09ERSA9IDEwO1xuXG4vLyBQcml2YXRlIHN5bWJvbCBmb3IgaWRlbnRpZnlpbmcgYFNvdXJjZU5vZGVgcyB3aGVuIG11bHRpcGxlIHZlcnNpb25zIG9mXG4vLyB0aGUgc291cmNlLW1hcCBsaWJyYXJ5IGFyZSBsb2FkZWQuIFRoaXMgTVVTVCBOT1QgQ0hBTkdFIGFjcm9zc1xuLy8gdmVyc2lvbnMhXG52YXIgaXNTb3VyY2VOb2RlID0gXCIkJCRpc1NvdXJjZU5vZGUkJCRcIjtcblxuLyoqXG4gKiBTb3VyY2VOb2RlcyBwcm92aWRlIGEgd2F5IHRvIGFic3RyYWN0IG92ZXIgaW50ZXJwb2xhdGluZy9jb25jYXRlbmF0aW5nXG4gKiBzbmlwcGV0cyBvZiBnZW5lcmF0ZWQgSmF2YVNjcmlwdCBzb3VyY2UgY29kZSB3aGlsZSBtYWludGFpbmluZyB0aGUgbGluZSBhbmRcbiAqIGNvbHVtbiBpbmZvcm1hdGlvbiBhc3NvY2lhdGVkIHdpdGggdGhlIG9yaWdpbmFsIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwYXJhbSBhTGluZSBUaGUgb3JpZ2luYWwgbGluZSBudW1iZXIuXG4gKiBAcGFyYW0gYUNvbHVtbiBUaGUgb3JpZ2luYWwgY29sdW1uIG51bWJlci5cbiAqIEBwYXJhbSBhU291cmNlIFRoZSBvcmlnaW5hbCBzb3VyY2UncyBmaWxlbmFtZS5cbiAqIEBwYXJhbSBhQ2h1bmtzIE9wdGlvbmFsLiBBbiBhcnJheSBvZiBzdHJpbmdzIHdoaWNoIGFyZSBzbmlwcGV0cyBvZlxuICogICAgICAgIGdlbmVyYXRlZCBKUywgb3Igb3RoZXIgU291cmNlTm9kZXMuXG4gKiBAcGFyYW0gYU5hbWUgVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIuXG4gKi9cbmZ1bmN0aW9uIFNvdXJjZU5vZGUoYUxpbmUsIGFDb2x1bW4sIGFTb3VyY2UsIGFDaHVua3MsIGFOYW1lKSB7XG4gIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgdGhpcy5zb3VyY2VDb250ZW50cyA9IHt9O1xuICB0aGlzLmxpbmUgPSBhTGluZSA9PSBudWxsID8gbnVsbCA6IGFMaW5lO1xuICB0aGlzLmNvbHVtbiA9IGFDb2x1bW4gPT0gbnVsbCA/IG51bGwgOiBhQ29sdW1uO1xuICB0aGlzLnNvdXJjZSA9IGFTb3VyY2UgPT0gbnVsbCA/IG51bGwgOiBhU291cmNlO1xuICB0aGlzLm5hbWUgPSBhTmFtZSA9PSBudWxsID8gbnVsbCA6IGFOYW1lO1xuICB0aGlzW2lzU291cmNlTm9kZV0gPSB0cnVlO1xuICBpZiAoYUNodW5rcyAhPSBudWxsKSB0aGlzLmFkZChhQ2h1bmtzKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgU291cmNlTm9kZSBmcm9tIGdlbmVyYXRlZCBjb2RlIGFuZCBhIFNvdXJjZU1hcENvbnN1bWVyLlxuICpcbiAqIEBwYXJhbSBhR2VuZXJhdGVkQ29kZSBUaGUgZ2VuZXJhdGVkIGNvZGVcbiAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIFNvdXJjZU1hcCBmb3IgdGhlIGdlbmVyYXRlZCBjb2RlXG4gKiBAcGFyYW0gYVJlbGF0aXZlUGF0aCBPcHRpb25hbC4gVGhlIHBhdGggdGhhdCByZWxhdGl2ZSBzb3VyY2VzIGluIHRoZVxuICogICAgICAgIFNvdXJjZU1hcENvbnN1bWVyIHNob3VsZCBiZSByZWxhdGl2ZSB0by5cbiAqL1xuU291cmNlTm9kZS5mcm9tU3RyaW5nV2l0aFNvdXJjZU1hcCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU5vZGVfZnJvbVN0cmluZ1dpdGhTb3VyY2VNYXAoYUdlbmVyYXRlZENvZGUsIGFTb3VyY2VNYXBDb25zdW1lciwgYVJlbGF0aXZlUGF0aCkge1xuICAgIC8vIFRoZSBTb3VyY2VOb2RlIHdlIHdhbnQgdG8gZmlsbCB3aXRoIHRoZSBnZW5lcmF0ZWQgY29kZVxuICAgIC8vIGFuZCB0aGUgU291cmNlTWFwXG4gICAgdmFyIG5vZGUgPSBuZXcgU291cmNlTm9kZSgpO1xuXG4gICAgLy8gQWxsIGV2ZW4gaW5kaWNlcyBvZiB0aGlzIGFycmF5IGFyZSBvbmUgbGluZSBvZiB0aGUgZ2VuZXJhdGVkIGNvZGUsXG4gICAgLy8gd2hpbGUgYWxsIG9kZCBpbmRpY2VzIGFyZSB0aGUgbmV3bGluZXMgYmV0d2VlbiB0d28gYWRqYWNlbnQgbGluZXNcbiAgICAvLyAoc2luY2UgYFJFR0VYX05FV0xJTkVgIGNhcHR1cmVzIGl0cyBtYXRjaCkuXG4gICAgLy8gUHJvY2Vzc2VkIGZyYWdtZW50cyBhcmUgYWNjZXNzZWQgYnkgY2FsbGluZyBgc2hpZnROZXh0TGluZWAuXG4gICAgdmFyIHJlbWFpbmluZ0xpbmVzID0gYUdlbmVyYXRlZENvZGUuc3BsaXQoUkVHRVhfTkVXTElORSk7XG4gICAgdmFyIHJlbWFpbmluZ0xpbmVzSW5kZXggPSAwO1xuICAgIHZhciBzaGlmdE5leHRMaW5lID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGluZUNvbnRlbnRzID0gZ2V0TmV4dExpbmUoKTtcbiAgICAgIC8vIFRoZSBsYXN0IGxpbmUgb2YgYSBmaWxlIG1pZ2h0IG5vdCBoYXZlIGEgbmV3bGluZS5cbiAgICAgIHZhciBuZXdMaW5lID0gZ2V0TmV4dExpbmUoKSB8fCBcIlwiO1xuICAgICAgcmV0dXJuIGxpbmVDb250ZW50cyArIG5ld0xpbmU7XG5cbiAgICAgIGZ1bmN0aW9uIGdldE5leHRMaW5lKCkge1xuICAgICAgICByZXR1cm4gcmVtYWluaW5nTGluZXNJbmRleCA8IHJlbWFpbmluZ0xpbmVzLmxlbmd0aCA/XG4gICAgICAgICAgICByZW1haW5pbmdMaW5lc1tyZW1haW5pbmdMaW5lc0luZGV4KytdIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBXZSBuZWVkIHRvIHJlbWVtYmVyIHRoZSBwb3NpdGlvbiBvZiBcInJlbWFpbmluZ0xpbmVzXCJcbiAgICB2YXIgbGFzdEdlbmVyYXRlZExpbmUgPSAxLCBsYXN0R2VuZXJhdGVkQ29sdW1uID0gMDtcblxuICAgIC8vIFRoZSBnZW5lcmF0ZSBTb3VyY2VOb2RlcyB3ZSBuZWVkIGEgY29kZSByYW5nZS5cbiAgICAvLyBUbyBleHRyYWN0IGl0IGN1cnJlbnQgYW5kIGxhc3QgbWFwcGluZyBpcyB1c2VkLlxuICAgIC8vIEhlcmUgd2Ugc3RvcmUgdGhlIGxhc3QgbWFwcGluZy5cbiAgICB2YXIgbGFzdE1hcHBpbmcgPSBudWxsO1xuXG4gICAgYVNvdXJjZU1hcENvbnN1bWVyLmVhY2hNYXBwaW5nKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICBpZiAobGFzdE1hcHBpbmcgIT09IG51bGwpIHtcbiAgICAgICAgLy8gV2UgYWRkIHRoZSBjb2RlIGZyb20gXCJsYXN0TWFwcGluZ1wiIHRvIFwibWFwcGluZ1wiOlxuICAgICAgICAvLyBGaXJzdCBjaGVjayBpZiB0aGVyZSBpcyBhIG5ldyBsaW5lIGluIGJldHdlZW4uXG4gICAgICAgIGlmIChsYXN0R2VuZXJhdGVkTGluZSA8IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgIC8vIEFzc29jaWF0ZSBmaXJzdCBsaW5lIHdpdGggXCJsYXN0TWFwcGluZ1wiXG4gICAgICAgICAgYWRkTWFwcGluZ1dpdGhDb2RlKGxhc3RNYXBwaW5nLCBzaGlmdE5leHRMaW5lKCkpO1xuICAgICAgICAgIGxhc3RHZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICAgICAgLy8gVGhlIHJlbWFpbmluZyBjb2RlIGlzIGFkZGVkIHdpdGhvdXQgbWFwcGluZ1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIG5ldyBsaW5lIGluIGJldHdlZW4uXG4gICAgICAgICAgLy8gQXNzb2NpYXRlIHRoZSBjb2RlIGJldHdlZW4gXCJsYXN0R2VuZXJhdGVkQ29sdW1uXCIgYW5kXG4gICAgICAgICAgLy8gXCJtYXBwaW5nLmdlbmVyYXRlZENvbHVtblwiIHdpdGggXCJsYXN0TWFwcGluZ1wiXG4gICAgICAgICAgdmFyIG5leHRMaW5lID0gcmVtYWluaW5nTGluZXNbcmVtYWluaW5nTGluZXNJbmRleF0gfHwgJyc7XG4gICAgICAgICAgdmFyIGNvZGUgPSBuZXh0TGluZS5zdWJzdHIoMCwgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICAgIHJlbWFpbmluZ0xpbmVzW3JlbWFpbmluZ0xpbmVzSW5kZXhdID0gbmV4dExpbmUuc3Vic3RyKG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG4gICAgICAgICAgYWRkTWFwcGluZ1dpdGhDb2RlKGxhc3RNYXBwaW5nLCBjb2RlKTtcbiAgICAgICAgICAvLyBObyBtb3JlIHJlbWFpbmluZyBjb2RlLCBjb250aW51ZVxuICAgICAgICAgIGxhc3RNYXBwaW5nID0gbWFwcGluZztcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFdlIGFkZCB0aGUgZ2VuZXJhdGVkIGNvZGUgdW50aWwgdGhlIGZpcnN0IG1hcHBpbmdcbiAgICAgIC8vIHRvIHRoZSBTb3VyY2VOb2RlIHdpdGhvdXQgYW55IG1hcHBpbmcuXG4gICAgICAvLyBFYWNoIGxpbmUgaXMgYWRkZWQgYXMgc2VwYXJhdGUgc3RyaW5nLlxuICAgICAgd2hpbGUgKGxhc3RHZW5lcmF0ZWRMaW5lIDwgbWFwcGluZy5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgIG5vZGUuYWRkKHNoaWZ0TmV4dExpbmUoKSk7XG4gICAgICAgIGxhc3RHZW5lcmF0ZWRMaW5lKys7XG4gICAgICB9XG4gICAgICBpZiAobGFzdEdlbmVyYXRlZENvbHVtbiA8IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKSB7XG4gICAgICAgIHZhciBuZXh0TGluZSA9IHJlbWFpbmluZ0xpbmVzW3JlbWFpbmluZ0xpbmVzSW5kZXhdIHx8ICcnO1xuICAgICAgICBub2RlLmFkZChuZXh0TGluZS5zdWJzdHIoMCwgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4pKTtcbiAgICAgICAgcmVtYWluaW5nTGluZXNbcmVtYWluaW5nTGluZXNJbmRleF0gPSBuZXh0TGluZS5zdWJzdHIobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG4gICAgICB9XG4gICAgICBsYXN0TWFwcGluZyA9IG1hcHBpbmc7XG4gICAgfSwgdGhpcyk7XG4gICAgLy8gV2UgaGF2ZSBwcm9jZXNzZWQgYWxsIG1hcHBpbmdzLlxuICAgIGlmIChyZW1haW5pbmdMaW5lc0luZGV4IDwgcmVtYWluaW5nTGluZXMubGVuZ3RoKSB7XG4gICAgICBpZiAobGFzdE1hcHBpbmcpIHtcbiAgICAgICAgLy8gQXNzb2NpYXRlIHRoZSByZW1haW5pbmcgY29kZSBpbiB0aGUgY3VycmVudCBsaW5lIHdpdGggXCJsYXN0TWFwcGluZ1wiXG4gICAgICAgIGFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZywgc2hpZnROZXh0TGluZSgpKTtcbiAgICAgIH1cbiAgICAgIC8vIGFuZCBhZGQgdGhlIHJlbWFpbmluZyBsaW5lcyB3aXRob3V0IGFueSBtYXBwaW5nXG4gICAgICBub2RlLmFkZChyZW1haW5pbmdMaW5lcy5zcGxpY2UocmVtYWluaW5nTGluZXNJbmRleCkuam9pbihcIlwiKSk7XG4gICAgfVxuXG4gICAgLy8gQ29weSBzb3VyY2VzQ29udGVudCBpbnRvIFNvdXJjZU5vZGVcbiAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICB2YXIgY29udGVudCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKHNvdXJjZUZpbGUpO1xuICAgICAgaWYgKGNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBpZiAoYVJlbGF0aXZlUGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgc291cmNlRmlsZSA9IHV0aWwuam9pbihhUmVsYXRpdmVQYXRoLCBzb3VyY2VGaWxlKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbm9kZTtcblxuICAgIGZ1bmN0aW9uIGFkZE1hcHBpbmdXaXRoQ29kZShtYXBwaW5nLCBjb2RlKSB7XG4gICAgICBpZiAobWFwcGluZyA9PT0gbnVsbCB8fCBtYXBwaW5nLnNvdXJjZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5vZGUuYWRkKGNvZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFSZWxhdGl2ZVBhdGhcbiAgICAgICAgICA/IHV0aWwuam9pbihhUmVsYXRpdmVQYXRoLCBtYXBwaW5nLnNvdXJjZSlcbiAgICAgICAgICA6IG1hcHBpbmcuc291cmNlO1xuICAgICAgICBub2RlLmFkZChuZXcgU291cmNlTm9kZShtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm5hbWUpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbi8qKlxuICogQWRkIGEgY2h1bmsgb2YgZ2VuZXJhdGVkIEpTIHRvIHRoaXMgc291cmNlIG5vZGUuXG4gKlxuICogQHBhcmFtIGFDaHVuayBBIHN0cmluZyBzbmlwcGV0IG9mIGdlbmVyYXRlZCBKUyBjb2RlLCBhbm90aGVyIGluc3RhbmNlIG9mXG4gKiAgICAgICAgU291cmNlTm9kZSwgb3IgYW4gYXJyYXkgd2hlcmUgZWFjaCBtZW1iZXIgaXMgb25lIG9mIHRob3NlIHRoaW5ncy5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gU291cmNlTm9kZV9hZGQoYUNodW5rKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFDaHVuaykpIHtcbiAgICBhQ2h1bmsuZm9yRWFjaChmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgIHRoaXMuYWRkKGNodW5rKTtcbiAgICB9LCB0aGlzKTtcbiAgfVxuICBlbHNlIGlmIChhQ2h1bmtbaXNTb3VyY2VOb2RlXSB8fCB0eXBlb2YgYUNodW5rID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKGFDaHVuaykge1xuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGFDaHVuayk7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICBcIkV4cGVjdGVkIGEgU291cmNlTm9kZSwgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBTb3VyY2VOb2RlcyBhbmQgc3RyaW5ncy4gR290IFwiICsgYUNodW5rXG4gICAgKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkIGEgY2h1bmsgb2YgZ2VuZXJhdGVkIEpTIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhpcyBzb3VyY2Ugbm9kZS5cbiAqXG4gKiBAcGFyYW0gYUNodW5rIEEgc3RyaW5nIHNuaXBwZXQgb2YgZ2VuZXJhdGVkIEpTIGNvZGUsIGFub3RoZXIgaW5zdGFuY2Ugb2ZcbiAqICAgICAgICBTb3VyY2VOb2RlLCBvciBhbiBhcnJheSB3aGVyZSBlYWNoIG1lbWJlciBpcyBvbmUgb2YgdGhvc2UgdGhpbmdzLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS5wcmVwZW5kID0gZnVuY3Rpb24gU291cmNlTm9kZV9wcmVwZW5kKGFDaHVuaykge1xuICBpZiAoQXJyYXkuaXNBcnJheShhQ2h1bmspKSB7XG4gICAgZm9yICh2YXIgaSA9IGFDaHVuay5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHRoaXMucHJlcGVuZChhQ2h1bmtbaV0pO1xuICAgIH1cbiAgfVxuICBlbHNlIGlmIChhQ2h1bmtbaXNTb3VyY2VOb2RlXSB8fCB0eXBlb2YgYUNodW5rID09PSBcInN0cmluZ1wiKSB7XG4gICAgdGhpcy5jaGlsZHJlbi51bnNoaWZ0KGFDaHVuayk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgIFwiRXhwZWN0ZWQgYSBTb3VyY2VOb2RlLCBzdHJpbmcsIG9yIGFuIGFycmF5IG9mIFNvdXJjZU5vZGVzIGFuZCBzdHJpbmdzLiBHb3QgXCIgKyBhQ2h1bmtcbiAgICApO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBXYWxrIG92ZXIgdGhlIHRyZWUgb2YgSlMgc25pcHBldHMgaW4gdGhpcyBub2RlIGFuZCBpdHMgY2hpbGRyZW4uIFRoZVxuICogd2Fsa2luZyBmdW5jdGlvbiBpcyBjYWxsZWQgb25jZSBmb3IgZWFjaCBzbmlwcGV0IG9mIEpTIGFuZCBpcyBwYXNzZWQgdGhhdFxuICogc25pcHBldCBhbmQgdGhlIGl0cyBvcmlnaW5hbCBhc3NvY2lhdGVkIHNvdXJjZSdzIGxpbmUvY29sdW1uIGxvY2F0aW9uLlxuICpcbiAqIEBwYXJhbSBhRm4gVGhlIHRyYXZlcnNhbCBmdW5jdGlvbi5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfd2FsayhhRm4pIHtcbiAgdmFyIGNodW5rO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGNodW5rID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICBpZiAoY2h1bmtbaXNTb3VyY2VOb2RlXSkge1xuICAgICAgY2h1bmsud2FsayhhRm4pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChjaHVuayAhPT0gJycpIHtcbiAgICAgICAgYUZuKGNodW5rLCB7IHNvdXJjZTogdGhpcy5zb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxpbmUsXG4gICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBMaWtlIGBTdHJpbmcucHJvdG90eXBlLmpvaW5gIGV4Y2VwdCBmb3IgU291cmNlTm9kZXMuIEluc2VydHMgYGFTdHJgIGJldHdlZW5cbiAqIGVhY2ggb2YgYHRoaXMuY2hpbGRyZW5gLlxuICpcbiAqIEBwYXJhbSBhU2VwIFRoZSBzZXBhcmF0b3IuXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiBTb3VyY2VOb2RlX2pvaW4oYVNlcCkge1xuICB2YXIgbmV3Q2hpbGRyZW47XG4gIHZhciBpO1xuICB2YXIgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7XG4gIGlmIChsZW4gPiAwKSB7XG4gICAgbmV3Q2hpbGRyZW4gPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuLTE7IGkrKykge1xuICAgICAgbmV3Q2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkcmVuW2ldKTtcbiAgICAgIG5ld0NoaWxkcmVuLnB1c2goYVNlcCk7XG4gICAgfVxuICAgIG5ld0NoaWxkcmVuLnB1c2godGhpcy5jaGlsZHJlbltpXSk7XG4gICAgdGhpcy5jaGlsZHJlbiA9IG5ld0NoaWxkcmVuO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYWxsIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSBvbiB0aGUgdmVyeSByaWdodC1tb3N0IHNvdXJjZSBzbmlwcGV0LiBVc2VmdWxcbiAqIGZvciB0cmltbWluZyB3aGl0ZXNwYWNlIGZyb20gdGhlIGVuZCBvZiBhIHNvdXJjZSBub2RlLCBldGMuXG4gKlxuICogQHBhcmFtIGFQYXR0ZXJuIFRoZSBwYXR0ZXJuIHRvIHJlcGxhY2UuXG4gKiBAcGFyYW0gYVJlcGxhY2VtZW50IFRoZSB0aGluZyB0byByZXBsYWNlIHRoZSBwYXR0ZXJuIHdpdGguXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLnJlcGxhY2VSaWdodCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfcmVwbGFjZVJpZ2h0KGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpIHtcbiAgdmFyIGxhc3RDaGlsZCA9IHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgaWYgKGxhc3RDaGlsZFtpc1NvdXJjZU5vZGVdKSB7XG4gICAgbGFzdENoaWxkLnJlcGxhY2VSaWdodChhUGF0dGVybiwgYVJlcGxhY2VtZW50KTtcbiAgfVxuICBlbHNlIGlmICh0eXBlb2YgbGFzdENoaWxkID09PSAnc3RyaW5nJykge1xuICAgIHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXSA9IGxhc3RDaGlsZC5yZXBsYWNlKGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpO1xuICB9XG4gIGVsc2Uge1xuICAgIHRoaXMuY2hpbGRyZW4ucHVzaCgnJy5yZXBsYWNlKGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBzb3VyY2UgY29udGVudCBmb3IgYSBzb3VyY2UgZmlsZS4gVGhpcyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3JcbiAqIGluIHRoZSBzb3VyY2VzQ29udGVudCBmaWVsZC5cbiAqXG4gKiBAcGFyYW0gYVNvdXJjZUZpbGUgVGhlIGZpbGVuYW1lIG9mIHRoZSBzb3VyY2UgZmlsZVxuICogQHBhcmFtIGFTb3VyY2VDb250ZW50IFRoZSBjb250ZW50IG9mIHRoZSBzb3VyY2UgZmlsZVxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS5zZXRTb3VyY2VDb250ZW50ID1cbiAgZnVuY3Rpb24gU291cmNlTm9kZV9zZXRTb3VyY2VDb250ZW50KGFTb3VyY2VGaWxlLCBhU291cmNlQ29udGVudCkge1xuICAgIHRoaXMuc291cmNlQ29udGVudHNbdXRpbC50b1NldFN0cmluZyhhU291cmNlRmlsZSldID0gYVNvdXJjZUNvbnRlbnQ7XG4gIH07XG5cbi8qKlxuICogV2FsayBvdmVyIHRoZSB0cmVlIG9mIFNvdXJjZU5vZGVzLiBUaGUgd2Fsa2luZyBmdW5jdGlvbiBpcyBjYWxsZWQgZm9yIGVhY2hcbiAqIHNvdXJjZSBmaWxlIGNvbnRlbnQgYW5kIGlzIHBhc3NlZCB0aGUgZmlsZW5hbWUgYW5kIHNvdXJjZSBjb250ZW50LlxuICpcbiAqIEBwYXJhbSBhRm4gVGhlIHRyYXZlcnNhbCBmdW5jdGlvbi5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUud2Fsa1NvdXJjZUNvbnRlbnRzID1cbiAgZnVuY3Rpb24gU291cmNlTm9kZV93YWxrU291cmNlQ29udGVudHMoYUZuKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLmNoaWxkcmVuW2ldW2lzU291cmNlTm9kZV0pIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbltpXS53YWxrU291cmNlQ29udGVudHMoYUZuKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc291cmNlcyA9IE9iamVjdC5rZXlzKHRoaXMuc291cmNlQ29udGVudHMpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzb3VyY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhRm4odXRpbC5mcm9tU2V0U3RyaW5nKHNvdXJjZXNbaV0pLCB0aGlzLnNvdXJjZUNvbnRlbnRzW3NvdXJjZXNbaV1dKTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzb3VyY2Ugbm9kZS4gV2Fsa3Mgb3ZlciB0aGUgdHJlZVxuICogYW5kIGNvbmNhdGVuYXRlcyBhbGwgdGhlIHZhcmlvdXMgc25pcHBldHMgdG9nZXRoZXIgdG8gb25lIHN0cmluZy5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3RvU3RyaW5nKCkge1xuICB2YXIgc3RyID0gXCJcIjtcbiAgdGhpcy53YWxrKGZ1bmN0aW9uIChjaHVuaykge1xuICAgIHN0ciArPSBjaHVuaztcbiAgfSk7XG4gIHJldHVybiBzdHI7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHNvdXJjZSBub2RlIGFsb25nIHdpdGggYSBzb3VyY2VcbiAqIG1hcC5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUudG9TdHJpbmdXaXRoU291cmNlTWFwID0gZnVuY3Rpb24gU291cmNlTm9kZV90b1N0cmluZ1dpdGhTb3VyY2VNYXAoYUFyZ3MpIHtcbiAgdmFyIGdlbmVyYXRlZCA9IHtcbiAgICBjb2RlOiBcIlwiLFxuICAgIGxpbmU6IDEsXG4gICAgY29sdW1uOiAwXG4gIH07XG4gIHZhciBtYXAgPSBuZXcgU291cmNlTWFwR2VuZXJhdG9yKGFBcmdzKTtcbiAgdmFyIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSBmYWxzZTtcbiAgdmFyIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG51bGw7XG4gIHZhciBsYXN0T3JpZ2luYWxMaW5lID0gbnVsbDtcbiAgdmFyIGxhc3RPcmlnaW5hbENvbHVtbiA9IG51bGw7XG4gIHZhciBsYXN0T3JpZ2luYWxOYW1lID0gbnVsbDtcbiAgdGhpcy53YWxrKGZ1bmN0aW9uIChjaHVuaywgb3JpZ2luYWwpIHtcbiAgICBnZW5lcmF0ZWQuY29kZSArPSBjaHVuaztcbiAgICBpZiAob3JpZ2luYWwuc291cmNlICE9PSBudWxsXG4gICAgICAgICYmIG9yaWdpbmFsLmxpbmUgIT09IG51bGxcbiAgICAgICAgJiYgb3JpZ2luYWwuY29sdW1uICE9PSBudWxsKSB7XG4gICAgICBpZihsYXN0T3JpZ2luYWxTb3VyY2UgIT09IG9yaWdpbmFsLnNvdXJjZVxuICAgICAgICAgfHwgbGFzdE9yaWdpbmFsTGluZSAhPT0gb3JpZ2luYWwubGluZVxuICAgICAgICAgfHwgbGFzdE9yaWdpbmFsQ29sdW1uICE9PSBvcmlnaW5hbC5jb2x1bW5cbiAgICAgICAgIHx8IGxhc3RPcmlnaW5hbE5hbWUgIT09IG9yaWdpbmFsLm5hbWUpIHtcbiAgICAgICAgbWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICAgIHNvdXJjZTogb3JpZ2luYWwuc291cmNlLFxuICAgICAgICAgIG9yaWdpbmFsOiB7XG4gICAgICAgICAgICBsaW5lOiBvcmlnaW5hbC5saW5lLFxuICAgICAgICAgICAgY29sdW1uOiBvcmlnaW5hbC5jb2x1bW5cbiAgICAgICAgICB9LFxuICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgbGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgICB9LFxuICAgICAgICAgIG5hbWU6IG9yaWdpbmFsLm5hbWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBvcmlnaW5hbC5zb3VyY2U7XG4gICAgICBsYXN0T3JpZ2luYWxMaW5lID0gb3JpZ2luYWwubGluZTtcbiAgICAgIGxhc3RPcmlnaW5hbENvbHVtbiA9IG9yaWdpbmFsLmNvbHVtbjtcbiAgICAgIGxhc3RPcmlnaW5hbE5hbWUgPSBvcmlnaW5hbC5uYW1lO1xuICAgICAgc291cmNlTWFwcGluZ0FjdGl2ZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChzb3VyY2VNYXBwaW5nQWN0aXZlKSB7XG4gICAgICBtYXAuYWRkTWFwcGluZyh7XG4gICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkLmNvbHVtblxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG51bGw7XG4gICAgICBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gICAgfVxuICAgIGZvciAodmFyIGlkeCA9IDAsIGxlbmd0aCA9IGNodW5rLmxlbmd0aDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgaWYgKGNodW5rLmNoYXJDb2RlQXQoaWR4KSA9PT0gTkVXTElORV9DT0RFKSB7XG4gICAgICAgIGdlbmVyYXRlZC5saW5lKys7XG4gICAgICAgIGdlbmVyYXRlZC5jb2x1bW4gPSAwO1xuICAgICAgICAvLyBNYXBwaW5ncyBlbmQgYXQgZW9sXG4gICAgICAgIGlmIChpZHggKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuICAgICAgICAgIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChzb3VyY2VNYXBwaW5nQWN0aXZlKSB7XG4gICAgICAgICAgbWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICAgICAgc291cmNlOiBvcmlnaW5hbC5zb3VyY2UsXG4gICAgICAgICAgICBvcmlnaW5hbDoge1xuICAgICAgICAgICAgICBsaW5lOiBvcmlnaW5hbC5saW5lLFxuICAgICAgICAgICAgICBjb2x1bW46IG9yaWdpbmFsLmNvbHVtblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmFtZTogb3JpZ2luYWwubmFtZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZW5lcmF0ZWQuY29sdW1uKys7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgdGhpcy53YWxrU291cmNlQ29udGVudHMoZnVuY3Rpb24gKHNvdXJjZUZpbGUsIHNvdXJjZUNvbnRlbnQpIHtcbiAgICBtYXAuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBzb3VyY2VDb250ZW50KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHsgY29kZTogZ2VuZXJhdGVkLmNvZGUsIG1hcDogbWFwIH07XG59O1xuXG5leHBvcnRzLlNvdXJjZU5vZGUgPSBTb3VyY2VOb2RlO1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG4vKipcbiAqIFRoaXMgaXMgYSBoZWxwZXIgZnVuY3Rpb24gZm9yIGdldHRpbmcgdmFsdWVzIGZyb20gcGFyYW1ldGVyL29wdGlvbnNcbiAqIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIGFyZ3MgVGhlIG9iamVjdCB3ZSBhcmUgZXh0cmFjdGluZyB2YWx1ZXMgZnJvbVxuICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHdlIGFyZSBnZXR0aW5nLlxuICogQHBhcmFtIGRlZmF1bHRWYWx1ZSBBbiBvcHRpb25hbCB2YWx1ZSB0byByZXR1cm4gaWYgdGhlIHByb3BlcnR5IGlzIG1pc3NpbmdcbiAqIGZyb20gdGhlIG9iamVjdC4gSWYgdGhpcyBpcyBub3Qgc3BlY2lmaWVkIGFuZCB0aGUgcHJvcGVydHkgaXMgbWlzc2luZywgYW5cbiAqIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICovXG5mdW5jdGlvbiBnZXRBcmcoYUFyZ3MsIGFOYW1lLCBhRGVmYXVsdFZhbHVlKSB7XG4gIGlmIChhTmFtZSBpbiBhQXJncykge1xuICAgIHJldHVybiBhQXJnc1thTmFtZV07XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHJldHVybiBhRGVmYXVsdFZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignXCInICsgYU5hbWUgKyAnXCIgaXMgYSByZXF1aXJlZCBhcmd1bWVudC4nKTtcbiAgfVxufVxuZXhwb3J0cy5nZXRBcmcgPSBnZXRBcmc7XG5cbnZhciB1cmxSZWdleHAgPSAvXig/OihbXFx3K1xcLS5dKyk6KT9cXC9cXC8oPzooXFx3KzpcXHcrKUApPyhbXFx3Li1dKikoPzo6KFxcZCspKT8oLiopJC87XG52YXIgZGF0YVVybFJlZ2V4cCA9IC9eZGF0YTouK1xcLC4rJC87XG5cbmZ1bmN0aW9uIHVybFBhcnNlKGFVcmwpIHtcbiAgdmFyIG1hdGNoID0gYVVybC5tYXRjaCh1cmxSZWdleHApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzY2hlbWU6IG1hdGNoWzFdLFxuICAgIGF1dGg6IG1hdGNoWzJdLFxuICAgIGhvc3Q6IG1hdGNoWzNdLFxuICAgIHBvcnQ6IG1hdGNoWzRdLFxuICAgIHBhdGg6IG1hdGNoWzVdXG4gIH07XG59XG5leHBvcnRzLnVybFBhcnNlID0gdXJsUGFyc2U7XG5cbmZ1bmN0aW9uIHVybEdlbmVyYXRlKGFQYXJzZWRVcmwpIHtcbiAgdmFyIHVybCA9ICcnO1xuICBpZiAoYVBhcnNlZFVybC5zY2hlbWUpIHtcbiAgICB1cmwgKz0gYVBhcnNlZFVybC5zY2hlbWUgKyAnOic7XG4gIH1cbiAgdXJsICs9ICcvLyc7XG4gIGlmIChhUGFyc2VkVXJsLmF1dGgpIHtcbiAgICB1cmwgKz0gYVBhcnNlZFVybC5hdXRoICsgJ0AnO1xuICB9XG4gIGlmIChhUGFyc2VkVXJsLmhvc3QpIHtcbiAgICB1cmwgKz0gYVBhcnNlZFVybC5ob3N0O1xuICB9XG4gIGlmIChhUGFyc2VkVXJsLnBvcnQpIHtcbiAgICB1cmwgKz0gXCI6XCIgKyBhUGFyc2VkVXJsLnBvcnRcbiAgfVxuICBpZiAoYVBhcnNlZFVybC5wYXRoKSB7XG4gICAgdXJsICs9IGFQYXJzZWRVcmwucGF0aDtcbiAgfVxuICByZXR1cm4gdXJsO1xufVxuZXhwb3J0cy51cmxHZW5lcmF0ZSA9IHVybEdlbmVyYXRlO1xuXG4vKipcbiAqIE5vcm1hbGl6ZXMgYSBwYXRoLCBvciB0aGUgcGF0aCBwb3J0aW9uIG9mIGEgVVJMOlxuICpcbiAqIC0gUmVwbGFjZXMgY29uc2VjdXRpdmUgc2xhc2hlcyB3aXRoIG9uZSBzbGFzaC5cbiAqIC0gUmVtb3ZlcyB1bm5lY2Vzc2FyeSAnLicgcGFydHMuXG4gKiAtIFJlbW92ZXMgdW5uZWNlc3NhcnkgJzxkaXI+Ly4uJyBwYXJ0cy5cbiAqXG4gKiBCYXNlZCBvbiBjb2RlIGluIHRoZSBOb2RlLmpzICdwYXRoJyBjb3JlIG1vZHVsZS5cbiAqXG4gKiBAcGFyYW0gYVBhdGggVGhlIHBhdGggb3IgdXJsIHRvIG5vcm1hbGl6ZS5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplKGFQYXRoKSB7XG4gIHZhciBwYXRoID0gYVBhdGg7XG4gIHZhciB1cmwgPSB1cmxQYXJzZShhUGF0aCk7XG4gIGlmICh1cmwpIHtcbiAgICBpZiAoIXVybC5wYXRoKSB7XG4gICAgICByZXR1cm4gYVBhdGg7XG4gICAgfVxuICAgIHBhdGggPSB1cmwucGF0aDtcbiAgfVxuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKTtcblxuICB2YXIgcGFydHMgPSBwYXRoLnNwbGl0KC9cXC8rLyk7XG4gIGZvciAodmFyIHBhcnQsIHVwID0gMCwgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgcGFydCA9IHBhcnRzW2ldO1xuICAgIGlmIChwYXJ0ID09PSAnLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKHBhcnQgPT09ICcuLicpIHtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCA+IDApIHtcbiAgICAgIGlmIChwYXJ0ID09PSAnJykge1xuICAgICAgICAvLyBUaGUgZmlyc3QgcGFydCBpcyBibGFuayBpZiB0aGUgcGF0aCBpcyBhYnNvbHV0ZS4gVHJ5aW5nIHRvIGdvXG4gICAgICAgIC8vIGFib3ZlIHRoZSByb290IGlzIGEgbm8tb3AuIFRoZXJlZm9yZSB3ZSBjYW4gcmVtb3ZlIGFsbCAnLi4nIHBhcnRzXG4gICAgICAgIC8vIGRpcmVjdGx5IGFmdGVyIHRoZSByb290LlxuICAgICAgICBwYXJ0cy5zcGxpY2UoaSArIDEsIHVwKTtcbiAgICAgICAgdXAgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydHMuc3BsaWNlKGksIDIpO1xuICAgICAgICB1cC0tO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwYXRoID0gcGFydHMuam9pbignLycpO1xuXG4gIGlmIChwYXRoID09PSAnJykge1xuICAgIHBhdGggPSBpc0Fic29sdXRlID8gJy8nIDogJy4nO1xuICB9XG5cbiAgaWYgKHVybCkge1xuICAgIHVybC5wYXRoID0gcGF0aDtcbiAgICByZXR1cm4gdXJsR2VuZXJhdGUodXJsKTtcbiAgfVxuICByZXR1cm4gcGF0aDtcbn1cbmV4cG9ydHMubm9ybWFsaXplID0gbm9ybWFsaXplO1xuXG4vKipcbiAqIEpvaW5zIHR3byBwYXRocy9VUkxzLlxuICpcbiAqIEBwYXJhbSBhUm9vdCBUaGUgcm9vdCBwYXRoIG9yIFVSTC5cbiAqIEBwYXJhbSBhUGF0aCBUaGUgcGF0aCBvciBVUkwgdG8gYmUgam9pbmVkIHdpdGggdGhlIHJvb3QuXG4gKlxuICogLSBJZiBhUGF0aCBpcyBhIFVSTCBvciBhIGRhdGEgVVJJLCBhUGF0aCBpcyByZXR1cm5lZCwgdW5sZXNzIGFQYXRoIGlzIGFcbiAqICAgc2NoZW1lLXJlbGF0aXZlIFVSTDogVGhlbiB0aGUgc2NoZW1lIG9mIGFSb290LCBpZiBhbnksIGlzIHByZXBlbmRlZFxuICogICBmaXJzdC5cbiAqIC0gT3RoZXJ3aXNlIGFQYXRoIGlzIGEgcGF0aC4gSWYgYVJvb3QgaXMgYSBVUkwsIHRoZW4gaXRzIHBhdGggcG9ydGlvblxuICogICBpcyB1cGRhdGVkIHdpdGggdGhlIHJlc3VsdCBhbmQgYVJvb3QgaXMgcmV0dXJuZWQuIE90aGVyd2lzZSB0aGUgcmVzdWx0XG4gKiAgIGlzIHJldHVybmVkLlxuICogICAtIElmIGFQYXRoIGlzIGFic29sdXRlLCB0aGUgcmVzdWx0IGlzIGFQYXRoLlxuICogICAtIE90aGVyd2lzZSB0aGUgdHdvIHBhdGhzIGFyZSBqb2luZWQgd2l0aCBhIHNsYXNoLlxuICogLSBKb2luaW5nIGZvciBleGFtcGxlICdodHRwOi8vJyBhbmQgJ3d3dy5leGFtcGxlLmNvbScgaXMgYWxzbyBzdXBwb3J0ZWQuXG4gKi9cbmZ1bmN0aW9uIGpvaW4oYVJvb3QsIGFQYXRoKSB7XG4gIGlmIChhUm9vdCA9PT0gXCJcIikge1xuICAgIGFSb290ID0gXCIuXCI7XG4gIH1cbiAgaWYgKGFQYXRoID09PSBcIlwiKSB7XG4gICAgYVBhdGggPSBcIi5cIjtcbiAgfVxuICB2YXIgYVBhdGhVcmwgPSB1cmxQYXJzZShhUGF0aCk7XG4gIHZhciBhUm9vdFVybCA9IHVybFBhcnNlKGFSb290KTtcbiAgaWYgKGFSb290VXJsKSB7XG4gICAgYVJvb3QgPSBhUm9vdFVybC5wYXRoIHx8ICcvJztcbiAgfVxuXG4gIC8vIGBqb2luKGZvbywgJy8vd3d3LmV4YW1wbGUub3JnJylgXG4gIGlmIChhUGF0aFVybCAmJiAhYVBhdGhVcmwuc2NoZW1lKSB7XG4gICAgaWYgKGFSb290VXJsKSB7XG4gICAgICBhUGF0aFVybC5zY2hlbWUgPSBhUm9vdFVybC5zY2hlbWU7XG4gICAgfVxuICAgIHJldHVybiB1cmxHZW5lcmF0ZShhUGF0aFVybCk7XG4gIH1cblxuICBpZiAoYVBhdGhVcmwgfHwgYVBhdGgubWF0Y2goZGF0YVVybFJlZ2V4cCkpIHtcbiAgICByZXR1cm4gYVBhdGg7XG4gIH1cblxuICAvLyBgam9pbignaHR0cDovLycsICd3d3cuZXhhbXBsZS5jb20nKWBcbiAgaWYgKGFSb290VXJsICYmICFhUm9vdFVybC5ob3N0ICYmICFhUm9vdFVybC5wYXRoKSB7XG4gICAgYVJvb3RVcmwuaG9zdCA9IGFQYXRoO1xuICAgIHJldHVybiB1cmxHZW5lcmF0ZShhUm9vdFVybCk7XG4gIH1cblxuICB2YXIgam9pbmVkID0gYVBhdGguY2hhckF0KDApID09PSAnLydcbiAgICA/IGFQYXRoXG4gICAgOiBub3JtYWxpemUoYVJvb3QucmVwbGFjZSgvXFwvKyQvLCAnJykgKyAnLycgKyBhUGF0aCk7XG5cbiAgaWYgKGFSb290VXJsKSB7XG4gICAgYVJvb3RVcmwucGF0aCA9IGpvaW5lZDtcbiAgICByZXR1cm4gdXJsR2VuZXJhdGUoYVJvb3RVcmwpO1xuICB9XG4gIHJldHVybiBqb2luZWQ7XG59XG5leHBvcnRzLmpvaW4gPSBqb2luO1xuXG5leHBvcnRzLmlzQWJzb2x1dGUgPSBmdW5jdGlvbiAoYVBhdGgpIHtcbiAgcmV0dXJuIGFQYXRoLmNoYXJBdCgwKSA9PT0gJy8nIHx8IHVybFJlZ2V4cC50ZXN0KGFQYXRoKTtcbn07XG5cbi8qKlxuICogTWFrZSBhIHBhdGggcmVsYXRpdmUgdG8gYSBVUkwgb3IgYW5vdGhlciBwYXRoLlxuICpcbiAqIEBwYXJhbSBhUm9vdCBUaGUgcm9vdCBwYXRoIG9yIFVSTC5cbiAqIEBwYXJhbSBhUGF0aCBUaGUgcGF0aCBvciBVUkwgdG8gYmUgbWFkZSByZWxhdGl2ZSB0byBhUm9vdC5cbiAqL1xuZnVuY3Rpb24gcmVsYXRpdmUoYVJvb3QsIGFQYXRoKSB7XG4gIGlmIChhUm9vdCA9PT0gXCJcIikge1xuICAgIGFSb290ID0gXCIuXCI7XG4gIH1cblxuICBhUm9vdCA9IGFSb290LnJlcGxhY2UoL1xcLyQvLCAnJyk7XG5cbiAgLy8gSXQgaXMgcG9zc2libGUgZm9yIHRoZSBwYXRoIHRvIGJlIGFib3ZlIHRoZSByb290LiBJbiB0aGlzIGNhc2UsIHNpbXBseVxuICAvLyBjaGVja2luZyB3aGV0aGVyIHRoZSByb290IGlzIGEgcHJlZml4IG9mIHRoZSBwYXRoIHdvbid0IHdvcmsuIEluc3RlYWQsIHdlXG4gIC8vIG5lZWQgdG8gcmVtb3ZlIGNvbXBvbmVudHMgZnJvbSB0aGUgcm9vdCBvbmUgYnkgb25lLCB1bnRpbCBlaXRoZXIgd2UgZmluZFxuICAvLyBhIHByZWZpeCB0aGF0IGZpdHMsIG9yIHdlIHJ1biBvdXQgb2YgY29tcG9uZW50cyB0byByZW1vdmUuXG4gIHZhciBsZXZlbCA9IDA7XG4gIHdoaWxlIChhUGF0aC5pbmRleE9mKGFSb290ICsgJy8nKSAhPT0gMCkge1xuICAgIHZhciBpbmRleCA9IGFSb290Lmxhc3RJbmRleE9mKFwiL1wiKTtcbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICByZXR1cm4gYVBhdGg7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIG9ubHkgcGFydCBvZiB0aGUgcm9vdCB0aGF0IGlzIGxlZnQgaXMgdGhlIHNjaGVtZSAoaS5lLiBodHRwOi8vLFxuICAgIC8vIGZpbGU6Ly8vLCBldGMuKSwgb25lIG9yIG1vcmUgc2xhc2hlcyAoLyksIG9yIHNpbXBseSBub3RoaW5nIGF0IGFsbCwgd2VcbiAgICAvLyBoYXZlIGV4aGF1c3RlZCBhbGwgY29tcG9uZW50cywgc28gdGhlIHBhdGggaXMgbm90IHJlbGF0aXZlIHRvIHRoZSByb290LlxuICAgIGFSb290ID0gYVJvb3Quc2xpY2UoMCwgaW5kZXgpO1xuICAgIGlmIChhUm9vdC5tYXRjaCgvXihbXlxcL10rOlxcLyk/XFwvKiQvKSkge1xuICAgICAgcmV0dXJuIGFQYXRoO1xuICAgIH1cblxuICAgICsrbGV2ZWw7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgd2UgYWRkIGEgXCIuLi9cIiBmb3IgZWFjaCBjb21wb25lbnQgd2UgcmVtb3ZlZCBmcm9tIHRoZSByb290LlxuICByZXR1cm4gQXJyYXkobGV2ZWwgKyAxKS5qb2luKFwiLi4vXCIpICsgYVBhdGguc3Vic3RyKGFSb290Lmxlbmd0aCArIDEpO1xufVxuZXhwb3J0cy5yZWxhdGl2ZSA9IHJlbGF0aXZlO1xuXG52YXIgc3VwcG9ydHNOdWxsUHJvdG8gPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgb2JqID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuICEoJ19fcHJvdG9fXycgaW4gb2JqKTtcbn0oKSk7XG5cbmZ1bmN0aW9uIGlkZW50aXR5IChzKSB7XG4gIHJldHVybiBzO1xufVxuXG4vKipcbiAqIEJlY2F1c2UgYmVoYXZpb3IgZ29lcyB3YWNreSB3aGVuIHlvdSBzZXQgYF9fcHJvdG9fX2Agb24gb2JqZWN0cywgd2VcbiAqIGhhdmUgdG8gcHJlZml4IGFsbCB0aGUgc3RyaW5ncyBpbiBvdXIgc2V0IHdpdGggYW4gYXJiaXRyYXJ5IGNoYXJhY3Rlci5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc291cmNlLW1hcC9wdWxsLzMxIGFuZFxuICogaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc291cmNlLW1hcC9pc3N1ZXMvMzBcbiAqXG4gKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAqL1xuZnVuY3Rpb24gdG9TZXRTdHJpbmcoYVN0cikge1xuICBpZiAoaXNQcm90b1N0cmluZyhhU3RyKSkge1xuICAgIHJldHVybiAnJCcgKyBhU3RyO1xuICB9XG5cbiAgcmV0dXJuIGFTdHI7XG59XG5leHBvcnRzLnRvU2V0U3RyaW5nID0gc3VwcG9ydHNOdWxsUHJvdG8gPyBpZGVudGl0eSA6IHRvU2V0U3RyaW5nO1xuXG5mdW5jdGlvbiBmcm9tU2V0U3RyaW5nKGFTdHIpIHtcbiAgaWYgKGlzUHJvdG9TdHJpbmcoYVN0cikpIHtcbiAgICByZXR1cm4gYVN0ci5zbGljZSgxKTtcbiAgfVxuXG4gIHJldHVybiBhU3RyO1xufVxuZXhwb3J0cy5mcm9tU2V0U3RyaW5nID0gc3VwcG9ydHNOdWxsUHJvdG8gPyBpZGVudGl0eSA6IGZyb21TZXRTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzUHJvdG9TdHJpbmcocykge1xuICBpZiAoIXMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gcy5sZW5ndGg7XG5cbiAgaWYgKGxlbmd0aCA8IDkgLyogXCJfX3Byb3RvX19cIi5sZW5ndGggKi8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAocy5jaGFyQ29kZUF0KGxlbmd0aCAtIDEpICE9PSA5NSAgLyogJ18nICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gMikgIT09IDk1ICAvKiAnXycgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSAzKSAhPT0gMTExIC8qICdvJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDQpICE9PSAxMTYgLyogJ3QnICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gNSkgIT09IDExMSAvKiAnbycgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA2KSAhPT0gMTE0IC8qICdyJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDcpICE9PSAxMTIgLyogJ3AnICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gOCkgIT09IDk1ICAvKiAnXycgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA5KSAhPT0gOTUgIC8qICdfJyAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSBsZW5ndGggLSAxMDsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAocy5jaGFyQ29kZUF0KGkpICE9PSAzNiAvKiAnJCcgKi8pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBDb21wYXJhdG9yIGJldHdlZW4gdHdvIG1hcHBpbmdzIHdoZXJlIHRoZSBvcmlnaW5hbCBwb3NpdGlvbnMgYXJlIGNvbXBhcmVkLlxuICpcbiAqIE9wdGlvbmFsbHkgcGFzcyBpbiBgdHJ1ZWAgYXMgYG9ubHlDb21wYXJlR2VuZXJhdGVkYCB0byBjb25zaWRlciB0d29cbiAqIG1hcHBpbmdzIHdpdGggdGhlIHNhbWUgb3JpZ2luYWwgc291cmNlL2xpbmUvY29sdW1uLCBidXQgZGlmZmVyZW50IGdlbmVyYXRlZFxuICogbGluZSBhbmQgY29sdW1uIHRoZSBzYW1lLiBVc2VmdWwgd2hlbiBzZWFyY2hpbmcgZm9yIGEgbWFwcGluZyB3aXRoIGFcbiAqIHN0dWJiZWQgb3V0IG1hcHBpbmcuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKG1hcHBpbmdBLCBtYXBwaW5nQiwgb25seUNvbXBhcmVPcmlnaW5hbCkge1xuICB2YXIgY21wID0gc3RyY21wKG1hcHBpbmdBLnNvdXJjZSwgbWFwcGluZ0Iuc291cmNlKTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCB8fCBvbmx5Q29tcGFyZU9yaWdpbmFsKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbiAtIG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICByZXR1cm4gc3RyY21wKG1hcHBpbmdBLm5hbWUsIG1hcHBpbmdCLm5hbWUpO1xufVxuZXhwb3J0cy5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyA9IGNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zO1xuXG4vKipcbiAqIENvbXBhcmF0b3IgYmV0d2VlbiB0d28gbWFwcGluZ3Mgd2l0aCBkZWZsYXRlZCBzb3VyY2UgYW5kIG5hbWUgaW5kaWNlcyB3aGVyZVxuICogdGhlIGdlbmVyYXRlZCBwb3NpdGlvbnMgYXJlIGNvbXBhcmVkLlxuICpcbiAqIE9wdGlvbmFsbHkgcGFzcyBpbiBgdHJ1ZWAgYXMgYG9ubHlDb21wYXJlR2VuZXJhdGVkYCB0byBjb25zaWRlciB0d29cbiAqIG1hcHBpbmdzIHdpdGggdGhlIHNhbWUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiwgYnV0IGRpZmZlcmVudFxuICogc291cmNlL25hbWUvb3JpZ2luYWwgbGluZSBhbmQgY29sdW1uIHRoZSBzYW1lLiBVc2VmdWwgd2hlbiBzZWFyY2hpbmcgZm9yIGFcbiAqIG1hcHBpbmcgd2l0aCBhIHN0dWJiZWQgb3V0IG1hcHBpbmcuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkKG1hcHBpbmdBLCBtYXBwaW5nQiwgb25seUNvbXBhcmVHZW5lcmF0ZWQpIHtcbiAgdmFyIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmUgLSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbiAtIG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCB8fCBvbmx5Q29tcGFyZUdlbmVyYXRlZCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBzdHJjbXAobWFwcGluZ0Euc291cmNlLCBtYXBwaW5nQi5zb3VyY2UpO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsTGluZSAtIG1hcHBpbmdCLm9yaWdpbmFsTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIHJldHVybiBzdHJjbXAobWFwcGluZ0EubmFtZSwgbWFwcGluZ0IubmFtZSk7XG59XG5leHBvcnRzLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkID0gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQ7XG5cbmZ1bmN0aW9uIHN0cmNtcChhU3RyMSwgYVN0cjIpIHtcbiAgaWYgKGFTdHIxID09PSBhU3RyMikge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgaWYgKGFTdHIxID09PSBudWxsKSB7XG4gICAgcmV0dXJuIDE7IC8vIGFTdHIyICE9PSBudWxsXG4gIH1cblxuICBpZiAoYVN0cjIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gLTE7IC8vIGFTdHIxICE9PSBudWxsXG4gIH1cblxuICBpZiAoYVN0cjEgPiBhU3RyMikge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIENvbXBhcmF0b3IgYmV0d2VlbiB0d28gbWFwcGluZ3Mgd2l0aCBpbmZsYXRlZCBzb3VyY2UgYW5kIG5hbWUgc3RyaW5ncyB3aGVyZVxuICogdGhlIGdlbmVyYXRlZCBwb3NpdGlvbnMgYXJlIGNvbXBhcmVkLlxuICovXG5mdW5jdGlvbiBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZChtYXBwaW5nQSwgbWFwcGluZ0IpIHtcbiAgdmFyIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmUgLSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbiAtIG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBzdHJjbXAobWFwcGluZ0Euc291cmNlLCBtYXBwaW5nQi5zb3VyY2UpO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsTGluZSAtIG1hcHBpbmdCLm9yaWdpbmFsTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIHJldHVybiBzdHJjbXAobWFwcGluZ0EubmFtZSwgbWFwcGluZ0IubmFtZSk7XG59XG5leHBvcnRzLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkID0gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQ7XG5cbi8qKlxuICogU3RyaXAgYW55IEpTT04gWFNTSSBhdm9pZGFuY2UgcHJlZml4IGZyb20gdGhlIHN0cmluZyAoYXMgZG9jdW1lbnRlZFxuICogaW4gdGhlIHNvdXJjZSBtYXBzIHNwZWNpZmljYXRpb24pLCBhbmQgdGhlbiBwYXJzZSB0aGUgc3RyaW5nIGFzXG4gKiBKU09OLlxuICovXG5mdW5jdGlvbiBwYXJzZVNvdXJjZU1hcElucHV0KHN0cikge1xuICByZXR1cm4gSlNPTi5wYXJzZShzdHIucmVwbGFjZSgvXlxcKV19J1teXFxuXSpcXG4vLCAnJykpO1xufVxuZXhwb3J0cy5wYXJzZVNvdXJjZU1hcElucHV0ID0gcGFyc2VTb3VyY2VNYXBJbnB1dDtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBVUkwgb2YgYSBzb3VyY2UgZ2l2ZW4gdGhlIHRoZSBzb3VyY2Ugcm9vdCwgdGhlIHNvdXJjZSdzXG4gKiBVUkwsIGFuZCB0aGUgc291cmNlIG1hcCdzIFVSTC5cbiAqL1xuZnVuY3Rpb24gY29tcHV0ZVNvdXJjZVVSTChzb3VyY2VSb290LCBzb3VyY2VVUkwsIHNvdXJjZU1hcFVSTCkge1xuICBzb3VyY2VVUkwgPSBzb3VyY2VVUkwgfHwgJyc7XG5cbiAgaWYgKHNvdXJjZVJvb3QpIHtcbiAgICAvLyBUaGlzIGZvbGxvd3Mgd2hhdCBDaHJvbWUgZG9lcy5cbiAgICBpZiAoc291cmNlUm9vdFtzb3VyY2VSb290Lmxlbmd0aCAtIDFdICE9PSAnLycgJiYgc291cmNlVVJMWzBdICE9PSAnLycpIHtcbiAgICAgIHNvdXJjZVJvb3QgKz0gJy8nO1xuICAgIH1cbiAgICAvLyBUaGUgc3BlYyBzYXlzOlxuICAgIC8vICAgTGluZSA0OiBBbiBvcHRpb25hbCBzb3VyY2Ugcm9vdCwgdXNlZnVsIGZvciByZWxvY2F0aW5nIHNvdXJjZVxuICAgIC8vICAgZmlsZXMgb24gYSBzZXJ2ZXIgb3IgcmVtb3ZpbmcgcmVwZWF0ZWQgdmFsdWVzIGluIHRoZVxuICAgIC8vICAg4oCcc291cmNlc+KAnSBlbnRyeS4gIFRoaXMgdmFsdWUgaXMgcHJlcGVuZGVkIHRvIHRoZSBpbmRpdmlkdWFsXG4gICAgLy8gICBlbnRyaWVzIGluIHRoZSDigJxzb3VyY2XigJ0gZmllbGQuXG4gICAgc291cmNlVVJMID0gc291cmNlUm9vdCArIHNvdXJjZVVSTDtcbiAgfVxuXG4gIC8vIEhpc3RvcmljYWxseSwgU291cmNlTWFwQ29uc3VtZXIgZGlkIG5vdCB0YWtlIHRoZSBzb3VyY2VNYXBVUkwgYXNcbiAgLy8gYSBwYXJhbWV0ZXIuICBUaGlzIG1vZGUgaXMgc3RpbGwgc29tZXdoYXQgc3VwcG9ydGVkLCB3aGljaCBpcyB3aHlcbiAgLy8gdGhpcyBjb2RlIGJsb2NrIGlzIGNvbmRpdGlvbmFsLiAgSG93ZXZlciwgaXQncyBwcmVmZXJhYmxlIHRvIHBhc3NcbiAgLy8gdGhlIHNvdXJjZSBtYXAgVVJMIHRvIFNvdXJjZU1hcENvbnN1bWVyLCBzbyB0aGF0IHRoaXMgZnVuY3Rpb25cbiAgLy8gY2FuIGltcGxlbWVudCB0aGUgc291cmNlIFVSTCByZXNvbHV0aW9uIGFsZ29yaXRobSBhcyBvdXRsaW5lZCBpblxuICAvLyB0aGUgc3BlYy4gIFRoaXMgYmxvY2sgaXMgYmFzaWNhbGx5IHRoZSBlcXVpdmFsZW50IG9mOlxuICAvLyAgICBuZXcgVVJMKHNvdXJjZVVSTCwgc291cmNlTWFwVVJMKS50b1N0cmluZygpXG4gIC8vIC4uLiBleGNlcHQgaXQgYXZvaWRzIHVzaW5nIFVSTCwgd2hpY2ggd2Fzbid0IGF2YWlsYWJsZSBpbiB0aGVcbiAgLy8gb2xkZXIgcmVsZWFzZXMgb2Ygbm9kZSBzdGlsbCBzdXBwb3J0ZWQgYnkgdGhpcyBsaWJyYXJ5LlxuICAvL1xuICAvLyBUaGUgc3BlYyBzYXlzOlxuICAvLyAgIElmIHRoZSBzb3VyY2VzIGFyZSBub3QgYWJzb2x1dGUgVVJMcyBhZnRlciBwcmVwZW5kaW5nIG9mIHRoZVxuICAvLyAgIOKAnHNvdXJjZVJvb3TigJ0sIHRoZSBzb3VyY2VzIGFyZSByZXNvbHZlZCByZWxhdGl2ZSB0byB0aGVcbiAgLy8gICBTb3VyY2VNYXAgKGxpa2UgcmVzb2x2aW5nIHNjcmlwdCBzcmMgaW4gYSBodG1sIGRvY3VtZW50KS5cbiAgaWYgKHNvdXJjZU1hcFVSTCkge1xuICAgIHZhciBwYXJzZWQgPSB1cmxQYXJzZShzb3VyY2VNYXBVUkwpO1xuICAgIGlmICghcGFyc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzb3VyY2VNYXBVUkwgY291bGQgbm90IGJlIHBhcnNlZFwiKTtcbiAgICB9XG4gICAgaWYgKHBhcnNlZC5wYXRoKSB7XG4gICAgICAvLyBTdHJpcCB0aGUgbGFzdCBwYXRoIGNvbXBvbmVudCwgYnV0IGtlZXAgdGhlIFwiL1wiLlxuICAgICAgdmFyIGluZGV4ID0gcGFyc2VkLnBhdGgubGFzdEluZGV4T2YoJy8nKTtcbiAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgIHBhcnNlZC5wYXRoID0gcGFyc2VkLnBhdGguc3Vic3RyaW5nKDAsIGluZGV4ICsgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHNvdXJjZVVSTCA9IGpvaW4odXJsR2VuZXJhdGUocGFyc2VkKSwgc291cmNlVVJMKTtcbiAgfVxuXG4gIHJldHVybiBub3JtYWxpemUoc291cmNlVVJMKTtcbn1cbmV4cG9ydHMuY29tcHV0ZVNvdXJjZVVSTCA9IGNvbXB1dGVTb3VyY2VVUkw7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMDktMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0UudHh0IG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5leHBvcnRzLlNvdXJjZU1hcEdlbmVyYXRvciA9IHJlcXVpcmUoJy4vbGliL3NvdXJjZS1tYXAtZ2VuZXJhdG9yJykuU291cmNlTWFwR2VuZXJhdG9yO1xuZXhwb3J0cy5Tb3VyY2VNYXBDb25zdW1lciA9IHJlcXVpcmUoJy4vbGliL3NvdXJjZS1tYXAtY29uc3VtZXInKS5Tb3VyY2VNYXBDb25zdW1lcjtcbmV4cG9ydHMuU291cmNlTm9kZSA9IHJlcXVpcmUoJy4vbGliL3NvdXJjZS1ub2RlJykuU291cmNlTm9kZTtcbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJfZnJvbVwiOiBcImVzY29kZWdlbkBeMS44LnhcIixcbiAgXCJfaWRcIjogXCJlc2NvZGVnZW5AMS4xMS4wXCIsXG4gIFwiX2luQnVuZGxlXCI6IGZhbHNlLFxuICBcIl9pbnRlZ3JpdHlcIjogXCJzaGE1MTItSWVNVjQ1UmVpeEhTNTNLL09tZktBSXp0Ti9pZ0RIelRKVWhaTTNrMWpNaElaV2prNDVTTXdBdEJzRVhpSnAzdlNQbVRjdTZDWG43bUR2RkhSTjY2Znc9PVwiLFxuICBcIl9sb2NhdGlvblwiOiBcIi9lc2NvZGVnZW5cIixcbiAgXCJfcGhhbnRvbUNoaWxkcmVuXCI6IHt9LFxuICBcIl9yZXF1ZXN0ZWRcIjoge1xuICAgIFwidHlwZVwiOiBcInJhbmdlXCIsXG4gICAgXCJyZWdpc3RyeVwiOiB0cnVlLFxuICAgIFwicmF3XCI6IFwiZXNjb2RlZ2VuQF4xLjgueFwiLFxuICAgIFwibmFtZVwiOiBcImVzY29kZWdlblwiLFxuICAgIFwiZXNjYXBlZE5hbWVcIjogXCJlc2NvZGVnZW5cIixcbiAgICBcInJhd1NwZWNcIjogXCJeMS44LnhcIixcbiAgICBcInNhdmVTcGVjXCI6IG51bGwsXG4gICAgXCJmZXRjaFNwZWNcIjogXCJeMS44LnhcIlxuICB9LFxuICBcIl9yZXF1aXJlZEJ5XCI6IFtcbiAgICBcIiNVU0VSXCIsXG4gICAgXCIvXCIsXG4gICAgXCIvc3RhdGljLWV2YWxcIlxuICBdLFxuICBcIl9yZXNvbHZlZFwiOiBcImh0dHBzOi8vcmVnaXN0cnkubnBtanMub3JnL2VzY29kZWdlbi8tL2VzY29kZWdlbi0xLjExLjAudGd6XCIsXG4gIFwiX3NoYXN1bVwiOiBcImIyN2E5Mzg5NDgxZDViZmQ1YmVjNzZmN2JiMWViM2Y4ZjQ1NTY1ODlcIixcbiAgXCJfc3BlY1wiOiBcImVzY29kZWdlbkBeMS44LnhcIixcbiAgXCJfd2hlcmVcIjogXCIvZGF0YS9jaGFsbWVycy9wcm9qZWN0L2pzZmxvd1wiLFxuICBcImJpblwiOiB7XG4gICAgXCJlc2dlbmVyYXRlXCI6IFwiLi9iaW4vZXNnZW5lcmF0ZS5qc1wiLFxuICAgIFwiZXNjb2RlZ2VuXCI6IFwiLi9iaW4vZXNjb2RlZ2VuLmpzXCJcbiAgfSxcbiAgXCJidWdzXCI6IHtcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9lc3Rvb2xzL2VzY29kZWdlbi9pc3N1ZXNcIlxuICB9LFxuICBcImJ1bmRsZURlcGVuZGVuY2llc1wiOiBmYWxzZSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiZXNwcmltYVwiOiBcIl4zLjEuM1wiLFxuICAgIFwiZXN0cmF2ZXJzZVwiOiBcIl40LjIuMFwiLFxuICAgIFwiZXN1dGlsc1wiOiBcIl4yLjAuMlwiLFxuICAgIFwib3B0aW9uYXRvclwiOiBcIl4wLjguMVwiLFxuICAgIFwic291cmNlLW1hcFwiOiBcIn4wLjYuMVwiXG4gIH0sXG4gIFwiZGVwcmVjYXRlZFwiOiBmYWxzZSxcbiAgXCJkZXNjcmlwdGlvblwiOiBcIkVDTUFTY3JpcHQgY29kZSBnZW5lcmF0b3JcIixcbiAgXCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiYWNvcm5cIjogXCJeNC4wLjRcIixcbiAgICBcImJsdWViaXJkXCI6IFwiXjMuNC43XCIsXG4gICAgXCJib3dlci1yZWdpc3RyeS1jbGllbnRcIjogXCJeMS4wLjBcIixcbiAgICBcImNoYWlcIjogXCJeMy41LjBcIixcbiAgICBcImNvbW1vbmpzLWV2ZXJ5d2hlcmVcIjogXCJeMC45LjdcIixcbiAgICBcImd1bHBcIjogXCJeMy44LjEwXCIsXG4gICAgXCJndWxwLWVzbGludFwiOiBcIl4zLjAuMVwiLFxuICAgIFwiZ3VscC1tb2NoYVwiOiBcIl4zLjAuMVwiLFxuICAgIFwic2VtdmVyXCI6IFwiXjUuMS4wXCJcbiAgfSxcbiAgXCJlbmdpbmVzXCI6IHtcbiAgICBcIm5vZGVcIjogXCI+PTQuMFwiXG4gIH0sXG4gIFwiZmlsZXNcIjogW1xuICAgIFwiTElDRU5TRS5CU0RcIixcbiAgICBcIlJFQURNRS5tZFwiLFxuICAgIFwiYmluXCIsXG4gICAgXCJlc2NvZGVnZW4uanNcIixcbiAgICBcInBhY2thZ2UuanNvblwiXG4gIF0sXG4gIFwiaG9tZXBhZ2VcIjogXCJodHRwOi8vZ2l0aHViLmNvbS9lc3Rvb2xzL2VzY29kZWdlblwiLFxuICBcImxpY2Vuc2VcIjogXCJCU0QtMi1DbGF1c2VcIixcbiAgXCJtYWluXCI6IFwiZXNjb2RlZ2VuLmpzXCIsXG4gIFwibWFpbnRhaW5lcnNcIjogW1xuICAgIHtcbiAgICAgIFwibmFtZVwiOiBcIll1c3VrZSBTdXp1a2lcIixcbiAgICAgIFwiZW1haWxcIjogXCJ1dGF0YW5lLnRlYUBnbWFpbC5jb21cIixcbiAgICAgIFwidXJsXCI6IFwiaHR0cDovL2dpdGh1Yi5jb20vQ29uc3RlbGxhdGlvblwiXG4gICAgfVxuICBdLFxuICBcIm5hbWVcIjogXCJlc2NvZGVnZW5cIixcbiAgXCJvcHRpb25hbERlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJzb3VyY2UtbWFwXCI6IFwifjAuNi4xXCJcbiAgfSxcbiAgXCJyZXBvc2l0b3J5XCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICBcInVybFwiOiBcImdpdCtzc2g6Ly9naXRAZ2l0aHViLmNvbS9lc3Rvb2xzL2VzY29kZWdlbi5naXRcIlxuICB9LFxuICBcInNjcmlwdHNcIjoge1xuICAgIFwiYnVpbGRcIjogXCJjanNpZnkgLWEgcGF0aDogdG9vbHMvZW50cnktcG9pbnQuanMgPiBlc2NvZGVnZW4uYnJvd3Nlci5qc1wiLFxuICAgIFwiYnVpbGQtbWluXCI6IFwiY2pzaWZ5IC1tYSBwYXRoOiB0b29scy9lbnRyeS1wb2ludC5qcyA+IGVzY29kZWdlbi5icm93c2VyLm1pbi5qc1wiLFxuICAgIFwibGludFwiOiBcImd1bHAgbGludFwiLFxuICAgIFwicmVsZWFzZVwiOiBcIm5vZGUgdG9vbHMvcmVsZWFzZS5qc1wiLFxuICAgIFwidGVzdFwiOiBcImd1bHAgdHJhdmlzXCIsXG4gICAgXCJ1bml0LXRlc3RcIjogXCJndWxwIHRlc3RcIlxuICB9LFxuICBcInZlcnNpb25cIjogXCIxLjExLjBcIlxufVxuIiwiLypcbiAgQ29weXJpZ2h0IChjKSBqUXVlcnkgRm91bmRhdGlvbiwgSW5jLiBhbmQgQ29udHJpYnV0b3JzLCBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG4gIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIDxDT1BZUklHSFQgSE9MREVSPiBCRSBMSUFCTEUgRk9SIEFOWVxuICBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuICAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4gIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuICBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0ZcbiAgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG5cbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8vIFVuaXZlcnNhbCBNb2R1bGUgRGVmaW5pdGlvbiAoVU1EKSB0byBzdXBwb3J0IEFNRCwgQ29tbW9uSlMvTm9kZS5qcyxcbiAgICAvLyBSaGlubywgYW5kIHBsYWluIGJyb3dzZXIgbG9hZGluZy5cblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGZhY3RvcnkoZXhwb3J0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZmFjdG9yeSgocm9vdC5lc3ByaW1hID0ge30pKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIFRva2VuLFxuICAgICAgICBUb2tlbk5hbWUsXG4gICAgICAgIEZuRXhwclRva2VucyxcbiAgICAgICAgU3ludGF4LFxuICAgICAgICBQbGFjZUhvbGRlcnMsXG4gICAgICAgIE1lc3NhZ2VzLFxuICAgICAgICBSZWdleCxcbiAgICAgICAgc291cmNlLFxuICAgICAgICBzdHJpY3QsXG4gICAgICAgIGluZGV4LFxuICAgICAgICBsaW5lTnVtYmVyLFxuICAgICAgICBsaW5lU3RhcnQsXG4gICAgICAgIGhhc0xpbmVUZXJtaW5hdG9yLFxuICAgICAgICBsYXN0SW5kZXgsXG4gICAgICAgIGxhc3RMaW5lTnVtYmVyLFxuICAgICAgICBsYXN0TGluZVN0YXJ0LFxuICAgICAgICBzdGFydEluZGV4LFxuICAgICAgICBzdGFydExpbmVOdW1iZXIsXG4gICAgICAgIHN0YXJ0TGluZVN0YXJ0LFxuICAgICAgICBzY2FubmluZyxcbiAgICAgICAgbGVuZ3RoLFxuICAgICAgICBsb29rYWhlYWQsXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBleHRyYSxcbiAgICAgICAgaXNCaW5kaW5nRWxlbWVudCxcbiAgICAgICAgaXNBc3NpZ25tZW50VGFyZ2V0LFxuICAgICAgICBmaXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3I7XG5cbiAgICBUb2tlbiA9IHtcbiAgICAgICAgQm9vbGVhbkxpdGVyYWw6IDEsXG4gICAgICAgIEVPRjogMixcbiAgICAgICAgSWRlbnRpZmllcjogMyxcbiAgICAgICAgS2V5d29yZDogNCxcbiAgICAgICAgTnVsbExpdGVyYWw6IDUsXG4gICAgICAgIE51bWVyaWNMaXRlcmFsOiA2LFxuICAgICAgICBQdW5jdHVhdG9yOiA3LFxuICAgICAgICBTdHJpbmdMaXRlcmFsOiA4LFxuICAgICAgICBSZWd1bGFyRXhwcmVzc2lvbjogOSxcbiAgICAgICAgVGVtcGxhdGU6IDEwXG4gICAgfTtcblxuICAgIFRva2VuTmFtZSA9IHt9O1xuICAgIFRva2VuTmFtZVtUb2tlbi5Cb29sZWFuTGl0ZXJhbF0gPSAnQm9vbGVhbic7XG4gICAgVG9rZW5OYW1lW1Rva2VuLkVPRl0gPSAnPGVuZD4nO1xuICAgIFRva2VuTmFtZVtUb2tlbi5JZGVudGlmaWVyXSA9ICdJZGVudGlmaWVyJztcbiAgICBUb2tlbk5hbWVbVG9rZW4uS2V5d29yZF0gPSAnS2V5d29yZCc7XG4gICAgVG9rZW5OYW1lW1Rva2VuLk51bGxMaXRlcmFsXSA9ICdOdWxsJztcbiAgICBUb2tlbk5hbWVbVG9rZW4uTnVtZXJpY0xpdGVyYWxdID0gJ051bWVyaWMnO1xuICAgIFRva2VuTmFtZVtUb2tlbi5QdW5jdHVhdG9yXSA9ICdQdW5jdHVhdG9yJztcbiAgICBUb2tlbk5hbWVbVG9rZW4uU3RyaW5nTGl0ZXJhbF0gPSAnU3RyaW5nJztcbiAgICBUb2tlbk5hbWVbVG9rZW4uUmVndWxhckV4cHJlc3Npb25dID0gJ1JlZ3VsYXJFeHByZXNzaW9uJztcbiAgICBUb2tlbk5hbWVbVG9rZW4uVGVtcGxhdGVdID0gJ1RlbXBsYXRlJztcblxuICAgIC8vIEEgZnVuY3Rpb24gZm9sbG93aW5nIG9uZSBvZiB0aG9zZSB0b2tlbnMgaXMgYW4gZXhwcmVzc2lvbi5cbiAgICBGbkV4cHJUb2tlbnMgPSBbJygnLCAneycsICdbJywgJ2luJywgJ3R5cGVvZicsICdpbnN0YW5jZW9mJywgJ25ldycsXG4gICAgICAgICAgICAgICAgICAgICdyZXR1cm4nLCAnY2FzZScsICdkZWxldGUnLCAndGhyb3cnLCAndm9pZCcsXG4gICAgICAgICAgICAgICAgICAgIC8vIGFzc2lnbm1lbnQgb3BlcmF0b3JzXG4gICAgICAgICAgICAgICAgICAgICc9JywgJys9JywgJy09JywgJyo9JywgJy89JywgJyU9JywgJzw8PScsICc+Pj0nLCAnPj4+PScsXG4gICAgICAgICAgICAgICAgICAgICcmPScsICd8PScsICdePScsICcsJyxcbiAgICAgICAgICAgICAgICAgICAgLy8gYmluYXJ5L3VuYXJ5IG9wZXJhdG9yc1xuICAgICAgICAgICAgICAgICAgICAnKycsICctJywgJyonLCAnLycsICclJywgJysrJywgJy0tJywgJzw8JywgJz4+JywgJz4+PicsICcmJyxcbiAgICAgICAgICAgICAgICAgICAgJ3wnLCAnXicsICchJywgJ34nLCAnJiYnLCAnfHwnLCAnPycsICc6JywgJz09PScsICc9PScsICc+PScsXG4gICAgICAgICAgICAgICAgICAgICc8PScsICc8JywgJz4nLCAnIT0nLCAnIT09J107XG5cbiAgICBTeW50YXggPSB7XG4gICAgICAgIEFzc2lnbm1lbnRFeHByZXNzaW9uOiAnQXNzaWdubWVudEV4cHJlc3Npb24nLFxuICAgICAgICBBc3NpZ25tZW50UGF0dGVybjogJ0Fzc2lnbm1lbnRQYXR0ZXJuJyxcbiAgICAgICAgQXJyYXlFeHByZXNzaW9uOiAnQXJyYXlFeHByZXNzaW9uJyxcbiAgICAgICAgQXJyYXlQYXR0ZXJuOiAnQXJyYXlQYXR0ZXJuJyxcbiAgICAgICAgQXJyb3dGdW5jdGlvbkV4cHJlc3Npb246ICdBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbicsXG4gICAgICAgIEJsb2NrU3RhdGVtZW50OiAnQmxvY2tTdGF0ZW1lbnQnLFxuICAgICAgICBCaW5hcnlFeHByZXNzaW9uOiAnQmluYXJ5RXhwcmVzc2lvbicsXG4gICAgICAgIEJyZWFrU3RhdGVtZW50OiAnQnJlYWtTdGF0ZW1lbnQnLFxuICAgICAgICBDYWxsRXhwcmVzc2lvbjogJ0NhbGxFeHByZXNzaW9uJyxcbiAgICAgICAgQ2F0Y2hDbGF1c2U6ICdDYXRjaENsYXVzZScsXG4gICAgICAgIENsYXNzQm9keTogJ0NsYXNzQm9keScsXG4gICAgICAgIENsYXNzRGVjbGFyYXRpb246ICdDbGFzc0RlY2xhcmF0aW9uJyxcbiAgICAgICAgQ2xhc3NFeHByZXNzaW9uOiAnQ2xhc3NFeHByZXNzaW9uJyxcbiAgICAgICAgQ29uZGl0aW9uYWxFeHByZXNzaW9uOiAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJyxcbiAgICAgICAgQ29udGludWVTdGF0ZW1lbnQ6ICdDb250aW51ZVN0YXRlbWVudCcsXG4gICAgICAgIERvV2hpbGVTdGF0ZW1lbnQ6ICdEb1doaWxlU3RhdGVtZW50JyxcbiAgICAgICAgRGVidWdnZXJTdGF0ZW1lbnQ6ICdEZWJ1Z2dlclN0YXRlbWVudCcsXG4gICAgICAgIEVtcHR5U3RhdGVtZW50OiAnRW1wdHlTdGF0ZW1lbnQnLFxuICAgICAgICBFeHBvcnRBbGxEZWNsYXJhdGlvbjogJ0V4cG9ydEFsbERlY2xhcmF0aW9uJyxcbiAgICAgICAgRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uOiAnRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uJyxcbiAgICAgICAgRXhwb3J0TmFtZWREZWNsYXJhdGlvbjogJ0V4cG9ydE5hbWVkRGVjbGFyYXRpb24nLFxuICAgICAgICBFeHBvcnRTcGVjaWZpZXI6ICdFeHBvcnRTcGVjaWZpZXInLFxuICAgICAgICBFeHByZXNzaW9uU3RhdGVtZW50OiAnRXhwcmVzc2lvblN0YXRlbWVudCcsXG4gICAgICAgIEZvclN0YXRlbWVudDogJ0ZvclN0YXRlbWVudCcsXG4gICAgICAgIEZvck9mU3RhdGVtZW50OiAnRm9yT2ZTdGF0ZW1lbnQnLFxuICAgICAgICBGb3JJblN0YXRlbWVudDogJ0ZvckluU3RhdGVtZW50JyxcbiAgICAgICAgRnVuY3Rpb25EZWNsYXJhdGlvbjogJ0Z1bmN0aW9uRGVjbGFyYXRpb24nLFxuICAgICAgICBGdW5jdGlvbkV4cHJlc3Npb246ICdGdW5jdGlvbkV4cHJlc3Npb24nLFxuICAgICAgICBJZGVudGlmaWVyOiAnSWRlbnRpZmllcicsXG4gICAgICAgIElmU3RhdGVtZW50OiAnSWZTdGF0ZW1lbnQnLFxuICAgICAgICBJbXBvcnREZWNsYXJhdGlvbjogJ0ltcG9ydERlY2xhcmF0aW9uJyxcbiAgICAgICAgSW1wb3J0RGVmYXVsdFNwZWNpZmllcjogJ0ltcG9ydERlZmF1bHRTcGVjaWZpZXInLFxuICAgICAgICBJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXI6ICdJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXInLFxuICAgICAgICBJbXBvcnRTcGVjaWZpZXI6ICdJbXBvcnRTcGVjaWZpZXInLFxuICAgICAgICBMaXRlcmFsOiAnTGl0ZXJhbCcsXG4gICAgICAgIExhYmVsZWRTdGF0ZW1lbnQ6ICdMYWJlbGVkU3RhdGVtZW50JyxcbiAgICAgICAgTG9naWNhbEV4cHJlc3Npb246ICdMb2dpY2FsRXhwcmVzc2lvbicsXG4gICAgICAgIE1lbWJlckV4cHJlc3Npb246ICdNZW1iZXJFeHByZXNzaW9uJyxcbiAgICAgICAgTWV0YVByb3BlcnR5OiAnTWV0YVByb3BlcnR5JyxcbiAgICAgICAgTWV0aG9kRGVmaW5pdGlvbjogJ01ldGhvZERlZmluaXRpb24nLFxuICAgICAgICBOZXdFeHByZXNzaW9uOiAnTmV3RXhwcmVzc2lvbicsXG4gICAgICAgIE9iamVjdEV4cHJlc3Npb246ICdPYmplY3RFeHByZXNzaW9uJyxcbiAgICAgICAgT2JqZWN0UGF0dGVybjogJ09iamVjdFBhdHRlcm4nLFxuICAgICAgICBQcm9ncmFtOiAnUHJvZ3JhbScsXG4gICAgICAgIFByb3BlcnR5OiAnUHJvcGVydHknLFxuICAgICAgICBSZXN0RWxlbWVudDogJ1Jlc3RFbGVtZW50JyxcbiAgICAgICAgUmV0dXJuU3RhdGVtZW50OiAnUmV0dXJuU3RhdGVtZW50JyxcbiAgICAgICAgU2VxdWVuY2VFeHByZXNzaW9uOiAnU2VxdWVuY2VFeHByZXNzaW9uJyxcbiAgICAgICAgU3ByZWFkRWxlbWVudDogJ1NwcmVhZEVsZW1lbnQnLFxuICAgICAgICBTdXBlcjogJ1N1cGVyJyxcbiAgICAgICAgU3dpdGNoQ2FzZTogJ1N3aXRjaENhc2UnLFxuICAgICAgICBTd2l0Y2hTdGF0ZW1lbnQ6ICdTd2l0Y2hTdGF0ZW1lbnQnLFxuICAgICAgICBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb246ICdUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24nLFxuICAgICAgICBUZW1wbGF0ZUVsZW1lbnQ6ICdUZW1wbGF0ZUVsZW1lbnQnLFxuICAgICAgICBUZW1wbGF0ZUxpdGVyYWw6ICdUZW1wbGF0ZUxpdGVyYWwnLFxuICAgICAgICBUaGlzRXhwcmVzc2lvbjogJ1RoaXNFeHByZXNzaW9uJyxcbiAgICAgICAgVGhyb3dTdGF0ZW1lbnQ6ICdUaHJvd1N0YXRlbWVudCcsXG4gICAgICAgIFRyeVN0YXRlbWVudDogJ1RyeVN0YXRlbWVudCcsXG4gICAgICAgIFVuYXJ5RXhwcmVzc2lvbjogJ1VuYXJ5RXhwcmVzc2lvbicsXG4gICAgICAgIFVwZGF0ZUV4cHJlc3Npb246ICdVcGRhdGVFeHByZXNzaW9uJyxcbiAgICAgICAgVmFyaWFibGVEZWNsYXJhdGlvbjogJ1ZhcmlhYmxlRGVjbGFyYXRpb24nLFxuICAgICAgICBWYXJpYWJsZURlY2xhcmF0b3I6ICdWYXJpYWJsZURlY2xhcmF0b3InLFxuICAgICAgICBXaGlsZVN0YXRlbWVudDogJ1doaWxlU3RhdGVtZW50JyxcbiAgICAgICAgV2l0aFN0YXRlbWVudDogJ1dpdGhTdGF0ZW1lbnQnLFxuICAgICAgICBZaWVsZEV4cHJlc3Npb246ICdZaWVsZEV4cHJlc3Npb24nXG4gICAgfTtcblxuICAgIFBsYWNlSG9sZGVycyA9IHtcbiAgICAgICAgQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlcjogJ0Fycm93UGFyYW1ldGVyUGxhY2VIb2xkZXInXG4gICAgfTtcblxuICAgIC8vIEVycm9yIG1lc3NhZ2VzIHNob3VsZCBiZSBpZGVudGljYWwgdG8gVjguXG4gICAgTWVzc2FnZXMgPSB7XG4gICAgICAgIFVuZXhwZWN0ZWRUb2tlbjogJ1VuZXhwZWN0ZWQgdG9rZW4gJTAnLFxuICAgICAgICBVbmV4cGVjdGVkTnVtYmVyOiAnVW5leHBlY3RlZCBudW1iZXInLFxuICAgICAgICBVbmV4cGVjdGVkU3RyaW5nOiAnVW5leHBlY3RlZCBzdHJpbmcnLFxuICAgICAgICBVbmV4cGVjdGVkSWRlbnRpZmllcjogJ1VuZXhwZWN0ZWQgaWRlbnRpZmllcicsXG4gICAgICAgIFVuZXhwZWN0ZWRSZXNlcnZlZDogJ1VuZXhwZWN0ZWQgcmVzZXJ2ZWQgd29yZCcsXG4gICAgICAgIFVuZXhwZWN0ZWRUZW1wbGF0ZTogJ1VuZXhwZWN0ZWQgcXVhc2kgJTAnLFxuICAgICAgICBVbmV4cGVjdGVkRU9TOiAnVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQnLFxuICAgICAgICBOZXdsaW5lQWZ0ZXJUaHJvdzogJ0lsbGVnYWwgbmV3bGluZSBhZnRlciB0aHJvdycsXG4gICAgICAgIEludmFsaWRSZWdFeHA6ICdJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbicsXG4gICAgICAgIFVudGVybWluYXRlZFJlZ0V4cDogJ0ludmFsaWQgcmVndWxhciBleHByZXNzaW9uOiBtaXNzaW5nIC8nLFxuICAgICAgICBJbnZhbGlkTEhTSW5Bc3NpZ25tZW50OiAnSW52YWxpZCBsZWZ0LWhhbmQgc2lkZSBpbiBhc3NpZ25tZW50JyxcbiAgICAgICAgSW52YWxpZExIU0luRm9ySW46ICdJbnZhbGlkIGxlZnQtaGFuZCBzaWRlIGluIGZvci1pbicsXG4gICAgICAgIEludmFsaWRMSFNJbkZvckxvb3A6ICdJbnZhbGlkIGxlZnQtaGFuZCBzaWRlIGluIGZvci1sb29wJyxcbiAgICAgICAgTXVsdGlwbGVEZWZhdWx0c0luU3dpdGNoOiAnTW9yZSB0aGFuIG9uZSBkZWZhdWx0IGNsYXVzZSBpbiBzd2l0Y2ggc3RhdGVtZW50JyxcbiAgICAgICAgTm9DYXRjaE9yRmluYWxseTogJ01pc3NpbmcgY2F0Y2ggb3IgZmluYWxseSBhZnRlciB0cnknLFxuICAgICAgICBVbmtub3duTGFiZWw6ICdVbmRlZmluZWQgbGFiZWwgXFwnJTBcXCcnLFxuICAgICAgICBSZWRlY2xhcmF0aW9uOiAnJTAgXFwnJTFcXCcgaGFzIGFscmVhZHkgYmVlbiBkZWNsYXJlZCcsXG4gICAgICAgIElsbGVnYWxDb250aW51ZTogJ0lsbGVnYWwgY29udGludWUgc3RhdGVtZW50JyxcbiAgICAgICAgSWxsZWdhbEJyZWFrOiAnSWxsZWdhbCBicmVhayBzdGF0ZW1lbnQnLFxuICAgICAgICBJbGxlZ2FsUmV0dXJuOiAnSWxsZWdhbCByZXR1cm4gc3RhdGVtZW50JyxcbiAgICAgICAgU3RyaWN0TW9kZVdpdGg6ICdTdHJpY3QgbW9kZSBjb2RlIG1heSBub3QgaW5jbHVkZSBhIHdpdGggc3RhdGVtZW50JyxcbiAgICAgICAgU3RyaWN0Q2F0Y2hWYXJpYWJsZTogJ0NhdGNoIHZhcmlhYmxlIG1heSBub3QgYmUgZXZhbCBvciBhcmd1bWVudHMgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgICBTdHJpY3RWYXJOYW1lOiAnVmFyaWFibGUgbmFtZSBtYXkgbm90IGJlIGV2YWwgb3IgYXJndW1lbnRzIGluIHN0cmljdCBtb2RlJyxcbiAgICAgICAgU3RyaWN0UGFyYW1OYW1lOiAnUGFyYW1ldGVyIG5hbWUgZXZhbCBvciBhcmd1bWVudHMgaXMgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgICBTdHJpY3RQYXJhbUR1cGU6ICdTdHJpY3QgbW9kZSBmdW5jdGlvbiBtYXkgbm90IGhhdmUgZHVwbGljYXRlIHBhcmFtZXRlciBuYW1lcycsXG4gICAgICAgIFN0cmljdEZ1bmN0aW9uTmFtZTogJ0Z1bmN0aW9uIG5hbWUgbWF5IG5vdCBiZSBldmFsIG9yIGFyZ3VtZW50cyBpbiBzdHJpY3QgbW9kZScsXG4gICAgICAgIFN0cmljdE9jdGFsTGl0ZXJhbDogJ09jdGFsIGxpdGVyYWxzIGFyZSBub3QgYWxsb3dlZCBpbiBzdHJpY3QgbW9kZS4nLFxuICAgICAgICBTdHJpY3REZWxldGU6ICdEZWxldGUgb2YgYW4gdW5xdWFsaWZpZWQgaWRlbnRpZmllciBpbiBzdHJpY3QgbW9kZS4nLFxuICAgICAgICBTdHJpY3RMSFNBc3NpZ25tZW50OiAnQXNzaWdubWVudCB0byBldmFsIG9yIGFyZ3VtZW50cyBpcyBub3QgYWxsb3dlZCBpbiBzdHJpY3QgbW9kZScsXG4gICAgICAgIFN0cmljdExIU1Bvc3RmaXg6ICdQb3N0Zml4IGluY3JlbWVudC9kZWNyZW1lbnQgbWF5IG5vdCBoYXZlIGV2YWwgb3IgYXJndW1lbnRzIG9wZXJhbmQgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgICBTdHJpY3RMSFNQcmVmaXg6ICdQcmVmaXggaW5jcmVtZW50L2RlY3JlbWVudCBtYXkgbm90IGhhdmUgZXZhbCBvciBhcmd1bWVudHMgb3BlcmFuZCBpbiBzdHJpY3QgbW9kZScsXG4gICAgICAgIFN0cmljdFJlc2VydmVkV29yZDogJ1VzZSBvZiBmdXR1cmUgcmVzZXJ2ZWQgd29yZCBpbiBzdHJpY3QgbW9kZScsXG4gICAgICAgIFRlbXBsYXRlT2N0YWxMaXRlcmFsOiAnT2N0YWwgbGl0ZXJhbHMgYXJlIG5vdCBhbGxvd2VkIGluIHRlbXBsYXRlIHN0cmluZ3MuJyxcbiAgICAgICAgUGFyYW1ldGVyQWZ0ZXJSZXN0UGFyYW1ldGVyOiAnUmVzdCBwYXJhbWV0ZXIgbXVzdCBiZSBsYXN0IGZvcm1hbCBwYXJhbWV0ZXInLFxuICAgICAgICBEZWZhdWx0UmVzdFBhcmFtZXRlcjogJ1VuZXhwZWN0ZWQgdG9rZW4gPScsXG4gICAgICAgIE9iamVjdFBhdHRlcm5Bc1Jlc3RQYXJhbWV0ZXI6ICdVbmV4cGVjdGVkIHRva2VuIHsnLFxuICAgICAgICBEdXBsaWNhdGVQcm90b1Byb3BlcnR5OiAnRHVwbGljYXRlIF9fcHJvdG9fXyBmaWVsZHMgYXJlIG5vdCBhbGxvd2VkIGluIG9iamVjdCBsaXRlcmFscycsXG4gICAgICAgIENvbnN0cnVjdG9yU3BlY2lhbE1ldGhvZDogJ0NsYXNzIGNvbnN0cnVjdG9yIG1heSBub3QgYmUgYW4gYWNjZXNzb3InLFxuICAgICAgICBEdXBsaWNhdGVDb25zdHJ1Y3RvcjogJ0EgY2xhc3MgbWF5IG9ubHkgaGF2ZSBvbmUgY29uc3RydWN0b3InLFxuICAgICAgICBTdGF0aWNQcm90b3R5cGU6ICdDbGFzc2VzIG1heSBub3QgaGF2ZSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgcHJvdG90eXBlJyxcbiAgICAgICAgTWlzc2luZ0Zyb21DbGF1c2U6ICdVbmV4cGVjdGVkIHRva2VuJyxcbiAgICAgICAgTm9Bc0FmdGVySW1wb3J0TmFtZXNwYWNlOiAnVW5leHBlY3RlZCB0b2tlbicsXG4gICAgICAgIEludmFsaWRNb2R1bGVTcGVjaWZpZXI6ICdVbmV4cGVjdGVkIHRva2VuJyxcbiAgICAgICAgSWxsZWdhbEltcG9ydERlY2xhcmF0aW9uOiAnVW5leHBlY3RlZCB0b2tlbicsXG4gICAgICAgIElsbGVnYWxFeHBvcnREZWNsYXJhdGlvbjogJ1VuZXhwZWN0ZWQgdG9rZW4nLFxuICAgICAgICBEdXBsaWNhdGVCaW5kaW5nOiAnRHVwbGljYXRlIGJpbmRpbmcgJTAnXG4gICAgfTtcblxuICAgIC8vIFNlZSBhbHNvIHRvb2xzL2dlbmVyYXRlLXVuaWNvZGUtcmVnZXguanMuXG4gICAgUmVnZXggPSB7XG4gICAgICAgIC8vIEVDTUFTY3JpcHQgNi9Vbmljb2RlIHY3LjAuMCBOb25Bc2NpaUlkZW50aWZpZXJTdGFydDpcbiAgICAgICAgTm9uQXNjaWlJZGVudGlmaWVyU3RhcnQ6IC9bXFx4QUFcXHhCNVxceEJBXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM3RlxcdTAzODZcXHUwMzg4LVxcdTAzOEFcXHUwMzhDXFx1MDM4RS1cXHUwM0ExXFx1MDNBMy1cXHUwM0Y1XFx1MDNGNy1cXHUwNDgxXFx1MDQ4QS1cXHUwNTJGXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1RDAtXFx1MDVFQVxcdTA1RjAtXFx1MDVGMlxcdTA2MjAtXFx1MDY0QVxcdTA2NkVcXHUwNjZGXFx1MDY3MS1cXHUwNkQzXFx1MDZENVxcdTA2RTVcXHUwNkU2XFx1MDZFRVxcdTA2RUZcXHUwNkZBLVxcdTA2RkNcXHUwNkZGXFx1MDcxMFxcdTA3MTItXFx1MDcyRlxcdTA3NEQtXFx1MDdBNVxcdTA3QjFcXHUwN0NBLVxcdTA3RUFcXHUwN0Y0XFx1MDdGNVxcdTA3RkFcXHUwODAwLVxcdTA4MTVcXHUwODFBXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwOEEwLVxcdTA4QjJcXHUwOTA0LVxcdTA5MzlcXHUwOTNEXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk4MFxcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkRcXHUwOUNFXFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTFcXHUwOUYwXFx1MDlGMVxcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNzItXFx1MEE3NFxcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCRFxcdTBBRDBcXHUwQUUwXFx1MEFFMVxcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNEXFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjFcXHUwQjcxXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkQwXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzM5XFx1MEMzRFxcdTBDNThcXHUwQzU5XFx1MEM2MFxcdTBDNjFcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JEXFx1MENERVxcdTBDRTBcXHUwQ0UxXFx1MENGMVxcdTBDRjJcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNEXFx1MEQ0RVxcdTBENjBcXHUwRDYxXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBFMDEtXFx1MEUzMFxcdTBFMzJcXHUwRTMzXFx1MEU0MC1cXHUwRTQ2XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjBcXHUwRUIyXFx1MEVCM1xcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGNDAtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGODgtXFx1MEY4Q1xcdTEwMDAtXFx1MTAyQVxcdTEwM0ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVBLVxcdTEwNURcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZFLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhFXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RUUtXFx1MTZGOFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3ODAtXFx1MTdCM1xcdTE3RDdcXHUxN0RDXFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOEE4XFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5NTAtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QzEtXFx1MTlDN1xcdTFBMDAtXFx1MUExNlxcdTFBMjAtXFx1MUE1NFxcdTFBQTdcXHUxQjA1LVxcdTFCMzNcXHUxQjQ1LVxcdTFCNEJcXHUxQjgzLVxcdTFCQTBcXHUxQkFFXFx1MUJBRlxcdTFCQkEtXFx1MUJFNVxcdTFDMDAtXFx1MUMyM1xcdTFDNEQtXFx1MUM0RlxcdTFDNUEtXFx1MUM3RFxcdTFDRTktXFx1MUNFQ1xcdTFDRUUtXFx1MUNGMVxcdTFDRjVcXHUxQ0Y2XFx1MUQwMC1cXHUxREJGXFx1MUUwMC1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOC1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxNjAtXFx1MjE4OFxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNFRVxcdTJDRjJcXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHUyRDMwLVxcdTJENjdcXHUyRDZGXFx1MkQ4MC1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5Qi1cXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGQy1cXHUzMEZGXFx1MzEwNS1cXHUzMTJEXFx1MzEzMS1cXHUzMThFXFx1MzFBMC1cXHUzMUJBXFx1MzFGMC1cXHUzMUZGXFx1MzQwMC1cXHU0REI1XFx1NEUwMC1cXHU5RkNDXFx1QTAwMC1cXHVBNDhDXFx1QTREMC1cXHVBNEZEXFx1QTUwMC1cXHVBNjBDXFx1QTYxMC1cXHVBNjFGXFx1QTYyQVxcdUE2MkJcXHVBNjQwLVxcdUE2NkVcXHVBNjdGLVxcdUE2OURcXHVBNkEwLVxcdUE2RUZcXHVBNzE3LVxcdUE3MUZcXHVBNzIyLVxcdUE3ODhcXHVBNzhCLVxcdUE3OEVcXHVBNzkwLVxcdUE3QURcXHVBN0IwXFx1QTdCMVxcdUE3RjctXFx1QTgwMVxcdUE4MDMtXFx1QTgwNVxcdUE4MDctXFx1QTgwQVxcdUE4MEMtXFx1QTgyMlxcdUE4NDAtXFx1QTg3M1xcdUE4ODItXFx1QThCM1xcdUE4RjItXFx1QThGN1xcdUE4RkJcXHVBOTBBLVxcdUE5MjVcXHVBOTMwLVxcdUE5NDZcXHVBOTYwLVxcdUE5N0NcXHVBOTg0LVxcdUE5QjJcXHVBOUNGXFx1QTlFMC1cXHVBOUU0XFx1QTlFNi1cXHVBOUVGXFx1QTlGQS1cXHVBOUZFXFx1QUEwMC1cXHVBQTI4XFx1QUE0MC1cXHVBQTQyXFx1QUE0NC1cXHVBQTRCXFx1QUE2MC1cXHVBQTc2XFx1QUE3QVxcdUFBN0UtXFx1QUFBRlxcdUFBQjFcXHVBQUI1XFx1QUFCNlxcdUFBQjktXFx1QUFCRFxcdUFBQzBcXHVBQUMyXFx1QUFEQi1cXHVBQUREXFx1QUFFMC1cXHVBQUVBXFx1QUFGMi1cXHVBQUY0XFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUIzMC1cXHVBQjVBXFx1QUI1Qy1cXHVBQjVGXFx1QUI2NFxcdUFCNjVcXHVBQkMwLVxcdUFCRTJcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGQjFEXFx1RkIxRi1cXHVGQjI4XFx1RkIyQS1cXHVGQjM2XFx1RkIzOC1cXHVGQjNDXFx1RkIzRVxcdUZCNDBcXHVGQjQxXFx1RkI0M1xcdUZCNDRcXHVGQjQ2LVxcdUZCQjFcXHVGQkQzLVxcdUZEM0RcXHVGRDUwLVxcdUZEOEZcXHVGRDkyLVxcdUZEQzdcXHVGREYwLVxcdUZERkJcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkNcXHVGRjIxLVxcdUZGM0FcXHVGRjQxLVxcdUZGNUFcXHVGRjY2LVxcdUZGQkVcXHVGRkMyLVxcdUZGQzdcXHVGRkNBLVxcdUZGQ0ZcXHVGRkQyLVxcdUZGRDdcXHVGRkRBLVxcdUZGRENdfFxcdUQ4MDBbXFx1REMwMC1cXHVEQzBCXFx1REMwRC1cXHVEQzI2XFx1REMyOC1cXHVEQzNBXFx1REMzQ1xcdURDM0RcXHVEQzNGLVxcdURDNERcXHVEQzUwLVxcdURDNURcXHVEQzgwLVxcdURDRkFcXHVERDQwLVxcdURENzRcXHVERTgwLVxcdURFOUNcXHVERUEwLVxcdURFRDBcXHVERjAwLVxcdURGMUZcXHVERjMwLVxcdURGNEFcXHVERjUwLVxcdURGNzVcXHVERjgwLVxcdURGOURcXHVERkEwLVxcdURGQzNcXHVERkM4LVxcdURGQ0ZcXHVERkQxLVxcdURGRDVdfFxcdUQ4MDFbXFx1REMwMC1cXHVEQzlEXFx1REQwMC1cXHVERDI3XFx1REQzMC1cXHVERDYzXFx1REUwMC1cXHVERjM2XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjY3XXxcXHVEODAyW1xcdURDMDAtXFx1REMwNVxcdURDMDhcXHVEQzBBLVxcdURDMzVcXHVEQzM3XFx1REMzOFxcdURDM0NcXHVEQzNGLVxcdURDNTVcXHVEQzYwLVxcdURDNzZcXHVEQzgwLVxcdURDOUVcXHVERDAwLVxcdUREMTVcXHVERDIwLVxcdUREMzlcXHVERDgwLVxcdUREQjdcXHVEREJFXFx1RERCRlxcdURFMDBcXHVERTEwLVxcdURFMTNcXHVERTE1LVxcdURFMTdcXHVERTE5LVxcdURFMzNcXHVERTYwLVxcdURFN0NcXHVERTgwLVxcdURFOUNcXHVERUMwLVxcdURFQzdcXHVERUM5LVxcdURFRTRcXHVERjAwLVxcdURGMzVcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNzJcXHVERjgwLVxcdURGOTFdfFxcdUQ4MDNbXFx1REMwMC1cXHVEQzQ4XXxcXHVEODA0W1xcdURDMDMtXFx1REMzN1xcdURDODMtXFx1RENBRlxcdURDRDAtXFx1RENFOFxcdUREMDMtXFx1REQyNlxcdURENTAtXFx1REQ3MlxcdURENzZcXHVERDgzLVxcdUREQjJcXHVEREMxLVxcdUREQzRcXHVERERBXFx1REUwMC1cXHVERTExXFx1REUxMy1cXHVERTJCXFx1REVCMC1cXHVERURFXFx1REYwNS1cXHVERjBDXFx1REYwRlxcdURGMTBcXHVERjEzLVxcdURGMjhcXHVERjJBLVxcdURGMzBcXHVERjMyXFx1REYzM1xcdURGMzUtXFx1REYzOVxcdURGM0RcXHVERjVELVxcdURGNjFdfFxcdUQ4MDVbXFx1REM4MC1cXHVEQ0FGXFx1RENDNFxcdURDQzVcXHVEQ0M3XFx1REQ4MC1cXHVEREFFXFx1REUwMC1cXHVERTJGXFx1REU0NFxcdURFODAtXFx1REVBQV18XFx1RDgwNltcXHVEQ0EwLVxcdURDREZcXHVEQ0ZGXFx1REVDMC1cXHVERUY4XXxcXHVEODA4W1xcdURDMDAtXFx1REY5OF18XFx1RDgwOVtcXHVEQzAwLVxcdURDNkVdfFtcXHVEODBDXFx1RDg0MC1cXHVEODY4XFx1RDg2QS1cXHVEODZDXVtcXHVEQzAwLVxcdURGRkZdfFxcdUQ4MERbXFx1REMwMC1cXHVEQzJFXXxcXHVEODFBW1xcdURDMDAtXFx1REUzOFxcdURFNDAtXFx1REU1RVxcdURFRDAtXFx1REVFRFxcdURGMDAtXFx1REYyRlxcdURGNDAtXFx1REY0M1xcdURGNjMtXFx1REY3N1xcdURGN0QtXFx1REY4Rl18XFx1RDgxQltcXHVERjAwLVxcdURGNDRcXHVERjUwXFx1REY5My1cXHVERjlGXXxcXHVEODJDW1xcdURDMDBcXHVEQzAxXXxcXHVEODJGW1xcdURDMDAtXFx1REM2QVxcdURDNzAtXFx1REM3Q1xcdURDODAtXFx1REM4OFxcdURDOTAtXFx1REM5OV18XFx1RDgzNVtcXHVEQzAwLVxcdURDNTRcXHVEQzU2LVxcdURDOUNcXHVEQzlFXFx1REM5RlxcdURDQTJcXHVEQ0E1XFx1RENBNlxcdURDQTktXFx1RENBQ1xcdURDQUUtXFx1RENCOVxcdURDQkJcXHVEQ0JELVxcdURDQzNcXHVEQ0M1LVxcdUREMDVcXHVERDA3LVxcdUREMEFcXHVERDBELVxcdUREMTRcXHVERDE2LVxcdUREMUNcXHVERDFFLVxcdUREMzlcXHVERDNCLVxcdUREM0VcXHVERDQwLVxcdURENDRcXHVERDQ2XFx1REQ0QS1cXHVERDUwXFx1REQ1Mi1cXHVERUE1XFx1REVBOC1cXHVERUMwXFx1REVDMi1cXHVERURBXFx1REVEQy1cXHVERUZBXFx1REVGQy1cXHVERjE0XFx1REYxNi1cXHVERjM0XFx1REYzNi1cXHVERjRFXFx1REY1MC1cXHVERjZFXFx1REY3MC1cXHVERjg4XFx1REY4QS1cXHVERkE4XFx1REZBQS1cXHVERkMyXFx1REZDNC1cXHVERkNCXXxcXHVEODNBW1xcdURDMDAtXFx1RENDNF18XFx1RDgzQltcXHVERTAwLVxcdURFMDNcXHVERTA1LVxcdURFMUZcXHVERTIxXFx1REUyMlxcdURFMjRcXHVERTI3XFx1REUyOS1cXHVERTMyXFx1REUzNC1cXHVERTM3XFx1REUzOVxcdURFM0JcXHVERTQyXFx1REU0N1xcdURFNDlcXHVERTRCXFx1REU0RC1cXHVERTRGXFx1REU1MVxcdURFNTJcXHVERTU0XFx1REU1N1xcdURFNTlcXHVERTVCXFx1REU1RFxcdURFNUZcXHVERTYxXFx1REU2MlxcdURFNjRcXHVERTY3LVxcdURFNkFcXHVERTZDLVxcdURFNzJcXHVERTc0LVxcdURFNzdcXHVERTc5LVxcdURFN0NcXHVERTdFXFx1REU4MC1cXHVERTg5XFx1REU4Qi1cXHVERTlCXFx1REVBMS1cXHVERUEzXFx1REVBNS1cXHVERUE5XFx1REVBQi1cXHVERUJCXXxcXHVEODY5W1xcdURDMDAtXFx1REVENlxcdURGMDAtXFx1REZGRl18XFx1RDg2RFtcXHVEQzAwLVxcdURGMzRcXHVERjQwLVxcdURGRkZdfFxcdUQ4NkVbXFx1REMwMC1cXHVEQzFEXXxcXHVEODdFW1xcdURDMDAtXFx1REUxRF0vLFxuXG4gICAgICAgIC8vIEVDTUFTY3JpcHQgNi9Vbmljb2RlIHY3LjAuMCBOb25Bc2NpaUlkZW50aWZpZXJQYXJ0OlxuICAgICAgICBOb25Bc2NpaUlkZW50aWZpZXJQYXJ0OiAvW1xceEFBXFx4QjVcXHhCN1xceEJBXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzMDAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM3RlxcdTAzODYtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDgzLVxcdTA0ODdcXHUwNDhBLVxcdTA1MkZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDU5MS1cXHUwNUJEXFx1MDVCRlxcdTA1QzFcXHUwNUMyXFx1MDVDNFxcdTA1QzVcXHUwNUM3XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYxMC1cXHUwNjFBXFx1MDYyMC1cXHUwNjY5XFx1MDY2RS1cXHUwNkQzXFx1MDZENS1cXHUwNkRDXFx1MDZERi1cXHUwNkU4XFx1MDZFQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTAtXFx1MDc0QVxcdTA3NEQtXFx1MDdCMVxcdTA3QzAtXFx1MDdGNVxcdTA3RkFcXHUwODAwLVxcdTA4MkRcXHUwODQwLVxcdTA4NUJcXHUwOEEwLVxcdTA4QjJcXHUwOEU0LVxcdTA5NjNcXHUwOTY2LVxcdTA5NkZcXHUwOTcxLVxcdTA5ODNcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJDLVxcdTA5QzRcXHUwOUM3XFx1MDlDOFxcdTA5Q0ItXFx1MDlDRVxcdTA5RDdcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFM1xcdTA5RTYtXFx1MDlGMVxcdTBBMDEtXFx1MEEwM1xcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEEzQ1xcdTBBM0UtXFx1MEE0MlxcdTBBNDdcXHUwQTQ4XFx1MEE0Qi1cXHUwQTREXFx1MEE1MVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTY2LVxcdTBBNzVcXHUwQTgxLVxcdTBBODNcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkMtXFx1MEFDNVxcdTBBQzctXFx1MEFDOVxcdTBBQ0ItXFx1MEFDRFxcdTBBRDBcXHUwQUUwLVxcdTBBRTNcXHUwQUU2LVxcdTBBRUZcXHUwQjAxLVxcdTBCMDNcXHUwQjA1LVxcdTBCMENcXHUwQjBGXFx1MEIxMFxcdTBCMTMtXFx1MEIyOFxcdTBCMkEtXFx1MEIzMFxcdTBCMzJcXHUwQjMzXFx1MEIzNS1cXHUwQjM5XFx1MEIzQy1cXHUwQjQ0XFx1MEI0N1xcdTBCNDhcXHUwQjRCLVxcdTBCNERcXHUwQjU2XFx1MEI1N1xcdTBCNUNcXHUwQjVEXFx1MEI1Ri1cXHUwQjYzXFx1MEI2Ni1cXHUwQjZGXFx1MEI3MVxcdTBCODJcXHUwQjgzXFx1MEI4NS1cXHUwQjhBXFx1MEI4RS1cXHUwQjkwXFx1MEI5Mi1cXHUwQjk1XFx1MEI5OVxcdTBCOUFcXHUwQjlDXFx1MEI5RVxcdTBCOUZcXHUwQkEzXFx1MEJBNFxcdTBCQTgtXFx1MEJBQVxcdTBCQUUtXFx1MEJCOVxcdTBCQkUtXFx1MEJDMlxcdTBCQzYtXFx1MEJDOFxcdTBCQ0EtXFx1MEJDRFxcdTBCRDBcXHUwQkQ3XFx1MEJFNi1cXHUwQkVGXFx1MEMwMC1cXHUwQzAzXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzM5XFx1MEMzRC1cXHUwQzQ0XFx1MEM0Ni1cXHUwQzQ4XFx1MEM0QS1cXHUwQzREXFx1MEM1NVxcdTBDNTZcXHUwQzU4XFx1MEM1OVxcdTBDNjAtXFx1MEM2M1xcdTBDNjYtXFx1MEM2RlxcdTBDODEtXFx1MEM4M1xcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkMtXFx1MENDNFxcdTBDQzYtXFx1MENDOFxcdTBDQ0EtXFx1MENDRFxcdTBDRDVcXHUwQ0Q2XFx1MENERVxcdTBDRTAtXFx1MENFM1xcdTBDRTYtXFx1MENFRlxcdTBDRjFcXHUwQ0YyXFx1MEQwMS1cXHUwRDAzXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRC1cXHUwRDQ0XFx1MEQ0Ni1cXHUwRDQ4XFx1MEQ0QS1cXHUwRDRFXFx1MEQ1N1xcdTBENjAtXFx1MEQ2M1xcdTBENjYtXFx1MEQ2RlxcdTBEN0EtXFx1MEQ3RlxcdTBEODJcXHUwRDgzXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBEQ0FcXHUwRENGLVxcdTBERDRcXHUwREQ2XFx1MEREOC1cXHUwRERGXFx1MERFNi1cXHUwREVGXFx1MERGMlxcdTBERjNcXHUwRTAxLVxcdTBFM0FcXHUwRTQwLVxcdTBFNEVcXHUwRTUwLVxcdTBFNTlcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg3XFx1MEU4OFxcdTBFOEFcXHUwRThEXFx1MEU5NC1cXHUwRTk3XFx1MEU5OS1cXHUwRTlGXFx1MEVBMS1cXHUwRUEzXFx1MEVBNVxcdTBFQTdcXHUwRUFBXFx1MEVBQlxcdTBFQUQtXFx1MEVCOVxcdTBFQkItXFx1MEVCRFxcdTBFQzAtXFx1MEVDNFxcdTBFQzZcXHUwRUM4LVxcdTBFQ0RcXHUwRUQwLVxcdTBFRDlcXHUwRURDLVxcdTBFREZcXHUwRjAwXFx1MEYxOFxcdTBGMTlcXHUwRjIwLVxcdTBGMjlcXHUwRjM1XFx1MEYzN1xcdTBGMzlcXHUwRjNFLVxcdTBGNDdcXHUwRjQ5LVxcdTBGNkNcXHUwRjcxLVxcdTBGODRcXHUwRjg2LVxcdTBGOTdcXHUwRjk5LVxcdTBGQkNcXHUwRkM2XFx1MTAwMC1cXHUxMDQ5XFx1MTA1MC1cXHUxMDlEXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzNUQtXFx1MTM1RlxcdTEzNjktXFx1MTM3MVxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RUUtXFx1MTZGOFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxNFxcdTE3MjAtXFx1MTczNFxcdTE3NDAtXFx1MTc1M1xcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3NzJcXHUxNzczXFx1MTc4MC1cXHUxN0QzXFx1MTdEN1xcdTE3RENcXHUxN0REXFx1MTdFMC1cXHUxN0U5XFx1MTgwQi1cXHUxODBEXFx1MTgxMC1cXHUxODE5XFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFFXFx1MTkyMC1cXHUxOTJCXFx1MTkzMC1cXHUxOTNCXFx1MTk0Ni1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlCMC1cXHUxOUM5XFx1MTlEMC1cXHUxOURBXFx1MUEwMC1cXHUxQTFCXFx1MUEyMC1cXHUxQTVFXFx1MUE2MC1cXHUxQTdDXFx1MUE3Ri1cXHUxQTg5XFx1MUE5MC1cXHUxQTk5XFx1MUFBN1xcdTFBQjAtXFx1MUFCRFxcdTFCMDAtXFx1MUI0QlxcdTFCNTAtXFx1MUI1OVxcdTFCNkItXFx1MUI3M1xcdTFCODAtXFx1MUJGM1xcdTFDMDAtXFx1MUMzN1xcdTFDNDAtXFx1MUM0OVxcdTFDNEQtXFx1MUM3RFxcdTFDRDAtXFx1MUNEMlxcdTFDRDQtXFx1MUNGNlxcdTFDRjhcXHUxQ0Y5XFx1MUQwMC1cXHUxREY1XFx1MURGQy1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwMENcXHUyMDBEXFx1MjAzRlxcdTIwNDBcXHUyMDU0XFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyMEQwLVxcdTIwRENcXHUyMEUxXFx1MjBFNS1cXHUyMEYwXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOC1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxNjAtXFx1MjE4OFxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNGM1xcdTJEMDAtXFx1MkQyNVxcdTJEMjdcXHUyRDJEXFx1MkQzMC1cXHUyRDY3XFx1MkQ2RlxcdTJEN0YtXFx1MkQ5NlxcdTJEQTAtXFx1MkRBNlxcdTJEQTgtXFx1MkRBRVxcdTJEQjAtXFx1MkRCNlxcdTJEQjgtXFx1MkRCRVxcdTJEQzAtXFx1MkRDNlxcdTJEQzgtXFx1MkRDRVxcdTJERDAtXFx1MkRENlxcdTJERDgtXFx1MkRERVxcdTJERTAtXFx1MkRGRlxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyRlxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOTktXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRFxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZDQ1xcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYyQlxcdUE2NDAtXFx1QTY2RlxcdUE2NzQtXFx1QTY3RFxcdUE2N0YtXFx1QTY5RFxcdUE2OUYtXFx1QTZGMVxcdUE3MTctXFx1QTcxRlxcdUE3MjItXFx1QTc4OFxcdUE3OEItXFx1QTc4RVxcdUE3OTAtXFx1QTdBRFxcdUE3QjBcXHVBN0IxXFx1QTdGNy1cXHVBODI3XFx1QTg0MC1cXHVBODczXFx1QTg4MC1cXHVBOEM0XFx1QThEMC1cXHVBOEQ5XFx1QThFMC1cXHVBOEY3XFx1QThGQlxcdUE5MDAtXFx1QTkyRFxcdUE5MzAtXFx1QTk1M1xcdUE5NjAtXFx1QTk3Q1xcdUE5ODAtXFx1QTlDMFxcdUE5Q0YtXFx1QTlEOVxcdUE5RTAtXFx1QTlGRVxcdUFBMDAtXFx1QUEzNlxcdUFBNDAtXFx1QUE0RFxcdUFBNTAtXFx1QUE1OVxcdUFBNjAtXFx1QUE3NlxcdUFBN0EtXFx1QUFDMlxcdUFBREItXFx1QUFERFxcdUFBRTAtXFx1QUFFRlxcdUFBRjItXFx1QUFGNlxcdUFCMDEtXFx1QUIwNlxcdUFCMDktXFx1QUIwRVxcdUFCMTEtXFx1QUIxNlxcdUFCMjAtXFx1QUIyNlxcdUFCMjgtXFx1QUIyRVxcdUFCMzAtXFx1QUI1QVxcdUFCNUMtXFx1QUI1RlxcdUFCNjRcXHVBQjY1XFx1QUJDMC1cXHVBQkVBXFx1QUJFQ1xcdUFCRURcXHVBQkYwLVxcdUFCRjlcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGQjFELVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFMDAtXFx1RkUwRlxcdUZFMjAtXFx1RkUyRFxcdUZFMzNcXHVGRTM0XFx1RkU0RC1cXHVGRTRGXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYxMC1cXHVGRjE5XFx1RkYyMS1cXHVGRjNBXFx1RkYzRlxcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQ118XFx1RDgwMFtcXHVEQzAwLVxcdURDMEJcXHVEQzBELVxcdURDMjZcXHVEQzI4LVxcdURDM0FcXHVEQzNDXFx1REMzRFxcdURDM0YtXFx1REM0RFxcdURDNTAtXFx1REM1RFxcdURDODAtXFx1RENGQVxcdURENDAtXFx1REQ3NFxcdURERkRcXHVERTgwLVxcdURFOUNcXHVERUEwLVxcdURFRDBcXHVERUUwXFx1REYwMC1cXHVERjFGXFx1REYzMC1cXHVERjRBXFx1REY1MC1cXHVERjdBXFx1REY4MC1cXHVERjlEXFx1REZBMC1cXHVERkMzXFx1REZDOC1cXHVERkNGXFx1REZEMS1cXHVERkQ1XXxcXHVEODAxW1xcdURDMDAtXFx1REM5RFxcdURDQTAtXFx1RENBOVxcdUREMDAtXFx1REQyN1xcdUREMzAtXFx1REQ2M1xcdURFMDAtXFx1REYzNlxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY2N118XFx1RDgwMltcXHVEQzAwLVxcdURDMDVcXHVEQzA4XFx1REMwQS1cXHVEQzM1XFx1REMzN1xcdURDMzhcXHVEQzNDXFx1REMzRi1cXHVEQzU1XFx1REM2MC1cXHVEQzc2XFx1REM4MC1cXHVEQzlFXFx1REQwMC1cXHVERDE1XFx1REQyMC1cXHVERDM5XFx1REQ4MC1cXHVEREI3XFx1RERCRVxcdUREQkZcXHVERTAwLVxcdURFMDNcXHVERTA1XFx1REUwNlxcdURFMEMtXFx1REUxM1xcdURFMTUtXFx1REUxN1xcdURFMTktXFx1REUzM1xcdURFMzgtXFx1REUzQVxcdURFM0ZcXHVERTYwLVxcdURFN0NcXHVERTgwLVxcdURFOUNcXHVERUMwLVxcdURFQzdcXHVERUM5LVxcdURFRTZcXHVERjAwLVxcdURGMzVcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNzJcXHVERjgwLVxcdURGOTFdfFxcdUQ4MDNbXFx1REMwMC1cXHVEQzQ4XXxcXHVEODA0W1xcdURDMDAtXFx1REM0NlxcdURDNjYtXFx1REM2RlxcdURDN0YtXFx1RENCQVxcdURDRDAtXFx1RENFOFxcdURDRjAtXFx1RENGOVxcdUREMDAtXFx1REQzNFxcdUREMzYtXFx1REQzRlxcdURENTAtXFx1REQ3M1xcdURENzZcXHVERDgwLVxcdUREQzRcXHVEREQwLVxcdUREREFcXHVERTAwLVxcdURFMTFcXHVERTEzLVxcdURFMzdcXHVERUIwLVxcdURFRUFcXHVERUYwLVxcdURFRjlcXHVERjAxLVxcdURGMDNcXHVERjA1LVxcdURGMENcXHVERjBGXFx1REYxMFxcdURGMTMtXFx1REYyOFxcdURGMkEtXFx1REYzMFxcdURGMzJcXHVERjMzXFx1REYzNS1cXHVERjM5XFx1REYzQy1cXHVERjQ0XFx1REY0N1xcdURGNDhcXHVERjRCLVxcdURGNERcXHVERjU3XFx1REY1RC1cXHVERjYzXFx1REY2Ni1cXHVERjZDXFx1REY3MC1cXHVERjc0XXxcXHVEODA1W1xcdURDODAtXFx1RENDNVxcdURDQzdcXHVEQ0QwLVxcdURDRDlcXHVERDgwLVxcdUREQjVcXHVEREI4LVxcdUREQzBcXHVERTAwLVxcdURFNDBcXHVERTQ0XFx1REU1MC1cXHVERTU5XFx1REU4MC1cXHVERUI3XFx1REVDMC1cXHVERUM5XXxcXHVEODA2W1xcdURDQTAtXFx1RENFOVxcdURDRkZcXHVERUMwLVxcdURFRjhdfFxcdUQ4MDhbXFx1REMwMC1cXHVERjk4XXxcXHVEODA5W1xcdURDMDAtXFx1REM2RV18W1xcdUQ4MENcXHVEODQwLVxcdUQ4NjhcXHVEODZBLVxcdUQ4NkNdW1xcdURDMDAtXFx1REZGRl18XFx1RDgwRFtcXHVEQzAwLVxcdURDMkVdfFxcdUQ4MUFbXFx1REMwMC1cXHVERTM4XFx1REU0MC1cXHVERTVFXFx1REU2MC1cXHVERTY5XFx1REVEMC1cXHVERUVEXFx1REVGMC1cXHVERUY0XFx1REYwMC1cXHVERjM2XFx1REY0MC1cXHVERjQzXFx1REY1MC1cXHVERjU5XFx1REY2My1cXHVERjc3XFx1REY3RC1cXHVERjhGXXxcXHVEODFCW1xcdURGMDAtXFx1REY0NFxcdURGNTAtXFx1REY3RVxcdURGOEYtXFx1REY5Rl18XFx1RDgyQ1tcXHVEQzAwXFx1REMwMV18XFx1RDgyRltcXHVEQzAwLVxcdURDNkFcXHVEQzcwLVxcdURDN0NcXHVEQzgwLVxcdURDODhcXHVEQzkwLVxcdURDOTlcXHVEQzlEXFx1REM5RV18XFx1RDgzNFtcXHVERDY1LVxcdURENjlcXHVERDZELVxcdURENzJcXHVERDdCLVxcdUREODJcXHVERDg1LVxcdUREOEJcXHVEREFBLVxcdUREQURcXHVERTQyLVxcdURFNDRdfFxcdUQ4MzVbXFx1REMwMC1cXHVEQzU0XFx1REM1Ni1cXHVEQzlDXFx1REM5RVxcdURDOUZcXHVEQ0EyXFx1RENBNVxcdURDQTZcXHVEQ0E5LVxcdURDQUNcXHVEQ0FFLVxcdURDQjlcXHVEQ0JCXFx1RENCRC1cXHVEQ0MzXFx1RENDNS1cXHVERDA1XFx1REQwNy1cXHVERDBBXFx1REQwRC1cXHVERDE0XFx1REQxNi1cXHVERDFDXFx1REQxRS1cXHVERDM5XFx1REQzQi1cXHVERDNFXFx1REQ0MC1cXHVERDQ0XFx1REQ0NlxcdURENEEtXFx1REQ1MFxcdURENTItXFx1REVBNVxcdURFQTgtXFx1REVDMFxcdURFQzItXFx1REVEQVxcdURFREMtXFx1REVGQVxcdURFRkMtXFx1REYxNFxcdURGMTYtXFx1REYzNFxcdURGMzYtXFx1REY0RVxcdURGNTAtXFx1REY2RVxcdURGNzAtXFx1REY4OFxcdURGOEEtXFx1REZBOFxcdURGQUEtXFx1REZDMlxcdURGQzQtXFx1REZDQlxcdURGQ0UtXFx1REZGRl18XFx1RDgzQVtcXHVEQzAwLVxcdURDQzRcXHVEQ0QwLVxcdURDRDZdfFxcdUQ4M0JbXFx1REUwMC1cXHVERTAzXFx1REUwNS1cXHVERTFGXFx1REUyMVxcdURFMjJcXHVERTI0XFx1REUyN1xcdURFMjktXFx1REUzMlxcdURFMzQtXFx1REUzN1xcdURFMzlcXHVERTNCXFx1REU0MlxcdURFNDdcXHVERTQ5XFx1REU0QlxcdURFNEQtXFx1REU0RlxcdURFNTFcXHVERTUyXFx1REU1NFxcdURFNTdcXHVERTU5XFx1REU1QlxcdURFNURcXHVERTVGXFx1REU2MVxcdURFNjJcXHVERTY0XFx1REU2Ny1cXHVERTZBXFx1REU2Qy1cXHVERTcyXFx1REU3NC1cXHVERTc3XFx1REU3OS1cXHVERTdDXFx1REU3RVxcdURFODAtXFx1REU4OVxcdURFOEItXFx1REU5QlxcdURFQTEtXFx1REVBM1xcdURFQTUtXFx1REVBOVxcdURFQUItXFx1REVCQl18XFx1RDg2OVtcXHVEQzAwLVxcdURFRDZcXHVERjAwLVxcdURGRkZdfFxcdUQ4NkRbXFx1REMwMC1cXHVERjM0XFx1REY0MC1cXHVERkZGXXxcXHVEODZFW1xcdURDMDAtXFx1REMxRF18XFx1RDg3RVtcXHVEQzAwLVxcdURFMURdfFxcdURCNDBbXFx1REQwMC1cXHVEREVGXS9cbiAgICB9O1xuXG4gICAgLy8gRW5zdXJlIHRoZSBjb25kaXRpb24gaXMgdHJ1ZSwgb3RoZXJ3aXNlIHRocm93IGFuIGVycm9yLlxuICAgIC8vIFRoaXMgaXMgb25seSB0byBoYXZlIGEgYmV0dGVyIGNvbnRyYWN0IHNlbWFudGljLCBpLmUuIGFub3RoZXIgc2FmZXR5IG5ldFxuICAgIC8vIHRvIGNhdGNoIGEgbG9naWMgZXJyb3IuIFRoZSBjb25kaXRpb24gc2hhbGwgYmUgZnVsZmlsbGVkIGluIG5vcm1hbCBjYXNlLlxuICAgIC8vIERvIE5PVCB1c2UgdGhpcyB0byBlbmZvcmNlIGEgY2VydGFpbiBjb25kaXRpb24gb24gYW55IHVzZXIgaW5wdXQuXG5cbiAgICBmdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBU1NFUlQ6ICcgKyBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGVjaW1hbERpZ2l0KGNoKSB7XG4gICAgICAgIHJldHVybiAoY2ggPj0gMHgzMCAmJiBjaCA8PSAweDM5KTsgICAvLyAwLi45XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNIZXhEaWdpdChjaCkge1xuICAgICAgICByZXR1cm4gJzAxMjM0NTY3ODlhYmNkZWZBQkNERUYnLmluZGV4T2YoY2gpID49IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNPY3RhbERpZ2l0KGNoKSB7XG4gICAgICAgIHJldHVybiAnMDEyMzQ1NjcnLmluZGV4T2YoY2gpID49IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb2N0YWxUb0RlY2ltYWwoY2gpIHtcbiAgICAgICAgLy8gXFwwIGlzIG5vdCBvY3RhbCBlc2NhcGUgc2VxdWVuY2VcbiAgICAgICAgdmFyIG9jdGFsID0gKGNoICE9PSAnMCcpLCBjb2RlID0gJzAxMjM0NTY3Jy5pbmRleE9mKGNoKTtcblxuICAgICAgICBpZiAoaW5kZXggPCBsZW5ndGggJiYgaXNPY3RhbERpZ2l0KHNvdXJjZVtpbmRleF0pKSB7XG4gICAgICAgICAgICBvY3RhbCA9IHRydWU7XG4gICAgICAgICAgICBjb2RlID0gY29kZSAqIDggKyAnMDEyMzQ1NjcnLmluZGV4T2Yoc291cmNlW2luZGV4KytdKTtcblxuICAgICAgICAgICAgLy8gMyBkaWdpdHMgYXJlIG9ubHkgYWxsb3dlZCB3aGVuIHN0cmluZyBzdGFydHNcbiAgICAgICAgICAgIC8vIHdpdGggMCwgMSwgMiwgM1xuICAgICAgICAgICAgaWYgKCcwMTIzJy5pbmRleE9mKGNoKSA+PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGluZGV4IDwgbGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgIGlzT2N0YWxEaWdpdChzb3VyY2VbaW5kZXhdKSkge1xuICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlICogOCArICcwMTIzNDU2NycuaW5kZXhPZihzb3VyY2VbaW5kZXgrK10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6IGNvZGUsXG4gICAgICAgICAgICBvY3RhbDogb2N0YWxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBFQ01BLTI2MiAxMS4yIFdoaXRlIFNwYWNlXG5cbiAgICBmdW5jdGlvbiBpc1doaXRlU3BhY2UoY2gpIHtcbiAgICAgICAgcmV0dXJuIChjaCA9PT0gMHgyMCkgfHwgKGNoID09PSAweDA5KSB8fCAoY2ggPT09IDB4MEIpIHx8IChjaCA9PT0gMHgwQykgfHwgKGNoID09PSAweEEwKSB8fFxuICAgICAgICAgICAgKGNoID49IDB4MTY4MCAmJiBbMHgxNjgwLCAweDE4MEUsIDB4MjAwMCwgMHgyMDAxLCAweDIwMDIsIDB4MjAwMywgMHgyMDA0LCAweDIwMDUsIDB4MjAwNiwgMHgyMDA3LCAweDIwMDgsIDB4MjAwOSwgMHgyMDBBLCAweDIwMkYsIDB4MjA1RiwgMHgzMDAwLCAweEZFRkZdLmluZGV4T2YoY2gpID49IDApO1xuICAgIH1cblxuICAgIC8vIEVDTUEtMjYyIDExLjMgTGluZSBUZXJtaW5hdG9yc1xuXG4gICAgZnVuY3Rpb24gaXNMaW5lVGVybWluYXRvcihjaCkge1xuICAgICAgICByZXR1cm4gKGNoID09PSAweDBBKSB8fCAoY2ggPT09IDB4MEQpIHx8IChjaCA9PT0gMHgyMDI4KSB8fCAoY2ggPT09IDB4MjAyOSk7XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTEuNiBJZGVudGlmaWVyIE5hbWVzIGFuZCBJZGVudGlmaWVyc1xuXG4gICAgZnVuY3Rpb24gZnJvbUNvZGVQb2ludChjcCkge1xuICAgICAgICByZXR1cm4gKGNwIDwgMHgxMDAwMCkgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNwKSA6XG4gICAgICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RDgwMCArICgoY3AgLSAweDEwMDAwKSA+PiAxMCkpICtcbiAgICAgICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEQzAwICsgKChjcCAtIDB4MTAwMDApICYgMTAyMykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSWRlbnRpZmllclN0YXJ0KGNoKSB7XG4gICAgICAgIHJldHVybiAoY2ggPT09IDB4MjQpIHx8IChjaCA9PT0gMHg1RikgfHwgIC8vICQgKGRvbGxhcikgYW5kIF8gKHVuZGVyc2NvcmUpXG4gICAgICAgICAgICAoY2ggPj0gMHg0MSAmJiBjaCA8PSAweDVBKSB8fCAgICAgICAgIC8vIEEuLlpcbiAgICAgICAgICAgIChjaCA+PSAweDYxICYmIGNoIDw9IDB4N0EpIHx8ICAgICAgICAgLy8gYS4uelxuICAgICAgICAgICAgKGNoID09PSAweDVDKSB8fCAgICAgICAgICAgICAgICAgICAgICAvLyBcXCAoYmFja3NsYXNoKVxuICAgICAgICAgICAgKChjaCA+PSAweDgwKSAmJiBSZWdleC5Ob25Bc2NpaUlkZW50aWZpZXJTdGFydC50ZXN0KGZyb21Db2RlUG9pbnQoY2gpKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNJZGVudGlmaWVyUGFydChjaCkge1xuICAgICAgICByZXR1cm4gKGNoID09PSAweDI0KSB8fCAoY2ggPT09IDB4NUYpIHx8ICAvLyAkIChkb2xsYXIpIGFuZCBfICh1bmRlcnNjb3JlKVxuICAgICAgICAgICAgKGNoID49IDB4NDEgJiYgY2ggPD0gMHg1QSkgfHwgICAgICAgICAvLyBBLi5aXG4gICAgICAgICAgICAoY2ggPj0gMHg2MSAmJiBjaCA8PSAweDdBKSB8fCAgICAgICAgIC8vIGEuLnpcbiAgICAgICAgICAgIChjaCA+PSAweDMwICYmIGNoIDw9IDB4MzkpIHx8ICAgICAgICAgLy8gMC4uOVxuICAgICAgICAgICAgKGNoID09PSAweDVDKSB8fCAgICAgICAgICAgICAgICAgICAgICAvLyBcXCAoYmFja3NsYXNoKVxuICAgICAgICAgICAgKChjaCA+PSAweDgwKSAmJiBSZWdleC5Ob25Bc2NpaUlkZW50aWZpZXJQYXJ0LnRlc3QoZnJvbUNvZGVQb2ludChjaCkpKTtcbiAgICB9XG5cbiAgICAvLyBFQ01BLTI2MiAxMS42LjIuMiBGdXR1cmUgUmVzZXJ2ZWQgV29yZHNcblxuICAgIGZ1bmN0aW9uIGlzRnV0dXJlUmVzZXJ2ZWRXb3JkKGlkKSB7XG4gICAgICAgIHN3aXRjaCAoaWQpIHtcbiAgICAgICAgY2FzZSAnZW51bSc6XG4gICAgICAgIGNhc2UgJ2V4cG9ydCc6XG4gICAgICAgIGNhc2UgJ2ltcG9ydCc6XG4gICAgICAgIGNhc2UgJ3N1cGVyJzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKGlkKSB7XG4gICAgICAgIHN3aXRjaCAoaWQpIHtcbiAgICAgICAgY2FzZSAnaW1wbGVtZW50cyc6XG4gICAgICAgIGNhc2UgJ2ludGVyZmFjZSc6XG4gICAgICAgIGNhc2UgJ3BhY2thZ2UnOlxuICAgICAgICBjYXNlICdwcml2YXRlJzpcbiAgICAgICAgY2FzZSAncHJvdGVjdGVkJzpcbiAgICAgICAgY2FzZSAncHVibGljJzpcbiAgICAgICAgY2FzZSAnc3RhdGljJzpcbiAgICAgICAgY2FzZSAneWllbGQnOlxuICAgICAgICBjYXNlICdsZXQnOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1Jlc3RyaWN0ZWRXb3JkKGlkKSB7XG4gICAgICAgIHJldHVybiBpZCA9PT0gJ2V2YWwnIHx8IGlkID09PSAnYXJndW1lbnRzJztcbiAgICB9XG5cbiAgICAvLyBFQ01BLTI2MiAxMS42LjIuMSBLZXl3b3Jkc1xuXG4gICAgZnVuY3Rpb24gaXNLZXl3b3JkKGlkKSB7XG4gICAgICAgIHN3aXRjaCAoaWQubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICdpZicpIHx8IChpZCA9PT0gJ2luJykgfHwgKGlkID09PSAnZG8nKTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ3ZhcicpIHx8IChpZCA9PT0gJ2ZvcicpIHx8IChpZCA9PT0gJ25ldycpIHx8XG4gICAgICAgICAgICAgICAgKGlkID09PSAndHJ5JykgfHwgKGlkID09PSAnbGV0Jyk7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICd0aGlzJykgfHwgKGlkID09PSAnZWxzZScpIHx8IChpZCA9PT0gJ2Nhc2UnKSB8fFxuICAgICAgICAgICAgICAgIChpZCA9PT0gJ3ZvaWQnKSB8fCAoaWQgPT09ICd3aXRoJykgfHwgKGlkID09PSAnZW51bScpO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICByZXR1cm4gKGlkID09PSAnd2hpbGUnKSB8fCAoaWQgPT09ICdicmVhaycpIHx8IChpZCA9PT0gJ2NhdGNoJykgfHxcbiAgICAgICAgICAgICAgICAoaWQgPT09ICd0aHJvdycpIHx8IChpZCA9PT0gJ2NvbnN0JykgfHwgKGlkID09PSAneWllbGQnKSB8fFxuICAgICAgICAgICAgICAgIChpZCA9PT0gJ2NsYXNzJykgfHwgKGlkID09PSAnc3VwZXInKTtcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ3JldHVybicpIHx8IChpZCA9PT0gJ3R5cGVvZicpIHx8IChpZCA9PT0gJ2RlbGV0ZScpIHx8XG4gICAgICAgICAgICAgICAgKGlkID09PSAnc3dpdGNoJykgfHwgKGlkID09PSAnZXhwb3J0JykgfHwgKGlkID09PSAnaW1wb3J0Jyk7XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICdkZWZhdWx0JykgfHwgKGlkID09PSAnZmluYWxseScpIHx8IChpZCA9PT0gJ2V4dGVuZHMnKTtcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ2Z1bmN0aW9uJykgfHwgKGlkID09PSAnY29udGludWUnKSB8fCAoaWQgPT09ICdkZWJ1Z2dlcicpO1xuICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ2luc3RhbmNlb2YnKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEVDTUEtMjYyIDExLjQgQ29tbWVudHNcblxuICAgIGZ1bmN0aW9uIGFkZENvbW1lbnQodHlwZSwgdmFsdWUsIHN0YXJ0LCBlbmQsIGxvYykge1xuICAgICAgICB2YXIgY29tbWVudDtcblxuICAgICAgICBhc3NlcnQodHlwZW9mIHN0YXJ0ID09PSAnbnVtYmVyJywgJ0NvbW1lbnQgbXVzdCBoYXZlIHZhbGlkIHBvc2l0aW9uJyk7XG5cbiAgICAgICAgc3RhdGUubGFzdENvbW1lbnRTdGFydCA9IHN0YXJ0O1xuXG4gICAgICAgIGNvbW1lbnQgPSB7XG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH07XG4gICAgICAgIGlmIChleHRyYS5yYW5nZSkge1xuICAgICAgICAgICAgY29tbWVudC5yYW5nZSA9IFtzdGFydCwgZW5kXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXh0cmEubG9jKSB7XG4gICAgICAgICAgICBjb21tZW50LmxvYyA9IGxvYztcbiAgICAgICAgfVxuICAgICAgICBleHRyYS5jb21tZW50cy5wdXNoKGNvbW1lbnQpO1xuICAgICAgICBpZiAoZXh0cmEuYXR0YWNoQ29tbWVudCkge1xuICAgICAgICAgICAgZXh0cmEubGVhZGluZ0NvbW1lbnRzLnB1c2goY29tbWVudCk7XG4gICAgICAgICAgICBleHRyYS50cmFpbGluZ0NvbW1lbnRzLnB1c2goY29tbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4dHJhLnRva2VuaXplKSB7XG4gICAgICAgICAgICBjb21tZW50LnR5cGUgPSBjb21tZW50LnR5cGUgKyAnQ29tbWVudCc7XG4gICAgICAgICAgICBpZiAoZXh0cmEuZGVsZWdhdGUpIHtcbiAgICAgICAgICAgICAgICBjb21tZW50ID0gZXh0cmEuZGVsZWdhdGUoY29tbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHRyYS50b2tlbnMucHVzaChjb21tZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNraXBTaW5nbGVMaW5lQ29tbWVudChvZmZzZXQpIHtcbiAgICAgICAgdmFyIHN0YXJ0LCBsb2MsIGNoLCBjb21tZW50O1xuXG4gICAgICAgIHN0YXJ0ID0gaW5kZXggLSBvZmZzZXQ7XG4gICAgICAgIGxvYyA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBjb2x1bW46IGluZGV4IC0gbGluZVN0YXJ0IC0gb2Zmc2V0XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICBpZiAoaXNMaW5lVGVybWluYXRvcihjaCkpIHtcbiAgICAgICAgICAgICAgICBoYXNMaW5lVGVybWluYXRvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGV4dHJhLmNvbW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBzb3VyY2Uuc2xpY2Uoc3RhcnQgKyBvZmZzZXQsIGluZGV4IC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIGxvYy5lbmQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydCAtIDFcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYWRkQ29tbWVudCgnTGluZScsIGNvbW1lbnQsIHN0YXJ0LCBpbmRleCAtIDEsIGxvYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gMTMgJiYgc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpID09PSAxMCkge1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICArK2xpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV4dHJhLmNvbW1lbnRzKSB7XG4gICAgICAgICAgICBjb21tZW50ID0gc291cmNlLnNsaWNlKHN0YXJ0ICsgb2Zmc2V0LCBpbmRleCk7XG4gICAgICAgICAgICBsb2MuZW5kID0ge1xuICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFkZENvbW1lbnQoJ0xpbmUnLCBjb21tZW50LCBzdGFydCwgaW5kZXgsIGxvYyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBza2lwTXVsdGlMaW5lQ29tbWVudCgpIHtcbiAgICAgICAgdmFyIHN0YXJ0LCBsb2MsIGNoLCBjb21tZW50O1xuXG4gICAgICAgIGlmIChleHRyYS5jb21tZW50cykge1xuICAgICAgICAgICAgc3RhcnQgPSBpbmRleCAtIDI7XG4gICAgICAgICAgICBsb2MgPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydCAtIDJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICAgIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoKSkge1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gMHgwRCAmJiBzb3VyY2UuY2hhckNvZGVBdChpbmRleCArIDEpID09PSAweDBBKSB7XG4gICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhhc0xpbmVUZXJtaW5hdG9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICArK2xpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQgPSBpbmRleDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4MkEpIHtcbiAgICAgICAgICAgICAgICAvLyBCbG9jayBjb21tZW50IGVuZHMgd2l0aCAnKi8nLlxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChpbmRleCArIDEpID09PSAweDJGKSB7XG4gICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHRyYS5jb21tZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudCA9IHNvdXJjZS5zbGljZShzdGFydCArIDIsIGluZGV4IC0gMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2MuZW5kID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZENvbW1lbnQoJ0Jsb2NrJywgY29tbWVudCwgc3RhcnQsIGluZGV4LCBsb2MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJhbiBvZmYgdGhlIGVuZCBvZiB0aGUgZmlsZSAtIHRoZSB3aG9sZSB0aGluZyBpcyBhIGNvbW1lbnRcbiAgICAgICAgaWYgKGV4dHJhLmNvbW1lbnRzKSB7XG4gICAgICAgICAgICBsb2MuZW5kID0ge1xuICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbW1lbnQgPSBzb3VyY2Uuc2xpY2Uoc3RhcnQgKyAyLCBpbmRleCk7XG4gICAgICAgICAgICBhZGRDb21tZW50KCdCbG9jaycsIGNvbW1lbnQsIHN0YXJ0LCBpbmRleCwgbG9jKTtcbiAgICAgICAgfVxuICAgICAgICB0b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbigpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNraXBDb21tZW50KCkge1xuICAgICAgICB2YXIgY2gsIHN0YXJ0O1xuICAgICAgICBoYXNMaW5lVGVybWluYXRvciA9IGZhbHNlO1xuXG4gICAgICAgIHN0YXJ0ID0gKGluZGV4ID09PSAwKTtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcblxuICAgICAgICAgICAgaWYgKGlzV2hpdGVTcGFjZShjaCkpIHtcbiAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoKSkge1xuICAgICAgICAgICAgICAgIGhhc0xpbmVUZXJtaW5hdG9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gMHgwRCAmJiBzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgPT09IDB4MEEpIHtcbiAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKytsaW5lTnVtYmVyO1xuICAgICAgICAgICAgICAgIGxpbmVTdGFydCA9IGluZGV4O1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4MkYpIHsgLy8gVSswMDJGIGlzICcvJ1xuICAgICAgICAgICAgICAgIGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09IDB4MkYpIHtcbiAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgc2tpcFNpbmdsZUxpbmVDb21tZW50KDIpO1xuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gMHgyQSkgeyAgLy8gVSswMDJBIGlzICcqJ1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICBza2lwTXVsdGlMaW5lQ29tbWVudCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhcnQgJiYgY2ggPT09IDB4MkQpIHsgLy8gVSswMDJEIGlzICctJ1xuICAgICAgICAgICAgICAgIC8vIFUrMDAzRSBpcyAnPidcbiAgICAgICAgICAgICAgICBpZiAoKHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4ICsgMSkgPT09IDB4MkQpICYmIChzb3VyY2UuY2hhckNvZGVBdChpbmRleCArIDIpID09PSAweDNFKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyAnLS0+JyBpcyBhIHNpbmdsZS1saW5lIGNvbW1lbnRcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggKz0gMztcbiAgICAgICAgICAgICAgICAgICAgc2tpcFNpbmdsZUxpbmVDb21tZW50KDMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4M0MpIHsgLy8gVSswMDNDIGlzICc8J1xuICAgICAgICAgICAgICAgIGlmIChzb3VyY2Uuc2xpY2UoaW5kZXggKyAxLCBpbmRleCArIDQpID09PSAnIS0tJykge1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4OyAvLyBgPGBcbiAgICAgICAgICAgICAgICAgICAgKytpbmRleDsgLy8gYCFgXG4gICAgICAgICAgICAgICAgICAgICsraW5kZXg7IC8vIGAtYFxuICAgICAgICAgICAgICAgICAgICArK2luZGV4OyAvLyBgLWBcbiAgICAgICAgICAgICAgICAgICAgc2tpcFNpbmdsZUxpbmVDb21tZW50KDQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FuSGV4RXNjYXBlKHByZWZpeCkge1xuICAgICAgICB2YXIgaSwgbGVuLCBjaCwgY29kZSA9IDA7XG5cbiAgICAgICAgbGVuID0gKHByZWZpeCA9PT0gJ3UnKSA/IDQgOiAyO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA8IGxlbmd0aCAmJiBpc0hleERpZ2l0KHNvdXJjZVtpbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICAgICAgY29kZSA9IGNvZGUgKiAxNiArICcwMTIzNDU2Nzg5YWJjZGVmJy5pbmRleE9mKGNoLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NhblVuaWNvZGVDb2RlUG9pbnRFc2NhcGUoKSB7XG4gICAgICAgIHZhciBjaCwgY29kZTtcblxuICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgIGNvZGUgPSAwO1xuXG4gICAgICAgIC8vIEF0IGxlYXN0LCBvbmUgaGV4IGRpZ2l0IGlzIHJlcXVpcmVkLlxuICAgICAgICBpZiAoY2ggPT09ICd9Jykge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICBpZiAoIWlzSGV4RGlnaXQoY2gpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb2RlID0gY29kZSAqIDE2ICsgJzAxMjM0NTY3ODlhYmNkZWYnLmluZGV4T2YoY2gudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29kZSA+IDB4MTBGRkZGIHx8IGNoICE9PSAnfScpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnJvbUNvZGVQb2ludChjb2RlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb2RlUG9pbnRBdChpKSB7XG4gICAgICAgIHZhciBjcCwgZmlyc3QsIHNlY29uZDtcblxuICAgICAgICBjcCA9IHNvdXJjZS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY3AgPj0gMHhEODAwICYmIGNwIDw9IDB4REJGRikge1xuICAgICAgICAgICAgc2Vjb25kID0gc291cmNlLmNoYXJDb2RlQXQoaSArIDEpO1xuICAgICAgICAgICAgaWYgKHNlY29uZCA+PSAweERDMDAgJiYgc2Vjb25kIDw9IDB4REZGRikge1xuICAgICAgICAgICAgICAgIGZpcnN0ID0gY3A7XG4gICAgICAgICAgICAgICAgY3AgPSAoZmlyc3QgLSAweEQ4MDApICogMHg0MDAgKyBzZWNvbmQgLSAweERDMDAgKyAweDEwMDAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldENvbXBsZXhJZGVudGlmaWVyKCkge1xuICAgICAgICB2YXIgY3AsIGNoLCBpZDtcblxuICAgICAgICBjcCA9IGNvZGVQb2ludEF0KGluZGV4KTtcbiAgICAgICAgaWQgPSBmcm9tQ29kZVBvaW50KGNwKTtcbiAgICAgICAgaW5kZXggKz0gaWQubGVuZ3RoO1xuXG4gICAgICAgIC8vICdcXHUnIChVKzAwNUMsIFUrMDA3NSkgZGVub3RlcyBhbiBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICAgICAgaWYgKGNwID09PSAweDVDKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpICE9PSAweDc1KSB7XG4gICAgICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICBpZiAoc291cmNlW2luZGV4XSA9PT0gJ3snKSB7XG4gICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICBjaCA9IHNjYW5Vbmljb2RlQ29kZVBvaW50RXNjYXBlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoID0gc2NhbkhleEVzY2FwZSgndScpO1xuICAgICAgICAgICAgICAgIGNwID0gY2guY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNoIHx8IGNoID09PSAnXFxcXCcgfHwgIWlzSWRlbnRpZmllclN0YXJ0KGNwKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlkID0gY2g7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNwID0gY29kZVBvaW50QXQoaW5kZXgpO1xuICAgICAgICAgICAgaWYgKCFpc0lkZW50aWZpZXJQYXJ0KGNwKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2ggPSBmcm9tQ29kZVBvaW50KGNwKTtcbiAgICAgICAgICAgIGlkICs9IGNoO1xuICAgICAgICAgICAgaW5kZXggKz0gY2gubGVuZ3RoO1xuXG4gICAgICAgICAgICAvLyAnXFx1JyAoVSswMDVDLCBVKzAwNzUpIGRlbm90ZXMgYW4gZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICBpZiAoY3AgPT09IDB4NUMpIHtcbiAgICAgICAgICAgICAgICBpZCA9IGlkLnN1YnN0cigwLCBpZC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpICE9PSAweDc1KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZVtpbmRleF0gPT09ICd7Jykge1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICBjaCA9IHNjYW5Vbmljb2RlQ29kZVBvaW50RXNjYXBlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2ggPSBzY2FuSGV4RXNjYXBlKCd1Jyk7XG4gICAgICAgICAgICAgICAgICAgIGNwID0gY2guY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaCB8fCBjaCA9PT0gJ1xcXFwnIHx8ICFpc0lkZW50aWZpZXJQYXJ0KGNwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZCArPSBjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRJZGVudGlmaWVyKCkge1xuICAgICAgICB2YXIgc3RhcnQsIGNoO1xuXG4gICAgICAgIHN0YXJ0ID0gaW5kZXgrKztcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gMHg1Qykge1xuICAgICAgICAgICAgICAgIC8vIEJsYWNrc2xhc2ggKFUrMDA1QykgbWFya3MgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgaW5kZXggPSBzdGFydDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Q29tcGxleElkZW50aWZpZXIoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPj0gMHhEODAwICYmIGNoIDwgMHhERkZGKSB7XG4gICAgICAgICAgICAgICAgLy8gTmVlZCB0byBoYW5kbGUgc3Vycm9nYXRlIHBhaXJzLlxuICAgICAgICAgICAgICAgIGluZGV4ID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldENvbXBsZXhJZGVudGlmaWVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNJZGVudGlmaWVyUGFydChjaCkpIHtcbiAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzb3VyY2Uuc2xpY2Uoc3RhcnQsIGluZGV4KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FuSWRlbnRpZmllcigpIHtcbiAgICAgICAgdmFyIHN0YXJ0LCBpZCwgdHlwZTtcblxuICAgICAgICBzdGFydCA9IGluZGV4O1xuXG4gICAgICAgIC8vIEJhY2tzbGFzaCAoVSswMDVDKSBzdGFydHMgYW4gZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAgICAgIGlkID0gKHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSA9PT0gMHg1QykgPyBnZXRDb21wbGV4SWRlbnRpZmllcigpIDogZ2V0SWRlbnRpZmllcigpO1xuXG4gICAgICAgIC8vIFRoZXJlIGlzIG5vIGtleXdvcmQgb3IgbGl0ZXJhbCB3aXRoIG9ubHkgb25lIGNoYXJhY3Rlci5cbiAgICAgICAgLy8gVGh1cywgaXQgbXVzdCBiZSBhbiBpZGVudGlmaWVyLlxuICAgICAgICBpZiAoaWQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB0eXBlID0gVG9rZW4uSWRlbnRpZmllcjtcbiAgICAgICAgfSBlbHNlIGlmIChpc0tleXdvcmQoaWQpKSB7XG4gICAgICAgICAgICB0eXBlID0gVG9rZW4uS2V5d29yZDtcbiAgICAgICAgfSBlbHNlIGlmIChpZCA9PT0gJ251bGwnKSB7XG4gICAgICAgICAgICB0eXBlID0gVG9rZW4uTnVsbExpdGVyYWw7XG4gICAgICAgIH0gZWxzZSBpZiAoaWQgPT09ICd0cnVlJyB8fCBpZCA9PT0gJ2ZhbHNlJykge1xuICAgICAgICAgICAgdHlwZSA9IFRva2VuLkJvb2xlYW5MaXRlcmFsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHlwZSA9IFRva2VuLklkZW50aWZpZXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIHZhbHVlOiBpZCxcbiAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgfTtcbiAgICB9XG5cblxuICAgIC8vIEVDTUEtMjYyIDExLjcgUHVuY3R1YXRvcnNcblxuICAgIGZ1bmN0aW9uIHNjYW5QdW5jdHVhdG9yKCkge1xuICAgICAgICB2YXIgdG9rZW4sIHN0cjtcblxuICAgICAgICB0b2tlbiA9IHtcbiAgICAgICAgICAgIHR5cGU6IFRva2VuLlB1bmN0dWF0b3IsXG4gICAgICAgICAgICB2YWx1ZTogJycsXG4gICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICBzdGFydDogaW5kZXgsXG4gICAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIG1vc3QgY29tbW9uIHNpbmdsZS1jaGFyYWN0ZXIgcHVuY3R1YXRvcnMuXG4gICAgICAgIHN0ciA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgIHN3aXRjaCAoc3RyKSB7XG5cbiAgICAgICAgY2FzZSAnKCc6XG4gICAgICAgICAgICBpZiAoZXh0cmEudG9rZW5pemUpIHtcbiAgICAgICAgICAgICAgICBleHRyYS5vcGVuUGFyZW5Ub2tlbiA9IGV4dHJhLnRva2VuVmFsdWVzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd7JzpcbiAgICAgICAgICAgIGlmIChleHRyYS50b2tlbml6ZSkge1xuICAgICAgICAgICAgICAgIGV4dHJhLm9wZW5DdXJseVRva2VuID0gZXh0cmEudG9rZW5WYWx1ZXMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGUuY3VybHlTdGFjay5wdXNoKCd7Jyk7XG4gICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnLic6XG4gICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgaWYgKHNvdXJjZVtpbmRleF0gPT09ICcuJyAmJiBzb3VyY2VbaW5kZXggKyAxXSA9PT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgLy8gU3ByZWFkIG9wZXJhdG9yOiAuLi5cbiAgICAgICAgICAgICAgICBpbmRleCArPSAyO1xuICAgICAgICAgICAgICAgIHN0ciA9ICcuLi4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnfSc6XG4gICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgc3RhdGUuY3VybHlTdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICcpJzpcbiAgICAgICAgY2FzZSAnOyc6XG4gICAgICAgIGNhc2UgJywnOlxuICAgICAgICBjYXNlICdbJzpcbiAgICAgICAgY2FzZSAnXSc6XG4gICAgICAgIGNhc2UgJzonOlxuICAgICAgICBjYXNlICc/JzpcbiAgICAgICAgY2FzZSAnfic6XG4gICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIDQtY2hhcmFjdGVyIHB1bmN0dWF0b3IuXG4gICAgICAgICAgICBzdHIgPSBzb3VyY2Uuc3Vic3RyKGluZGV4LCA0KTtcbiAgICAgICAgICAgIGlmIChzdHIgPT09ICc+Pj49Jykge1xuICAgICAgICAgICAgICAgIGluZGV4ICs9IDQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgLy8gMy1jaGFyYWN0ZXIgcHVuY3R1YXRvcnMuXG4gICAgICAgICAgICAgICAgc3RyID0gc3RyLnN1YnN0cigwLCAzKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RyID09PSAnPT09JyB8fCBzdHIgPT09ICchPT0nIHx8IHN0ciA9PT0gJz4+PicgfHxcbiAgICAgICAgICAgICAgICAgICAgc3RyID09PSAnPDw9JyB8fCBzdHIgPT09ICc+Pj0nKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ICs9IDM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyAyLWNoYXJhY3RlciBwdW5jdHVhdG9ycy5cbiAgICAgICAgICAgICAgICAgICAgc3RyID0gc3RyLnN1YnN0cigwLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0ciA9PT0gJyYmJyB8fCBzdHIgPT09ICd8fCcgfHwgc3RyID09PSAnPT0nIHx8IHN0ciA9PT0gJyE9JyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyID09PSAnKz0nIHx8IHN0ciA9PT0gJy09JyB8fCBzdHIgPT09ICcqPScgfHwgc3RyID09PSAnLz0nIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgPT09ICcrKycgfHwgc3RyID09PSAnLS0nIHx8IHN0ciA9PT0gJzw8JyB8fCBzdHIgPT09ICc+PicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciA9PT0gJyY9JyB8fCBzdHIgPT09ICd8PScgfHwgc3RyID09PSAnXj0nIHx8IHN0ciA9PT0gJyU9JyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyID09PSAnPD0nIHx8IHN0ciA9PT0gJz49JyB8fCBzdHIgPT09ICc9PicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDEtY2hhcmFjdGVyIHB1bmN0dWF0b3JzLlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgnPD49ISstKiUmfF4vJy5pbmRleE9mKHN0cikgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5kZXggPT09IHRva2VuLnN0YXJ0KSB7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdG9rZW4uZW5kID0gaW5kZXg7XG4gICAgICAgIHRva2VuLnZhbHVlID0gc3RyO1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTEuOC4zIE51bWVyaWMgTGl0ZXJhbHNcblxuICAgIGZ1bmN0aW9uIHNjYW5IZXhMaXRlcmFsKHN0YXJ0KSB7XG4gICAgICAgIHZhciBudW1iZXIgPSAnJztcblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghaXNIZXhEaWdpdChzb3VyY2VbaW5kZXhdKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChudW1iZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogVG9rZW4uTnVtZXJpY0xpdGVyYWwsXG4gICAgICAgICAgICB2YWx1ZTogcGFyc2VJbnQoJzB4JyArIG51bWJlciwgMTYpLFxuICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjYW5CaW5hcnlMaXRlcmFsKHN0YXJ0KSB7XG4gICAgICAgIHZhciBjaCwgbnVtYmVyO1xuXG4gICAgICAgIG51bWJlciA9ICcnO1xuXG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKGNoICE9PSAnMCcgJiYgY2ggIT09ICcxJykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChudW1iZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBvbmx5IDBiIG9yIDBCXG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoY2gpIHx8IGlzRGVjaW1hbERpZ2l0KGNoKSkge1xuICAgICAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogVG9rZW4uTnVtZXJpY0xpdGVyYWwsXG4gICAgICAgICAgICB2YWx1ZTogcGFyc2VJbnQobnVtYmVyLCAyKSxcbiAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FuT2N0YWxMaXRlcmFsKHByZWZpeCwgc3RhcnQpIHtcbiAgICAgICAgdmFyIG51bWJlciwgb2N0YWw7XG5cbiAgICAgICAgaWYgKGlzT2N0YWxEaWdpdChwcmVmaXgpKSB7XG4gICAgICAgICAgICBvY3RhbCA9IHRydWU7XG4gICAgICAgICAgICBudW1iZXIgPSAnMCcgKyBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvY3RhbCA9IGZhbHNlO1xuICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgIG51bWJlciA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIWlzT2N0YWxEaWdpdChzb3VyY2VbaW5kZXhdKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb2N0YWwgJiYgbnVtYmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gb25seSAwbyBvciAwT1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpIHx8IGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogVG9rZW4uTnVtZXJpY0xpdGVyYWwsXG4gICAgICAgICAgICB2YWx1ZTogcGFyc2VJbnQobnVtYmVyLCA4KSxcbiAgICAgICAgICAgIG9jdGFsOiBvY3RhbCxcbiAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0ltcGxpY2l0T2N0YWxMaXRlcmFsKCkge1xuICAgICAgICB2YXIgaSwgY2g7XG5cbiAgICAgICAgLy8gSW1wbGljaXQgb2N0YWwsIHVubGVzcyB0aGVyZSBpcyBhIG5vbi1vY3RhbCBkaWdpdC5cbiAgICAgICAgLy8gKEFubmV4IEIuMS4xIG9uIE51bWVyaWMgTGl0ZXJhbHMpXG4gICAgICAgIGZvciAoaSA9IGluZGV4ICsgMTsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZVtpXTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJzgnIHx8IGNoID09PSAnOScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzT2N0YWxEaWdpdChjaCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjYW5OdW1lcmljTGl0ZXJhbCgpIHtcbiAgICAgICAgdmFyIG51bWJlciwgc3RhcnQsIGNoO1xuXG4gICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgYXNzZXJ0KGlzRGVjaW1hbERpZ2l0KGNoLmNoYXJDb2RlQXQoMCkpIHx8IChjaCA9PT0gJy4nKSxcbiAgICAgICAgICAgICdOdW1lcmljIGxpdGVyYWwgbXVzdCBzdGFydCB3aXRoIGEgZGVjaW1hbCBkaWdpdCBvciBhIGRlY2ltYWwgcG9pbnQnKTtcblxuICAgICAgICBzdGFydCA9IGluZGV4O1xuICAgICAgICBudW1iZXIgPSAnJztcbiAgICAgICAgaWYgKGNoICE9PSAnLicpIHtcbiAgICAgICAgICAgIG51bWJlciA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcblxuICAgICAgICAgICAgLy8gSGV4IG51bWJlciBzdGFydHMgd2l0aCAnMHgnLlxuICAgICAgICAgICAgLy8gT2N0YWwgbnVtYmVyIHN0YXJ0cyB3aXRoICcwJy5cbiAgICAgICAgICAgIC8vIE9jdGFsIG51bWJlciBpbiBFUzYgc3RhcnRzIHdpdGggJzBvJy5cbiAgICAgICAgICAgIC8vIEJpbmFyeSBudW1iZXIgaW4gRVM2IHN0YXJ0cyB3aXRoICcwYicuXG4gICAgICAgICAgICBpZiAobnVtYmVyID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICd4JyB8fCBjaCA9PT0gJ1gnKSB7XG4gICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzY2FuSGV4TGl0ZXJhbChzdGFydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ2InIHx8IGNoID09PSAnQicpIHtcbiAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjYW5CaW5hcnlMaXRlcmFsKHN0YXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnbycgfHwgY2ggPT09ICdPJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2Nhbk9jdGFsTGl0ZXJhbChjaCwgc3RhcnQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpc09jdGFsRGlnaXQoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0ltcGxpY2l0T2N0YWxMaXRlcmFsKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzY2FuT2N0YWxMaXRlcmFsKGNoLCBzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdoaWxlIChpc0RlY2ltYWxEaWdpdChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICAgICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaCA9PT0gJy4nKSB7XG4gICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgd2hpbGUgKGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoID09PSAnZScgfHwgY2ggPT09ICdFJykge1xuICAgICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcblxuICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnKycgfHwgY2ggPT09ICctJykge1xuICAgICAgICAgICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNEZWNpbWFsRGlnaXQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChpc0RlY2ltYWxEaWdpdChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogVG9rZW4uTnVtZXJpY0xpdGVyYWwsXG4gICAgICAgICAgICB2YWx1ZTogcGFyc2VGbG9hdChudW1iZXIpLFxuICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEVDTUEtMjYyIDExLjguNCBTdHJpbmcgTGl0ZXJhbHNcblxuICAgIGZ1bmN0aW9uIHNjYW5TdHJpbmdMaXRlcmFsKCkge1xuICAgICAgICB2YXIgc3RyID0gJycsIHF1b3RlLCBzdGFydCwgY2gsIHVuZXNjYXBlZCwgb2N0VG9EZWMsIG9jdGFsID0gZmFsc2U7XG5cbiAgICAgICAgcXVvdGUgPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICBhc3NlcnQoKHF1b3RlID09PSAnXFwnJyB8fCBxdW90ZSA9PT0gJ1wiJyksXG4gICAgICAgICAgICAnU3RyaW5nIGxpdGVyYWwgbXVzdCBzdGFydHMgd2l0aCBhIHF1b3RlJyk7XG5cbiAgICAgICAgc3RhcnQgPSBpbmRleDtcbiAgICAgICAgKytpbmRleDtcblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuXG4gICAgICAgICAgICBpZiAoY2ggPT09IHF1b3RlKSB7XG4gICAgICAgICAgICAgICAgcXVvdGUgPSAnJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICdcXFxcJykge1xuICAgICAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgICAgIGlmICghY2ggfHwgIWlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd1JzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlW2luZGV4XSA9PT0gJ3snKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gc2NhblVuaWNvZGVDb2RlUG9pbnRFc2NhcGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5lc2NhcGVkID0gc2NhbkhleEVzY2FwZShjaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF1bmVzY2FwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IHVuZXNjYXBlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICduJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxuJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdyJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxyJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFx0JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxiJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxmJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd2JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFx4MEInO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJzgnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICc5JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBjaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzT2N0YWxEaWdpdChjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvY3RUb0RlYyA9IG9jdGFsVG9EZWNpbWFsKGNoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9jdGFsID0gb2N0VG9EZWMub2N0YWwgfHwgb2N0YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUob2N0VG9EZWMuY29kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBjaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgKytsaW5lTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcXHInICYmIHNvdXJjZVtpbmRleF0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxpbmVTdGFydCA9IGluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHIgKz0gY2g7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocXVvdGUgIT09ICcnKSB7XG4gICAgICAgICAgICBpbmRleCA9IHN0YXJ0O1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBUb2tlbi5TdHJpbmdMaXRlcmFsLFxuICAgICAgICAgICAgdmFsdWU6IHN0cixcbiAgICAgICAgICAgIG9jdGFsOiBvY3RhbCxcbiAgICAgICAgICAgIGxpbmVOdW1iZXI6IHN0YXJ0TGluZU51bWJlcixcbiAgICAgICAgICAgIGxpbmVTdGFydDogc3RhcnRMaW5lU3RhcnQsXG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTEuOC42IFRlbXBsYXRlIExpdGVyYWwgTGV4aWNhbCBDb21wb25lbnRzXG5cbiAgICBmdW5jdGlvbiBzY2FuVGVtcGxhdGUoKSB7XG4gICAgICAgIHZhciBjb29rZWQgPSAnJywgY2gsIHN0YXJ0LCByYXdPZmZzZXQsIHRlcm1pbmF0ZWQsIGhlYWQsIHRhaWwsIHJlc3RvcmUsIHVuZXNjYXBlZDtcblxuICAgICAgICB0ZXJtaW5hdGVkID0gZmFsc2U7XG4gICAgICAgIHRhaWwgPSBmYWxzZTtcbiAgICAgICAgc3RhcnQgPSBpbmRleDtcbiAgICAgICAgaGVhZCA9IChzb3VyY2VbaW5kZXhdID09PSAnYCcpO1xuICAgICAgICByYXdPZmZzZXQgPSAyO1xuXG4gICAgICAgICsraW5kZXg7XG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJ2AnKSB7XG4gICAgICAgICAgICAgICAgcmF3T2Zmc2V0ID0gMTtcbiAgICAgICAgICAgICAgICB0YWlsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0ZXJtaW5hdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICckJykge1xuICAgICAgICAgICAgICAgIGlmIChzb3VyY2VbaW5kZXhdID09PSAneycpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuY3VybHlTdGFjay5wdXNoKCckeycpO1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvb2tlZCArPSBjaDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICdcXFxcJykge1xuICAgICAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgICAgIGlmICghaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ24nOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9ICdcXG4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3InOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9ICdcXHInO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9ICdcXHQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3UnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICd4JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VbaW5kZXhdID09PSAneycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSBzY2FuVW5pY29kZUNvZGVQb2ludEVzY2FwZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN0b3JlID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5lc2NhcGVkID0gc2NhbkhleEVzY2FwZShjaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVuZXNjYXBlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gdW5lc2NhcGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gcmVzdG9yZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSAnXFxiJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSAnXFxmJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd2JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSAnXFx2JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICcwJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0RlY2ltYWxEaWdpdChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWw6IFxcMDEgXFwwMiBhbmQgc28gb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihNZXNzYWdlcy5UZW1wbGF0ZU9jdGFsTGl0ZXJhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSAnXFwwJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNPY3RhbERpZ2l0KGNoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWw6IFxcMSBcXDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKE1lc3NhZ2VzLlRlbXBsYXRlT2N0YWxMaXRlcmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICArK2xpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xccicgJiYgc291cmNlW2luZGV4XSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGluZVN0YXJ0ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgICAgICAgICAgKytsaW5lTnVtYmVyO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xccicgJiYgc291cmNlW2luZGV4XSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgY29va2VkICs9ICdcXG4nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb29rZWQgKz0gY2g7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRlcm1pbmF0ZWQpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWhlYWQpIHtcbiAgICAgICAgICAgIHN0YXRlLmN1cmx5U3RhY2sucG9wKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogVG9rZW4uVGVtcGxhdGUsXG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIGNvb2tlZDogY29va2VkLFxuICAgICAgICAgICAgICAgIHJhdzogc291cmNlLnNsaWNlKHN0YXJ0ICsgMSwgaW5kZXggLSByYXdPZmZzZXQpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGVhZDogaGVhZCxcbiAgICAgICAgICAgIHRhaWw6IHRhaWwsXG4gICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTEuOC41IFJlZ3VsYXIgRXhwcmVzc2lvbiBMaXRlcmFsc1xuXG4gICAgZnVuY3Rpb24gdGVzdFJlZ0V4cChwYXR0ZXJuLCBmbGFncykge1xuICAgICAgICAvLyBUaGUgQk1QIGNoYXJhY3RlciB0byB1c2UgYXMgYSByZXBsYWNlbWVudCBmb3IgYXN0cmFsIHN5bWJvbHMgd2hlblxuICAgICAgICAvLyB0cmFuc2xhdGluZyBhbiBFUzYgXCJ1XCItZmxhZ2dlZCBwYXR0ZXJuIHRvIGFuIEVTNS1jb21wYXRpYmxlXG4gICAgICAgIC8vIGFwcHJveGltYXRpb24uXG4gICAgICAgIC8vIE5vdGU6IHJlcGxhY2luZyB3aXRoICdcXHVGRkZGJyBlbmFibGVzIGZhbHNlIHBvc2l0aXZlcyBpbiB1bmxpa2VseVxuICAgICAgICAvLyBzY2VuYXJpb3MuIEZvciBleGFtcGxlLCBgW1xcdXsxMDQ0Zn0tXFx1ezEwNDQwfV1gIGlzIGFuIGludmFsaWRcbiAgICAgICAgLy8gcGF0dGVybiB0aGF0IHdvdWxkIG5vdCBiZSBkZXRlY3RlZCBieSB0aGlzIHN1YnN0aXR1dGlvbi5cbiAgICAgICAgdmFyIGFzdHJhbFN1YnN0aXR1dGUgPSAnXFx1RkZGRicsXG4gICAgICAgICAgICB0bXAgPSBwYXR0ZXJuO1xuXG4gICAgICAgIGlmIChmbGFncy5pbmRleE9mKCd1JykgPj0gMCkge1xuICAgICAgICAgICAgdG1wID0gdG1wXG4gICAgICAgICAgICAgICAgLy8gUmVwbGFjZSBldmVyeSBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZSB3aXRoIHRoZSBlcXVpdmFsZW50XG4gICAgICAgICAgICAgICAgLy8gQk1QIGNoYXJhY3RlciBvciBhIGNvbnN0YW50IEFTQ0lJIGNvZGUgcG9pbnQgaW4gdGhlIGNhc2Ugb2ZcbiAgICAgICAgICAgICAgICAvLyBhc3RyYWwgc3ltYm9scy4gKFNlZSB0aGUgYWJvdmUgbm90ZSBvbiBgYXN0cmFsU3Vic3RpdHV0ZWBcbiAgICAgICAgICAgICAgICAvLyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4pXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFx1XFx7KFswLTlhLWZBLUZdKylcXH18XFxcXHUoW2EtZkEtRjAtOV17NH0pL2csIGZ1bmN0aW9uICgkMCwgJDEsICQyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2RlUG9pbnQgPSBwYXJzZUludCgkMSB8fCAkMiwgMTYpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZVBvaW50ID4gMHgxMEZGRkYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKG51bGwsIE1lc3NhZ2VzLkludmFsaWRSZWdFeHApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPD0gMHhGRkZGKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhc3RyYWxTdWJzdGl0dXRlO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLy8gUmVwbGFjZSBlYWNoIHBhaXJlZCBzdXJyb2dhdGUgd2l0aCBhIHNpbmdsZSBBU0NJSSBzeW1ib2wgdG9cbiAgICAgICAgICAgICAgICAvLyBhdm9pZCB0aHJvd2luZyBvbiByZWd1bGFyIGV4cHJlc3Npb25zIHRoYXQgYXJlIG9ubHkgdmFsaWQgaW5cbiAgICAgICAgICAgICAgICAvLyBjb21iaW5hdGlvbiB3aXRoIHRoZSBcInVcIiBmbGFnLlxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKFxuICAgICAgICAgICAgICAgICAgICAvW1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXS9nLFxuICAgICAgICAgICAgICAgICAgICBhc3RyYWxTdWJzdGl0dXRlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpcnN0LCBkZXRlY3QgaW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb25zLlxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgUmVnRXhwKHRtcCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKG51bGwsIE1lc3NhZ2VzLkludmFsaWRSZWdFeHApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmV0dXJuIGEgcmVndWxhciBleHByZXNzaW9uIG9iamVjdCBmb3IgdGhpcyBwYXR0ZXJuLWZsYWcgcGFpciwgb3JcbiAgICAgICAgLy8gYG51bGxgIGluIGNhc2UgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgZG9lc24ndCBzdXBwb3J0IHRoZSBmbGFncyBpdFxuICAgICAgICAvLyB1c2VzLlxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocGF0dGVybiwgZmxhZ3MpO1xuICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjYW5SZWdFeHBCb2R5KCkge1xuICAgICAgICB2YXIgY2gsIHN0ciwgY2xhc3NNYXJrZXIsIHRlcm1pbmF0ZWQsIGJvZHk7XG5cbiAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICBhc3NlcnQoY2ggPT09ICcvJywgJ1JlZ3VsYXIgZXhwcmVzc2lvbiBsaXRlcmFsIG11c3Qgc3RhcnQgd2l0aCBhIHNsYXNoJyk7XG4gICAgICAgIHN0ciA9IHNvdXJjZVtpbmRleCsrXTtcblxuICAgICAgICBjbGFzc01hcmtlciA9IGZhbHNlO1xuICAgICAgICB0ZXJtaW5hdGVkID0gZmFsc2U7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICBzdHIgKz0gY2g7XG4gICAgICAgICAgICBpZiAoY2ggPT09ICdcXFxcJykge1xuICAgICAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgICAgIC8vIEVDTUEtMjYyIDcuOC41XG4gICAgICAgICAgICAgICAgaWYgKGlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4obnVsbCwgTWVzc2FnZXMuVW50ZXJtaW5hdGVkUmVnRXhwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4obnVsbCwgTWVzc2FnZXMuVW50ZXJtaW5hdGVkUmVnRXhwKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NNYXJrZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICddJykge1xuICAgICAgICAgICAgICAgICAgICBjbGFzc01hcmtlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnLycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVybWluYXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICdbJykge1xuICAgICAgICAgICAgICAgICAgICBjbGFzc01hcmtlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0ZXJtaW5hdGVkKSB7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbihudWxsLCBNZXNzYWdlcy5VbnRlcm1pbmF0ZWRSZWdFeHApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXhjbHVkZSBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaC5cbiAgICAgICAgYm9keSA9IHN0ci5zdWJzdHIoMSwgc3RyLmxlbmd0aCAtIDIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IGJvZHksXG4gICAgICAgICAgICBsaXRlcmFsOiBzdHJcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FuUmVnRXhwRmxhZ3MoKSB7XG4gICAgICAgIHZhciBjaCwgc3RyLCBmbGFncywgcmVzdG9yZTtcblxuICAgICAgICBzdHIgPSAnJztcbiAgICAgICAgZmxhZ3MgPSAnJztcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgICAgICBpZiAoIWlzSWRlbnRpZmllclBhcnQoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xcXFwnICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ3UnKSB7XG4gICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHJlc3RvcmUgPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgY2ggPSBzY2FuSGV4RXNjYXBlKCd1Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmxhZ3MgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHN0ciArPSAnXFxcXHUnOyByZXN0b3JlIDwgaW5kZXg7ICsrcmVzdG9yZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBzb3VyY2VbcmVzdG9yZV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHJlc3RvcmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbGFncyArPSAndSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFx1JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbigpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXCc7XG4gICAgICAgICAgICAgICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmbGFncyArPSBjaDtcbiAgICAgICAgICAgICAgICBzdHIgKz0gY2g7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IGZsYWdzLFxuICAgICAgICAgICAgbGl0ZXJhbDogc3RyXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NhblJlZ0V4cCgpIHtcbiAgICAgICAgdmFyIHN0YXJ0LCBib2R5LCBmbGFncywgdmFsdWU7XG4gICAgICAgIHNjYW5uaW5nID0gdHJ1ZTtcblxuICAgICAgICBsb29rYWhlYWQgPSBudWxsO1xuICAgICAgICBza2lwQ29tbWVudCgpO1xuICAgICAgICBzdGFydCA9IGluZGV4O1xuXG4gICAgICAgIGJvZHkgPSBzY2FuUmVnRXhwQm9keSgpO1xuICAgICAgICBmbGFncyA9IHNjYW5SZWdFeHBGbGFncygpO1xuICAgICAgICB2YWx1ZSA9IHRlc3RSZWdFeHAoYm9keS52YWx1ZSwgZmxhZ3MudmFsdWUpO1xuICAgICAgICBzY2FubmluZyA9IGZhbHNlO1xuICAgICAgICBpZiAoZXh0cmEudG9rZW5pemUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogVG9rZW4uUmVndWxhckV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIHJlZ2V4OiB7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm46IGJvZHkudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzOiBmbGFncy52YWx1ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsaXRlcmFsOiBib2R5LmxpdGVyYWwgKyBmbGFncy5saXRlcmFsLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgcmVnZXg6IHtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuOiBib2R5LnZhbHVlLFxuICAgICAgICAgICAgICAgIGZsYWdzOiBmbGFncy52YWx1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb2xsZWN0UmVnZXgoKSB7XG4gICAgICAgIHZhciBwb3MsIGxvYywgcmVnZXgsIHRva2VuO1xuXG4gICAgICAgIHNraXBDb21tZW50KCk7XG5cbiAgICAgICAgcG9zID0gaW5kZXg7XG4gICAgICAgIGxvYyA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBjb2x1bW46IGluZGV4IC0gbGluZVN0YXJ0XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnZXggPSBzY2FuUmVnRXhwKCk7XG5cbiAgICAgICAgbG9jLmVuZCA9IHtcbiAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICBjb2x1bW46IGluZGV4IC0gbGluZVN0YXJ0XG4gICAgICAgIH07XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgaWYgKCFleHRyYS50b2tlbml6ZSkge1xuICAgICAgICAgICAgLy8gUG9wIHRoZSBwcmV2aW91cyB0b2tlbiwgd2hpY2ggaXMgbGlrZWx5ICcvJyBvciAnLz0nXG4gICAgICAgICAgICBpZiAoZXh0cmEudG9rZW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IGV4dHJhLnRva2Vuc1tleHRyYS50b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLnJhbmdlWzBdID09PSBwb3MgJiYgdG9rZW4udHlwZSA9PT0gJ1B1bmN0dWF0b3InKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSA9PT0gJy8nIHx8IHRva2VuLnZhbHVlID09PSAnLz0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYS50b2tlbnMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4dHJhLnRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnUmVndWxhckV4cHJlc3Npb24nLFxuICAgICAgICAgICAgICAgIHZhbHVlOiByZWdleC5saXRlcmFsLFxuICAgICAgICAgICAgICAgIHJlZ2V4OiByZWdleC5yZWdleCxcbiAgICAgICAgICAgICAgICByYW5nZTogW3BvcywgaW5kZXhdLFxuICAgICAgICAgICAgICAgIGxvYzogbG9jXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWdleDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0lkZW50aWZpZXJOYW1lKHRva2VuKSB7XG4gICAgICAgIHJldHVybiB0b2tlbi50eXBlID09PSBUb2tlbi5JZGVudGlmaWVyIHx8XG4gICAgICAgICAgICB0b2tlbi50eXBlID09PSBUb2tlbi5LZXl3b3JkIHx8XG4gICAgICAgICAgICB0b2tlbi50eXBlID09PSBUb2tlbi5Cb29sZWFuTGl0ZXJhbCB8fFxuICAgICAgICAgICAgdG9rZW4udHlwZSA9PT0gVG9rZW4uTnVsbExpdGVyYWw7XG4gICAgfVxuXG4gICAgLy8gVXNpbmcgdGhlIGZvbGxvd2luZyBhbGdvcml0aG06XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc3dlZXQuanMvd2lraS9kZXNpZ25cblxuICAgIGZ1bmN0aW9uIGFkdmFuY2VTbGFzaCgpIHtcbiAgICAgICAgdmFyIHJlZ2V4LCBwcmV2aW91cywgY2hlY2s7XG5cbiAgICAgICAgZnVuY3Rpb24gdGVzdEtleXdvcmQodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSAmJiAodmFsdWUubGVuZ3RoID4gMSkgJiYgKHZhbHVlWzBdID49ICdhJykgJiYgKHZhbHVlWzBdIDw9ICd6Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2aW91cyA9IGV4dHJhLnRva2VuVmFsdWVzW2V4dHJhLnRva2VuVmFsdWVzLmxlbmd0aCAtIDFdO1xuICAgICAgICByZWdleCA9IChwcmV2aW91cyAhPT0gbnVsbCk7XG5cbiAgICAgICAgc3dpdGNoIChwcmV2aW91cykge1xuICAgICAgICBjYXNlICd0aGlzJzpcbiAgICAgICAgY2FzZSAnXSc6XG4gICAgICAgICAgICByZWdleCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnKSc6XG4gICAgICAgICAgICBjaGVjayA9IGV4dHJhLnRva2VuVmFsdWVzW2V4dHJhLm9wZW5QYXJlblRva2VuIC0gMV07XG4gICAgICAgICAgICByZWdleCA9IChjaGVjayA9PT0gJ2lmJyB8fCBjaGVjayA9PT0gJ3doaWxlJyB8fCBjaGVjayA9PT0gJ2ZvcicgfHwgY2hlY2sgPT09ICd3aXRoJyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd9JzpcbiAgICAgICAgICAgIC8vIERpdmlkaW5nIGEgZnVuY3Rpb24gYnkgYW55dGhpbmcgbWFrZXMgbGl0dGxlIHNlbnNlLFxuICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgdG8gY2hlY2sgZm9yIHRoYXQuXG4gICAgICAgICAgICByZWdleCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRlc3RLZXl3b3JkKGV4dHJhLnRva2VuVmFsdWVzW2V4dHJhLm9wZW5DdXJseVRva2VuIC0gM10pKSB7XG4gICAgICAgICAgICAgICAgLy8gQW5vbnltb3VzIGZ1bmN0aW9uLCBlLmcuIGZ1bmN0aW9uKCl7fSAvNDJcbiAgICAgICAgICAgICAgICBjaGVjayA9IGV4dHJhLnRva2VuVmFsdWVzW2V4dHJhLm9wZW5DdXJseVRva2VuIC0gNF07XG4gICAgICAgICAgICAgICAgcmVnZXggPSBjaGVjayA/IChGbkV4cHJUb2tlbnMuaW5kZXhPZihjaGVjaykgPCAwKSA6IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0ZXN0S2V5d29yZChleHRyYS50b2tlblZhbHVlc1tleHRyYS5vcGVuQ3VybHlUb2tlbiAtIDRdKSkge1xuICAgICAgICAgICAgICAgIC8vIE5hbWVkIGZ1bmN0aW9uLCBlLmcuIGZ1bmN0aW9uIGYoKXt9IC80Mi9cbiAgICAgICAgICAgICAgICBjaGVjayA9IGV4dHJhLnRva2VuVmFsdWVzW2V4dHJhLm9wZW5DdXJseVRva2VuIC0gNV07XG4gICAgICAgICAgICAgICAgcmVnZXggPSBjaGVjayA/IChGbkV4cHJUb2tlbnMuaW5kZXhPZihjaGVjaykgPCAwKSA6IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVnZXggPyBjb2xsZWN0UmVnZXgoKSA6IHNjYW5QdW5jdHVhdG9yKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWR2YW5jZSgpIHtcbiAgICAgICAgdmFyIGNwLCB0b2tlbjtcblxuICAgICAgICBpZiAoaW5kZXggPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFRva2VuLkVPRixcbiAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICAgIHN0YXJ0OiBpbmRleCxcbiAgICAgICAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY3AgPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCk7XG5cbiAgICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KGNwKSkge1xuICAgICAgICAgICAgdG9rZW4gPSBzY2FuSWRlbnRpZmllcigpO1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBpc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQodG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4udHlwZSA9IFRva2VuLktleXdvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWZXJ5IGNvbW1vbjogKCBhbmQgKSBhbmQgO1xuICAgICAgICBpZiAoY3AgPT09IDB4MjggfHwgY3AgPT09IDB4MjkgfHwgY3AgPT09IDB4M0IpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RyaW5nIGxpdGVyYWwgc3RhcnRzIHdpdGggc2luZ2xlIHF1b3RlIChVKzAwMjcpIG9yIGRvdWJsZSBxdW90ZSAoVSswMDIyKS5cbiAgICAgICAgaWYgKGNwID09PSAweDI3IHx8IGNwID09PSAweDIyKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NhblN0cmluZ0xpdGVyYWwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERvdCAoLikgVSswMDJFIGNhbiBhbHNvIHN0YXJ0IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyLCBoZW5jZSB0aGUgbmVlZFxuICAgICAgICAvLyB0byBjaGVjayB0aGUgbmV4dCBjaGFyYWN0ZXIuXG4gICAgICAgIGlmIChjcCA9PT0gMHgyRSkge1xuICAgICAgICAgICAgaWYgKGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4ICsgMSkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjYW5OdW1lcmljTGl0ZXJhbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWNpbWFsRGlnaXQoY3ApKSB7XG4gICAgICAgICAgICByZXR1cm4gc2Nhbk51bWVyaWNMaXRlcmFsKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTbGFzaCAoLykgVSswMDJGIGNhbiBhbHNvIHN0YXJ0IGEgcmVnZXguXG4gICAgICAgIGlmIChleHRyYS50b2tlbml6ZSAmJiBjcCA9PT0gMHgyRikge1xuICAgICAgICAgICAgcmV0dXJuIGFkdmFuY2VTbGFzaCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGVtcGxhdGUgbGl0ZXJhbHMgc3RhcnQgd2l0aCBgIChVKzAwNjApIGZvciB0ZW1wbGF0ZSBoZWFkXG4gICAgICAgIC8vIG9yIH0gKFUrMDA3RCkgZm9yIHRlbXBsYXRlIG1pZGRsZSBvciB0ZW1wbGF0ZSB0YWlsLlxuICAgICAgICBpZiAoY3AgPT09IDB4NjAgfHwgKGNwID09PSAweDdEICYmIHN0YXRlLmN1cmx5U3RhY2tbc3RhdGUuY3VybHlTdGFjay5sZW5ndGggLSAxXSA9PT0gJyR7JykpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2FuVGVtcGxhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBvc3NpYmxlIGlkZW50aWZpZXIgc3RhcnQgaW4gYSBzdXJyb2dhdGUgcGFpci5cbiAgICAgICAgaWYgKGNwID49IDB4RDgwMCAmJiBjcCA8IDB4REZGRikge1xuICAgICAgICAgICAgY3AgPSBjb2RlUG9pbnRBdChpbmRleCk7XG4gICAgICAgICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoY3ApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjYW5JZGVudGlmaWVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb2xsZWN0VG9rZW4oKSB7XG4gICAgICAgIHZhciBsb2MsIHRva2VuLCB2YWx1ZSwgZW50cnk7XG5cbiAgICAgICAgbG9jID0ge1xuICAgICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0b2tlbiA9IGFkdmFuY2UoKTtcbiAgICAgICAgbG9jLmVuZCA9IHtcbiAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICBjb2x1bW46IGluZGV4IC0gbGluZVN0YXJ0XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLkVPRikge1xuICAgICAgICAgICAgdmFsdWUgPSBzb3VyY2Uuc2xpY2UodG9rZW4uc3RhcnQsIHRva2VuLmVuZCk7XG4gICAgICAgICAgICBlbnRyeSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBUb2tlbk5hbWVbdG9rZW4udHlwZV0sXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIHJhbmdlOiBbdG9rZW4uc3RhcnQsIHRva2VuLmVuZF0sXG4gICAgICAgICAgICAgICAgbG9jOiBsb2NcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodG9rZW4ucmVnZXgpIHtcbiAgICAgICAgICAgICAgICBlbnRyeS5yZWdleCA9IHtcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybjogdG9rZW4ucmVnZXgucGF0dGVybixcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3M6IHRva2VuLnJlZ2V4LmZsYWdzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHRyYS50b2tlblZhbHVlcykge1xuICAgICAgICAgICAgICAgIGV4dHJhLnRva2VuVmFsdWVzLnB1c2goKGVudHJ5LnR5cGUgPT09ICdQdW5jdHVhdG9yJyB8fCBlbnRyeS50eXBlID09PSAnS2V5d29yZCcpID8gZW50cnkudmFsdWUgOiBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHRyYS50b2tlbml6ZSkge1xuICAgICAgICAgICAgICAgIGlmICghZXh0cmEucmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGVudHJ5LnJhbmdlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWV4dHJhLmxvYykge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZW50cnkubG9jO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXh0cmEuZGVsZWdhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZW50cnkgPSBleHRyYS5kZWxlZ2F0ZShlbnRyeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXh0cmEudG9rZW5zLnB1c2goZW50cnkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxleCgpIHtcbiAgICAgICAgdmFyIHRva2VuO1xuICAgICAgICBzY2FubmluZyA9IHRydWU7XG5cbiAgICAgICAgbGFzdEluZGV4ID0gaW5kZXg7XG4gICAgICAgIGxhc3RMaW5lTnVtYmVyID0gbGluZU51bWJlcjtcbiAgICAgICAgbGFzdExpbmVTdGFydCA9IGxpbmVTdGFydDtcblxuICAgICAgICBza2lwQ29tbWVudCgpO1xuXG4gICAgICAgIHRva2VuID0gbG9va2FoZWFkO1xuXG4gICAgICAgIHN0YXJ0SW5kZXggPSBpbmRleDtcbiAgICAgICAgc3RhcnRMaW5lTnVtYmVyID0gbGluZU51bWJlcjtcbiAgICAgICAgc3RhcnRMaW5lU3RhcnQgPSBsaW5lU3RhcnQ7XG5cbiAgICAgICAgbG9va2FoZWFkID0gKHR5cGVvZiBleHRyYS50b2tlbnMgIT09ICd1bmRlZmluZWQnKSA/IGNvbGxlY3RUb2tlbigpIDogYWR2YW5jZSgpO1xuICAgICAgICBzY2FubmluZyA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVlaygpIHtcbiAgICAgICAgc2Nhbm5pbmcgPSB0cnVlO1xuXG4gICAgICAgIHNraXBDb21tZW50KCk7XG5cbiAgICAgICAgbGFzdEluZGV4ID0gaW5kZXg7XG4gICAgICAgIGxhc3RMaW5lTnVtYmVyID0gbGluZU51bWJlcjtcbiAgICAgICAgbGFzdExpbmVTdGFydCA9IGxpbmVTdGFydDtcblxuICAgICAgICBzdGFydEluZGV4ID0gaW5kZXg7XG4gICAgICAgIHN0YXJ0TGluZU51bWJlciA9IGxpbmVOdW1iZXI7XG4gICAgICAgIHN0YXJ0TGluZVN0YXJ0ID0gbGluZVN0YXJ0O1xuXG4gICAgICAgIGxvb2thaGVhZCA9ICh0eXBlb2YgZXh0cmEudG9rZW5zICE9PSAndW5kZWZpbmVkJykgPyBjb2xsZWN0VG9rZW4oKSA6IGFkdmFuY2UoKTtcbiAgICAgICAgc2Nhbm5pbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBQb3NpdGlvbigpIHtcbiAgICAgICAgdGhpcy5saW5lID0gc3RhcnRMaW5lTnVtYmVyO1xuICAgICAgICB0aGlzLmNvbHVtbiA9IHN0YXJ0SW5kZXggLSBzdGFydExpbmVTdGFydDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBTb3VyY2VMb2NhdGlvbigpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IG5ldyBQb3NpdGlvbigpO1xuICAgICAgICB0aGlzLmVuZCA9IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gV3JhcHBpbmdTb3VyY2VMb2NhdGlvbihzdGFydFRva2VuKSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSB7XG4gICAgICAgICAgICBsaW5lOiBzdGFydFRva2VuLmxpbmVOdW1iZXIsXG4gICAgICAgICAgICBjb2x1bW46IHN0YXJ0VG9rZW4uc3RhcnQgLSBzdGFydFRva2VuLmxpbmVTdGFydFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmVuZCA9IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTm9kZSgpIHtcbiAgICAgICAgaWYgKGV4dHJhLnJhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLnJhbmdlID0gW3N0YXJ0SW5kZXgsIDBdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHRyYS5sb2MpIHtcbiAgICAgICAgICAgIHRoaXMubG9jID0gbmV3IFNvdXJjZUxvY2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBXcmFwcGluZ05vZGUoc3RhcnRUb2tlbikge1xuICAgICAgICBpZiAoZXh0cmEucmFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMucmFuZ2UgPSBbc3RhcnRUb2tlbi5zdGFydCwgMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4dHJhLmxvYykge1xuICAgICAgICAgICAgdGhpcy5sb2MgPSBuZXcgV3JhcHBpbmdTb3VyY2VMb2NhdGlvbihzdGFydFRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIFdyYXBwaW5nTm9kZS5wcm90b3R5cGUgPSBOb2RlLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBwcm9jZXNzQ29tbWVudDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxhc3RDaGlsZCxcbiAgICAgICAgICAgICAgICBpbm5lckNvbW1lbnRzLFxuICAgICAgICAgICAgICAgIGxlYWRpbmdDb21tZW50cyxcbiAgICAgICAgICAgICAgICB0cmFpbGluZ0NvbW1lbnRzLFxuICAgICAgICAgICAgICAgIGJvdHRvbVJpZ2h0ID0gZXh0cmEuYm90dG9tUmlnaHRTdGFjayxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIGNvbW1lbnQsXG4gICAgICAgICAgICAgICAgbGFzdCA9IGJvdHRvbVJpZ2h0W2JvdHRvbVJpZ2h0Lmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSBTeW50YXguUHJvZ3JhbSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmJvZHkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBwYXRjaCBpbm5uZXJDb21tZW50cyBmb3IgcHJvcGVydGllcyBlbXB0eSBibG9ja1xuICAgICAgICAgICAgICogYGZ1bmN0aW9uIGEoKSB7LyoqIGNvbW1lbnRzICoqXFwvfWBcbiAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSBTeW50YXguQmxvY2tTdGF0ZW1lbnQgJiYgdGhpcy5ib2R5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlubmVyQ29tbWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBleHRyYS5sZWFkaW5nQ29tbWVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudCA9IGV4dHJhLmxlYWRpbmdDb21tZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmFuZ2VbMV0gPj0gY29tbWVudC5yYW5nZVsxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJDb21tZW50cy51bnNoaWZ0KGNvbW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmEubGVhZGluZ0NvbW1lbnRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhLnRyYWlsaW5nQ29tbWVudHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbm5lckNvbW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlubmVyQ29tbWVudHMgPSBpbm5lckNvbW1lbnRzO1xuICAgICAgICAgICAgICAgICAgICAvL2JvdHRvbVJpZ2h0LnB1c2godGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChleHRyYS50cmFpbGluZ0NvbW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0cmFpbGluZ0NvbW1lbnRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChpID0gZXh0cmEudHJhaWxpbmdDb21tZW50cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgICAgICAgICBjb21tZW50ID0gZXh0cmEudHJhaWxpbmdDb21tZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbW1lbnQucmFuZ2VbMF0gPj0gdGhpcy5yYW5nZVsxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhaWxpbmdDb21tZW50cy51bnNoaWZ0KGNvbW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmEudHJhaWxpbmdDb21tZW50cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXh0cmEudHJhaWxpbmdDb21tZW50cyA9IFtdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdCAmJiBsYXN0LnRyYWlsaW5nQ29tbWVudHMgJiYgbGFzdC50cmFpbGluZ0NvbW1lbnRzWzBdLnJhbmdlWzBdID49IHRoaXMucmFuZ2VbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhaWxpbmdDb21tZW50cyA9IGxhc3QudHJhaWxpbmdDb21tZW50cztcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGxhc3QudHJhaWxpbmdDb21tZW50cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEVhdGluZyB0aGUgc3RhY2suXG4gICAgICAgICAgICB3aGlsZSAobGFzdCAmJiBsYXN0LnJhbmdlWzBdID49IHRoaXMucmFuZ2VbMF0pIHtcbiAgICAgICAgICAgICAgICBsYXN0Q2hpbGQgPSBib3R0b21SaWdodC5wb3AoKTtcbiAgICAgICAgICAgICAgICBsYXN0ID0gYm90dG9tUmlnaHRbYm90dG9tUmlnaHQubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsYXN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdENoaWxkLmxlYWRpbmdDb21tZW50cykge1xuICAgICAgICAgICAgICAgICAgICBsZWFkaW5nQ29tbWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gbGFzdENoaWxkLmxlYWRpbmdDb21tZW50cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudCA9IGxhc3RDaGlsZC5sZWFkaW5nQ29tbWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tbWVudC5yYW5nZVsxXSA8PSB0aGlzLnJhbmdlWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVhZGluZ0NvbW1lbnRzLnVuc2hpZnQoY29tbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdENoaWxkLmxlYWRpbmdDb21tZW50cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWxhc3RDaGlsZC5sZWFkaW5nQ29tbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0Q2hpbGQubGVhZGluZ0NvbW1lbnRzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChleHRyYS5sZWFkaW5nQ29tbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGxlYWRpbmdDb21tZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IGV4dHJhLmxlYWRpbmdDb21tZW50cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgICAgICAgICBjb21tZW50ID0gZXh0cmEubGVhZGluZ0NvbW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tbWVudC5yYW5nZVsxXSA8PSB0aGlzLnJhbmdlWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWFkaW5nQ29tbWVudHMudW5zaGlmdChjb21tZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhLmxlYWRpbmdDb21tZW50cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgaWYgKGxlYWRpbmdDb21tZW50cyAmJiBsZWFkaW5nQ29tbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubGVhZGluZ0NvbW1lbnRzID0gbGVhZGluZ0NvbW1lbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRyYWlsaW5nQ29tbWVudHMgJiYgdHJhaWxpbmdDb21tZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFpbGluZ0NvbW1lbnRzID0gdHJhaWxpbmdDb21tZW50cztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYm90dG9tUmlnaHQucHVzaCh0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChleHRyYS5yYW5nZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmFuZ2VbMV0gPSBsYXN0SW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXh0cmEubG9jKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2MuZW5kID0ge1xuICAgICAgICAgICAgICAgICAgICBsaW5lOiBsYXN0TGluZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBsYXN0SW5kZXggLSBsYXN0TGluZVN0YXJ0XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoZXh0cmEuc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9jLnNvdXJjZSA9IGV4dHJhLnNvdXJjZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChleHRyYS5hdHRhY2hDb21tZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzQ29tbWVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaEFycmF5RXhwcmVzc2lvbjogZnVuY3Rpb24gKGVsZW1lbnRzKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguQXJyYXlFeHByZXNzaW9uO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaEFycmF5UGF0dGVybjogZnVuY3Rpb24gKGVsZW1lbnRzKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguQXJyYXlQYXR0ZXJuO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaEFycm93RnVuY3Rpb25FeHByZXNzaW9uOiBmdW5jdGlvbiAocGFyYW1zLCBkZWZhdWx0cywgYm9keSwgZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkFycm93RnVuY3Rpb25FeHByZXNzaW9uO1xuICAgICAgICAgICAgdGhpcy5pZCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgICAgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICAgICAgICB0aGlzLmdlbmVyYXRvciA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hBc3NpZ25tZW50RXhwcmVzc2lvbjogZnVuY3Rpb24gKG9wZXJhdG9yLCBsZWZ0LCByaWdodCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uO1xuICAgICAgICAgICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICAgICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hBc3NpZ25tZW50UGF0dGVybjogZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguQXNzaWdubWVudFBhdHRlcm47XG4gICAgICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaEJpbmFyeUV4cHJlc3Npb246IGZ1bmN0aW9uIChvcGVyYXRvciwgbGVmdCwgcmlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IChvcGVyYXRvciA9PT0gJ3x8JyB8fCBvcGVyYXRvciA9PT0gJyYmJykgPyBTeW50YXguTG9naWNhbEV4cHJlc3Npb24gOiBTeW50YXguQmluYXJ5RXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoQmxvY2tTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChib2R5KSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguQmxvY2tTdGF0ZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaEJyZWFrU3RhdGVtZW50OiBmdW5jdGlvbiAobGFiZWwpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5CcmVha1N0YXRlbWVudDtcbiAgICAgICAgICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hDYWxsRXhwcmVzc2lvbjogZnVuY3Rpb24gKGNhbGxlZSwgYXJncykge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkNhbGxFeHByZXNzaW9uO1xuICAgICAgICAgICAgdGhpcy5jYWxsZWUgPSBjYWxsZWU7XG4gICAgICAgICAgICB0aGlzLmFyZ3VtZW50cyA9IGFyZ3M7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoQ2F0Y2hDbGF1c2U6IGZ1bmN0aW9uIChwYXJhbSwgYm9keSkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkNhdGNoQ2xhdXNlO1xuICAgICAgICAgICAgdGhpcy5wYXJhbSA9IHBhcmFtO1xuICAgICAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hDbGFzc0JvZHk6IGZ1bmN0aW9uIChib2R5KSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguQ2xhc3NCb2R5O1xuICAgICAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hDbGFzc0RlY2xhcmF0aW9uOiBmdW5jdGlvbiAoaWQsIHN1cGVyQ2xhc3MsIGJvZHkpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5DbGFzc0RlY2xhcmF0aW9uO1xuICAgICAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICAgICAgdGhpcy5zdXBlckNsYXNzID0gc3VwZXJDbGFzcztcbiAgICAgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoQ2xhc3NFeHByZXNzaW9uOiBmdW5jdGlvbiAoaWQsIHN1cGVyQ2xhc3MsIGJvZHkpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5DbGFzc0V4cHJlc3Npb247XG4gICAgICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgICAgICB0aGlzLnN1cGVyQ2xhc3MgPSBzdXBlckNsYXNzO1xuICAgICAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hDb25kaXRpb25hbEV4cHJlc3Npb246IGZ1bmN0aW9uICh0ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGUpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5Db25kaXRpb25hbEV4cHJlc3Npb247XG4gICAgICAgICAgICB0aGlzLnRlc3QgPSB0ZXN0O1xuICAgICAgICAgICAgdGhpcy5jb25zZXF1ZW50ID0gY29uc2VxdWVudDtcbiAgICAgICAgICAgIHRoaXMuYWx0ZXJuYXRlID0gYWx0ZXJuYXRlO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaENvbnRpbnVlU3RhdGVtZW50OiBmdW5jdGlvbiAobGFiZWwpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5Db250aW51ZVN0YXRlbWVudDtcbiAgICAgICAgICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hEZWJ1Z2dlclN0YXRlbWVudDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkRlYnVnZ2VyU3RhdGVtZW50O1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaERvV2hpbGVTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChib2R5LCB0ZXN0KSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguRG9XaGlsZVN0YXRlbWVudDtcbiAgICAgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICAgICAgICB0aGlzLnRlc3QgPSB0ZXN0O1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaEVtcHR5U3RhdGVtZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguRW1wdHlTdGF0ZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoRXhwcmVzc2lvblN0YXRlbWVudDogZnVuY3Rpb24gKGV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5FeHByZXNzaW9uU3RhdGVtZW50O1xuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hGb3JTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChpbml0LCB0ZXN0LCB1cGRhdGUsIGJvZHkpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5Gb3JTdGF0ZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmluaXQgPSBpbml0O1xuICAgICAgICAgICAgdGhpcy50ZXN0ID0gdGVzdDtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlID0gdXBkYXRlO1xuICAgICAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hGb3JPZlN0YXRlbWVudDogZnVuY3Rpb24gKGxlZnQsIHJpZ2h0LCBib2R5KSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguRm9yT2ZTdGF0ZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgICAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hGb3JJblN0YXRlbWVudDogZnVuY3Rpb24gKGxlZnQsIHJpZ2h0LCBib2R5KSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguRm9ySW5TdGF0ZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgICAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgIHRoaXMuZWFjaCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaEZ1bmN0aW9uRGVjbGFyYXRpb246IGZ1bmN0aW9uIChpZCwgcGFyYW1zLCBkZWZhdWx0cywgYm9keSwgZ2VuZXJhdG9yKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguRnVuY3Rpb25EZWNsYXJhdGlvbjtcbiAgICAgICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuICAgICAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdG9yID0gZ2VuZXJhdG9yO1xuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoRnVuY3Rpb25FeHByZXNzaW9uOiBmdW5jdGlvbiAoaWQsIHBhcmFtcywgZGVmYXVsdHMsIGJvZHksIGdlbmVyYXRvcikge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkZ1bmN0aW9uRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuICAgICAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdG9yID0gZ2VuZXJhdG9yO1xuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoSWRlbnRpZmllcjogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5JZGVudGlmaWVyO1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hJZlN0YXRlbWVudDogZnVuY3Rpb24gKHRlc3QsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LklmU3RhdGVtZW50O1xuICAgICAgICAgICAgdGhpcy50ZXN0ID0gdGVzdDtcbiAgICAgICAgICAgIHRoaXMuY29uc2VxdWVudCA9IGNvbnNlcXVlbnQ7XG4gICAgICAgICAgICB0aGlzLmFsdGVybmF0ZSA9IGFsdGVybmF0ZTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hMYWJlbGVkU3RhdGVtZW50OiBmdW5jdGlvbiAobGFiZWwsIGJvZHkpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5MYWJlbGVkU3RhdGVtZW50O1xuICAgICAgICAgICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgICAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hMaXRlcmFsOiBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5MaXRlcmFsO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRva2VuLnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5yYXcgPSBzb3VyY2Uuc2xpY2UodG9rZW4uc3RhcnQsIHRva2VuLmVuZCk7XG4gICAgICAgICAgICBpZiAodG9rZW4ucmVnZXgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZ2V4ID0gdG9rZW4ucmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoTWVtYmVyRXhwcmVzc2lvbjogZnVuY3Rpb24gKGFjY2Vzc29yLCBvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguTWVtYmVyRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHRoaXMuY29tcHV0ZWQgPSBhY2Nlc3NvciA9PT0gJ1snO1xuICAgICAgICAgICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XG4gICAgICAgICAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoTWV0YVByb3BlcnR5OiBmdW5jdGlvbiAobWV0YSwgcHJvcGVydHkpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5NZXRhUHJvcGVydHk7XG4gICAgICAgICAgICB0aGlzLm1ldGEgPSBtZXRhO1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaE5ld0V4cHJlc3Npb246IGZ1bmN0aW9uIChjYWxsZWUsIGFyZ3MpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5OZXdFeHByZXNzaW9uO1xuICAgICAgICAgICAgdGhpcy5jYWxsZWUgPSBjYWxsZWU7XG4gICAgICAgICAgICB0aGlzLmFyZ3VtZW50cyA9IGFyZ3M7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoT2JqZWN0RXhwcmVzc2lvbjogZnVuY3Rpb24gKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5PYmplY3RFeHByZXNzaW9uO1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hPYmplY3RQYXR0ZXJuOiBmdW5jdGlvbiAocHJvcGVydGllcykge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4Lk9iamVjdFBhdHRlcm47XG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaFBvc3RmaXhFeHByZXNzaW9uOiBmdW5jdGlvbiAob3BlcmF0b3IsIGFyZ3VtZW50KSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguVXBkYXRlRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcbiAgICAgICAgICAgIHRoaXMucHJlZml4ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoUHJvZ3JhbTogZnVuY3Rpb24gKGJvZHksIHNvdXJjZVR5cGUpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5Qcm9ncmFtO1xuICAgICAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgIHRoaXMuc291cmNlVHlwZSA9IHNvdXJjZVR5cGU7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoUHJvcGVydHk6IGZ1bmN0aW9uIChraW5kLCBrZXksIGNvbXB1dGVkLCB2YWx1ZSwgbWV0aG9kLCBzaG9ydGhhbmQpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5Qcm9wZXJ0eTtcbiAgICAgICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICAgICAgdGhpcy5jb21wdXRlZCA9IGNvbXB1dGVkO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5raW5kID0ga2luZDtcbiAgICAgICAgICAgIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICAgICAgICAgICAgdGhpcy5zaG9ydGhhbmQgPSBzaG9ydGhhbmQ7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoUmVzdEVsZW1lbnQ6IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LlJlc3RFbGVtZW50O1xuICAgICAgICAgICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaFJldHVyblN0YXRlbWVudDogZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguUmV0dXJuU3RhdGVtZW50O1xuICAgICAgICAgICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaFNlcXVlbmNlRXhwcmVzc2lvbjogZnVuY3Rpb24gKGV4cHJlc3Npb25zKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguU2VxdWVuY2VFeHByZXNzaW9uO1xuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9ucyA9IGV4cHJlc3Npb25zO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaFNwcmVhZEVsZW1lbnQ6IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LlNwcmVhZEVsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmFyZ3VtZW50ID0gYXJndW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoU3dpdGNoQ2FzZTogZnVuY3Rpb24gKHRlc3QsIGNvbnNlcXVlbnQpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5Td2l0Y2hDYXNlO1xuICAgICAgICAgICAgdGhpcy50ZXN0ID0gdGVzdDtcbiAgICAgICAgICAgIHRoaXMuY29uc2VxdWVudCA9IGNvbnNlcXVlbnQ7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoU3VwZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5TdXBlcjtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hTd2l0Y2hTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChkaXNjcmltaW5hbnQsIGNhc2VzKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguU3dpdGNoU3RhdGVtZW50O1xuICAgICAgICAgICAgdGhpcy5kaXNjcmltaW5hbnQgPSBkaXNjcmltaW5hbnQ7XG4gICAgICAgICAgICB0aGlzLmNhc2VzID0gY2FzZXM7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uOiBmdW5jdGlvbiAodGFnLCBxdWFzaSkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHRoaXMudGFnID0gdGFnO1xuICAgICAgICAgICAgdGhpcy5xdWFzaSA9IHF1YXNpO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaFRlbXBsYXRlRWxlbWVudDogZnVuY3Rpb24gKHZhbHVlLCB0YWlsKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguVGVtcGxhdGVFbGVtZW50O1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy50YWlsID0gdGFpbDtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hUZW1wbGF0ZUxpdGVyYWw6IGZ1bmN0aW9uIChxdWFzaXMsIGV4cHJlc3Npb25zKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguVGVtcGxhdGVMaXRlcmFsO1xuICAgICAgICAgICAgdGhpcy5xdWFzaXMgPSBxdWFzaXM7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnM7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoVGhpc0V4cHJlc3Npb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5UaGlzRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hUaHJvd1N0YXRlbWVudDogZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguVGhyb3dTdGF0ZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmFyZ3VtZW50ID0gYXJndW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoVHJ5U3RhdGVtZW50OiBmdW5jdGlvbiAoYmxvY2ssIGhhbmRsZXIsIGZpbmFsaXplcikge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LlRyeVN0YXRlbWVudDtcbiAgICAgICAgICAgIHRoaXMuYmxvY2sgPSBibG9jaztcbiAgICAgICAgICAgIHRoaXMuZ3VhcmRlZEhhbmRsZXJzID0gW107XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXJzID0gaGFuZGxlciA/IFtoYW5kbGVyXSA6IFtdO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcbiAgICAgICAgICAgIHRoaXMuZmluYWxpemVyID0gZmluYWxpemVyO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaFVuYXJ5RXhwcmVzc2lvbjogZnVuY3Rpb24gKG9wZXJhdG9yLCBhcmd1bWVudCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gKG9wZXJhdG9yID09PSAnKysnIHx8IG9wZXJhdG9yID09PSAnLS0nKSA/IFN5bnRheC5VcGRhdGVFeHByZXNzaW9uIDogU3ludGF4LlVuYXJ5RXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcbiAgICAgICAgICAgIHRoaXMucHJlZml4ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hWYXJpYWJsZURlY2xhcmF0aW9uOiBmdW5jdGlvbiAoZGVjbGFyYXRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguVmFyaWFibGVEZWNsYXJhdGlvbjtcbiAgICAgICAgICAgIHRoaXMuZGVjbGFyYXRpb25zID0gZGVjbGFyYXRpb25zO1xuICAgICAgICAgICAgdGhpcy5raW5kID0gJ3Zhcic7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoTGV4aWNhbERlY2xhcmF0aW9uOiBmdW5jdGlvbiAoZGVjbGFyYXRpb25zLCBraW5kKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguVmFyaWFibGVEZWNsYXJhdGlvbjtcbiAgICAgICAgICAgIHRoaXMuZGVjbGFyYXRpb25zID0gZGVjbGFyYXRpb25zO1xuICAgICAgICAgICAgdGhpcy5raW5kID0ga2luZDtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hWYXJpYWJsZURlY2xhcmF0b3I6IGZ1bmN0aW9uIChpZCwgaW5pdCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LlZhcmlhYmxlRGVjbGFyYXRvcjtcbiAgICAgICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgICAgIHRoaXMuaW5pdCA9IGluaXQ7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoV2hpbGVTdGF0ZW1lbnQ6IGZ1bmN0aW9uICh0ZXN0LCBib2R5KSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguV2hpbGVTdGF0ZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLnRlc3QgPSB0ZXN0O1xuICAgICAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hXaXRoU3RhdGVtZW50OiBmdW5jdGlvbiAob2JqZWN0LCBib2R5KSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguV2l0aFN0YXRlbWVudDtcbiAgICAgICAgICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuICAgICAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hFeHBvcnRTcGVjaWZpZXI6IGZ1bmN0aW9uIChsb2NhbCwgZXhwb3J0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5FeHBvcnRTcGVjaWZpZXI7XG4gICAgICAgICAgICB0aGlzLmV4cG9ydGVkID0gZXhwb3J0ZWQgfHwgbG9jYWw7XG4gICAgICAgICAgICB0aGlzLmxvY2FsID0gbG9jYWw7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoSW1wb3J0RGVmYXVsdFNwZWNpZmllcjogZnVuY3Rpb24gKGxvY2FsKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguSW1wb3J0RGVmYXVsdFNwZWNpZmllcjtcbiAgICAgICAgICAgIHRoaXMubG9jYWwgPSBsb2NhbDtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXI6IGZ1bmN0aW9uIChsb2NhbCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkltcG9ydE5hbWVzcGFjZVNwZWNpZmllcjtcbiAgICAgICAgICAgIHRoaXMubG9jYWwgPSBsb2NhbDtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hFeHBvcnROYW1lZERlY2xhcmF0aW9uOiBmdW5jdGlvbiAoZGVjbGFyYXRpb24sIHNwZWNpZmllcnMsIHNyYykge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkV4cG9ydE5hbWVkRGVjbGFyYXRpb247XG4gICAgICAgICAgICB0aGlzLmRlY2xhcmF0aW9uID0gZGVjbGFyYXRpb247XG4gICAgICAgICAgICB0aGlzLnNwZWNpZmllcnMgPSBzcGVjaWZpZXJzO1xuICAgICAgICAgICAgdGhpcy5zb3VyY2UgPSBzcmM7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uOiBmdW5jdGlvbiAoZGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5FeHBvcnREZWZhdWx0RGVjbGFyYXRpb247XG4gICAgICAgICAgICB0aGlzLmRlY2xhcmF0aW9uID0gZGVjbGFyYXRpb247XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoRXhwb3J0QWxsRGVjbGFyYXRpb246IGZ1bmN0aW9uIChzcmMpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5FeHBvcnRBbGxEZWNsYXJhdGlvbjtcbiAgICAgICAgICAgIHRoaXMuc291cmNlID0gc3JjO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaEltcG9ydFNwZWNpZmllcjogZnVuY3Rpb24gKGxvY2FsLCBpbXBvcnRlZCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkltcG9ydFNwZWNpZmllcjtcbiAgICAgICAgICAgIHRoaXMubG9jYWwgPSBsb2NhbCB8fCBpbXBvcnRlZDtcbiAgICAgICAgICAgIHRoaXMuaW1wb3J0ZWQgPSBpbXBvcnRlZDtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hJbXBvcnREZWNsYXJhdGlvbjogZnVuY3Rpb24gKHNwZWNpZmllcnMsIHNyYykge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkltcG9ydERlY2xhcmF0aW9uO1xuICAgICAgICAgICAgdGhpcy5zcGVjaWZpZXJzID0gc3BlY2lmaWVycztcbiAgICAgICAgICAgIHRoaXMuc291cmNlID0gc3JjO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaFlpZWxkRXhwcmVzc2lvbjogZnVuY3Rpb24gKGFyZ3VtZW50LCBkZWxlZ2F0ZSkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LllpZWxkRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcbiAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIGZ1bmN0aW9uIHJlY29yZEVycm9yKGVycm9yKSB7XG4gICAgICAgIHZhciBlLCBleGlzdGluZztcblxuICAgICAgICBmb3IgKGUgPSAwOyBlIDwgZXh0cmEuZXJyb3JzLmxlbmd0aDsgZSsrKSB7XG4gICAgICAgICAgICBleGlzdGluZyA9IGV4dHJhLmVycm9yc1tlXTtcbiAgICAgICAgICAgIC8vIFByZXZlbnQgZHVwbGljYXRlZCBlcnJvci5cbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICBpZiAoZXhpc3RpbmcuaW5kZXggPT09IGVycm9yLmluZGV4ICYmIGV4aXN0aW5nLm1lc3NhZ2UgPT09IGVycm9yLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBleHRyYS5lcnJvcnMucHVzaChlcnJvcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uc3RydWN0RXJyb3IobXNnLCBjb2x1bW4pIHtcbiAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSBjYXRjaCAoYmFzZSkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmIChPYmplY3QuY3JlYXRlICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIGVycm9yID0gT2JqZWN0LmNyZWF0ZShiYXNlKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyb3IsICdjb2x1bW4nLCB7IHZhbHVlOiBjb2x1bW4gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVFcnJvcihsaW5lLCBwb3MsIGRlc2NyaXB0aW9uKSB7XG4gICAgICAgIHZhciBtc2csIGNvbHVtbiwgZXJyb3I7XG5cbiAgICAgICAgbXNnID0gJ0xpbmUgJyArIGxpbmUgKyAnOiAnICsgZGVzY3JpcHRpb247XG4gICAgICAgIGNvbHVtbiA9IHBvcyAtIChzY2FubmluZyA/IGxpbmVTdGFydCA6IGxhc3RMaW5lU3RhcnQpICsgMTtcbiAgICAgICAgZXJyb3IgPSBjb25zdHJ1Y3RFcnJvcihtc2csIGNvbHVtbik7XG4gICAgICAgIGVycm9yLmxpbmVOdW1iZXIgPSBsaW5lO1xuICAgICAgICBlcnJvci5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICBlcnJvci5pbmRleCA9IHBvcztcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cblxuICAgIC8vIFRocm93IGFuIGV4Y2VwdGlvblxuXG4gICAgZnVuY3Rpb24gdGhyb3dFcnJvcihtZXNzYWdlRm9ybWF0KSB7XG4gICAgICAgIHZhciBhcmdzLCBtc2c7XG5cbiAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIG1zZyA9IG1lc3NhZ2VGb3JtYXQucmVwbGFjZSgvJShcXGQpL2csXG4gICAgICAgICAgICBmdW5jdGlvbiAod2hvbGUsIGlkeCkge1xuICAgICAgICAgICAgICAgIGFzc2VydChpZHggPCBhcmdzLmxlbmd0aCwgJ01lc3NhZ2UgcmVmZXJlbmNlIG11c3QgYmUgaW4gcmFuZ2UnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJnc1tpZHhdO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIHRocm93IGNyZWF0ZUVycm9yKGxhc3RMaW5lTnVtYmVyLCBsYXN0SW5kZXgsIG1zZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9sZXJhdGVFcnJvcihtZXNzYWdlRm9ybWF0KSB7XG4gICAgICAgIHZhciBhcmdzLCBtc2csIGVycm9yO1xuXG4gICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBtc2cgPSBtZXNzYWdlRm9ybWF0LnJlcGxhY2UoLyUoXFxkKS9nLFxuICAgICAgICAgICAgZnVuY3Rpb24gKHdob2xlLCBpZHgpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQoaWR4IDwgYXJncy5sZW5ndGgsICdNZXNzYWdlIHJlZmVyZW5jZSBtdXN0IGJlIGluIHJhbmdlJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3NbaWR4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICBlcnJvciA9IGNyZWF0ZUVycm9yKGxpbmVOdW1iZXIsIGxhc3RJbmRleCwgbXNnKTtcbiAgICAgICAgaWYgKGV4dHJhLmVycm9ycykge1xuICAgICAgICAgICAgcmVjb3JkRXJyb3IoZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaHJvdyBhbiBleGNlcHRpb24gYmVjYXVzZSBvZiB0aGUgdG9rZW4uXG5cbiAgICBmdW5jdGlvbiB1bmV4cGVjdGVkVG9rZW5FcnJvcih0b2tlbiwgbWVzc2FnZSkge1xuICAgICAgICB2YXIgdmFsdWUsIG1zZyA9IG1lc3NhZ2UgfHwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuO1xuXG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgbXNnID0gKHRva2VuLnR5cGUgPT09IFRva2VuLkVPRikgPyBNZXNzYWdlcy5VbmV4cGVjdGVkRU9TIDpcbiAgICAgICAgICAgICAgICAgICAgKHRva2VuLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXIpID8gTWVzc2FnZXMuVW5leHBlY3RlZElkZW50aWZpZXIgOlxuICAgICAgICAgICAgICAgICAgICAodG9rZW4udHlwZSA9PT0gVG9rZW4uTnVtZXJpY0xpdGVyYWwpID8gTWVzc2FnZXMuVW5leHBlY3RlZE51bWJlciA6XG4gICAgICAgICAgICAgICAgICAgICh0b2tlbi50eXBlID09PSBUb2tlbi5TdHJpbmdMaXRlcmFsKSA/IE1lc3NhZ2VzLlVuZXhwZWN0ZWRTdHJpbmcgOlxuICAgICAgICAgICAgICAgICAgICAodG9rZW4udHlwZSA9PT0gVG9rZW4uVGVtcGxhdGUpID8gTWVzc2FnZXMuVW5leHBlY3RlZFRlbXBsYXRlIDpcbiAgICAgICAgICAgICAgICAgICAgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLktleXdvcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnV0dXJlUmVzZXJ2ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXNnID0gTWVzc2FnZXMuVW5leHBlY3RlZFJlc2VydmVkO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBpc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQodG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtc2cgPSBNZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbHVlID0gKHRva2VuLnR5cGUgPT09IFRva2VuLlRlbXBsYXRlKSA/IHRva2VuLnZhbHVlLnJhdyA6IHRva2VuLnZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSAnSUxMRUdBTCc7XG4gICAgICAgIH1cblxuICAgICAgICBtc2cgPSBtc2cucmVwbGFjZSgnJTAnLCB2YWx1ZSk7XG5cbiAgICAgICAgcmV0dXJuICh0b2tlbiAmJiB0eXBlb2YgdG9rZW4ubGluZU51bWJlciA9PT0gJ251bWJlcicpID9cbiAgICAgICAgICAgIGNyZWF0ZUVycm9yKHRva2VuLmxpbmVOdW1iZXIsIHRva2VuLnN0YXJ0LCBtc2cpIDpcbiAgICAgICAgICAgIGNyZWF0ZUVycm9yKHNjYW5uaW5nID8gbGluZU51bWJlciA6IGxhc3RMaW5lTnVtYmVyLCBzY2FubmluZyA/IGluZGV4IDogbGFzdEluZGV4LCBtc2cpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRocm93VW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlKSB7XG4gICAgICAgIHRocm93IHVuZXhwZWN0ZWRUb2tlbkVycm9yKHRva2VuLCBtZXNzYWdlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZSkge1xuICAgICAgICB2YXIgZXJyb3IgPSB1bmV4cGVjdGVkVG9rZW5FcnJvcih0b2tlbiwgbWVzc2FnZSk7XG4gICAgICAgIGlmIChleHRyYS5lcnJvcnMpIHtcbiAgICAgICAgICAgIHJlY29yZEVycm9yKGVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRXhwZWN0IHRoZSBuZXh0IHRva2VuIHRvIG1hdGNoIHRoZSBzcGVjaWZpZWQgcHVuY3R1YXRvci5cbiAgICAvLyBJZiBub3QsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cblxuICAgIGZ1bmN0aW9uIGV4cGVjdCh2YWx1ZSkge1xuICAgICAgICB2YXIgdG9rZW4gPSBsZXgoKTtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLlB1bmN0dWF0b3IgfHwgdG9rZW4udmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBleHBlY3RDb21tYVNlcGFyYXRvclxuICAgICAqIEBkZXNjcmlwdGlvbiBRdWlldGx5IGV4cGVjdCBhIGNvbW1hIHdoZW4gaW4gdG9sZXJhbnQgbW9kZSwgb3RoZXJ3aXNlIGRlbGVnYXRlc1xuICAgICAqIHRvIDxjb2RlPmV4cGVjdCh2YWx1ZSk8L2NvZGU+XG4gICAgICogQHNpbmNlIDIuMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV4cGVjdENvbW1hU2VwYXJhdG9yKCkge1xuICAgICAgICB2YXIgdG9rZW47XG5cbiAgICAgICAgaWYgKGV4dHJhLmVycm9ycykge1xuICAgICAgICAgICAgdG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uUHVuY3R1YXRvciAmJiB0b2tlbi52YWx1ZSA9PT0gJywnKSB7XG4gICAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLlB1bmN0dWF0b3IgJiYgdG9rZW4udmFsdWUgPT09ICc7Jykge1xuICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleHBlY3QoJywnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEV4cGVjdCB0aGUgbmV4dCB0b2tlbiB0byBtYXRjaCB0aGUgc3BlY2lmaWVkIGtleXdvcmQuXG4gICAgLy8gSWYgbm90LCBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXG5cbiAgICBmdW5jdGlvbiBleHBlY3RLZXl3b3JkKGtleXdvcmQpIHtcbiAgICAgICAgdmFyIHRva2VuID0gbGV4KCk7XG4gICAgICAgIGlmICh0b2tlbi50eXBlICE9PSBUb2tlbi5LZXl3b3JkIHx8IHRva2VuLnZhbHVlICE9PSBrZXl3b3JkKSB7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gdHJ1ZSBpZiB0aGUgbmV4dCB0b2tlbiBtYXRjaGVzIHRoZSBzcGVjaWZpZWQgcHVuY3R1YXRvci5cblxuICAgIGZ1bmN0aW9uIG1hdGNoKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uUHVuY3R1YXRvciAmJiBsb29rYWhlYWQudmFsdWUgPT09IHZhbHVlO1xuICAgIH1cblxuICAgIC8vIFJldHVybiB0cnVlIGlmIHRoZSBuZXh0IHRva2VuIG1hdGNoZXMgdGhlIHNwZWNpZmllZCBrZXl3b3JkXG5cbiAgICBmdW5jdGlvbiBtYXRjaEtleXdvcmQoa2V5d29yZCkge1xuICAgICAgICByZXR1cm4gbG9va2FoZWFkLnR5cGUgPT09IFRva2VuLktleXdvcmQgJiYgbG9va2FoZWFkLnZhbHVlID09PSBrZXl3b3JkO1xuICAgIH1cblxuICAgIC8vIFJldHVybiB0cnVlIGlmIHRoZSBuZXh0IHRva2VuIG1hdGNoZXMgdGhlIHNwZWNpZmllZCBjb250ZXh0dWFsIGtleXdvcmRcbiAgICAvLyAod2hlcmUgYW4gaWRlbnRpZmllciBpcyBzb21ldGltZXMgYSBrZXl3b3JkIGRlcGVuZGluZyBvbiB0aGUgY29udGV4dClcblxuICAgIGZ1bmN0aW9uIG1hdGNoQ29udGV4dHVhbEtleXdvcmQoa2V5d29yZCkge1xuICAgICAgICByZXR1cm4gbG9va2FoZWFkLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXIgJiYgbG9va2FoZWFkLnZhbHVlID09PSBrZXl3b3JkO1xuICAgIH1cblxuICAgIC8vIFJldHVybiB0cnVlIGlmIHRoZSBuZXh0IHRva2VuIGlzIGFuIGFzc2lnbm1lbnQgb3BlcmF0b3JcblxuICAgIGZ1bmN0aW9uIG1hdGNoQXNzaWduKCkge1xuICAgICAgICB2YXIgb3A7XG5cbiAgICAgICAgaWYgKGxvb2thaGVhZC50eXBlICE9PSBUb2tlbi5QdW5jdHVhdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgb3AgPSBsb29rYWhlYWQudmFsdWU7XG4gICAgICAgIHJldHVybiBvcCA9PT0gJz0nIHx8XG4gICAgICAgICAgICBvcCA9PT0gJyo9JyB8fFxuICAgICAgICAgICAgb3AgPT09ICcvPScgfHxcbiAgICAgICAgICAgIG9wID09PSAnJT0nIHx8XG4gICAgICAgICAgICBvcCA9PT0gJys9JyB8fFxuICAgICAgICAgICAgb3AgPT09ICctPScgfHxcbiAgICAgICAgICAgIG9wID09PSAnPDw9JyB8fFxuICAgICAgICAgICAgb3AgPT09ICc+Pj0nIHx8XG4gICAgICAgICAgICBvcCA9PT0gJz4+Pj0nIHx8XG4gICAgICAgICAgICBvcCA9PT0gJyY9JyB8fFxuICAgICAgICAgICAgb3AgPT09ICdePScgfHxcbiAgICAgICAgICAgIG9wID09PSAnfD0nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbnN1bWVTZW1pY29sb24oKSB7XG4gICAgICAgIC8vIENhdGNoIHRoZSB2ZXJ5IGNvbW1vbiBjYXNlIGZpcnN0OiBpbW1lZGlhdGVseSBhIHNlbWljb2xvbiAoVSswMDNCKS5cbiAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KHN0YXJ0SW5kZXgpID09PSAweDNCIHx8IG1hdGNoKCc7JykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc0xpbmVUZXJtaW5hdG9yKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGSVhNRShpa2FyaWVuYXRvcik6IHRoaXMgaXMgc2VlbWluZ2x5IGFuIGlzc3VlIGluIHRoZSBwcmV2aW91cyBsb2NhdGlvbiBpbmZvIGNvbnZlbnRpb24uXG4gICAgICAgIGxhc3RJbmRleCA9IHN0YXJ0SW5kZXg7XG4gICAgICAgIGxhc3RMaW5lTnVtYmVyID0gc3RhcnRMaW5lTnVtYmVyO1xuICAgICAgICBsYXN0TGluZVN0YXJ0ID0gc3RhcnRMaW5lU3RhcnQ7XG5cbiAgICAgICAgaWYgKGxvb2thaGVhZC50eXBlICE9PSBUb2tlbi5FT0YgJiYgIW1hdGNoKCd9JykpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKGxvb2thaGVhZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDb3ZlciBncmFtbWFyIHN1cHBvcnQuXG4gICAgLy9cbiAgICAvLyBXaGVuIGFuIGFzc2lnbm1lbnQgZXhwcmVzc2lvbiBwb3NpdGlvbiBzdGFydHMgd2l0aCBhbiBsZWZ0IHBhcmVudGhlc2lzLCB0aGUgZGV0ZXJtaW5hdGlvbiBvZiB0aGUgdHlwZVxuICAgIC8vIG9mIHRoZSBzeW50YXggaXMgdG8gYmUgZGVmZXJyZWQgYXJiaXRyYXJpbHkgbG9uZyB1bnRpbCB0aGUgZW5kIG9mIHRoZSBwYXJlbnRoZXNlcyBwYWlyIChwbHVzIGEgbG9va2FoZWFkKVxuICAgIC8vIG9yIHRoZSBmaXJzdCBjb21tYS4gVGhpcyBzaXR1YXRpb24gYWxzbyBkZWZlcnMgdGhlIGRldGVybWluYXRpb24gb2YgYWxsIHRoZSBleHByZXNzaW9ucyBuZXN0ZWQgaW4gdGhlIHBhaXIuXG4gICAgLy9cbiAgICAvLyBUaGVyZSBhcmUgdGhyZWUgcHJvZHVjdGlvbnMgdGhhdCBjYW4gYmUgcGFyc2VkIGluIGEgcGFyZW50aGVzZXMgcGFpciB0aGF0IG5lZWRzIHRvIGJlIGRldGVybWluZWRcbiAgICAvLyBhZnRlciB0aGUgb3V0ZXJtb3N0IHBhaXIgaXMgY2xvc2VkLiBUaGV5IGFyZTpcbiAgICAvL1xuICAgIC8vICAgMS4gQXNzaWdubWVudEV4cHJlc3Npb25cbiAgICAvLyAgIDIuIEJpbmRpbmdFbGVtZW50c1xuICAgIC8vICAgMy4gQXNzaWdubWVudFRhcmdldHNcbiAgICAvL1xuICAgIC8vIEluIG9yZGVyIHRvIGF2b2lkIGV4cG9uZW50aWFsIGJhY2t0cmFja2luZywgd2UgdXNlIHR3byBmbGFncyB0byBkZW5vdGUgaWYgdGhlIHByb2R1Y3Rpb24gY2FuIGJlXG4gICAgLy8gYmluZGluZyBlbGVtZW50IG9yIGFzc2lnbm1lbnQgdGFyZ2V0LlxuICAgIC8vXG4gICAgLy8gVGhlIHRocmVlIHByb2R1Y3Rpb25zIGhhdmUgdGhlIHJlbGF0aW9uc2hpcDpcbiAgICAvL1xuICAgIC8vICAgQmluZGluZ0VsZW1lbnRzIOKKhiBBc3NpZ25tZW50VGFyZ2V0cyDiioYgQXNzaWdubWVudEV4cHJlc3Npb25cbiAgICAvL1xuICAgIC8vIHdpdGggYSBzaW5nbGUgZXhjZXB0aW9uIHRoYXQgQ292ZXJJbml0aWFsaXplZE5hbWUgd2hlbiB1c2VkIGRpcmVjdGx5IGluIGFuIEV4cHJlc3Npb24sIGdlbmVyYXRlc1xuICAgIC8vIGFuIGVhcmx5IGVycm9yLiBUaGVyZWZvcmUsIHdlIG5lZWQgdGhlIHRoaXJkIHN0YXRlLCBmaXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IsIHRvIHRyYWNrIHRoZVxuICAgIC8vIGZpcnN0IHVzYWdlIG9mIENvdmVySW5pdGlhbGl6ZWROYW1lIGFuZCByZXBvcnQgaXQgd2hlbiB3ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIHBhcmVudGhlc2VzIHBhaXIuXG4gICAgLy9cbiAgICAvLyBpc29sYXRlQ292ZXJHcmFtbWFyIGZ1bmN0aW9uIHJ1bnMgdGhlIGdpdmVuIHBhcnNlciBmdW5jdGlvbiB3aXRoIGEgbmV3IGNvdmVyIGdyYW1tYXIgY29udGV4dCwgYW5kIGl0IGRvZXMgbm90XG4gICAgLy8gZWZmZWN0IHRoZSBjdXJyZW50IGZsYWdzLiBUaGlzIG1lYW5zIHRoZSBwcm9kdWN0aW9uIHRoZSBwYXJzZXIgcGFyc2VzIGlzIG9ubHkgdXNlZCBhcyBhbiBleHByZXNzaW9uLiBUaGVyZWZvcmVcbiAgICAvLyB0aGUgQ292ZXJJbml0aWFsaXplZE5hbWUgY2hlY2sgaXMgY29uZHVjdGVkLlxuICAgIC8vXG4gICAgLy8gaW5oZXJpdENvdmVyR3JhbW1hciBmdW5jdGlvbiBydW5zIHRoZSBnaXZlbiBwYXJzZSBmdW5jdGlvbiB3aXRoIGEgbmV3IGNvdmVyIGdyYW1tYXIgY29udGV4dCwgYW5kIGl0IHByb3BhZ2F0ZXNcbiAgICAvLyB0aGUgZmxhZ3Mgb3V0c2lkZSBvZiB0aGUgcGFyc2VyLiBUaGlzIG1lYW5zIHRoZSBwcm9kdWN0aW9uIHRoZSBwYXJzZXIgcGFyc2VzIGlzIHVzZWQgYXMgYSBwYXJ0IG9mIGEgcG90ZW50aWFsXG4gICAgLy8gcGF0dGVybi4gVGhlIENvdmVySW5pdGlhbGl6ZWROYW1lIGNoZWNrIGlzIGRlZmVycmVkLlxuICAgIGZ1bmN0aW9uIGlzb2xhdGVDb3ZlckdyYW1tYXIocGFyc2VyKSB7XG4gICAgICAgIHZhciBvbGRJc0JpbmRpbmdFbGVtZW50ID0gaXNCaW5kaW5nRWxlbWVudCxcbiAgICAgICAgICAgIG9sZElzQXNzaWdubWVudFRhcmdldCA9IGlzQXNzaWdubWVudFRhcmdldCxcbiAgICAgICAgICAgIG9sZEZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciA9IGZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvcixcbiAgICAgICAgICAgIHJlc3VsdDtcbiAgICAgICAgaXNCaW5kaW5nRWxlbWVudCA9IHRydWU7XG4gICAgICAgIGlzQXNzaWdubWVudFRhcmdldCA9IHRydWU7XG4gICAgICAgIGZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciA9IG51bGw7XG4gICAgICAgIHJlc3VsdCA9IHBhcnNlcigpO1xuICAgICAgICBpZiAoZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbihmaXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlzQmluZGluZ0VsZW1lbnQgPSBvbGRJc0JpbmRpbmdFbGVtZW50O1xuICAgICAgICBpc0Fzc2lnbm1lbnRUYXJnZXQgPSBvbGRJc0Fzc2lnbm1lbnRUYXJnZXQ7XG4gICAgICAgIGZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciA9IG9sZEZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvcjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbmhlcml0Q292ZXJHcmFtbWFyKHBhcnNlcikge1xuICAgICAgICB2YXIgb2xkSXNCaW5kaW5nRWxlbWVudCA9IGlzQmluZGluZ0VsZW1lbnQsXG4gICAgICAgICAgICBvbGRJc0Fzc2lnbm1lbnRUYXJnZXQgPSBpc0Fzc2lnbm1lbnRUYXJnZXQsXG4gICAgICAgICAgICBvbGRGaXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgPSBmaXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IsXG4gICAgICAgICAgICByZXN1bHQ7XG4gICAgICAgIGlzQmluZGluZ0VsZW1lbnQgPSB0cnVlO1xuICAgICAgICBpc0Fzc2lnbm1lbnRUYXJnZXQgPSB0cnVlO1xuICAgICAgICBmaXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgPSBudWxsO1xuICAgICAgICByZXN1bHQgPSBwYXJzZXIoKTtcbiAgICAgICAgaXNCaW5kaW5nRWxlbWVudCA9IGlzQmluZGluZ0VsZW1lbnQgJiYgb2xkSXNCaW5kaW5nRWxlbWVudDtcbiAgICAgICAgaXNBc3NpZ25tZW50VGFyZ2V0ID0gaXNBc3NpZ25tZW50VGFyZ2V0ICYmIG9sZElzQXNzaWdubWVudFRhcmdldDtcbiAgICAgICAgZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gb2xkRmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yIHx8IGZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvcjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBFQ01BLTI2MiAxMy4zLjMgRGVzdHJ1Y3R1cmluZyBCaW5kaW5nIFBhdHRlcm5zXG5cbiAgICBmdW5jdGlvbiBwYXJzZUFycmF5UGF0dGVybihwYXJhbXMsIGtpbmQpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBuZXcgTm9kZSgpLCBlbGVtZW50cyA9IFtdLCByZXN0LCByZXN0Tm9kZTtcbiAgICAgICAgZXhwZWN0KCdbJyk7XG5cbiAgICAgICAgd2hpbGUgKCFtYXRjaCgnXScpKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2goJywnKSkge1xuICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCgnLi4uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdE5vZGUgPSBuZXcgTm9kZSgpO1xuICAgICAgICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnB1c2gobG9va2FoZWFkKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdCA9IHBhcnNlVmFyaWFibGVJZGVudGlmaWVyKGtpbmQpO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKHJlc3ROb2RlLmZpbmlzaFJlc3RFbGVtZW50KHJlc3QpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChwYXJzZVBhdHRlcm5XaXRoRGVmYXVsdChwYXJhbXMsIGtpbmQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaCgnXScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdCgnLCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgZXhwZWN0KCddJyk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoQXJyYXlQYXR0ZXJuKGVsZW1lbnRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVByb3BlcnR5UGF0dGVybihwYXJhbXMsIGtpbmQpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBuZXcgTm9kZSgpLCBrZXksIGtleVRva2VuLCBjb21wdXRlZCA9IG1hdGNoKCdbJyksIGluaXQ7XG4gICAgICAgIGlmIChsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uSWRlbnRpZmllcikge1xuICAgICAgICAgICAga2V5VG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICAgICAgICBrZXkgPSBwYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xuICAgICAgICAgICAgaWYgKG1hdGNoKCc9JykpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChrZXlUb2tlbik7XG4gICAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICAgICAgaW5pdCA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaFByb3BlcnR5KFxuICAgICAgICAgICAgICAgICAgICAnaW5pdCcsIGtleSwgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG5ldyBXcmFwcGluZ05vZGUoa2V5VG9rZW4pLmZpbmlzaEFzc2lnbm1lbnRQYXR0ZXJuKGtleSwgaW5pdCksIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIW1hdGNoKCc6JykpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChrZXlUb2tlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoUHJvcGVydHkoJ2luaXQnLCBrZXksIGZhbHNlLCBrZXksIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGtleSA9IHBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcbiAgICAgICAgfVxuICAgICAgICBleHBlY3QoJzonKTtcbiAgICAgICAgaW5pdCA9IHBhcnNlUGF0dGVybldpdGhEZWZhdWx0KHBhcmFtcywga2luZCk7XG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaFByb3BlcnR5KCdpbml0Jywga2V5LCBjb21wdXRlZCwgaW5pdCwgZmFsc2UsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU9iamVjdFBhdHRlcm4ocGFyYW1zLCBraW5kKSB7XG4gICAgICAgIHZhciBub2RlID0gbmV3IE5vZGUoKSwgcHJvcGVydGllcyA9IFtdO1xuXG4gICAgICAgIGV4cGVjdCgneycpO1xuXG4gICAgICAgIHdoaWxlICghbWF0Y2goJ30nKSkge1xuICAgICAgICAgICAgcHJvcGVydGllcy5wdXNoKHBhcnNlUHJvcGVydHlQYXR0ZXJuKHBhcmFtcywga2luZCkpO1xuICAgICAgICAgICAgaWYgKCFtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICAgICAgZXhwZWN0KCcsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXgoKTtcblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hPYmplY3RQYXR0ZXJuKHByb3BlcnRpZXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlUGF0dGVybihwYXJhbXMsIGtpbmQpIHtcbiAgICAgICAgaWYgKG1hdGNoKCdbJykpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUFycmF5UGF0dGVybihwYXJhbXMsIGtpbmQpO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKCd7JykpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZU9iamVjdFBhdHRlcm4ocGFyYW1zLCBraW5kKTtcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaEtleXdvcmQoJ2xldCcpKSB7XG4gICAgICAgICAgICBpZiAoa2luZCA9PT0gJ2NvbnN0JyB8fCBraW5kID09PSAnbGV0Jykge1xuICAgICAgICAgICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKGxvb2thaGVhZCwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmFtcy5wdXNoKGxvb2thaGVhZCk7XG4gICAgICAgIHJldHVybiBwYXJzZVZhcmlhYmxlSWRlbnRpZmllcihraW5kKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVBhdHRlcm5XaXRoRGVmYXVsdChwYXJhbXMsIGtpbmQpIHtcbiAgICAgICAgdmFyIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQsIHBhdHRlcm4sIHByZXZpb3VzQWxsb3dZaWVsZCwgcmlnaHQ7XG4gICAgICAgIHBhdHRlcm4gPSBwYXJzZVBhdHRlcm4ocGFyYW1zLCBraW5kKTtcbiAgICAgICAgaWYgKG1hdGNoKCc9JykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgcHJldmlvdXNBbGxvd1lpZWxkID0gc3RhdGUuYWxsb3dZaWVsZDtcbiAgICAgICAgICAgIHN0YXRlLmFsbG93WWllbGQgPSB0cnVlO1xuICAgICAgICAgICAgcmlnaHQgPSBpc29sYXRlQ292ZXJHcmFtbWFyKHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xuICAgICAgICAgICAgc3RhdGUuYWxsb3dZaWVsZCA9IHByZXZpb3VzQWxsb3dZaWVsZDtcbiAgICAgICAgICAgIHBhdHRlcm4gPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaEFzc2lnbm1lbnRQYXR0ZXJuKHBhdHRlcm4sIHJpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0dGVybjtcbiAgICB9XG5cbiAgICAvLyBFQ01BLTI2MiAxMi4yLjUgQXJyYXkgSW5pdGlhbGl6ZXJcblxuICAgIGZ1bmN0aW9uIHBhcnNlQXJyYXlJbml0aWFsaXplcigpIHtcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gW10sIG5vZGUgPSBuZXcgTm9kZSgpLCByZXN0U3ByZWFkO1xuXG4gICAgICAgIGV4cGVjdCgnWycpO1xuXG4gICAgICAgIHdoaWxlICghbWF0Y2goJ10nKSkge1xuICAgICAgICAgICAgaWYgKG1hdGNoKCcsJykpIHtcbiAgICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaCgnLi4uJykpIHtcbiAgICAgICAgICAgICAgICByZXN0U3ByZWFkID0gbmV3IE5vZGUoKTtcbiAgICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgICAgICByZXN0U3ByZWFkLmZpbmlzaFNwcmVhZEVsZW1lbnQoaW5oZXJpdENvdmVyR3JhbW1hcihwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoKCddJykpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNBc3NpZ25tZW50VGFyZ2V0ID0gaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBleHBlY3QoJywnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChyZXN0U3ByZWFkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChpbmhlcml0Q292ZXJHcmFtbWFyKHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pKTtcblxuICAgICAgICAgICAgICAgIGlmICghbWF0Y2goJ10nKSkge1xuICAgICAgICAgICAgICAgICAgICBleHBlY3QoJywnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXgoKTtcblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hBcnJheUV4cHJlc3Npb24oZWxlbWVudHMpO1xuICAgIH1cblxuICAgIC8vIEVDTUEtMjYyIDEyLjIuNiBPYmplY3QgSW5pdGlhbGl6ZXJcblxuICAgIGZ1bmN0aW9uIHBhcnNlUHJvcGVydHlGdW5jdGlvbihub2RlLCBwYXJhbUluZm8sIGlzR2VuZXJhdG9yKSB7XG4gICAgICAgIHZhciBwcmV2aW91c1N0cmljdCwgYm9keTtcblxuICAgICAgICBpc0Fzc2lnbm1lbnRUYXJnZXQgPSBpc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XG5cbiAgICAgICAgcHJldmlvdXNTdHJpY3QgPSBzdHJpY3Q7XG4gICAgICAgIGJvZHkgPSBpc29sYXRlQ292ZXJHcmFtbWFyKHBhcnNlRnVuY3Rpb25Tb3VyY2VFbGVtZW50cyk7XG5cbiAgICAgICAgaWYgKHN0cmljdCAmJiBwYXJhbUluZm8uZmlyc3RSZXN0cmljdGVkKSB7XG4gICAgICAgICAgICB0b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbihwYXJhbUluZm8uZmlyc3RSZXN0cmljdGVkLCBwYXJhbUluZm8ubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmljdCAmJiBwYXJhbUluZm8uc3RyaWN0ZWQpIHtcbiAgICAgICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHBhcmFtSW5mby5zdHJpY3RlZCwgcGFyYW1JbmZvLm1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RyaWN0ID0gcHJldmlvdXNTdHJpY3Q7XG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaEZ1bmN0aW9uRXhwcmVzc2lvbihudWxsLCBwYXJhbUluZm8ucGFyYW1zLCBwYXJhbUluZm8uZGVmYXVsdHMsIGJvZHksIGlzR2VuZXJhdG9yKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVByb3BlcnR5TWV0aG9kRnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbXMsIG1ldGhvZCwgbm9kZSA9IG5ldyBOb2RlKCksXG4gICAgICAgICAgICBwcmV2aW91c0FsbG93WWllbGQgPSBzdGF0ZS5hbGxvd1lpZWxkO1xuXG4gICAgICAgIHN0YXRlLmFsbG93WWllbGQgPSBmYWxzZTtcbiAgICAgICAgcGFyYW1zID0gcGFyc2VQYXJhbXMoKTtcbiAgICAgICAgc3RhdGUuYWxsb3dZaWVsZCA9IHByZXZpb3VzQWxsb3dZaWVsZDtcblxuICAgICAgICBzdGF0ZS5hbGxvd1lpZWxkID0gZmFsc2U7XG4gICAgICAgIG1ldGhvZCA9IHBhcnNlUHJvcGVydHlGdW5jdGlvbihub2RlLCBwYXJhbXMsIGZhbHNlKTtcbiAgICAgICAgc3RhdGUuYWxsb3dZaWVsZCA9IHByZXZpb3VzQWxsb3dZaWVsZDtcblxuICAgICAgICByZXR1cm4gbWV0aG9kO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKSB7XG4gICAgICAgIHZhciB0b2tlbiwgbm9kZSA9IG5ldyBOb2RlKCksIGV4cHI7XG5cbiAgICAgICAgdG9rZW4gPSBsZXgoKTtcblxuICAgICAgICAvLyBOb3RlOiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmx5IGZyb20gcGFyc2VPYmplY3RQcm9wZXJ0eSgpLCB3aGVyZVxuICAgICAgICAvLyBFT0YgYW5kIFB1bmN0dWF0b3IgdG9rZW5zIGFyZSBhbHJlYWR5IGZpbHRlcmVkIG91dC5cblxuICAgICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgY2FzZSBUb2tlbi5TdHJpbmdMaXRlcmFsOlxuICAgICAgICBjYXNlIFRva2VuLk51bWVyaWNMaXRlcmFsOlxuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiB0b2tlbi5vY3RhbCkge1xuICAgICAgICAgICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBNZXNzYWdlcy5TdHJpY3RPY3RhbExpdGVyYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoTGl0ZXJhbCh0b2tlbik7XG4gICAgICAgIGNhc2UgVG9rZW4uSWRlbnRpZmllcjpcbiAgICAgICAgY2FzZSBUb2tlbi5Cb29sZWFuTGl0ZXJhbDpcbiAgICAgICAgY2FzZSBUb2tlbi5OdWxsTGl0ZXJhbDpcbiAgICAgICAgY2FzZSBUb2tlbi5LZXl3b3JkOlxuICAgICAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoSWRlbnRpZmllcih0b2tlbi52YWx1ZSk7XG4gICAgICAgIGNhc2UgVG9rZW4uUHVuY3R1YXRvcjpcbiAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSA9PT0gJ1snKSB7XG4gICAgICAgICAgICAgICAgZXhwciA9IGlzb2xhdGVDb3ZlckdyYW1tYXIocGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgZXhwZWN0KCddJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9va2FoZWFkUHJvcGVydHlOYW1lKCkge1xuICAgICAgICBzd2l0Y2ggKGxvb2thaGVhZC50eXBlKSB7XG4gICAgICAgIGNhc2UgVG9rZW4uSWRlbnRpZmllcjpcbiAgICAgICAgY2FzZSBUb2tlbi5TdHJpbmdMaXRlcmFsOlxuICAgICAgICBjYXNlIFRva2VuLkJvb2xlYW5MaXRlcmFsOlxuICAgICAgICBjYXNlIFRva2VuLk51bGxMaXRlcmFsOlxuICAgICAgICBjYXNlIFRva2VuLk51bWVyaWNMaXRlcmFsOlxuICAgICAgICBjYXNlIFRva2VuLktleXdvcmQ6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY2FzZSBUb2tlbi5QdW5jdHVhdG9yOlxuICAgICAgICAgICAgcmV0dXJuIGxvb2thaGVhZC52YWx1ZSA9PT0gJ1snO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHRvIHRyeSB0byBwYXJzZSBhIE1ldGhvZERlZmluaXRpb24gYXMgZGVmaW5lZCBpbiAxNC4zLiBCdXQgaW4gdGhlIGNhc2Ugb2Ygb2JqZWN0IGxpdGVyYWxzLFxuICAgIC8vIGl0IG1pZ2h0IGJlIGNhbGxlZCBhdCBhIHBvc2l0aW9uIHdoZXJlIHRoZXJlIGlzIGluIGZhY3QgYSBzaG9ydCBoYW5kIGlkZW50aWZpZXIgcGF0dGVybiBvciBhIGRhdGEgcHJvcGVydHkuXG4gICAgLy8gVGhpcyBjYW4gb25seSBiZSBkZXRlcm1pbmVkIGFmdGVyIHdlIGNvbnN1bWVkIHVwIHRvIHRoZSBsZWZ0IHBhcmVudGhlc2VzLlxuICAgIC8vXG4gICAgLy8gSW4gb3JkZXIgdG8gYXZvaWQgYmFjayB0cmFja2luZywgaXQgcmV0dXJucyBgbnVsbGAgaWYgdGhlIHBvc2l0aW9uIGlzIG5vdCBhIE1ldGhvZERlZmluaXRpb24gYW5kIHRoZSBjYWxsZXJcbiAgICAvLyBpcyByZXNwb25zaWJsZSB0byB2aXNpdCBvdGhlciBvcHRpb25zLlxuICAgIGZ1bmN0aW9uIHRyeVBhcnNlTWV0aG9kRGVmaW5pdGlvbih0b2tlbiwga2V5LCBjb21wdXRlZCwgbm9kZSkge1xuICAgICAgICB2YXIgdmFsdWUsIG9wdGlvbnMsIG1ldGhvZE5vZGUsIHBhcmFtcyxcbiAgICAgICAgICAgIHByZXZpb3VzQWxsb3dZaWVsZCA9IHN0YXRlLmFsbG93WWllbGQ7XG5cbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBgZ2V0YCBhbmQgYHNldGA7XG5cbiAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSA9PT0gJ2dldCcgJiYgbG9va2FoZWFkUHJvcGVydHlOYW1lKCkpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlZCA9IG1hdGNoKCdbJyk7XG4gICAgICAgICAgICAgICAga2V5ID0gcGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xuICAgICAgICAgICAgICAgIG1ldGhvZE5vZGUgPSBuZXcgTm9kZSgpO1xuICAgICAgICAgICAgICAgIGV4cGVjdCgnKCcpO1xuICAgICAgICAgICAgICAgIGV4cGVjdCgnKScpO1xuXG4gICAgICAgICAgICAgICAgc3RhdGUuYWxsb3dZaWVsZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VQcm9wZXJ0eUZ1bmN0aW9uKG1ldGhvZE5vZGUsIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBzdHJpY3RlZDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBudWxsXG4gICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHN0YXRlLmFsbG93WWllbGQgPSBwcmV2aW91c0FsbG93WWllbGQ7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hQcm9wZXJ0eSgnZ2V0Jywga2V5LCBjb21wdXRlZCwgdmFsdWUsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuLnZhbHVlID09PSAnc2V0JyAmJiBsb29rYWhlYWRQcm9wZXJ0eU5hbWUoKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVkID0gbWF0Y2goJ1snKTtcbiAgICAgICAgICAgICAgICBrZXkgPSBwYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XG4gICAgICAgICAgICAgICAgbWV0aG9kTm9kZSA9IG5ldyBOb2RlKCk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KCcoJyk7XG5cbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0Q291bnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbVNldDoge31cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCgnKScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKGxvb2thaGVhZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuYWxsb3dZaWVsZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZVBhcmFtKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5hbGxvd1lpZWxkID0gcHJldmlvdXNBbGxvd1lpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0Q291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGVmYXVsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBleHBlY3QoJyknKTtcblxuICAgICAgICAgICAgICAgIHN0YXRlLmFsbG93WWllbGQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlUHJvcGVydHlGdW5jdGlvbihtZXRob2ROb2RlLCBvcHRpb25zLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgc3RhdGUuYWxsb3dZaWVsZCA9IHByZXZpb3VzQWxsb3dZaWVsZDtcblxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaFByb3BlcnR5KCdzZXQnLCBrZXksIGNvbXB1dGVkLCB2YWx1ZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5QdW5jdHVhdG9yICYmIHRva2VuLnZhbHVlID09PSAnKicgJiYgbG9va2FoZWFkUHJvcGVydHlOYW1lKCkpIHtcbiAgICAgICAgICAgIGNvbXB1dGVkID0gbWF0Y2goJ1snKTtcbiAgICAgICAgICAgIGtleSA9IHBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcbiAgICAgICAgICAgIG1ldGhvZE5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgICAgICBzdGF0ZS5hbGxvd1lpZWxkID0gdHJ1ZTtcbiAgICAgICAgICAgIHBhcmFtcyA9IHBhcnNlUGFyYW1zKCk7XG4gICAgICAgICAgICBzdGF0ZS5hbGxvd1lpZWxkID0gcHJldmlvdXNBbGxvd1lpZWxkO1xuXG4gICAgICAgICAgICBzdGF0ZS5hbGxvd1lpZWxkID0gZmFsc2U7XG4gICAgICAgICAgICB2YWx1ZSA9IHBhcnNlUHJvcGVydHlGdW5jdGlvbihtZXRob2ROb2RlLCBwYXJhbXMsIHRydWUpO1xuICAgICAgICAgICAgc3RhdGUuYWxsb3dZaWVsZCA9IHByZXZpb3VzQWxsb3dZaWVsZDtcblxuICAgICAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoUHJvcGVydHkoJ2luaXQnLCBrZXksIGNvbXB1dGVkLCB2YWx1ZSwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGtleSAmJiBtYXRjaCgnKCcpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHBhcnNlUHJvcGVydHlNZXRob2RGdW5jdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoUHJvcGVydHkoJ2luaXQnLCBrZXksIGNvbXB1dGVkLCB2YWx1ZSwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm90IGEgTWV0aG9kRGVmaW5pdGlvbi5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VPYmplY3RQcm9wZXJ0eShoYXNQcm90bykge1xuICAgICAgICB2YXIgdG9rZW4gPSBsb29rYWhlYWQsIG5vZGUgPSBuZXcgTm9kZSgpLCBjb21wdXRlZCwga2V5LCBtYXliZU1ldGhvZCwgcHJvdG8sIHZhbHVlO1xuXG4gICAgICAgIGNvbXB1dGVkID0gbWF0Y2goJ1snKTtcbiAgICAgICAgaWYgKG1hdGNoKCcqJykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAga2V5ID0gcGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xuICAgICAgICB9XG4gICAgICAgIG1heWJlTWV0aG9kID0gdHJ5UGFyc2VNZXRob2REZWZpbml0aW9uKHRva2VuLCBrZXksIGNvbXB1dGVkLCBub2RlKTtcbiAgICAgICAgaWYgKG1heWJlTWV0aG9kKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF5YmVNZXRob2Q7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4obG9va2FoZWFkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGZvciBkdXBsaWNhdGVkIF9fcHJvdG9fX1xuICAgICAgICBpZiAoIWNvbXB1dGVkKSB7XG4gICAgICAgICAgICBwcm90byA9IChrZXkudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIgJiYga2V5Lm5hbWUgPT09ICdfX3Byb3RvX18nKSB8fFxuICAgICAgICAgICAgICAgIChrZXkudHlwZSA9PT0gU3ludGF4LkxpdGVyYWwgJiYga2V5LnZhbHVlID09PSAnX19wcm90b19fJyk7XG4gICAgICAgICAgICBpZiAoaGFzUHJvdG8udmFsdWUgJiYgcHJvdG8pIHtcbiAgICAgICAgICAgICAgICB0b2xlcmF0ZUVycm9yKE1lc3NhZ2VzLkR1cGxpY2F0ZVByb3RvUHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFzUHJvdG8udmFsdWUgfD0gcHJvdG87XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2goJzonKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICB2YWx1ZSA9IGluaGVyaXRDb3ZlckdyYW1tYXIocGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hQcm9wZXJ0eSgnaW5pdCcsIGtleSwgY29tcHV0ZWQsIHZhbHVlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaCgnPScpKSB7XG4gICAgICAgICAgICAgICAgZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gbG9va2FoZWFkO1xuICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gaXNvbGF0ZUNvdmVyR3JhbW1hcihwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hQcm9wZXJ0eSgnaW5pdCcsIGtleSwgY29tcHV0ZWQsXG4gICAgICAgICAgICAgICAgICAgIG5ldyBXcmFwcGluZ05vZGUodG9rZW4pLmZpbmlzaEFzc2lnbm1lbnRQYXR0ZXJuKGtleSwgdmFsdWUpLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hQcm9wZXJ0eSgnaW5pdCcsIGtleSwgY29tcHV0ZWQsIGtleSwgZmFsc2UsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4obG9va2FoZWFkKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU9iamVjdEluaXRpYWxpemVyKCkge1xuICAgICAgICB2YXIgcHJvcGVydGllcyA9IFtdLCBoYXNQcm90byA9IHt2YWx1ZTogZmFsc2V9LCBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgICBleHBlY3QoJ3snKTtcblxuICAgICAgICB3aGlsZSAoIW1hdGNoKCd9JykpIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMucHVzaChwYXJzZU9iamVjdFByb3BlcnR5KGhhc1Byb3RvKSk7XG5cbiAgICAgICAgICAgIGlmICghbWF0Y2goJ30nKSkge1xuICAgICAgICAgICAgICAgIGV4cGVjdENvbW1hU2VwYXJhdG9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3QoJ30nKTtcblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hPYmplY3RFeHByZXNzaW9uKHByb3BlcnRpZXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihleHByKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBzd2l0Y2ggKGV4cHIudHlwZSkge1xuICAgICAgICBjYXNlIFN5bnRheC5JZGVudGlmaWVyOlxuICAgICAgICBjYXNlIFN5bnRheC5NZW1iZXJFeHByZXNzaW9uOlxuICAgICAgICBjYXNlIFN5bnRheC5SZXN0RWxlbWVudDpcbiAgICAgICAgY2FzZSBTeW50YXguQXNzaWdubWVudFBhdHRlcm46XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTeW50YXguU3ByZWFkRWxlbWVudDpcbiAgICAgICAgICAgIGV4cHIudHlwZSA9IFN5bnRheC5SZXN0RWxlbWVudDtcbiAgICAgICAgICAgIHJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihleHByLmFyZ3VtZW50KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFN5bnRheC5BcnJheUV4cHJlc3Npb246XG4gICAgICAgICAgICBleHByLnR5cGUgPSBTeW50YXguQXJyYXlQYXR0ZXJuO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGV4cHIuZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoZXhwci5lbGVtZW50c1tpXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oZXhwci5lbGVtZW50c1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU3ludGF4Lk9iamVjdEV4cHJlc3Npb246XG4gICAgICAgICAgICBleHByLnR5cGUgPSBTeW50YXguT2JqZWN0UGF0dGVybjtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBleHByLnByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oZXhwci5wcm9wZXJ0aWVzW2ldLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFN5bnRheC5Bc3NpZ25tZW50RXhwcmVzc2lvbjpcbiAgICAgICAgICAgIGV4cHIudHlwZSA9IFN5bnRheC5Bc3NpZ25tZW50UGF0dGVybjtcbiAgICAgICAgICAgIHJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihleHByLmxlZnQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyBBbGxvdyBvdGhlciBub2RlIHR5cGUgZm9yIHRvbGVyYW50IHBhcnNpbmcuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEVDTUEtMjYyIDEyLjIuOSBUZW1wbGF0ZSBMaXRlcmFsc1xuXG4gICAgZnVuY3Rpb24gcGFyc2VUZW1wbGF0ZUVsZW1lbnQob3B0aW9uKSB7XG4gICAgICAgIHZhciBub2RlLCB0b2tlbjtcblxuICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgIT09IFRva2VuLlRlbXBsYXRlIHx8IChvcHRpb24uaGVhZCAmJiAhbG9va2FoZWFkLmhlYWQpKSB7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZSA9IG5ldyBOb2RlKCk7XG4gICAgICAgIHRva2VuID0gbGV4KCk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoVGVtcGxhdGVFbGVtZW50KHsgcmF3OiB0b2tlbi52YWx1ZS5yYXcsIGNvb2tlZDogdG9rZW4udmFsdWUuY29va2VkIH0sIHRva2VuLnRhaWwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlVGVtcGxhdGVMaXRlcmFsKCkge1xuICAgICAgICB2YXIgcXVhc2ksIHF1YXNpcywgZXhwcmVzc2lvbnMsIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIHF1YXNpID0gcGFyc2VUZW1wbGF0ZUVsZW1lbnQoeyBoZWFkOiB0cnVlIH0pO1xuICAgICAgICBxdWFzaXMgPSBbcXVhc2ldO1xuICAgICAgICBleHByZXNzaW9ucyA9IFtdO1xuXG4gICAgICAgIHdoaWxlICghcXVhc2kudGFpbCkge1xuICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaChwYXJzZUV4cHJlc3Npb24oKSk7XG4gICAgICAgICAgICBxdWFzaSA9IHBhcnNlVGVtcGxhdGVFbGVtZW50KHsgaGVhZDogZmFsc2UgfSk7XG4gICAgICAgICAgICBxdWFzaXMucHVzaChxdWFzaSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hUZW1wbGF0ZUxpdGVyYWwocXVhc2lzLCBleHByZXNzaW9ucyk7XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTIuMi4xMCBUaGUgR3JvdXBpbmcgT3BlcmF0b3JcblxuICAgIGZ1bmN0aW9uIHBhcnNlR3JvdXBFeHByZXNzaW9uKCkge1xuICAgICAgICB2YXIgZXhwciwgZXhwcmVzc2lvbnMsIHN0YXJ0VG9rZW4sIGksIHBhcmFtcyA9IFtdO1xuXG4gICAgICAgIGV4cGVjdCgnKCcpO1xuXG4gICAgICAgIGlmIChtYXRjaCgnKScpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIGlmICghbWF0Y2goJz0+JykpIHtcbiAgICAgICAgICAgICAgICBleHBlY3QoJz0+Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFBsYWNlSG9sZGVycy5BcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyLFxuICAgICAgICAgICAgICAgIHBhcmFtczogW10sXG4gICAgICAgICAgICAgICAgcmF3UGFyYW1zOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICAgIGlmIChtYXRjaCgnLi4uJykpIHtcbiAgICAgICAgICAgIGV4cHIgPSBwYXJzZVJlc3RFbGVtZW50KHBhcmFtcyk7XG4gICAgICAgICAgICBleHBlY3QoJyknKTtcbiAgICAgICAgICAgIGlmICghbWF0Y2goJz0+JykpIHtcbiAgICAgICAgICAgICAgICBleHBlY3QoJz0+Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFBsYWNlSG9sZGVycy5BcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyLFxuICAgICAgICAgICAgICAgIHBhcmFtczogW2V4cHJdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaXNCaW5kaW5nRWxlbWVudCA9IHRydWU7XG4gICAgICAgIGV4cHIgPSBpbmhlcml0Q292ZXJHcmFtbWFyKHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xuXG4gICAgICAgIGlmIChtYXRjaCgnLCcpKSB7XG4gICAgICAgICAgICBpc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIGV4cHJlc3Npb25zID0gW2V4cHJdO1xuXG4gICAgICAgICAgICB3aGlsZSAoc3RhcnRJbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmICghbWF0Y2goJywnKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV4KCk7XG5cbiAgICAgICAgICAgICAgICBpZiAobWF0Y2goJy4uLicpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNCaW5kaW5nRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4obG9va2FoZWFkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKHBhcnNlUmVzdEVsZW1lbnQocGFyYW1zKSk7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdCgnKScpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1hdGNoKCc9PicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3QoJz0+Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXhwcmVzc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihleHByZXNzaW9uc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFBsYWNlSG9sZGVycy5BcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBleHByZXNzaW9uc1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2goaW5oZXJpdENvdmVyR3JhbW1hcihwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaFNlcXVlbmNlRXhwcmVzc2lvbihleHByZXNzaW9ucyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGV4cGVjdCgnKScpO1xuXG4gICAgICAgIGlmIChtYXRjaCgnPT4nKSkge1xuICAgICAgICAgICAgaWYgKGV4cHIudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIgJiYgZXhwci5uYW1lID09PSAneWllbGQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogUGxhY2VIb2xkZXJzLkFycm93UGFyYW1ldGVyUGxhY2VIb2xkZXIsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtczogW2V4cHJdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFpc0JpbmRpbmdFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4obG9va2FoZWFkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGV4cHIudHlwZSA9PT0gU3ludGF4LlNlcXVlbmNlRXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBleHByLmV4cHJlc3Npb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihleHByLmV4cHJlc3Npb25zW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihleHByKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXhwciA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBQbGFjZUhvbGRlcnMuQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlcixcbiAgICAgICAgICAgICAgICBwYXJhbXM6IGV4cHIudHlwZSA9PT0gU3ludGF4LlNlcXVlbmNlRXhwcmVzc2lvbiA/IGV4cHIuZXhwcmVzc2lvbnMgOiBbZXhwcl1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cblxuICAgIC8vIEVDTUEtMjYyIDEyLjIgUHJpbWFyeSBFeHByZXNzaW9uc1xuXG4gICAgZnVuY3Rpb24gcGFyc2VQcmltYXJ5RXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIHR5cGUsIHRva2VuLCBleHByLCBub2RlO1xuXG4gICAgICAgIGlmIChtYXRjaCgnKCcpKSB7XG4gICAgICAgICAgICBpc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gaW5oZXJpdENvdmVyR3JhbW1hcihwYXJzZUdyb3VwRXhwcmVzc2lvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2goJ1snKSkge1xuICAgICAgICAgICAgcmV0dXJuIGluaGVyaXRDb3ZlckdyYW1tYXIocGFyc2VBcnJheUluaXRpYWxpemVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaCgneycpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5oZXJpdENvdmVyR3JhbW1hcihwYXJzZU9iamVjdEluaXRpYWxpemVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHR5cGUgPSBsb29rYWhlYWQudHlwZTtcbiAgICAgICAgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09IFRva2VuLklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5zb3VyY2VUeXBlID09PSAnbW9kdWxlJyAmJiBsb29rYWhlYWQudmFsdWUgPT09ICdhd2FpdCcpIHtcbiAgICAgICAgICAgICAgICB0b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbihsb29rYWhlYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhwciA9IG5vZGUuZmluaXNoSWRlbnRpZmllcihsZXgoKS52YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gVG9rZW4uU3RyaW5nTGl0ZXJhbCB8fCB0eXBlID09PSBUb2tlbi5OdW1lcmljTGl0ZXJhbCkge1xuICAgICAgICAgICAgaXNBc3NpZ25tZW50VGFyZ2V0ID0gaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBsb29rYWhlYWQub2N0YWwpIHtcbiAgICAgICAgICAgICAgICB0b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbihsb29rYWhlYWQsIE1lc3NhZ2VzLlN0cmljdE9jdGFsTGl0ZXJhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHByID0gbm9kZS5maW5pc2hMaXRlcmFsKGxleCgpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBUb2tlbi5LZXl3b3JkKSB7XG4gICAgICAgICAgICBpZiAoIXN0cmljdCAmJiBzdGF0ZS5hbGxvd1lpZWxkICYmIG1hdGNoS2V5d29yZCgneWllbGQnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZU5vbkNvbXB1dGVkUHJvcGVydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3RyaWN0ICYmIG1hdGNoS2V5d29yZCgnbGV0JykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hJZGVudGlmaWVyKGxleCgpLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzQXNzaWdubWVudFRhcmdldCA9IGlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGdW5jdGlvbkV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ3RoaXMnKSkge1xuICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaFRoaXNFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hLZXl3b3JkKCdjbGFzcycpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlQ2xhc3NFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbihsZXgoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gVG9rZW4uQm9vbGVhbkxpdGVyYWwpIHtcbiAgICAgICAgICAgIGlzQXNzaWdubWVudFRhcmdldCA9IGlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRva2VuID0gbGV4KCk7XG4gICAgICAgICAgICB0b2tlbi52YWx1ZSA9ICh0b2tlbi52YWx1ZSA9PT0gJ3RydWUnKTtcbiAgICAgICAgICAgIGV4cHIgPSBub2RlLmZpbmlzaExpdGVyYWwodG9rZW4pO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFRva2VuLk51bGxMaXRlcmFsKSB7XG4gICAgICAgICAgICBpc0Fzc2lnbm1lbnRUYXJnZXQgPSBpc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICB0b2tlbiA9IGxleCgpO1xuICAgICAgICAgICAgdG9rZW4udmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgZXhwciA9IG5vZGUuZmluaXNoTGl0ZXJhbCh0b2tlbik7XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2goJy8nKSB8fCBtYXRjaCgnLz0nKSkge1xuICAgICAgICAgICAgaXNBc3NpZ25tZW50VGFyZ2V0ID0gaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgaW5kZXggPSBzdGFydEluZGV4O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4dHJhLnRva2VucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IGNvbGxlY3RSZWdleCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHNjYW5SZWdFeHAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgZXhwciA9IG5vZGUuZmluaXNoTGl0ZXJhbCh0b2tlbik7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gVG9rZW4uVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIGV4cHIgPSBwYXJzZVRlbXBsYXRlTGl0ZXJhbCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4obGV4KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTIuMyBMZWZ0LUhhbmQtU2lkZSBFeHByZXNzaW9uc1xuXG4gICAgZnVuY3Rpb24gcGFyc2VBcmd1bWVudHMoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGV4cHI7XG5cbiAgICAgICAgZXhwZWN0KCcoJyk7XG5cbiAgICAgICAgaWYgKCFtYXRjaCgnKScpKSB7XG4gICAgICAgICAgICB3aGlsZSAoc3RhcnRJbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCgnLi4uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwciA9IG5ldyBOb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgICAgICBleHByLmZpbmlzaFNwcmVhZEVsZW1lbnQoaXNvbGF0ZUNvdmVyR3JhbW1hcihwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwciA9IGlzb2xhdGVDb3ZlckdyYW1tYXIocGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFyZ3MucHVzaChleHByKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2goJyknKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXhwZWN0Q29tbWFTZXBhcmF0b3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4cGVjdCgnKScpO1xuXG4gICAgICAgIHJldHVybiBhcmdzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTm9uQ29tcHV0ZWRQcm9wZXJ0eSgpIHtcbiAgICAgICAgdmFyIHRva2VuLCBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgICB0b2tlbiA9IGxleCgpO1xuXG4gICAgICAgIGlmICghaXNJZGVudGlmaWVyTmFtZSh0b2tlbikpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKHRva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaElkZW50aWZpZXIodG9rZW4udmFsdWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTm9uQ29tcHV0ZWRNZW1iZXIoKSB7XG4gICAgICAgIGV4cGVjdCgnLicpO1xuXG4gICAgICAgIHJldHVybiBwYXJzZU5vbkNvbXB1dGVkUHJvcGVydHkoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUNvbXB1dGVkTWVtYmVyKCkge1xuICAgICAgICB2YXIgZXhwcjtcblxuICAgICAgICBleHBlY3QoJ1snKTtcblxuICAgICAgICBleHByID0gaXNvbGF0ZUNvdmVyR3JhbW1hcihwYXJzZUV4cHJlc3Npb24pO1xuXG4gICAgICAgIGV4cGVjdCgnXScpO1xuXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIC8vIEVDTUEtMjYyIDEyLjMuMyBUaGUgbmV3IE9wZXJhdG9yXG5cbiAgICBmdW5jdGlvbiBwYXJzZU5ld0V4cHJlc3Npb24oKSB7XG4gICAgICAgIHZhciBjYWxsZWUsIGFyZ3MsIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ25ldycpO1xuXG4gICAgICAgIGlmIChtYXRjaCgnLicpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIGlmIChsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uSWRlbnRpZmllciAmJiBsb29rYWhlYWQudmFsdWUgPT09ICd0YXJnZXQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmluRnVuY3Rpb25Cb2R5KSB7XG4gICAgICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hNZXRhUHJvcGVydHkoJ25ldycsICd0YXJnZXQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbihsb29rYWhlYWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGVlID0gaXNvbGF0ZUNvdmVyR3JhbW1hcihwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb24pO1xuICAgICAgICBhcmdzID0gbWF0Y2goJygnKSA/IHBhcnNlQXJndW1lbnRzKCkgOiBbXTtcblxuICAgICAgICBpc0Fzc2lnbm1lbnRUYXJnZXQgPSBpc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoTmV3RXhwcmVzc2lvbihjYWxsZWUsIGFyZ3MpO1xuICAgIH1cblxuICAgIC8vIEVDTUEtMjYyIDEyLjMuNCBGdW5jdGlvbiBDYWxsc1xuXG4gICAgZnVuY3Rpb24gcGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uQWxsb3dDYWxsKCkge1xuICAgICAgICB2YXIgcXVhc2ksIGV4cHIsIGFyZ3MsIHByb3BlcnR5LCBzdGFydFRva2VuLCBwcmV2aW91c0FsbG93SW4gPSBzdGF0ZS5hbGxvd0luO1xuXG4gICAgICAgIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICAgIHN0YXRlLmFsbG93SW4gPSB0cnVlO1xuXG4gICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ3N1cGVyJykgJiYgc3RhdGUuaW5GdW5jdGlvbkJvZHkpIHtcbiAgICAgICAgICAgIGV4cHIgPSBuZXcgTm9kZSgpO1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICBleHByID0gZXhwci5maW5pc2hTdXBlcigpO1xuICAgICAgICAgICAgaWYgKCFtYXRjaCgnKCcpICYmICFtYXRjaCgnLicpICYmICFtYXRjaCgnWycpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4obG9va2FoZWFkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4cHIgPSBpbmhlcml0Q292ZXJHcmFtbWFyKG1hdGNoS2V5d29yZCgnbmV3JykgPyBwYXJzZU5ld0V4cHJlc3Npb24gOiBwYXJzZVByaW1hcnlFeHByZXNzaW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmIChtYXRjaCgnLicpKSB7XG4gICAgICAgICAgICAgICAgaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlzQXNzaWdubWVudFRhcmdldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcHJvcGVydHkgPSBwYXJzZU5vbkNvbXB1dGVkTWVtYmVyKCk7XG4gICAgICAgICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUoc3RhcnRUb2tlbikuZmluaXNoTWVtYmVyRXhwcmVzc2lvbignLicsIGV4cHIsIHByb3BlcnR5KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2goJygnKSkge1xuICAgICAgICAgICAgICAgIGlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBhcmdzID0gcGFyc2VBcmd1bWVudHMoKTtcbiAgICAgICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKS5maW5pc2hDYWxsRXhwcmVzc2lvbihleHByLCBhcmdzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2goJ1snKSkge1xuICAgICAgICAgICAgICAgIGlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpc0Fzc2lnbm1lbnRUYXJnZXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHByb3BlcnR5ID0gcGFyc2VDb21wdXRlZE1lbWJlcigpO1xuICAgICAgICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaE1lbWJlckV4cHJlc3Npb24oJ1snLCBleHByLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5UZW1wbGF0ZSAmJiBsb29rYWhlYWQuaGVhZCkge1xuICAgICAgICAgICAgICAgIHF1YXNpID0gcGFyc2VUZW1wbGF0ZUxpdGVyYWwoKTtcbiAgICAgICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKS5maW5pc2hUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24oZXhwciwgcXVhc2kpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5hbGxvd0luID0gcHJldmlvdXNBbGxvd0luO1xuXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIC8vIEVDTUEtMjYyIDEyLjMgTGVmdC1IYW5kLVNpZGUgRXhwcmVzc2lvbnNcblxuICAgIGZ1bmN0aW9uIHBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIHF1YXNpLCBleHByLCBwcm9wZXJ0eSwgc3RhcnRUb2tlbjtcbiAgICAgICAgYXNzZXJ0KHN0YXRlLmFsbG93SW4sICdjYWxsZWUgb2YgbmV3IGV4cHJlc3Npb24gYWx3YXlzIGFsbG93IGluIGtleXdvcmQuJyk7XG5cbiAgICAgICAgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcblxuICAgICAgICBpZiAobWF0Y2hLZXl3b3JkKCdzdXBlcicpICYmIHN0YXRlLmluRnVuY3Rpb25Cb2R5KSB7XG4gICAgICAgICAgICBleHByID0gbmV3IE5vZGUoKTtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgZXhwciA9IGV4cHIuZmluaXNoU3VwZXIoKTtcbiAgICAgICAgICAgIGlmICghbWF0Y2goJ1snKSAmJiAhbWF0Y2goJy4nKSkge1xuICAgICAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKGxvb2thaGVhZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleHByID0gaW5oZXJpdENvdmVyR3JhbW1hcihtYXRjaEtleXdvcmQoJ25ldycpID8gcGFyc2VOZXdFeHByZXNzaW9uIDogcGFyc2VQcmltYXJ5RXhwcmVzc2lvbik7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAobWF0Y2goJ1snKSkge1xuICAgICAgICAgICAgICAgIGlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpc0Fzc2lnbm1lbnRUYXJnZXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHByb3BlcnR5ID0gcGFyc2VDb21wdXRlZE1lbWJlcigpO1xuICAgICAgICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaE1lbWJlckV4cHJlc3Npb24oJ1snLCBleHByLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKCcuJykpIHtcbiAgICAgICAgICAgICAgICBpc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaXNBc3NpZ25tZW50VGFyZ2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eSA9IHBhcnNlTm9uQ29tcHV0ZWRNZW1iZXIoKTtcbiAgICAgICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKS5maW5pc2hNZW1iZXJFeHByZXNzaW9uKCcuJywgZXhwciwgcHJvcGVydHkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uVGVtcGxhdGUgJiYgbG9va2FoZWFkLmhlYWQpIHtcbiAgICAgICAgICAgICAgICBxdWFzaSA9IHBhcnNlVGVtcGxhdGVMaXRlcmFsKCk7XG4gICAgICAgICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUoc3RhcnRUb2tlbikuZmluaXNoVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uKGV4cHIsIHF1YXNpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTIuNCBQb3N0Zml4IEV4cHJlc3Npb25zXG5cbiAgICBmdW5jdGlvbiBwYXJzZVBvc3RmaXhFeHByZXNzaW9uKCkge1xuICAgICAgICB2YXIgZXhwciwgdG9rZW4sIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XG5cbiAgICAgICAgZXhwciA9IGluaGVyaXRDb3ZlckdyYW1tYXIocGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uQWxsb3dDYWxsKTtcblxuICAgICAgICBpZiAoIWhhc0xpbmVUZXJtaW5hdG9yICYmIGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5QdW5jdHVhdG9yKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2goJysrJykgfHwgbWF0Y2goJy0tJykpIHtcbiAgICAgICAgICAgICAgICAvLyBFQ01BLTI2MiAxMS4zLjEsIDExLjMuMlxuICAgICAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgZXhwci50eXBlID09PSBTeW50YXguSWRlbnRpZmllciAmJiBpc1Jlc3RyaWN0ZWRXb3JkKGV4cHIubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9sZXJhdGVFcnJvcihNZXNzYWdlcy5TdHJpY3RMSFNQb3N0Zml4KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWlzQXNzaWdubWVudFRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICB0b2xlcmF0ZUVycm9yKE1lc3NhZ2VzLkludmFsaWRMSFNJbkFzc2lnbm1lbnQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlzQXNzaWdubWVudFRhcmdldCA9IGlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIHRva2VuID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUoc3RhcnRUb2tlbikuZmluaXNoUG9zdGZpeEV4cHJlc3Npb24odG9rZW4udmFsdWUsIGV4cHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTIuNSBVbmFyeSBPcGVyYXRvcnNcblxuICAgIGZ1bmN0aW9uIHBhcnNlVW5hcnlFeHByZXNzaW9uKCkge1xuICAgICAgICB2YXIgdG9rZW4sIGV4cHIsIHN0YXJ0VG9rZW47XG5cbiAgICAgICAgaWYgKGxvb2thaGVhZC50eXBlICE9PSBUb2tlbi5QdW5jdHVhdG9yICYmIGxvb2thaGVhZC50eXBlICE9PSBUb2tlbi5LZXl3b3JkKSB7XG4gICAgICAgICAgICBleHByID0gcGFyc2VQb3N0Zml4RXhwcmVzc2lvbigpO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKCcrKycpIHx8IG1hdGNoKCctLScpKSB7XG4gICAgICAgICAgICBzdGFydFRva2VuID0gbG9va2FoZWFkO1xuICAgICAgICAgICAgdG9rZW4gPSBsZXgoKTtcbiAgICAgICAgICAgIGV4cHIgPSBpbmhlcml0Q292ZXJHcmFtbWFyKHBhcnNlVW5hcnlFeHByZXNzaW9uKTtcbiAgICAgICAgICAgIC8vIEVDTUEtMjYyIDExLjQuNCwgMTEuNC41XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGV4cHIudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIgJiYgaXNSZXN0cmljdGVkV29yZChleHByLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdG9sZXJhdGVFcnJvcihNZXNzYWdlcy5TdHJpY3RMSFNQcmVmaXgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWlzQXNzaWdubWVudFRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRvbGVyYXRlRXJyb3IoTWVzc2FnZXMuSW52YWxpZExIU0luQXNzaWdubWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKS5maW5pc2hVbmFyeUV4cHJlc3Npb24odG9rZW4udmFsdWUsIGV4cHIpO1xuICAgICAgICAgICAgaXNBc3NpZ25tZW50VGFyZ2V0ID0gaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKCcrJykgfHwgbWF0Y2goJy0nKSB8fCBtYXRjaCgnficpIHx8IG1hdGNoKCchJykpIHtcbiAgICAgICAgICAgIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICAgICAgICB0b2tlbiA9IGxleCgpO1xuICAgICAgICAgICAgZXhwciA9IGluaGVyaXRDb3ZlckdyYW1tYXIocGFyc2VVbmFyeUV4cHJlc3Npb24pO1xuICAgICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUoc3RhcnRUb2tlbikuZmluaXNoVW5hcnlFeHByZXNzaW9uKHRva2VuLnZhbHVlLCBleHByKTtcbiAgICAgICAgICAgIGlzQXNzaWdubWVudFRhcmdldCA9IGlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaEtleXdvcmQoJ2RlbGV0ZScpIHx8IG1hdGNoS2V5d29yZCgndm9pZCcpIHx8IG1hdGNoS2V5d29yZCgndHlwZW9mJykpIHtcbiAgICAgICAgICAgIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICAgICAgICB0b2tlbiA9IGxleCgpO1xuICAgICAgICAgICAgZXhwciA9IGluaGVyaXRDb3ZlckdyYW1tYXIocGFyc2VVbmFyeUV4cHJlc3Npb24pO1xuICAgICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUoc3RhcnRUb2tlbikuZmluaXNoVW5hcnlFeHByZXNzaW9uKHRva2VuLnZhbHVlLCBleHByKTtcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgZXhwci5vcGVyYXRvciA9PT0gJ2RlbGV0ZScgJiYgZXhwci5hcmd1bWVudC50eXBlID09PSBTeW50YXguSWRlbnRpZmllcikge1xuICAgICAgICAgICAgICAgIHRvbGVyYXRlRXJyb3IoTWVzc2FnZXMuU3RyaWN0RGVsZXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzQXNzaWdubWVudFRhcmdldCA9IGlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4cHIgPSBwYXJzZVBvc3RmaXhFeHByZXNzaW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBiaW5hcnlQcmVjZWRlbmNlKHRva2VuLCBhbGxvd0luKSB7XG4gICAgICAgIHZhciBwcmVjID0gMDtcblxuICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gVG9rZW4uUHVuY3R1YXRvciAmJiB0b2tlbi50eXBlICE9PSBUb2tlbi5LZXl3b3JkKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAodG9rZW4udmFsdWUpIHtcbiAgICAgICAgY2FzZSAnfHwnOlxuICAgICAgICAgICAgcHJlYyA9IDE7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICcmJic6XG4gICAgICAgICAgICBwcmVjID0gMjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3wnOlxuICAgICAgICAgICAgcHJlYyA9IDM7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdeJzpcbiAgICAgICAgICAgIHByZWMgPSA0O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnJic6XG4gICAgICAgICAgICBwcmVjID0gNTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJz09JzpcbiAgICAgICAgY2FzZSAnIT0nOlxuICAgICAgICBjYXNlICc9PT0nOlxuICAgICAgICBjYXNlICchPT0nOlxuICAgICAgICAgICAgcHJlYyA9IDY7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgY2FzZSAnPic6XG4gICAgICAgIGNhc2UgJzw9JzpcbiAgICAgICAgY2FzZSAnPj0nOlxuICAgICAgICBjYXNlICdpbnN0YW5jZW9mJzpcbiAgICAgICAgICAgIHByZWMgPSA3O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnaW4nOlxuICAgICAgICAgICAgcHJlYyA9IGFsbG93SW4gPyA3IDogMDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJzw8JzpcbiAgICAgICAgY2FzZSAnPj4nOlxuICAgICAgICBjYXNlICc+Pj4nOlxuICAgICAgICAgICAgcHJlYyA9IDg7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICBwcmVjID0gOTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJyonOlxuICAgICAgICBjYXNlICcvJzpcbiAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgICBwcmVjID0gMTE7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHJlYztcbiAgICB9XG5cbiAgICAvLyBFQ01BLTI2MiAxMi42IE11bHRpcGxpY2F0aXZlIE9wZXJhdG9yc1xuICAgIC8vIEVDTUEtMjYyIDEyLjcgQWRkaXRpdmUgT3BlcmF0b3JzXG4gICAgLy8gRUNNQS0yNjIgMTIuOCBCaXR3aXNlIFNoaWZ0IE9wZXJhdG9yc1xuICAgIC8vIEVDTUEtMjYyIDEyLjkgUmVsYXRpb25hbCBPcGVyYXRvcnNcbiAgICAvLyBFQ01BLTI2MiAxMi4xMCBFcXVhbGl0eSBPcGVyYXRvcnNcbiAgICAvLyBFQ01BLTI2MiAxMi4xMSBCaW5hcnkgQml0d2lzZSBPcGVyYXRvcnNcbiAgICAvLyBFQ01BLTI2MiAxMi4xMiBCaW5hcnkgTG9naWNhbCBPcGVyYXRvcnNcblxuICAgIGZ1bmN0aW9uIHBhcnNlQmluYXJ5RXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIG1hcmtlciwgbWFya2VycywgZXhwciwgdG9rZW4sIHByZWMsIHN0YWNrLCByaWdodCwgb3BlcmF0b3IsIGxlZnQsIGk7XG5cbiAgICAgICAgbWFya2VyID0gbG9va2FoZWFkO1xuICAgICAgICBsZWZ0ID0gaW5oZXJpdENvdmVyR3JhbW1hcihwYXJzZVVuYXJ5RXhwcmVzc2lvbik7XG5cbiAgICAgICAgdG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICAgIHByZWMgPSBiaW5hcnlQcmVjZWRlbmNlKHRva2VuLCBzdGF0ZS5hbGxvd0luKTtcbiAgICAgICAgaWYgKHByZWMgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBsZWZ0O1xuICAgICAgICB9XG4gICAgICAgIGlzQXNzaWdubWVudFRhcmdldCA9IGlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgdG9rZW4ucHJlYyA9IHByZWM7XG4gICAgICAgIGxleCgpO1xuXG4gICAgICAgIG1hcmtlcnMgPSBbbWFya2VyLCBsb29rYWhlYWRdO1xuICAgICAgICByaWdodCA9IGlzb2xhdGVDb3ZlckdyYW1tYXIocGFyc2VVbmFyeUV4cHJlc3Npb24pO1xuXG4gICAgICAgIHN0YWNrID0gW2xlZnQsIHRva2VuLCByaWdodF07XG5cbiAgICAgICAgd2hpbGUgKChwcmVjID0gYmluYXJ5UHJlY2VkZW5jZShsb29rYWhlYWQsIHN0YXRlLmFsbG93SW4pKSA+IDApIHtcblxuICAgICAgICAgICAgLy8gUmVkdWNlOiBtYWtlIGEgYmluYXJ5IGV4cHJlc3Npb24gZnJvbSB0aGUgdGhyZWUgdG9wbW9zdCBlbnRyaWVzLlxuICAgICAgICAgICAgd2hpbGUgKChzdGFjay5sZW5ndGggPiAyKSAmJiAocHJlYyA8PSBzdGFja1tzdGFjay5sZW5ndGggLSAyXS5wcmVjKSkge1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgb3BlcmF0b3IgPSBzdGFjay5wb3AoKS52YWx1ZTtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgbWFya2Vycy5wb3AoKTtcbiAgICAgICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShtYXJrZXJzW21hcmtlcnMubGVuZ3RoIC0gMV0pLmZpbmlzaEJpbmFyeUV4cHJlc3Npb24ob3BlcmF0b3IsIGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKGV4cHIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTaGlmdC5cbiAgICAgICAgICAgIHRva2VuID0gbGV4KCk7XG4gICAgICAgICAgICB0b2tlbi5wcmVjID0gcHJlYztcbiAgICAgICAgICAgIHN0YWNrLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgbWFya2Vycy5wdXNoKGxvb2thaGVhZCk7XG4gICAgICAgICAgICBleHByID0gaXNvbGF0ZUNvdmVyR3JhbW1hcihwYXJzZVVuYXJ5RXhwcmVzc2lvbik7XG4gICAgICAgICAgICBzdGFjay5wdXNoKGV4cHIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmluYWwgcmVkdWNlIHRvIGNsZWFuLXVwIHRoZSBzdGFjay5cbiAgICAgICAgaSA9IHN0YWNrLmxlbmd0aCAtIDE7XG4gICAgICAgIGV4cHIgPSBzdGFja1tpXTtcbiAgICAgICAgbWFya2Vycy5wb3AoKTtcbiAgICAgICAgd2hpbGUgKGkgPiAxKSB7XG4gICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShtYXJrZXJzLnBvcCgpKS5maW5pc2hCaW5hcnlFeHByZXNzaW9uKHN0YWNrW2kgLSAxXS52YWx1ZSwgc3RhY2tbaSAtIDJdLCBleHByKTtcbiAgICAgICAgICAgIGkgLT0gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuXG4gICAgLy8gRUNNQS0yNjIgMTIuMTMgQ29uZGl0aW9uYWwgT3BlcmF0b3JcblxuICAgIGZ1bmN0aW9uIHBhcnNlQ29uZGl0aW9uYWxFeHByZXNzaW9uKCkge1xuICAgICAgICB2YXIgZXhwciwgcHJldmlvdXNBbGxvd0luLCBjb25zZXF1ZW50LCBhbHRlcm5hdGUsIHN0YXJ0VG9rZW47XG5cbiAgICAgICAgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcblxuICAgICAgICBleHByID0gaW5oZXJpdENvdmVyR3JhbW1hcihwYXJzZUJpbmFyeUV4cHJlc3Npb24pO1xuICAgICAgICBpZiAobWF0Y2goJz8nKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICBwcmV2aW91c0FsbG93SW4gPSBzdGF0ZS5hbGxvd0luO1xuICAgICAgICAgICAgc3RhdGUuYWxsb3dJbiA9IHRydWU7XG4gICAgICAgICAgICBjb25zZXF1ZW50ID0gaXNvbGF0ZUNvdmVyR3JhbW1hcihwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcbiAgICAgICAgICAgIHN0YXRlLmFsbG93SW4gPSBwcmV2aW91c0FsbG93SW47XG4gICAgICAgICAgICBleHBlY3QoJzonKTtcbiAgICAgICAgICAgIGFsdGVybmF0ZSA9IGlzb2xhdGVDb3ZlckdyYW1tYXIocGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XG5cbiAgICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaENvbmRpdGlvbmFsRXhwcmVzc2lvbihleHByLCBjb25zZXF1ZW50LCBhbHRlcm5hdGUpO1xuICAgICAgICAgICAgaXNBc3NpZ25tZW50VGFyZ2V0ID0gaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTQuMiBBcnJvdyBGdW5jdGlvbiBEZWZpbml0aW9uc1xuXG4gICAgZnVuY3Rpb24gcGFyc2VDb25jaXNlQm9keSgpIHtcbiAgICAgICAgaWYgKG1hdGNoKCd7JykpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZ1bmN0aW9uU291cmNlRWxlbWVudHMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNvbGF0ZUNvdmVyR3JhbW1hcihwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja1BhdHRlcm5QYXJhbShvcHRpb25zLCBwYXJhbSkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgc3dpdGNoIChwYXJhbS50eXBlKSB7XG4gICAgICAgIGNhc2UgU3ludGF4LklkZW50aWZpZXI6XG4gICAgICAgICAgICB2YWxpZGF0ZVBhcmFtKG9wdGlvbnMsIHBhcmFtLCBwYXJhbS5uYW1lKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFN5bnRheC5SZXN0RWxlbWVudDpcbiAgICAgICAgICAgIGNoZWNrUGF0dGVyblBhcmFtKG9wdGlvbnMsIHBhcmFtLmFyZ3VtZW50KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFN5bnRheC5Bc3NpZ25tZW50UGF0dGVybjpcbiAgICAgICAgICAgIGNoZWNrUGF0dGVyblBhcmFtKG9wdGlvbnMsIHBhcmFtLmxlZnQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU3ludGF4LkFycmF5UGF0dGVybjpcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXJhbS5lbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbS5lbGVtZW50c1tpXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjaGVja1BhdHRlcm5QYXJhbShvcHRpb25zLCBwYXJhbS5lbGVtZW50c1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU3ludGF4LllpZWxkRXhwcmVzc2lvbjpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYXNzZXJ0KHBhcmFtLnR5cGUgPT09IFN5bnRheC5PYmplY3RQYXR0ZXJuLCAnSW52YWxpZCB0eXBlJyk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFyYW0ucHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNoZWNrUGF0dGVyblBhcmFtKG9wdGlvbnMsIHBhcmFtLnByb3BlcnRpZXNbaV0udmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVpbnRlcnByZXRBc0NvdmVyRm9ybWFsc0xpc3QoZXhwcikge1xuICAgICAgICB2YXIgaSwgbGVuLCBwYXJhbSwgcGFyYW1zLCBkZWZhdWx0cywgZGVmYXVsdENvdW50LCBvcHRpb25zLCB0b2tlbjtcblxuICAgICAgICBkZWZhdWx0cyA9IFtdO1xuICAgICAgICBkZWZhdWx0Q291bnQgPSAwO1xuICAgICAgICBwYXJhbXMgPSBbZXhwcl07XG5cbiAgICAgICAgc3dpdGNoIChleHByLnR5cGUpIHtcbiAgICAgICAgY2FzZSBTeW50YXguSWRlbnRpZmllcjpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFBsYWNlSG9sZGVycy5BcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyOlxuICAgICAgICAgICAgcGFyYW1zID0gZXhwci5wYXJhbXM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHBhcmFtU2V0OiB7fVxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHBhcmFtcy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgcGFyYW0gPSBwYXJhbXNbaV07XG4gICAgICAgICAgICBzd2l0Y2ggKHBhcmFtLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgU3ludGF4LkFzc2lnbm1lbnRQYXR0ZXJuOlxuICAgICAgICAgICAgICAgIHBhcmFtc1tpXSA9IHBhcmFtLmxlZnQ7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtLnJpZ2h0LnR5cGUgPT09IFN5bnRheC5ZaWVsZEV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtLnJpZ2h0LmFyZ3VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbihsb29rYWhlYWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtLnJpZ2h0LnR5cGUgPSBTeW50YXguSWRlbnRpZmllcjtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW0ucmlnaHQubmFtZSA9ICd5aWVsZCc7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXJhbS5yaWdodC5hcmd1bWVudDtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhcmFtLnJpZ2h0LmRlbGVnYXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0cy5wdXNoKHBhcmFtLnJpZ2h0KTtcbiAgICAgICAgICAgICAgICArK2RlZmF1bHRDb3VudDtcbiAgICAgICAgICAgICAgICBjaGVja1BhdHRlcm5QYXJhbShvcHRpb25zLCBwYXJhbS5sZWZ0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY2hlY2tQYXR0ZXJuUGFyYW0ob3B0aW9ucywgcGFyYW0pO1xuICAgICAgICAgICAgICAgIHBhcmFtc1tpXSA9IHBhcmFtO1xuICAgICAgICAgICAgICAgIGRlZmF1bHRzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyaWN0IHx8ICFzdGF0ZS5hbGxvd1lpZWxkKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBwYXJhbXMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBwYXJhbSA9IHBhcmFtc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gU3ludGF4LllpZWxkRXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbihsb29rYWhlYWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLm1lc3NhZ2UgPT09IE1lc3NhZ2VzLlN0cmljdFBhcmFtRHVwZSkge1xuICAgICAgICAgICAgdG9rZW4gPSBzdHJpY3QgPyBvcHRpb25zLnN0cmljdGVkIDogb3B0aW9ucy5maXJzdFJlc3RyaWN0ZWQ7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbiwgb3B0aW9ucy5tZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWZhdWx0Q291bnQgPT09IDApIHtcbiAgICAgICAgICAgIGRlZmF1bHRzID0gW107XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgICAgICBkZWZhdWx0czogZGVmYXVsdHMsXG4gICAgICAgICAgICBzdHJpY3RlZDogb3B0aW9ucy5zdHJpY3RlZCxcbiAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZDogb3B0aW9ucy5maXJzdFJlc3RyaWN0ZWQsXG4gICAgICAgICAgICBtZXNzYWdlOiBvcHRpb25zLm1lc3NhZ2VcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUFycm93RnVuY3Rpb25FeHByZXNzaW9uKG9wdGlvbnMsIG5vZGUpIHtcbiAgICAgICAgdmFyIHByZXZpb3VzU3RyaWN0LCBwcmV2aW91c0FsbG93WWllbGQsIGJvZHk7XG5cbiAgICAgICAgaWYgKGhhc0xpbmVUZXJtaW5hdG9yKSB7XG4gICAgICAgICAgICB0b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbihsb29rYWhlYWQpO1xuICAgICAgICB9XG4gICAgICAgIGV4cGVjdCgnPT4nKTtcblxuICAgICAgICBwcmV2aW91c1N0cmljdCA9IHN0cmljdDtcbiAgICAgICAgcHJldmlvdXNBbGxvd1lpZWxkID0gc3RhdGUuYWxsb3dZaWVsZDtcbiAgICAgICAgc3RhdGUuYWxsb3dZaWVsZCA9IHRydWU7XG5cbiAgICAgICAgYm9keSA9IHBhcnNlQ29uY2lzZUJvZHkoKTtcblxuICAgICAgICBpZiAoc3RyaWN0ICYmIG9wdGlvbnMuZmlyc3RSZXN0cmljdGVkKSB7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbihvcHRpb25zLmZpcnN0UmVzdHJpY3RlZCwgb3B0aW9ucy5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyaWN0ICYmIG9wdGlvbnMuc3RyaWN0ZWQpIHtcbiAgICAgICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKG9wdGlvbnMuc3RyaWN0ZWQsIG9wdGlvbnMubWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzdHJpY3QgPSBwcmV2aW91c1N0cmljdDtcbiAgICAgICAgc3RhdGUuYWxsb3dZaWVsZCA9IHByZXZpb3VzQWxsb3dZaWVsZDtcblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbihvcHRpb25zLnBhcmFtcywgb3B0aW9ucy5kZWZhdWx0cywgYm9keSwgYm9keS50eXBlICE9PSBTeW50YXguQmxvY2tTdGF0ZW1lbnQpO1xuICAgIH1cblxuICAgIC8vIEVDTUEtMjYyIDE0LjQgWWllbGQgZXhwcmVzc2lvblxuXG4gICAgZnVuY3Rpb24gcGFyc2VZaWVsZEV4cHJlc3Npb24oKSB7XG4gICAgICAgIHZhciBhcmd1bWVudCwgZXhwciwgZGVsZWdhdGUsIHByZXZpb3VzQWxsb3dZaWVsZDtcblxuICAgICAgICBhcmd1bWVudCA9IG51bGw7XG4gICAgICAgIGV4cHIgPSBuZXcgTm9kZSgpO1xuICAgICAgICBkZWxlZ2F0ZSA9IGZhbHNlO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ3lpZWxkJyk7XG5cbiAgICAgICAgaWYgKCFoYXNMaW5lVGVybWluYXRvcikge1xuICAgICAgICAgICAgcHJldmlvdXNBbGxvd1lpZWxkID0gc3RhdGUuYWxsb3dZaWVsZDtcbiAgICAgICAgICAgIHN0YXRlLmFsbG93WWllbGQgPSBmYWxzZTtcbiAgICAgICAgICAgIGRlbGVnYXRlID0gbWF0Y2goJyonKTtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgIGFyZ3VtZW50ID0gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoKCc7JykgJiYgIW1hdGNoKCd9JykgJiYgIW1hdGNoKCcpJykgJiYgbG9va2FoZWFkLnR5cGUgIT09IFRva2VuLkVPRikge1xuICAgICAgICAgICAgICAgICAgICBhcmd1bWVudCA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZS5hbGxvd1lpZWxkID0gcHJldmlvdXNBbGxvd1lpZWxkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4cHIuZmluaXNoWWllbGRFeHByZXNzaW9uKGFyZ3VtZW50LCBkZWxlZ2F0ZSk7XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTIuMTQgQXNzaWdubWVudCBPcGVyYXRvcnNcblxuICAgIGZ1bmN0aW9uIHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKSB7XG4gICAgICAgIHZhciB0b2tlbiwgZXhwciwgcmlnaHQsIGxpc3QsIHN0YXJ0VG9rZW47XG5cbiAgICAgICAgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgdG9rZW4gPSBsb29rYWhlYWQ7XG5cbiAgICAgICAgaWYgKCFzdGF0ZS5hbGxvd1lpZWxkICYmIG1hdGNoS2V5d29yZCgneWllbGQnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlWWllbGRFeHByZXNzaW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICBleHByID0gcGFyc2VDb25kaXRpb25hbEV4cHJlc3Npb24oKTtcblxuICAgICAgICBpZiAoZXhwci50eXBlID09PSBQbGFjZUhvbGRlcnMuQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlciB8fCBtYXRjaCgnPT4nKSkge1xuICAgICAgICAgICAgaXNBc3NpZ25tZW50VGFyZ2V0ID0gaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgbGlzdCA9IHJlaW50ZXJwcmV0QXNDb3ZlckZvcm1hbHNMaXN0KGV4cHIpO1xuXG4gICAgICAgICAgICBpZiAobGlzdCkge1xuICAgICAgICAgICAgICAgIGZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24obGlzdCwgbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBleHByO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoQXNzaWduKCkpIHtcbiAgICAgICAgICAgIGlmICghaXNBc3NpZ25tZW50VGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdG9sZXJhdGVFcnJvcihNZXNzYWdlcy5JbnZhbGlkTEhTSW5Bc3NpZ25tZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRUNNQS0yNjIgMTIuMS4xXG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGV4cHIudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNSZXN0cmljdGVkV29yZChleHByLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBNZXNzYWdlcy5TdHJpY3RMSFNBc3NpZ25tZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZChleHByLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBNZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFtYXRjaCgnPScpKSB7XG4gICAgICAgICAgICAgICAgaXNBc3NpZ25tZW50VGFyZ2V0ID0gaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oZXhwcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRva2VuID0gbGV4KCk7XG4gICAgICAgICAgICByaWdodCA9IGlzb2xhdGVDb3ZlckdyYW1tYXIocGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XG4gICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKS5maW5pc2hBc3NpZ25tZW50RXhwcmVzc2lvbih0b2tlbi52YWx1ZSwgZXhwciwgcmlnaHQpO1xuICAgICAgICAgICAgZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIC8vIEVDTUEtMjYyIDEyLjE1IENvbW1hIE9wZXJhdG9yXG5cbiAgICBmdW5jdGlvbiBwYXJzZUV4cHJlc3Npb24oKSB7XG4gICAgICAgIHZhciBleHByLCBzdGFydFRva2VuID0gbG9va2FoZWFkLCBleHByZXNzaW9ucztcblxuICAgICAgICBleHByID0gaXNvbGF0ZUNvdmVyR3JhbW1hcihwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcblxuICAgICAgICBpZiAobWF0Y2goJywnKSkge1xuICAgICAgICAgICAgZXhwcmVzc2lvbnMgPSBbZXhwcl07XG5cbiAgICAgICAgICAgIHdoaWxlIChzdGFydEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaCgnLCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKGlzb2xhdGVDb3ZlckdyYW1tYXIocGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKS5maW5pc2hTZXF1ZW5jZUV4cHJlc3Npb24oZXhwcmVzc2lvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTMuMiBCbG9ja1xuXG4gICAgZnVuY3Rpb24gcGFyc2VTdGF0ZW1lbnRMaXN0SXRlbSgpIHtcbiAgICAgICAgaWYgKGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5LZXl3b3JkKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGxvb2thaGVhZC52YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSAnZXhwb3J0JzpcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc291cmNlVHlwZSAhPT0gJ21vZHVsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4obG9va2FoZWFkLCBNZXNzYWdlcy5JbGxlZ2FsRXhwb3J0RGVjbGFyYXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VFeHBvcnREZWNsYXJhdGlvbigpO1xuICAgICAgICAgICAgY2FzZSAnaW1wb3J0JzpcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc291cmNlVHlwZSAhPT0gJ21vZHVsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4obG9va2FoZWFkLCBNZXNzYWdlcy5JbGxlZ2FsSW1wb3J0RGVjbGFyYXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbXBvcnREZWNsYXJhdGlvbigpO1xuICAgICAgICAgICAgY2FzZSAnY29uc3QnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUxleGljYWxEZWNsYXJhdGlvbih7aW5Gb3I6IGZhbHNlfSk7XG4gICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbihuZXcgTm9kZSgpKTtcbiAgICAgICAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VDbGFzc0RlY2xhcmF0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2hLZXl3b3JkKCdsZXQnKSAmJiBpc0xleGljYWxEZWNsYXJhdGlvbigpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VMZXhpY2FsRGVjbGFyYXRpb24oe2luRm9yOiBmYWxzZX0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnNlU3RhdGVtZW50KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VTdGF0ZW1lbnRMaXN0KCkge1xuICAgICAgICB2YXIgbGlzdCA9IFtdO1xuICAgICAgICB3aGlsZSAoc3RhcnRJbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKG1hdGNoKCd9JykpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpc3QucHVzaChwYXJzZVN0YXRlbWVudExpc3RJdGVtKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VCbG9jaygpIHtcbiAgICAgICAgdmFyIGJsb2NrLCBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgICBleHBlY3QoJ3snKTtcblxuICAgICAgICBibG9jayA9IHBhcnNlU3RhdGVtZW50TGlzdCgpO1xuXG4gICAgICAgIGV4cGVjdCgnfScpO1xuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaEJsb2NrU3RhdGVtZW50KGJsb2NrKTtcbiAgICB9XG5cbiAgICAvLyBFQ01BLTI2MiAxMy4zLjIgVmFyaWFibGUgU3RhdGVtZW50XG5cbiAgICBmdW5jdGlvbiBwYXJzZVZhcmlhYmxlSWRlbnRpZmllcihraW5kKSB7XG4gICAgICAgIHZhciB0b2tlbiwgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgICAgdG9rZW4gPSBsZXgoKTtcblxuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uS2V5d29yZCAmJiB0b2tlbi52YWx1ZSA9PT0gJ3lpZWxkJykge1xuICAgICAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBNZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQpO1xuICAgICAgICAgICAgfSBpZiAoIXN0YXRlLmFsbG93WWllbGQpIHtcbiAgICAgICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodG9rZW4udHlwZSAhPT0gVG9rZW4uSWRlbnRpZmllcikge1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiB0b2tlbi50eXBlID09PSBUb2tlbi5LZXl3b3JkICYmIGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgTWVzc2FnZXMuU3RyaWN0UmVzZXJ2ZWRXb3JkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmljdCB8fCB0b2tlbi52YWx1ZSAhPT0gJ2xldCcgfHwga2luZCAhPT0gJ3ZhcicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS5zb3VyY2VUeXBlID09PSAnbW9kdWxlJyAmJiB0b2tlbi50eXBlID09PSBUb2tlbi5JZGVudGlmaWVyICYmIHRva2VuLnZhbHVlID09PSAnYXdhaXQnKSB7XG4gICAgICAgICAgICB0b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hJZGVudGlmaWVyKHRva2VuLnZhbHVlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVZhcmlhYmxlRGVjbGFyYXRpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgaW5pdCA9IG51bGwsIGlkLCBub2RlID0gbmV3IE5vZGUoKSwgcGFyYW1zID0gW107XG5cbiAgICAgICAgaWQgPSBwYXJzZVBhdHRlcm4ocGFyYW1zLCAndmFyJyk7XG5cbiAgICAgICAgLy8gRUNNQS0yNjIgMTIuMi4xXG4gICAgICAgIGlmIChzdHJpY3QgJiYgaXNSZXN0cmljdGVkV29yZChpZC5uYW1lKSkge1xuICAgICAgICAgICAgdG9sZXJhdGVFcnJvcihNZXNzYWdlcy5TdHJpY3RWYXJOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaCgnPScpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIGluaXQgPSBpc29sYXRlQ292ZXJHcmFtbWFyKHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xuICAgICAgICB9IGVsc2UgaWYgKGlkLnR5cGUgIT09IFN5bnRheC5JZGVudGlmaWVyICYmICFvcHRpb25zLmluRm9yKSB7XG4gICAgICAgICAgICBleHBlY3QoJz0nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaFZhcmlhYmxlRGVjbGFyYXRvcihpZCwgaW5pdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uTGlzdChvcHRpb25zKSB7XG4gICAgICAgIHZhciBvcHQsIGxpc3Q7XG5cbiAgICAgICAgb3B0ID0geyBpbkZvcjogb3B0aW9ucy5pbkZvciB9O1xuICAgICAgICBsaXN0ID0gW3BhcnNlVmFyaWFibGVEZWNsYXJhdGlvbihvcHQpXTtcblxuICAgICAgICB3aGlsZSAobWF0Y2goJywnKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICBsaXN0LnB1c2gocGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uKG9wdCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VWYXJpYWJsZVN0YXRlbWVudChub2RlKSB7XG4gICAgICAgIHZhciBkZWNsYXJhdGlvbnM7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgndmFyJyk7XG5cbiAgICAgICAgZGVjbGFyYXRpb25zID0gcGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uTGlzdCh7IGluRm9yOiBmYWxzZSB9KTtcblxuICAgICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoVmFyaWFibGVEZWNsYXJhdGlvbihkZWNsYXJhdGlvbnMpO1xuICAgIH1cblxuICAgIC8vIEVDTUEtMjYyIDEzLjMuMSBMZXQgYW5kIENvbnN0IERlY2xhcmF0aW9uc1xuXG4gICAgZnVuY3Rpb24gcGFyc2VMZXhpY2FsQmluZGluZyhraW5kLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBpbml0ID0gbnVsbCwgaWQsIG5vZGUgPSBuZXcgTm9kZSgpLCBwYXJhbXMgPSBbXTtcblxuICAgICAgICBpZCA9IHBhcnNlUGF0dGVybihwYXJhbXMsIGtpbmQpO1xuXG4gICAgICAgIC8vIEVDTUEtMjYyIDEyLjIuMVxuICAgICAgICBpZiAoc3RyaWN0ICYmIGlkLnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyICYmIGlzUmVzdHJpY3RlZFdvcmQoaWQubmFtZSkpIHtcbiAgICAgICAgICAgIHRvbGVyYXRlRXJyb3IoTWVzc2FnZXMuU3RyaWN0VmFyTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoa2luZCA9PT0gJ2NvbnN0Jykge1xuICAgICAgICAgICAgaWYgKCFtYXRjaEtleXdvcmQoJ2luJykgJiYgIW1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ29mJykpIHtcbiAgICAgICAgICAgICAgICBleHBlY3QoJz0nKTtcbiAgICAgICAgICAgICAgICBpbml0ID0gaXNvbGF0ZUNvdmVyR3JhbW1hcihwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICgoIW9wdGlvbnMuaW5Gb3IgJiYgaWQudHlwZSAhPT0gU3ludGF4LklkZW50aWZpZXIpIHx8IG1hdGNoKCc9JykpIHtcbiAgICAgICAgICAgIGV4cGVjdCgnPScpO1xuICAgICAgICAgICAgaW5pdCA9IGlzb2xhdGVDb3ZlckdyYW1tYXIocGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hWYXJpYWJsZURlY2xhcmF0b3IoaWQsIGluaXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlQmluZGluZ0xpc3Qoa2luZCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgbGlzdCA9IFtwYXJzZUxleGljYWxCaW5kaW5nKGtpbmQsIG9wdGlvbnMpXTtcblxuICAgICAgICB3aGlsZSAobWF0Y2goJywnKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICBsaXN0LnB1c2gocGFyc2VMZXhpY2FsQmluZGluZyhraW5kLCBvcHRpb25zKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIHRva2VuaXplclN0YXRlKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgaGFzTGluZVRlcm1pbmF0b3I6IGhhc0xpbmVUZXJtaW5hdG9yLFxuICAgICAgICAgICAgbGFzdEluZGV4OiBsYXN0SW5kZXgsXG4gICAgICAgICAgICBsYXN0TGluZU51bWJlcjogbGFzdExpbmVOdW1iZXIsXG4gICAgICAgICAgICBsYXN0TGluZVN0YXJ0OiBsYXN0TGluZVN0YXJ0LFxuICAgICAgICAgICAgc3RhcnRJbmRleDogc3RhcnRJbmRleCxcbiAgICAgICAgICAgIHN0YXJ0TGluZU51bWJlcjogc3RhcnRMaW5lTnVtYmVyLFxuICAgICAgICAgICAgc3RhcnRMaW5lU3RhcnQ6IHN0YXJ0TGluZVN0YXJ0LFxuICAgICAgICAgICAgbG9va2FoZWFkOiBsb29rYWhlYWQsXG4gICAgICAgICAgICB0b2tlbkNvdW50OiBleHRyYS50b2tlbnMgPyBleHRyYS50b2tlbnMubGVuZ3RoIDogMFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc2V0VG9rZW5pemVyU3RhdGUodHMpIHtcbiAgICAgICAgaW5kZXggPSB0cy5pbmRleDtcbiAgICAgICAgbGluZU51bWJlciA9IHRzLmxpbmVOdW1iZXI7XG4gICAgICAgIGxpbmVTdGFydCA9IHRzLmxpbmVTdGFydDtcbiAgICAgICAgaGFzTGluZVRlcm1pbmF0b3IgPSB0cy5oYXNMaW5lVGVybWluYXRvcjtcbiAgICAgICAgbGFzdEluZGV4ID0gdHMubGFzdEluZGV4O1xuICAgICAgICBsYXN0TGluZU51bWJlciA9IHRzLmxhc3RMaW5lTnVtYmVyO1xuICAgICAgICBsYXN0TGluZVN0YXJ0ID0gdHMubGFzdExpbmVTdGFydDtcbiAgICAgICAgc3RhcnRJbmRleCA9IHRzLnN0YXJ0SW5kZXg7XG4gICAgICAgIHN0YXJ0TGluZU51bWJlciA9IHRzLnN0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgc3RhcnRMaW5lU3RhcnQgPSB0cy5zdGFydExpbmVTdGFydDtcbiAgICAgICAgbG9va2FoZWFkID0gdHMubG9va2FoZWFkO1xuICAgICAgICBpZiAoZXh0cmEudG9rZW5zKSB7XG4gICAgICAgICAgICBleHRyYS50b2tlbnMuc3BsaWNlKHRzLnRva2VuQ291bnQsIGV4dHJhLnRva2Vucy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNMZXhpY2FsRGVjbGFyYXRpb24oKSB7XG4gICAgICAgIHZhciBsZXhpY2FsLCB0cztcblxuICAgICAgICB0cyA9IHRva2VuaXplclN0YXRlKCk7XG5cbiAgICAgICAgbGV4KCk7XG4gICAgICAgIGxleGljYWwgPSAobG9va2FoZWFkLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXIpIHx8IG1hdGNoKCdbJykgfHwgbWF0Y2goJ3snKSB8fFxuICAgICAgICAgICAgbWF0Y2hLZXl3b3JkKCdsZXQnKSB8fCBtYXRjaEtleXdvcmQoJ3lpZWxkJyk7XG5cbiAgICAgICAgcmVzZXRUb2tlbml6ZXJTdGF0ZSh0cyk7XG5cbiAgICAgICAgcmV0dXJuIGxleGljYWw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VMZXhpY2FsRGVjbGFyYXRpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIga2luZCwgZGVjbGFyYXRpb25zLCBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgICBraW5kID0gbGV4KCkudmFsdWU7XG4gICAgICAgIGFzc2VydChraW5kID09PSAnbGV0JyB8fCBraW5kID09PSAnY29uc3QnLCAnTGV4aWNhbCBkZWNsYXJhdGlvbiBtdXN0IGJlIGVpdGhlciBsZXQgb3IgY29uc3QnKTtcblxuICAgICAgICBkZWNsYXJhdGlvbnMgPSBwYXJzZUJpbmRpbmdMaXN0KGtpbmQsIG9wdGlvbnMpO1xuXG4gICAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hMZXhpY2FsRGVjbGFyYXRpb24oZGVjbGFyYXRpb25zLCBraW5kKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVJlc3RFbGVtZW50KHBhcmFtcykge1xuICAgICAgICB2YXIgcGFyYW0sIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIGxleCgpO1xuXG4gICAgICAgIGlmIChtYXRjaCgneycpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKE1lc3NhZ2VzLk9iamVjdFBhdHRlcm5Bc1Jlc3RQYXJhbWV0ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyYW1zLnB1c2gobG9va2FoZWFkKTtcblxuICAgICAgICBwYXJhbSA9IHBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XG5cbiAgICAgICAgaWYgKG1hdGNoKCc9JykpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoTWVzc2FnZXMuRGVmYXVsdFJlc3RQYXJhbWV0ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtYXRjaCgnKScpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKE1lc3NhZ2VzLlBhcmFtZXRlckFmdGVyUmVzdFBhcmFtZXRlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hSZXN0RWxlbWVudChwYXJhbSk7XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTMuNCBFbXB0eSBTdGF0ZW1lbnRcblxuICAgIGZ1bmN0aW9uIHBhcnNlRW1wdHlTdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICBleHBlY3QoJzsnKTtcbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoRW1wdHlTdGF0ZW1lbnQoKTtcbiAgICB9XG5cbiAgICAvLyBFQ01BLTI2MiAxMi40IEV4cHJlc3Npb24gU3RhdGVtZW50XG5cbiAgICBmdW5jdGlvbiBwYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICB2YXIgZXhwciA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaEV4cHJlc3Npb25TdGF0ZW1lbnQoZXhwcik7XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTMuNiBJZiBzdGF0ZW1lbnRcblxuICAgIGZ1bmN0aW9uIHBhcnNlSWZTdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICB2YXIgdGVzdCwgY29uc2VxdWVudCwgYWx0ZXJuYXRlO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ2lmJyk7XG5cbiAgICAgICAgZXhwZWN0KCcoJyk7XG5cbiAgICAgICAgdGVzdCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXG4gICAgICAgIGV4cGVjdCgnKScpO1xuXG4gICAgICAgIGNvbnNlcXVlbnQgPSBwYXJzZVN0YXRlbWVudCgpO1xuXG4gICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2Vsc2UnKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICBhbHRlcm5hdGUgPSBwYXJzZVN0YXRlbWVudCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWx0ZXJuYXRlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaElmU3RhdGVtZW50KHRlc3QsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSk7XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTMuNyBJdGVyYXRpb24gU3RhdGVtZW50c1xuXG4gICAgZnVuY3Rpb24gcGFyc2VEb1doaWxlU3RhdGVtZW50KG5vZGUpIHtcbiAgICAgICAgdmFyIGJvZHksIHRlc3QsIG9sZEluSXRlcmF0aW9uO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ2RvJyk7XG5cbiAgICAgICAgb2xkSW5JdGVyYXRpb24gPSBzdGF0ZS5pbkl0ZXJhdGlvbjtcbiAgICAgICAgc3RhdGUuaW5JdGVyYXRpb24gPSB0cnVlO1xuXG4gICAgICAgIGJvZHkgPSBwYXJzZVN0YXRlbWVudCgpO1xuXG4gICAgICAgIHN0YXRlLmluSXRlcmF0aW9uID0gb2xkSW5JdGVyYXRpb247XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnd2hpbGUnKTtcblxuICAgICAgICBleHBlY3QoJygnKTtcblxuICAgICAgICB0ZXN0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgZXhwZWN0KCcpJyk7XG5cbiAgICAgICAgaWYgKG1hdGNoKCc7JykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoRG9XaGlsZVN0YXRlbWVudChib2R5LCB0ZXN0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVdoaWxlU3RhdGVtZW50KG5vZGUpIHtcbiAgICAgICAgdmFyIHRlc3QsIGJvZHksIG9sZEluSXRlcmF0aW9uO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ3doaWxlJyk7XG5cbiAgICAgICAgZXhwZWN0KCcoJyk7XG5cbiAgICAgICAgdGVzdCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXG4gICAgICAgIGV4cGVjdCgnKScpO1xuXG4gICAgICAgIG9sZEluSXRlcmF0aW9uID0gc3RhdGUuaW5JdGVyYXRpb247XG4gICAgICAgIHN0YXRlLmluSXRlcmF0aW9uID0gdHJ1ZTtcblxuICAgICAgICBib2R5ID0gcGFyc2VTdGF0ZW1lbnQoKTtcblxuICAgICAgICBzdGF0ZS5pbkl0ZXJhdGlvbiA9IG9sZEluSXRlcmF0aW9uO1xuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaFdoaWxlU3RhdGVtZW50KHRlc3QsIGJvZHkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlRm9yU3RhdGVtZW50KG5vZGUpIHtcbiAgICAgICAgdmFyIGluaXQsIGZvckluLCBpbml0U2VxLCBpbml0U3RhcnRUb2tlbiwgdGVzdCwgdXBkYXRlLCBsZWZ0LCByaWdodCwga2luZCwgZGVjbGFyYXRpb25zLFxuICAgICAgICAgICAgYm9keSwgb2xkSW5JdGVyYXRpb24sIHByZXZpb3VzQWxsb3dJbiA9IHN0YXRlLmFsbG93SW47XG5cbiAgICAgICAgaW5pdCA9IHRlc3QgPSB1cGRhdGUgPSBudWxsO1xuICAgICAgICBmb3JJbiA9IHRydWU7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnZm9yJyk7XG5cbiAgICAgICAgZXhwZWN0KCcoJyk7XG5cbiAgICAgICAgaWYgKG1hdGNoKCc7JykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG1hdGNoS2V5d29yZCgndmFyJykpIHtcbiAgICAgICAgICAgICAgICBpbml0ID0gbmV3IE5vZGUoKTtcbiAgICAgICAgICAgICAgICBsZXgoKTtcblxuICAgICAgICAgICAgICAgIHN0YXRlLmFsbG93SW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnMgPSBwYXJzZVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KHsgaW5Gb3I6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgc3RhdGUuYWxsb3dJbiA9IHByZXZpb3VzQWxsb3dJbjtcblxuICAgICAgICAgICAgICAgIGlmIChkZWNsYXJhdGlvbnMubGVuZ3RoID09PSAxICYmIG1hdGNoS2V5d29yZCgnaW4nKSkge1xuICAgICAgICAgICAgICAgICAgICBpbml0ID0gaW5pdC5maW5pc2hWYXJpYWJsZURlY2xhcmF0aW9uKGRlY2xhcmF0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gaW5pdDtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgICAgICAgICAgaW5pdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkZWNsYXJhdGlvbnMubGVuZ3RoID09PSAxICYmIGRlY2xhcmF0aW9uc1swXS5pbml0ID09PSBudWxsICYmIG1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ29mJykpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdCA9IGluaXQuZmluaXNoVmFyaWFibGVEZWNsYXJhdGlvbihkZWNsYXJhdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGluaXQ7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgICAgICAgICBpbml0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgZm9ySW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbml0ID0gaW5pdC5maW5pc2hWYXJpYWJsZURlY2xhcmF0aW9uKGRlY2xhcmF0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdCgnOycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2hLZXl3b3JkKCdjb25zdCcpIHx8IG1hdGNoS2V5d29yZCgnbGV0JykpIHtcbiAgICAgICAgICAgICAgICBpbml0ID0gbmV3IE5vZGUoKTtcbiAgICAgICAgICAgICAgICBraW5kID0gbGV4KCkudmFsdWU7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXN0cmljdCAmJiBsb29rYWhlYWQudmFsdWUgPT09ICdpbicpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdCA9IGluaXQuZmluaXNoSWRlbnRpZmllcihraW5kKTtcbiAgICAgICAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBpbml0O1xuICAgICAgICAgICAgICAgICAgICByaWdodCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgICAgICAgICBpbml0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5hbGxvd0luID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9ucyA9IHBhcnNlQmluZGluZ0xpc3Qoa2luZCwge2luRm9yOiB0cnVlfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmFsbG93SW4gPSBwcmV2aW91c0FsbG93SW47XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlY2xhcmF0aW9ucy5sZW5ndGggPT09IDEgJiYgZGVjbGFyYXRpb25zWzBdLmluaXQgPT09IG51bGwgJiYgbWF0Y2hLZXl3b3JkKCdpbicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0ID0gaW5pdC5maW5pc2hMZXhpY2FsRGVjbGFyYXRpb24oZGVjbGFyYXRpb25zLCBraW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGluaXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVjbGFyYXRpb25zLmxlbmd0aCA9PT0gMSAmJiBkZWNsYXJhdGlvbnNbMF0uaW5pdCA9PT0gbnVsbCAmJiBtYXRjaENvbnRleHR1YWxLZXl3b3JkKCdvZicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0ID0gaW5pdC5maW5pc2hMZXhpY2FsRGVjbGFyYXRpb24oZGVjbGFyYXRpb25zLCBraW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGluaXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9ySW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXQgPSBpbml0LmZpbmlzaExleGljYWxEZWNsYXJhdGlvbihkZWNsYXJhdGlvbnMsIGtpbmQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbml0U3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgICAgICAgICBzdGF0ZS5hbGxvd0luID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaW5pdCA9IGluaGVyaXRDb3ZlckdyYW1tYXIocGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgc3RhdGUuYWxsb3dJbiA9IHByZXZpb3VzQWxsb3dJbjtcblxuICAgICAgICAgICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2luJykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0Fzc2lnbm1lbnRUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvbGVyYXRlRXJyb3IoTWVzc2FnZXMuSW52YWxpZExIU0luRm9ySW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIHJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihpbml0KTtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGluaXQ7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGluaXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnb2YnKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQXNzaWdubWVudFRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9sZXJhdGVFcnJvcihNZXNzYWdlcy5JbnZhbGlkTEhTSW5Gb3JMb29wKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgICAgICByZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oaW5pdCk7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBpbml0O1xuICAgICAgICAgICAgICAgICAgICByaWdodCA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgICAgICAgICAgaW5pdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGZvckluID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKCcsJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRTZXEgPSBbaW5pdF07XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAobWF0Y2goJywnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRTZXEucHVzaChpc29sYXRlQ292ZXJHcmFtbWFyKHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXQgPSBuZXcgV3JhcHBpbmdOb2RlKGluaXRTdGFydFRva2VuKS5maW5pc2hTZXF1ZW5jZUV4cHJlc3Npb24oaW5pdFNlcSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KCc7Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBsZWZ0ID09PSAndW5kZWZpbmVkJykge1xuXG4gICAgICAgICAgICBpZiAoIW1hdGNoKCc7JykpIHtcbiAgICAgICAgICAgICAgICB0ZXN0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHBlY3QoJzsnKTtcblxuICAgICAgICAgICAgaWYgKCFtYXRjaCgnKScpKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3QoJyknKTtcblxuICAgICAgICBvbGRJbkl0ZXJhdGlvbiA9IHN0YXRlLmluSXRlcmF0aW9uO1xuICAgICAgICBzdGF0ZS5pbkl0ZXJhdGlvbiA9IHRydWU7XG5cbiAgICAgICAgYm9keSA9IGlzb2xhdGVDb3ZlckdyYW1tYXIocGFyc2VTdGF0ZW1lbnQpO1xuXG4gICAgICAgIHN0YXRlLmluSXRlcmF0aW9uID0gb2xkSW5JdGVyYXRpb247XG5cbiAgICAgICAgcmV0dXJuICh0eXBlb2YgbGVmdCA9PT0gJ3VuZGVmaW5lZCcpID9cbiAgICAgICAgICAgICAgICBub2RlLmZpbmlzaEZvclN0YXRlbWVudChpbml0LCB0ZXN0LCB1cGRhdGUsIGJvZHkpIDpcbiAgICAgICAgICAgICAgICBmb3JJbiA/IG5vZGUuZmluaXNoRm9ySW5TdGF0ZW1lbnQobGVmdCwgcmlnaHQsIGJvZHkpIDpcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5maW5pc2hGb3JPZlN0YXRlbWVudChsZWZ0LCByaWdodCwgYm9keSk7XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTMuOCBUaGUgY29udGludWUgc3RhdGVtZW50XG5cbiAgICBmdW5jdGlvbiBwYXJzZUNvbnRpbnVlU3RhdGVtZW50KG5vZGUpIHtcbiAgICAgICAgdmFyIGxhYmVsID0gbnVsbCwga2V5O1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ2NvbnRpbnVlJyk7XG5cbiAgICAgICAgLy8gT3B0aW1pemUgdGhlIG1vc3QgY29tbW9uIGZvcm06ICdjb250aW51ZTsnLlxuICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoc3RhcnRJbmRleCkgPT09IDB4M0IpIHtcbiAgICAgICAgICAgIGxleCgpO1xuXG4gICAgICAgICAgICBpZiAoIXN0YXRlLmluSXRlcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihNZXNzYWdlcy5JbGxlZ2FsQ29udGludWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hDb250aW51ZVN0YXRlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNMaW5lVGVybWluYXRvcikge1xuICAgICAgICAgICAgaWYgKCFzdGF0ZS5pbkl0ZXJhdGlvbikge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoTWVzc2FnZXMuSWxsZWdhbENvbnRpbnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoQ29udGludWVTdGF0ZW1lbnQobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIGxhYmVsID0gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcblxuICAgICAgICAgICAga2V5ID0gJyQnICsgbGFiZWwubmFtZTtcbiAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YXRlLmxhYmVsU2V0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihNZXNzYWdlcy5Vbmtub3duTGFiZWwsIGxhYmVsLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuXG4gICAgICAgIGlmIChsYWJlbCA9PT0gbnVsbCAmJiAhc3RhdGUuaW5JdGVyYXRpb24pIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoTWVzc2FnZXMuSWxsZWdhbENvbnRpbnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaENvbnRpbnVlU3RhdGVtZW50KGxhYmVsKTtcbiAgICB9XG5cbiAgICAvLyBFQ01BLTI2MiAxMy45IFRoZSBicmVhayBzdGF0ZW1lbnRcblxuICAgIGZ1bmN0aW9uIHBhcnNlQnJlYWtTdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICB2YXIgbGFiZWwgPSBudWxsLCBrZXk7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnYnJlYWsnKTtcblxuICAgICAgICAvLyBDYXRjaCB0aGUgdmVyeSBjb21tb24gY2FzZSBmaXJzdDogaW1tZWRpYXRlbHkgYSBzZW1pY29sb24gKFUrMDAzQikuXG4gICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChsYXN0SW5kZXgpID09PSAweDNCKSB7XG4gICAgICAgICAgICBsZXgoKTtcblxuICAgICAgICAgICAgaWYgKCEoc3RhdGUuaW5JdGVyYXRpb24gfHwgc3RhdGUuaW5Td2l0Y2gpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihNZXNzYWdlcy5JbGxlZ2FsQnJlYWspO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hCcmVha1N0YXRlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNMaW5lVGVybWluYXRvcikge1xuICAgICAgICAgICAgaWYgKCEoc3RhdGUuaW5JdGVyYXRpb24gfHwgc3RhdGUuaW5Td2l0Y2gpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihNZXNzYWdlcy5JbGxlZ2FsQnJlYWspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICBsYWJlbCA9IHBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XG5cbiAgICAgICAgICAgIGtleSA9ICckJyArIGxhYmVsLm5hbWU7XG4gICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzdGF0ZS5sYWJlbFNldCwga2V5KSkge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoTWVzc2FnZXMuVW5rbm93bkxhYmVsLCBsYWJlbC5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcblxuICAgICAgICBpZiAobGFiZWwgPT09IG51bGwgJiYgIShzdGF0ZS5pbkl0ZXJhdGlvbiB8fCBzdGF0ZS5pblN3aXRjaCkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoTWVzc2FnZXMuSWxsZWdhbEJyZWFrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaEJyZWFrU3RhdGVtZW50KGxhYmVsKTtcbiAgICB9XG5cbiAgICAvLyBFQ01BLTI2MiAxMy4xMCBUaGUgcmV0dXJuIHN0YXRlbWVudFxuXG4gICAgZnVuY3Rpb24gcGFyc2VSZXR1cm5TdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICB2YXIgYXJndW1lbnQgPSBudWxsO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ3JldHVybicpO1xuXG4gICAgICAgIGlmICghc3RhdGUuaW5GdW5jdGlvbkJvZHkpIHtcbiAgICAgICAgICAgIHRvbGVyYXRlRXJyb3IoTWVzc2FnZXMuSWxsZWdhbFJldHVybik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAncmV0dXJuJyBmb2xsb3dlZCBieSBhIHNwYWNlIGFuZCBhbiBpZGVudGlmaWVyIGlzIHZlcnkgY29tbW9uLlxuICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQobGFzdEluZGV4KSA9PT0gMHgyMCkge1xuICAgICAgICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHNvdXJjZS5jaGFyQ29kZUF0KGxhc3RJbmRleCArIDEpKSkge1xuICAgICAgICAgICAgICAgIGFyZ3VtZW50ID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaFJldHVyblN0YXRlbWVudChhcmd1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzTGluZVRlcm1pbmF0b3IpIHtcbiAgICAgICAgICAgIC8vIEhBQ0tcbiAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaFJldHVyblN0YXRlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbWF0Y2goJzsnKSkge1xuICAgICAgICAgICAgaWYgKCFtYXRjaCgnfScpICYmIGxvb2thaGVhZC50eXBlICE9PSBUb2tlbi5FT0YpIHtcbiAgICAgICAgICAgICAgICBhcmd1bWVudCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaFJldHVyblN0YXRlbWVudChhcmd1bWVudCk7XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTMuMTEgVGhlIHdpdGggc3RhdGVtZW50XG5cbiAgICBmdW5jdGlvbiBwYXJzZVdpdGhTdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICB2YXIgb2JqZWN0LCBib2R5O1xuXG4gICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgIHRvbGVyYXRlRXJyb3IoTWVzc2FnZXMuU3RyaWN0TW9kZVdpdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnd2l0aCcpO1xuXG4gICAgICAgIGV4cGVjdCgnKCcpO1xuXG4gICAgICAgIG9iamVjdCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXG4gICAgICAgIGV4cGVjdCgnKScpO1xuXG4gICAgICAgIGJvZHkgPSBwYXJzZVN0YXRlbWVudCgpO1xuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaFdpdGhTdGF0ZW1lbnQob2JqZWN0LCBib2R5KTtcbiAgICB9XG5cbiAgICAvLyBFQ01BLTI2MiAxMy4xMiBUaGUgc3dpdGNoIHN0YXRlbWVudFxuXG4gICAgZnVuY3Rpb24gcGFyc2VTd2l0Y2hDYXNlKCkge1xuICAgICAgICB2YXIgdGVzdCwgY29uc2VxdWVudCA9IFtdLCBzdGF0ZW1lbnQsIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2RlZmF1bHQnKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICB0ZXN0ID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4cGVjdEtleXdvcmQoJ2Nhc2UnKTtcbiAgICAgICAgICAgIHRlc3QgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgfVxuICAgICAgICBleHBlY3QoJzonKTtcblxuICAgICAgICB3aGlsZSAoc3RhcnRJbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKG1hdGNoKCd9JykgfHwgbWF0Y2hLZXl3b3JkKCdkZWZhdWx0JykgfHwgbWF0Y2hLZXl3b3JkKCdjYXNlJykpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXRlbWVudCA9IHBhcnNlU3RhdGVtZW50TGlzdEl0ZW0oKTtcbiAgICAgICAgICAgIGNvbnNlcXVlbnQucHVzaChzdGF0ZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoU3dpdGNoQ2FzZSh0ZXN0LCBjb25zZXF1ZW50KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVN3aXRjaFN0YXRlbWVudChub2RlKSB7XG4gICAgICAgIHZhciBkaXNjcmltaW5hbnQsIGNhc2VzLCBjbGF1c2UsIG9sZEluU3dpdGNoLCBkZWZhdWx0Rm91bmQ7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnc3dpdGNoJyk7XG5cbiAgICAgICAgZXhwZWN0KCcoJyk7XG5cbiAgICAgICAgZGlzY3JpbWluYW50ID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgZXhwZWN0KCcpJyk7XG5cbiAgICAgICAgZXhwZWN0KCd7Jyk7XG5cbiAgICAgICAgY2FzZXMgPSBbXTtcblxuICAgICAgICBpZiAobWF0Y2goJ30nKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hTd2l0Y2hTdGF0ZW1lbnQoZGlzY3JpbWluYW50LCBjYXNlcyk7XG4gICAgICAgIH1cblxuICAgICAgICBvbGRJblN3aXRjaCA9IHN0YXRlLmluU3dpdGNoO1xuICAgICAgICBzdGF0ZS5pblN3aXRjaCA9IHRydWU7XG4gICAgICAgIGRlZmF1bHRGb3VuZCA9IGZhbHNlO1xuXG4gICAgICAgIHdoaWxlIChzdGFydEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2goJ30nKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xhdXNlID0gcGFyc2VTd2l0Y2hDYXNlKCk7XG4gICAgICAgICAgICBpZiAoY2xhdXNlLnRlc3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVmYXVsdEZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoTWVzc2FnZXMuTXVsdGlwbGVEZWZhdWx0c0luU3dpdGNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2VzLnB1c2goY2xhdXNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLmluU3dpdGNoID0gb2xkSW5Td2l0Y2g7XG5cbiAgICAgICAgZXhwZWN0KCd9Jyk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoU3dpdGNoU3RhdGVtZW50KGRpc2NyaW1pbmFudCwgY2FzZXMpO1xuICAgIH1cblxuICAgIC8vIEVDTUEtMjYyIDEzLjE0IFRoZSB0aHJvdyBzdGF0ZW1lbnRcblxuICAgIGZ1bmN0aW9uIHBhcnNlVGhyb3dTdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICB2YXIgYXJndW1lbnQ7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgndGhyb3cnKTtcblxuICAgICAgICBpZiAoaGFzTGluZVRlcm1pbmF0b3IpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoTWVzc2FnZXMuTmV3bGluZUFmdGVyVGhyb3cpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXJndW1lbnQgPSBwYXJzZUV4cHJlc3Npb24oKTtcblxuICAgICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoVGhyb3dTdGF0ZW1lbnQoYXJndW1lbnQpO1xuICAgIH1cblxuICAgIC8vIEVDTUEtMjYyIDEzLjE1IFRoZSB0cnkgc3RhdGVtZW50XG5cbiAgICBmdW5jdGlvbiBwYXJzZUNhdGNoQ2xhdXNlKCkge1xuICAgICAgICB2YXIgcGFyYW0sIHBhcmFtcyA9IFtdLCBwYXJhbU1hcCA9IHt9LCBrZXksIGksIGJvZHksIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ2NhdGNoJyk7XG5cbiAgICAgICAgZXhwZWN0KCcoJyk7XG4gICAgICAgIGlmIChtYXRjaCgnKScpKSB7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbihsb29rYWhlYWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyYW0gPSBwYXJzZVBhdHRlcm4ocGFyYW1zKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAga2V5ID0gJyQnICsgcGFyYW1zW2ldLnZhbHVlO1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwYXJhbU1hcCwga2V5KSkge1xuICAgICAgICAgICAgICAgIHRvbGVyYXRlRXJyb3IoTWVzc2FnZXMuRHVwbGljYXRlQmluZGluZywgcGFyYW1zW2ldLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmFtTWFwW2tleV0gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRUNNQS0yNjIgMTIuMTQuMVxuICAgICAgICBpZiAoc3RyaWN0ICYmIGlzUmVzdHJpY3RlZFdvcmQocGFyYW0ubmFtZSkpIHtcbiAgICAgICAgICAgIHRvbGVyYXRlRXJyb3IoTWVzc2FnZXMuU3RyaWN0Q2F0Y2hWYXJpYWJsZSk7XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3QoJyknKTtcbiAgICAgICAgYm9keSA9IHBhcnNlQmxvY2soKTtcbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoQ2F0Y2hDbGF1c2UocGFyYW0sIGJvZHkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlVHJ5U3RhdGVtZW50KG5vZGUpIHtcbiAgICAgICAgdmFyIGJsb2NrLCBoYW5kbGVyID0gbnVsbCwgZmluYWxpemVyID0gbnVsbDtcblxuICAgICAgICBleHBlY3RLZXl3b3JkKCd0cnknKTtcblxuICAgICAgICBibG9jayA9IHBhcnNlQmxvY2soKTtcblxuICAgICAgICBpZiAobWF0Y2hLZXl3b3JkKCdjYXRjaCcpKSB7XG4gICAgICAgICAgICBoYW5kbGVyID0gcGFyc2VDYXRjaENsYXVzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoS2V5d29yZCgnZmluYWxseScpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIGZpbmFsaXplciA9IHBhcnNlQmxvY2soKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaGFuZGxlciAmJiAhZmluYWxpemVyKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKE1lc3NhZ2VzLk5vQ2F0Y2hPckZpbmFsbHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoVHJ5U3RhdGVtZW50KGJsb2NrLCBoYW5kbGVyLCBmaW5hbGl6ZXIpO1xuICAgIH1cblxuICAgIC8vIEVDTUEtMjYyIDEzLjE2IFRoZSBkZWJ1Z2dlciBzdGF0ZW1lbnRcblxuICAgIGZ1bmN0aW9uIHBhcnNlRGVidWdnZXJTdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICBleHBlY3RLZXl3b3JkKCdkZWJ1Z2dlcicpO1xuXG4gICAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hEZWJ1Z2dlclN0YXRlbWVudCgpO1xuICAgIH1cblxuICAgIC8vIDEzIFN0YXRlbWVudHNcblxuICAgIGZ1bmN0aW9uIHBhcnNlU3RhdGVtZW50KCkge1xuICAgICAgICB2YXIgdHlwZSA9IGxvb2thaGVhZC50eXBlLFxuICAgICAgICAgICAgZXhwcixcbiAgICAgICAgICAgIGxhYmVsZWRCb2R5LFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgbm9kZTtcblxuICAgICAgICBpZiAodHlwZSA9PT0gVG9rZW4uRU9GKSB7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbihsb29rYWhlYWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUgPT09IFRva2VuLlB1bmN0dWF0b3IgJiYgbG9va2FoZWFkLnZhbHVlID09PSAneycpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUJsb2NrKCk7XG4gICAgICAgIH1cbiAgICAgICAgaXNBc3NpZ25tZW50VGFyZ2V0ID0gaXNCaW5kaW5nRWxlbWVudCA9IHRydWU7XG4gICAgICAgIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIGlmICh0eXBlID09PSBUb2tlbi5QdW5jdHVhdG9yKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGxvb2thaGVhZC52YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSAnOyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRW1wdHlTdGF0ZW1lbnQobm9kZSk7XG4gICAgICAgICAgICBjYXNlICcoJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBUb2tlbi5LZXl3b3JkKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGxvb2thaGVhZC52YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSAnYnJlYWsnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUJyZWFrU3RhdGVtZW50KG5vZGUpO1xuICAgICAgICAgICAgY2FzZSAnY29udGludWUnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUNvbnRpbnVlU3RhdGVtZW50KG5vZGUpO1xuICAgICAgICAgICAgY2FzZSAnZGVidWdnZXInOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZURlYnVnZ2VyU3RhdGVtZW50KG5vZGUpO1xuICAgICAgICAgICAgY2FzZSAnZG8nOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZURvV2hpbGVTdGF0ZW1lbnQobm9kZSk7XG4gICAgICAgICAgICBjYXNlICdmb3InOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUZvclN0YXRlbWVudChub2RlKTtcbiAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uKG5vZGUpO1xuICAgICAgICAgICAgY2FzZSAnaWYnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUlmU3RhdGVtZW50KG5vZGUpO1xuICAgICAgICAgICAgY2FzZSAncmV0dXJuJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VSZXR1cm5TdGF0ZW1lbnQobm9kZSk7XG4gICAgICAgICAgICBjYXNlICdzd2l0Y2gnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVN3aXRjaFN0YXRlbWVudChub2RlKTtcbiAgICAgICAgICAgIGNhc2UgJ3Rocm93JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VUaHJvd1N0YXRlbWVudChub2RlKTtcbiAgICAgICAgICAgIGNhc2UgJ3RyeSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlVHJ5U3RhdGVtZW50KG5vZGUpO1xuICAgICAgICAgICAgY2FzZSAndmFyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VWYXJpYWJsZVN0YXRlbWVudChub2RlKTtcbiAgICAgICAgICAgIGNhc2UgJ3doaWxlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VXaGlsZVN0YXRlbWVudChub2RlKTtcbiAgICAgICAgICAgIGNhc2UgJ3dpdGgnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVdpdGhTdGF0ZW1lbnQobm9kZSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZXhwciA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXG4gICAgICAgIC8vIEVDTUEtMjYyIDEyLjEyIExhYmVsbGVkIFN0YXRlbWVudHNcbiAgICAgICAgaWYgKChleHByLnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyKSAmJiBtYXRjaCgnOicpKSB7XG4gICAgICAgICAgICBsZXgoKTtcblxuICAgICAgICAgICAga2V5ID0gJyQnICsgZXhwci5uYW1lO1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzdGF0ZS5sYWJlbFNldCwga2V5KSkge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoTWVzc2FnZXMuUmVkZWNsYXJhdGlvbiwgJ0xhYmVsJywgZXhwci5uYW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RhdGUubGFiZWxTZXRba2V5XSA9IHRydWU7XG4gICAgICAgICAgICBsYWJlbGVkQm9keSA9IHBhcnNlU3RhdGVtZW50KCk7XG4gICAgICAgICAgICBkZWxldGUgc3RhdGUubGFiZWxTZXRba2V5XTtcbiAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaExhYmVsZWRTdGF0ZW1lbnQoZXhwciwgbGFiZWxlZEJvZHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaEV4cHJlc3Npb25TdGF0ZW1lbnQoZXhwcik7XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTQuMSBGdW5jdGlvbiBEZWZpbml0aW9uXG5cbiAgICBmdW5jdGlvbiBwYXJzZUZ1bmN0aW9uU291cmNlRWxlbWVudHMoKSB7XG4gICAgICAgIHZhciBzdGF0ZW1lbnQsIGJvZHkgPSBbXSwgdG9rZW4sIGRpcmVjdGl2ZSwgZmlyc3RSZXN0cmljdGVkLFxuICAgICAgICAgICAgb2xkTGFiZWxTZXQsIG9sZEluSXRlcmF0aW9uLCBvbGRJblN3aXRjaCwgb2xkSW5GdW5jdGlvbkJvZHksXG4gICAgICAgICAgICBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgICBleHBlY3QoJ3snKTtcblxuICAgICAgICB3aGlsZSAoc3RhcnRJbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGxvb2thaGVhZC50eXBlICE9PSBUb2tlbi5TdHJpbmdMaXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b2tlbiA9IGxvb2thaGVhZDtcblxuICAgICAgICAgICAgc3RhdGVtZW50ID0gcGFyc2VTdGF0ZW1lbnRMaXN0SXRlbSgpO1xuICAgICAgICAgICAgYm9keS5wdXNoKHN0YXRlbWVudCk7XG4gICAgICAgICAgICBpZiAoc3RhdGVtZW50LmV4cHJlc3Npb24udHlwZSAhPT0gU3ludGF4LkxpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIG5vdCBkaXJlY3RpdmVcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpcmVjdGl2ZSA9IHNvdXJjZS5zbGljZSh0b2tlbi5zdGFydCArIDEsIHRva2VuLmVuZCAtIDEpO1xuICAgICAgICAgICAgaWYgKGRpcmVjdGl2ZSA9PT0gJ3VzZSBzdHJpY3QnKSB7XG4gICAgICAgICAgICAgICAgc3RyaWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RSZXN0cmljdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKGZpcnN0UmVzdHJpY3RlZCwgTWVzc2FnZXMuU3RyaWN0T2N0YWxMaXRlcmFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghZmlyc3RSZXN0cmljdGVkICYmIHRva2VuLm9jdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9sZExhYmVsU2V0ID0gc3RhdGUubGFiZWxTZXQ7XG4gICAgICAgIG9sZEluSXRlcmF0aW9uID0gc3RhdGUuaW5JdGVyYXRpb247XG4gICAgICAgIG9sZEluU3dpdGNoID0gc3RhdGUuaW5Td2l0Y2g7XG4gICAgICAgIG9sZEluRnVuY3Rpb25Cb2R5ID0gc3RhdGUuaW5GdW5jdGlvbkJvZHk7XG5cbiAgICAgICAgc3RhdGUubGFiZWxTZXQgPSB7fTtcbiAgICAgICAgc3RhdGUuaW5JdGVyYXRpb24gPSBmYWxzZTtcbiAgICAgICAgc3RhdGUuaW5Td2l0Y2ggPSBmYWxzZTtcbiAgICAgICAgc3RhdGUuaW5GdW5jdGlvbkJvZHkgPSB0cnVlO1xuXG4gICAgICAgIHdoaWxlIChzdGFydEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2goJ30nKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYm9keS5wdXNoKHBhcnNlU3RhdGVtZW50TGlzdEl0ZW0oKSk7XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3QoJ30nKTtcblxuICAgICAgICBzdGF0ZS5sYWJlbFNldCA9IG9sZExhYmVsU2V0O1xuICAgICAgICBzdGF0ZS5pbkl0ZXJhdGlvbiA9IG9sZEluSXRlcmF0aW9uO1xuICAgICAgICBzdGF0ZS5pblN3aXRjaCA9IG9sZEluU3dpdGNoO1xuICAgICAgICBzdGF0ZS5pbkZ1bmN0aW9uQm9keSA9IG9sZEluRnVuY3Rpb25Cb2R5O1xuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaEJsb2NrU3RhdGVtZW50KGJvZHkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlUGFyYW0ob3B0aW9ucywgcGFyYW0sIG5hbWUpIHtcbiAgICAgICAgdmFyIGtleSA9ICckJyArIG5hbWU7XG4gICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgIGlmIChpc1Jlc3RyaWN0ZWRXb3JkKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zdHJpY3RlZCA9IHBhcmFtO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMubWVzc2FnZSA9IE1lc3NhZ2VzLlN0cmljdFBhcmFtTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucy5wYXJhbVNldCwga2V5KSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuc3RyaWN0ZWQgPSBwYXJhbTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLm1lc3NhZ2UgPSBNZXNzYWdlcy5TdHJpY3RQYXJhbUR1cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIW9wdGlvbnMuZmlyc3RSZXN0cmljdGVkKSB7XG4gICAgICAgICAgICBpZiAoaXNSZXN0cmljdGVkV29yZChuYW1lKSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZmlyc3RSZXN0cmljdGVkID0gcGFyYW07XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5tZXNzYWdlID0gTWVzc2FnZXMuU3RyaWN0UGFyYW1OYW1lO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmZpcnN0UmVzdHJpY3RlZCA9IHBhcmFtO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMubWVzc2FnZSA9IE1lc3NhZ2VzLlN0cmljdFJlc2VydmVkV29yZDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMucGFyYW1TZXQsIGtleSkpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnN0cmljdGVkID0gcGFyYW07XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5tZXNzYWdlID0gTWVzc2FnZXMuU3RyaWN0UGFyYW1EdXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMucGFyYW1TZXRba2V5XSA9IHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VQYXJhbShvcHRpb25zKSB7XG4gICAgICAgIHZhciB0b2tlbiwgcGFyYW0sIHBhcmFtcyA9IFtdLCBpLCBkZWY7XG5cbiAgICAgICAgdG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICAgIGlmICh0b2tlbi52YWx1ZSA9PT0gJy4uLicpIHtcbiAgICAgICAgICAgIHBhcmFtID0gcGFyc2VSZXN0RWxlbWVudChwYXJhbXMpO1xuICAgICAgICAgICAgdmFsaWRhdGVQYXJhbShvcHRpb25zLCBwYXJhbS5hcmd1bWVudCwgcGFyYW0uYXJndW1lbnQubmFtZSk7XG4gICAgICAgICAgICBvcHRpb25zLnBhcmFtcy5wdXNoKHBhcmFtKTtcbiAgICAgICAgICAgIG9wdGlvbnMuZGVmYXVsdHMucHVzaChudWxsKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmFtID0gcGFyc2VQYXR0ZXJuV2l0aERlZmF1bHQocGFyYW1zKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFsaWRhdGVQYXJhbShvcHRpb25zLCBwYXJhbXNbaV0sIHBhcmFtc1tpXS52YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gU3ludGF4LkFzc2lnbm1lbnRQYXR0ZXJuKSB7XG4gICAgICAgICAgICBkZWYgPSBwYXJhbS5yaWdodDtcbiAgICAgICAgICAgIHBhcmFtID0gcGFyYW0ubGVmdDtcbiAgICAgICAgICAgICsrb3B0aW9ucy5kZWZhdWx0Q291bnQ7XG4gICAgICAgIH1cblxuICAgICAgICBvcHRpb25zLnBhcmFtcy5wdXNoKHBhcmFtKTtcbiAgICAgICAgb3B0aW9ucy5kZWZhdWx0cy5wdXNoKGRlZik7XG5cbiAgICAgICAgcmV0dXJuICFtYXRjaCgnKScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlUGFyYW1zKGZpcnN0UmVzdHJpY3RlZCkge1xuICAgICAgICB2YXIgb3B0aW9ucztcblxuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgcGFyYW1zOiBbXSxcbiAgICAgICAgICAgIGRlZmF1bHRDb3VudDogMCxcbiAgICAgICAgICAgIGRlZmF1bHRzOiBbXSxcbiAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZDogZmlyc3RSZXN0cmljdGVkXG4gICAgICAgIH07XG5cbiAgICAgICAgZXhwZWN0KCcoJyk7XG5cbiAgICAgICAgaWYgKCFtYXRjaCgnKScpKSB7XG4gICAgICAgICAgICBvcHRpb25zLnBhcmFtU2V0ID0ge307XG4gICAgICAgICAgICB3aGlsZSAoc3RhcnRJbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmICghcGFyc2VQYXJhbShvcHRpb25zKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXhwZWN0KCcsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3QoJyknKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0Q291bnQgPT09IDApIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZGVmYXVsdHMgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYXJhbXM6IG9wdGlvbnMucGFyYW1zLFxuICAgICAgICAgICAgZGVmYXVsdHM6IG9wdGlvbnMuZGVmYXVsdHMsXG4gICAgICAgICAgICBzdHJpY3RlZDogb3B0aW9ucy5zdHJpY3RlZCxcbiAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZDogb3B0aW9ucy5maXJzdFJlc3RyaWN0ZWQsXG4gICAgICAgICAgICBtZXNzYWdlOiBvcHRpb25zLm1lc3NhZ2VcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24obm9kZSwgaWRlbnRpZmllcklzT3B0aW9uYWwpIHtcbiAgICAgICAgdmFyIGlkID0gbnVsbCwgcGFyYW1zID0gW10sIGRlZmF1bHRzID0gW10sIGJvZHksIHRva2VuLCBzdHJpY3RlZCwgdG1wLCBmaXJzdFJlc3RyaWN0ZWQsIG1lc3NhZ2UsIHByZXZpb3VzU3RyaWN0LFxuICAgICAgICAgICAgaXNHZW5lcmF0b3IsIHByZXZpb3VzQWxsb3dZaWVsZDtcblxuICAgICAgICBwcmV2aW91c0FsbG93WWllbGQgPSBzdGF0ZS5hbGxvd1lpZWxkO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ2Z1bmN0aW9uJyk7XG5cbiAgICAgICAgaXNHZW5lcmF0b3IgPSBtYXRjaCgnKicpO1xuICAgICAgICBpZiAoaXNHZW5lcmF0b3IpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpZGVudGlmaWVySXNPcHRpb25hbCB8fCAhbWF0Y2goJygnKSkge1xuICAgICAgICAgICAgdG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICAgICAgICBpZCA9IHBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XG4gICAgICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzUmVzdHJpY3RlZFdvcmQodG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBNZXNzYWdlcy5TdHJpY3RGdW5jdGlvbk5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzUmVzdHJpY3RlZFdvcmQodG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gTWVzc2FnZXMuU3RyaWN0RnVuY3Rpb25OYW1lO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IE1lc3NhZ2VzLlN0cmljdFJlc2VydmVkV29yZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5hbGxvd1lpZWxkID0gIWlzR2VuZXJhdG9yO1xuICAgICAgICB0bXAgPSBwYXJzZVBhcmFtcyhmaXJzdFJlc3RyaWN0ZWQpO1xuICAgICAgICBwYXJhbXMgPSB0bXAucGFyYW1zO1xuICAgICAgICBkZWZhdWx0cyA9IHRtcC5kZWZhdWx0cztcbiAgICAgICAgc3RyaWN0ZWQgPSB0bXAuc3RyaWN0ZWQ7XG4gICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRtcC5maXJzdFJlc3RyaWN0ZWQ7XG4gICAgICAgIGlmICh0bXAubWVzc2FnZSkge1xuICAgICAgICAgICAgbWVzc2FnZSA9IHRtcC5tZXNzYWdlO1xuICAgICAgICB9XG5cblxuICAgICAgICBwcmV2aW91c1N0cmljdCA9IHN0cmljdDtcbiAgICAgICAgYm9keSA9IHBhcnNlRnVuY3Rpb25Tb3VyY2VFbGVtZW50cygpO1xuICAgICAgICBpZiAoc3RyaWN0ICYmIGZpcnN0UmVzdHJpY3RlZCkge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4oZmlyc3RSZXN0cmljdGVkLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyaWN0ICYmIHN0cmljdGVkKSB7XG4gICAgICAgICAgICB0b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbihzdHJpY3RlZCwgbWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzdHJpY3QgPSBwcmV2aW91c1N0cmljdDtcbiAgICAgICAgc3RhdGUuYWxsb3dZaWVsZCA9IHByZXZpb3VzQWxsb3dZaWVsZDtcblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hGdW5jdGlvbkRlY2xhcmF0aW9uKGlkLCBwYXJhbXMsIGRlZmF1bHRzLCBib2R5LCBpc0dlbmVyYXRvcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VGdW5jdGlvbkV4cHJlc3Npb24oKSB7XG4gICAgICAgIHZhciB0b2tlbiwgaWQgPSBudWxsLCBzdHJpY3RlZCwgZmlyc3RSZXN0cmljdGVkLCBtZXNzYWdlLCB0bXAsXG4gICAgICAgICAgICBwYXJhbXMgPSBbXSwgZGVmYXVsdHMgPSBbXSwgYm9keSwgcHJldmlvdXNTdHJpY3QsIG5vZGUgPSBuZXcgTm9kZSgpLFxuICAgICAgICAgICAgaXNHZW5lcmF0b3IsIHByZXZpb3VzQWxsb3dZaWVsZDtcblxuICAgICAgICBwcmV2aW91c0FsbG93WWllbGQgPSBzdGF0ZS5hbGxvd1lpZWxkO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ2Z1bmN0aW9uJyk7XG5cbiAgICAgICAgaXNHZW5lcmF0b3IgPSBtYXRjaCgnKicpO1xuICAgICAgICBpZiAoaXNHZW5lcmF0b3IpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuYWxsb3dZaWVsZCA9ICFpc0dlbmVyYXRvcjtcbiAgICAgICAgaWYgKCFtYXRjaCgnKCcpKSB7XG4gICAgICAgICAgICB0b2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgICAgIGlkID0gKCFzdHJpY3QgJiYgIWlzR2VuZXJhdG9yICYmIG1hdGNoS2V5d29yZCgneWllbGQnKSkgPyBwYXJzZU5vbkNvbXB1dGVkUHJvcGVydHkoKSA6IHBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XG4gICAgICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzUmVzdHJpY3RlZFdvcmQodG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBNZXNzYWdlcy5TdHJpY3RGdW5jdGlvbk5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzUmVzdHJpY3RlZFdvcmQodG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gTWVzc2FnZXMuU3RyaWN0RnVuY3Rpb25OYW1lO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IE1lc3NhZ2VzLlN0cmljdFJlc2VydmVkV29yZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0bXAgPSBwYXJzZVBhcmFtcyhmaXJzdFJlc3RyaWN0ZWQpO1xuICAgICAgICBwYXJhbXMgPSB0bXAucGFyYW1zO1xuICAgICAgICBkZWZhdWx0cyA9IHRtcC5kZWZhdWx0cztcbiAgICAgICAgc3RyaWN0ZWQgPSB0bXAuc3RyaWN0ZWQ7XG4gICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRtcC5maXJzdFJlc3RyaWN0ZWQ7XG4gICAgICAgIGlmICh0bXAubWVzc2FnZSkge1xuICAgICAgICAgICAgbWVzc2FnZSA9IHRtcC5tZXNzYWdlO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldmlvdXNTdHJpY3QgPSBzdHJpY3Q7XG4gICAgICAgIGJvZHkgPSBwYXJzZUZ1bmN0aW9uU291cmNlRWxlbWVudHMoKTtcbiAgICAgICAgaWYgKHN0cmljdCAmJiBmaXJzdFJlc3RyaWN0ZWQpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKGZpcnN0UmVzdHJpY3RlZCwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmljdCAmJiBzdHJpY3RlZCkge1xuICAgICAgICAgICAgdG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4oc3RyaWN0ZWQsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHN0cmljdCA9IHByZXZpb3VzU3RyaWN0O1xuICAgICAgICBzdGF0ZS5hbGxvd1lpZWxkID0gcHJldmlvdXNBbGxvd1lpZWxkO1xuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaEZ1bmN0aW9uRXhwcmVzc2lvbihpZCwgcGFyYW1zLCBkZWZhdWx0cywgYm9keSwgaXNHZW5lcmF0b3IpO1xuICAgIH1cblxuICAgIC8vIEVDTUEtMjYyIDE0LjUgQ2xhc3MgRGVmaW5pdGlvbnNcblxuICAgIGZ1bmN0aW9uIHBhcnNlQ2xhc3NCb2R5KCkge1xuICAgICAgICB2YXIgY2xhc3NCb2R5LCB0b2tlbiwgaXNTdGF0aWMsIGhhc0NvbnN0cnVjdG9yID0gZmFsc2UsIGJvZHksIG1ldGhvZCwgY29tcHV0ZWQsIGtleTtcblxuICAgICAgICBjbGFzc0JvZHkgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIGV4cGVjdCgneycpO1xuICAgICAgICBib2R5ID0gW107XG4gICAgICAgIHdoaWxlICghbWF0Y2goJ30nKSkge1xuICAgICAgICAgICAgaWYgKG1hdGNoKCc7JykpIHtcbiAgICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gbmV3IE5vZGUoKTtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgICAgICAgICBpc1N0YXRpYyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbXB1dGVkID0gbWF0Y2goJ1snKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2goJyonKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBwYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkubmFtZSA9PT0gJ3N0YXRpYycgJiYgKGxvb2thaGVhZFByb3BlcnR5TmFtZSgpIHx8IG1hdGNoKCcqJykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU3RhdGljID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXB1dGVkID0gbWF0Y2goJ1snKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCgnKicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IHBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtZXRob2QgPSB0cnlQYXJzZU1ldGhvZERlZmluaXRpb24odG9rZW4sIGtleSwgY29tcHV0ZWQsIG1ldGhvZCk7XG4gICAgICAgICAgICAgICAgaWYgKG1ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2RbJ3N0YXRpYyddID0gaXNTdGF0aWM7IC8vIGpzY3M6aWdub3JlIHJlcXVpcmVEb3ROb3RhdGlvblxuICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kLmtpbmQgPT09ICdpbml0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kLmtpbmQgPSAnbWV0aG9kJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzU3RhdGljKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1ldGhvZC5jb21wdXRlZCAmJiAobWV0aG9kLmtleS5uYW1lIHx8IG1ldGhvZC5rZXkudmFsdWUudG9TdHJpbmcoKSkgPT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kLmtpbmQgIT09ICdtZXRob2QnIHx8ICFtZXRob2QubWV0aG9kIHx8IG1ldGhvZC52YWx1ZS5nZW5lcmF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4sIE1lc3NhZ2VzLkNvbnN0cnVjdG9yU3BlY2lhbE1ldGhvZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbiwgTWVzc2FnZXMuRHVwbGljYXRlQ29uc3RydWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc0NvbnN0cnVjdG9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kLmtpbmQgPSAnY29uc3RydWN0b3InO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtZXRob2QuY29tcHV0ZWQgJiYgKG1ldGhvZC5rZXkubmFtZSB8fCBtZXRob2Qua2V5LnZhbHVlLnRvU3RyaW5nKCkpID09PSAncHJvdG90eXBlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKHRva2VuLCBNZXNzYWdlcy5TdGF0aWNQcm90b3R5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZC50eXBlID0gU3ludGF4Lk1ldGhvZERlZmluaXRpb247XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBtZXRob2QubWV0aG9kO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbWV0aG9kLnNob3J0aGFuZDtcbiAgICAgICAgICAgICAgICAgICAgYm9keS5wdXNoKG1ldGhvZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4obG9va2FoZWFkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV4KCk7XG4gICAgICAgIHJldHVybiBjbGFzc0JvZHkuZmluaXNoQ2xhc3NCb2R5KGJvZHkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlQ2xhc3NEZWNsYXJhdGlvbihpZGVudGlmaWVySXNPcHRpb25hbCkge1xuICAgICAgICB2YXIgaWQgPSBudWxsLCBzdXBlckNsYXNzID0gbnVsbCwgY2xhc3NOb2RlID0gbmV3IE5vZGUoKSwgY2xhc3NCb2R5LCBwcmV2aW91c1N0cmljdCA9IHN0cmljdDtcbiAgICAgICAgc3RyaWN0ID0gdHJ1ZTtcblxuICAgICAgICBleHBlY3RLZXl3b3JkKCdjbGFzcycpO1xuXG4gICAgICAgIGlmICghaWRlbnRpZmllcklzT3B0aW9uYWwgfHwgbG9va2FoZWFkLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIGlkID0gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2V4dGVuZHMnKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICBzdXBlckNsYXNzID0gaXNvbGF0ZUNvdmVyR3JhbW1hcihwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGwpO1xuICAgICAgICB9XG4gICAgICAgIGNsYXNzQm9keSA9IHBhcnNlQ2xhc3NCb2R5KCk7XG4gICAgICAgIHN0cmljdCA9IHByZXZpb3VzU3RyaWN0O1xuXG4gICAgICAgIHJldHVybiBjbGFzc05vZGUuZmluaXNoQ2xhc3NEZWNsYXJhdGlvbihpZCwgc3VwZXJDbGFzcywgY2xhc3NCb2R5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUNsYXNzRXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGlkID0gbnVsbCwgc3VwZXJDbGFzcyA9IG51bGwsIGNsYXNzTm9kZSA9IG5ldyBOb2RlKCksIGNsYXNzQm9keSwgcHJldmlvdXNTdHJpY3QgPSBzdHJpY3Q7XG4gICAgICAgIHN0cmljdCA9IHRydWU7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnY2xhc3MnKTtcblxuICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIGlkID0gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2V4dGVuZHMnKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICBzdXBlckNsYXNzID0gaXNvbGF0ZUNvdmVyR3JhbW1hcihwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGwpO1xuICAgICAgICB9XG4gICAgICAgIGNsYXNzQm9keSA9IHBhcnNlQ2xhc3NCb2R5KCk7XG4gICAgICAgIHN0cmljdCA9IHByZXZpb3VzU3RyaWN0O1xuXG4gICAgICAgIHJldHVybiBjbGFzc05vZGUuZmluaXNoQ2xhc3NFeHByZXNzaW9uKGlkLCBzdXBlckNsYXNzLCBjbGFzc0JvZHkpO1xuICAgIH1cblxuICAgIC8vIEVDTUEtMjYyIDE1LjIgTW9kdWxlc1xuXG4gICAgZnVuY3Rpb24gcGFyc2VNb2R1bGVTcGVjaWZpZXIoKSB7XG4gICAgICAgIHZhciBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgIT09IFRva2VuLlN0cmluZ0xpdGVyYWwpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoTWVzc2FnZXMuSW52YWxpZE1vZHVsZVNwZWNpZmllcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoTGl0ZXJhbChsZXgoKSk7XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTUuMi4zIEV4cG9ydHNcblxuICAgIGZ1bmN0aW9uIHBhcnNlRXhwb3J0U3BlY2lmaWVyKCkge1xuICAgICAgICB2YXIgZXhwb3J0ZWQsIGxvY2FsLCBub2RlID0gbmV3IE5vZGUoKSwgZGVmO1xuICAgICAgICBpZiAobWF0Y2hLZXl3b3JkKCdkZWZhdWx0JykpIHtcbiAgICAgICAgICAgIC8vIGV4cG9ydCB7ZGVmYXVsdH0gZnJvbSAnc29tZXRoaW5nJztcbiAgICAgICAgICAgIGRlZiA9IG5ldyBOb2RlKCk7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIGxvY2FsID0gZGVmLmZpbmlzaElkZW50aWZpZXIoJ2RlZmF1bHQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvY2FsID0gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnYXMnKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICBleHBvcnRlZCA9IHBhcnNlTm9uQ29tcHV0ZWRQcm9wZXJ0eSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaEV4cG9ydFNwZWNpZmllcihsb2NhbCwgZXhwb3J0ZWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlRXhwb3J0TmFtZWREZWNsYXJhdGlvbihub2RlKSB7XG4gICAgICAgIHZhciBkZWNsYXJhdGlvbiA9IG51bGwsXG4gICAgICAgICAgICBpc0V4cG9ydEZyb21JZGVudGlmaWVyLFxuICAgICAgICAgICAgc3JjID0gbnVsbCwgc3BlY2lmaWVycyA9IFtdO1xuXG4gICAgICAgIC8vIG5vbi1kZWZhdWx0IGV4cG9ydFxuICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgPT09IFRva2VuLktleXdvcmQpIHtcbiAgICAgICAgICAgIC8vIGNvdmVyczpcbiAgICAgICAgICAgIC8vIGV4cG9ydCB2YXIgZiA9IDE7XG4gICAgICAgICAgICBzd2l0Y2ggKGxvb2thaGVhZC52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2xldCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnY29uc3QnOlxuICAgICAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbiA9IHBhcnNlTGV4aWNhbERlY2xhcmF0aW9uKHtpbkZvcjogZmFsc2V9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoRXhwb3J0TmFtZWREZWNsYXJhdGlvbihkZWNsYXJhdGlvbiwgc3BlY2lmaWVycywgbnVsbCk7XG4gICAgICAgICAgICAgICAgY2FzZSAndmFyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbiA9IHBhcnNlU3RhdGVtZW50TGlzdEl0ZW0oKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoRXhwb3J0TmFtZWREZWNsYXJhdGlvbihkZWNsYXJhdGlvbiwgc3BlY2lmaWVycywgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3QoJ3snKTtcbiAgICAgICAgd2hpbGUgKCFtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICBpc0V4cG9ydEZyb21JZGVudGlmaWVyID0gaXNFeHBvcnRGcm9tSWRlbnRpZmllciB8fCBtYXRjaEtleXdvcmQoJ2RlZmF1bHQnKTtcbiAgICAgICAgICAgIHNwZWNpZmllcnMucHVzaChwYXJzZUV4cG9ydFNwZWNpZmllcigpKTtcbiAgICAgICAgICAgIGlmICghbWF0Y2goJ30nKSkge1xuICAgICAgICAgICAgICAgIGV4cGVjdCgnLCcpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBleHBlY3QoJ30nKTtcblxuICAgICAgICBpZiAobWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnZnJvbScpKSB7XG4gICAgICAgICAgICAvLyBjb3ZlcmluZzpcbiAgICAgICAgICAgIC8vIGV4cG9ydCB7ZGVmYXVsdH0gZnJvbSAnZm9vJztcbiAgICAgICAgICAgIC8vIGV4cG9ydCB7Zm9vfSBmcm9tICdmb28nO1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICBzcmMgPSBwYXJzZU1vZHVsZVNwZWNpZmllcigpO1xuICAgICAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRXhwb3J0RnJvbUlkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIC8vIGNvdmVyaW5nOlxuICAgICAgICAgICAgLy8gZXhwb3J0IHtkZWZhdWx0fTsgLy8gbWlzc2luZyBmcm9tQ2xhdXNlXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGxvb2thaGVhZC52YWx1ZSA/XG4gICAgICAgICAgICAgICAgICAgIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiA6IE1lc3NhZ2VzLk1pc3NpbmdGcm9tQ2xhdXNlLCBsb29rYWhlYWQudmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY292ZXJcbiAgICAgICAgICAgIC8vIGV4cG9ydCB7Zm9vfTtcbiAgICAgICAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hFeHBvcnROYW1lZERlY2xhcmF0aW9uKGRlY2xhcmF0aW9uLCBzcGVjaWZpZXJzLCBzcmMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uKG5vZGUpIHtcbiAgICAgICAgdmFyIGRlY2xhcmF0aW9uID0gbnVsbCxcbiAgICAgICAgICAgIGV4cHJlc3Npb24gPSBudWxsO1xuXG4gICAgICAgIC8vIGNvdmVyczpcbiAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQgLi4uXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ2RlZmF1bHQnKTtcblxuICAgICAgICBpZiAobWF0Y2hLZXl3b3JkKCdmdW5jdGlvbicpKSB7XG4gICAgICAgICAgICAvLyBjb3ZlcnM6XG4gICAgICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmb28gKCkge31cbiAgICAgICAgICAgIC8vIGV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpIHt9XG4gICAgICAgICAgICBkZWNsYXJhdGlvbiA9IHBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbihuZXcgTm9kZSgpLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbihkZWNsYXJhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoS2V5d29yZCgnY2xhc3MnKSkge1xuICAgICAgICAgICAgZGVjbGFyYXRpb24gPSBwYXJzZUNsYXNzRGVjbGFyYXRpb24odHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24oZGVjbGFyYXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2Zyb20nKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sIGxvb2thaGVhZC52YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb3ZlcnM6XG4gICAgICAgIC8vIGV4cG9ydCBkZWZhdWx0IHt9O1xuICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCBbXTtcbiAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQgKDEgKyAyKTtcbiAgICAgICAgaWYgKG1hdGNoKCd7JykpIHtcbiAgICAgICAgICAgIGV4cHJlc3Npb24gPSBwYXJzZU9iamVjdEluaXRpYWxpemVyKCk7XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2goJ1snKSkge1xuICAgICAgICAgICAgZXhwcmVzc2lvbiA9IHBhcnNlQXJyYXlJbml0aWFsaXplcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhwcmVzc2lvbiA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbihleHByZXNzaW9uKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUV4cG9ydEFsbERlY2xhcmF0aW9uKG5vZGUpIHtcbiAgICAgICAgdmFyIHNyYztcblxuICAgICAgICAvLyBjb3ZlcnM6XG4gICAgICAgIC8vIGV4cG9ydCAqIGZyb20gJ2Zvbyc7XG4gICAgICAgIGV4cGVjdCgnKicpO1xuICAgICAgICBpZiAoIW1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2Zyb20nKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihsb29rYWhlYWQudmFsdWUgP1xuICAgICAgICAgICAgICAgICAgICBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4gOiBNZXNzYWdlcy5NaXNzaW5nRnJvbUNsYXVzZSwgbG9va2FoZWFkLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXgoKTtcbiAgICAgICAgc3JjID0gcGFyc2VNb2R1bGVTcGVjaWZpZXIoKTtcbiAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaEV4cG9ydEFsbERlY2xhcmF0aW9uKHNyYyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VFeHBvcnREZWNsYXJhdGlvbigpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBuZXcgTm9kZSgpO1xuICAgICAgICBpZiAoc3RhdGUuaW5GdW5jdGlvbkJvZHkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoTWVzc2FnZXMuSWxsZWdhbEV4cG9ydERlY2xhcmF0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ2V4cG9ydCcpO1xuXG4gICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2RlZmF1bHQnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaCgnKicpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VFeHBvcnRBbGxEZWNsYXJhdGlvbihub2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VFeHBvcnROYW1lZERlY2xhcmF0aW9uKG5vZGUpO1xuICAgIH1cblxuICAgIC8vIEVDTUEtMjYyIDE1LjIuMiBJbXBvcnRzXG5cbiAgICBmdW5jdGlvbiBwYXJzZUltcG9ydFNwZWNpZmllcigpIHtcbiAgICAgICAgLy8gaW1wb3J0IHs8Zm9vIGFzIGJhcj59IC4uLjtcbiAgICAgICAgdmFyIGxvY2FsLCBpbXBvcnRlZCwgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgICAgaW1wb3J0ZWQgPSBwYXJzZU5vbkNvbXB1dGVkUHJvcGVydHkoKTtcbiAgICAgICAgaWYgKG1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2FzJykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgbG9jYWwgPSBwYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoSW1wb3J0U3BlY2lmaWVyKGxvY2FsLCBpbXBvcnRlZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VOYW1lZEltcG9ydHMoKSB7XG4gICAgICAgIHZhciBzcGVjaWZpZXJzID0gW107XG4gICAgICAgIC8vIHtmb28sIGJhciBhcyBiYXN9XG4gICAgICAgIGV4cGVjdCgneycpO1xuICAgICAgICB3aGlsZSAoIW1hdGNoKCd9JykpIHtcbiAgICAgICAgICAgIHNwZWNpZmllcnMucHVzaChwYXJzZUltcG9ydFNwZWNpZmllcigpKTtcbiAgICAgICAgICAgIGlmICghbWF0Y2goJ30nKSkge1xuICAgICAgICAgICAgICAgIGV4cGVjdCgnLCcpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBleHBlY3QoJ30nKTtcbiAgICAgICAgcmV0dXJuIHNwZWNpZmllcnM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VJbXBvcnREZWZhdWx0U3BlY2lmaWVyKCkge1xuICAgICAgICAvLyBpbXBvcnQgPGZvbz4gLi4uO1xuICAgICAgICB2YXIgbG9jYWwsIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIGxvY2FsID0gcGFyc2VOb25Db21wdXRlZFByb3BlcnR5KCk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoSW1wb3J0RGVmYXVsdFNwZWNpZmllcihsb2NhbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIoKSB7XG4gICAgICAgIC8vIGltcG9ydCA8KiBhcyBmb28+IC4uLjtcbiAgICAgICAgdmFyIGxvY2FsLCBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgICBleHBlY3QoJyonKTtcbiAgICAgICAgaWYgKCFtYXRjaENvbnRleHR1YWxLZXl3b3JkKCdhcycpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKE1lc3NhZ2VzLk5vQXNBZnRlckltcG9ydE5hbWVzcGFjZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV4KCk7XG4gICAgICAgIGxvY2FsID0gcGFyc2VOb25Db21wdXRlZFByb3BlcnR5KCk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyKGxvY2FsKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUltcG9ydERlY2xhcmF0aW9uKCkge1xuICAgICAgICB2YXIgc3BlY2lmaWVycyA9IFtdLCBzcmMsIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIGlmIChzdGF0ZS5pbkZ1bmN0aW9uQm9keSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihNZXNzYWdlcy5JbGxlZ2FsSW1wb3J0RGVjbGFyYXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnaW1wb3J0Jyk7XG5cbiAgICAgICAgaWYgKGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5TdHJpbmdMaXRlcmFsKSB7XG4gICAgICAgICAgICAvLyBpbXBvcnQgJ2Zvbyc7XG4gICAgICAgICAgICBzcmMgPSBwYXJzZU1vZHVsZVNwZWNpZmllcigpO1xuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBpZiAobWF0Y2goJ3snKSkge1xuICAgICAgICAgICAgICAgIC8vIGltcG9ydCB7YmFyfVxuICAgICAgICAgICAgICAgIHNwZWNpZmllcnMgPSBzcGVjaWZpZXJzLmNvbmNhdChwYXJzZU5hbWVkSW1wb3J0cygpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2goJyonKSkge1xuICAgICAgICAgICAgICAgIC8vIGltcG9ydCAqIGFzIGZvb1xuICAgICAgICAgICAgICAgIHNwZWNpZmllcnMucHVzaChwYXJzZUltcG9ydE5hbWVzcGFjZVNwZWNpZmllcigpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNJZGVudGlmaWVyTmFtZShsb29rYWhlYWQpICYmICFtYXRjaEtleXdvcmQoJ2RlZmF1bHQnKSkge1xuICAgICAgICAgICAgICAgIC8vIGltcG9ydCBmb29cbiAgICAgICAgICAgICAgICBzcGVjaWZpZXJzLnB1c2gocGFyc2VJbXBvcnREZWZhdWx0U3BlY2lmaWVyKCkpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCgnLCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2goJyonKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW1wb3J0IGZvbywgKiBhcyBmb29cbiAgICAgICAgICAgICAgICAgICAgICAgIHNwZWNpZmllcnMucHVzaChwYXJzZUltcG9ydE5hbWVzcGFjZVNwZWNpZmllcigpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaCgneycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbXBvcnQgZm9vLCB7YmFyfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3BlY2lmaWVycyA9IHNwZWNpZmllcnMuY29uY2F0KHBhcnNlTmFtZWRJbXBvcnRzKCkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4obG9va2FoZWFkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4obGV4KCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2Zyb20nKSkge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3IobG9va2FoZWFkLnZhbHVlID9cbiAgICAgICAgICAgICAgICAgICAgICAgIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiA6IE1lc3NhZ2VzLk1pc3NpbmdGcm9tQ2xhdXNlLCBsb29rYWhlYWQudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICBzcmMgPSBwYXJzZU1vZHVsZVNwZWNpZmllcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hJbXBvcnREZWNsYXJhdGlvbihzcGVjaWZpZXJzLCBzcmMpO1xuICAgIH1cblxuICAgIC8vIEVDTUEtMjYyIDE1LjEgU2NyaXB0c1xuXG4gICAgZnVuY3Rpb24gcGFyc2VTY3JpcHRCb2R5KCkge1xuICAgICAgICB2YXIgc3RhdGVtZW50LCBib2R5ID0gW10sIHRva2VuLCBkaXJlY3RpdmUsIGZpcnN0UmVzdHJpY3RlZDtcblxuICAgICAgICB3aGlsZSAoc3RhcnRJbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgdG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gVG9rZW4uU3RyaW5nTGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdGF0ZW1lbnQgPSBwYXJzZVN0YXRlbWVudExpc3RJdGVtKCk7XG4gICAgICAgICAgICBib2R5LnB1c2goc3RhdGVtZW50KTtcbiAgICAgICAgICAgIGlmIChzdGF0ZW1lbnQuZXhwcmVzc2lvbi50eXBlICE9PSBTeW50YXguTGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgbm90IGRpcmVjdGl2ZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlyZWN0aXZlID0gc291cmNlLnNsaWNlKHRva2VuLnN0YXJ0ICsgMSwgdG9rZW4uZW5kIC0gMSk7XG4gICAgICAgICAgICBpZiAoZGlyZWN0aXZlID09PSAndXNlIHN0cmljdCcpIHtcbiAgICAgICAgICAgICAgICBzdHJpY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdFJlc3RyaWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4oZmlyc3RSZXN0cmljdGVkLCBNZXNzYWdlcy5TdHJpY3RPY3RhbExpdGVyYWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmaXJzdFJlc3RyaWN0ZWQgJiYgdG9rZW4ub2N0YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gdG9rZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKHN0YXJ0SW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHN0YXRlbWVudCA9IHBhcnNlU3RhdGVtZW50TGlzdEl0ZW0oKTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBib2R5LnB1c2goc3RhdGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYm9keTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVByb2dyYW0oKSB7XG4gICAgICAgIHZhciBib2R5LCBub2RlO1xuXG4gICAgICAgIHBlZWsoKTtcbiAgICAgICAgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgICAgYm9keSA9IHBhcnNlU2NyaXB0Qm9keSgpO1xuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hQcm9ncmFtKGJvZHksIHN0YXRlLnNvdXJjZVR5cGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbHRlclRva2VuTG9jYXRpb24oKSB7XG4gICAgICAgIHZhciBpLCBlbnRyeSwgdG9rZW4sIHRva2VucyA9IFtdO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBleHRyYS50b2tlbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGVudHJ5ID0gZXh0cmEudG9rZW5zW2ldO1xuICAgICAgICAgICAgdG9rZW4gPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogZW50cnkudHlwZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZW50cnkudmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZW50cnkucmVnZXgpIHtcbiAgICAgICAgICAgICAgICB0b2tlbi5yZWdleCA9IHtcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybjogZW50cnkucmVnZXgucGF0dGVybixcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3M6IGVudHJ5LnJlZ2V4LmZsYWdzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHRyYS5yYW5nZSkge1xuICAgICAgICAgICAgICAgIHRva2VuLnJhbmdlID0gZW50cnkucmFuZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXh0cmEubG9jKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4ubG9jID0gZW50cnkubG9jO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgZXh0cmEudG9rZW5zID0gdG9rZW5zO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRva2VuaXplKGNvZGUsIG9wdGlvbnMsIGRlbGVnYXRlKSB7XG4gICAgICAgIHZhciB0b1N0cmluZyxcbiAgICAgICAgICAgIHRva2VucztcblxuICAgICAgICB0b1N0cmluZyA9IFN0cmluZztcbiAgICAgICAgaWYgKHR5cGVvZiBjb2RlICE9PSAnc3RyaW5nJyAmJiAhKGNvZGUgaW5zdGFuY2VvZiBTdHJpbmcpKSB7XG4gICAgICAgICAgICBjb2RlID0gdG9TdHJpbmcoY29kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzb3VyY2UgPSBjb2RlO1xuICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIGxpbmVOdW1iZXIgPSAoc291cmNlLmxlbmd0aCA+IDApID8gMSA6IDA7XG4gICAgICAgIGxpbmVTdGFydCA9IDA7XG4gICAgICAgIHN0YXJ0SW5kZXggPSBpbmRleDtcbiAgICAgICAgc3RhcnRMaW5lTnVtYmVyID0gbGluZU51bWJlcjtcbiAgICAgICAgc3RhcnRMaW5lU3RhcnQgPSBsaW5lU3RhcnQ7XG4gICAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG4gICAgICAgIGxvb2thaGVhZCA9IG51bGw7XG4gICAgICAgIHN0YXRlID0ge1xuICAgICAgICAgICAgYWxsb3dJbjogdHJ1ZSxcbiAgICAgICAgICAgIGFsbG93WWllbGQ6IHRydWUsXG4gICAgICAgICAgICBsYWJlbFNldDoge30sXG4gICAgICAgICAgICBpbkZ1bmN0aW9uQm9keTogZmFsc2UsXG4gICAgICAgICAgICBpbkl0ZXJhdGlvbjogZmFsc2UsXG4gICAgICAgICAgICBpblN3aXRjaDogZmFsc2UsXG4gICAgICAgICAgICBsYXN0Q29tbWVudFN0YXJ0OiAtMSxcbiAgICAgICAgICAgIGN1cmx5U3RhY2s6IFtdXG4gICAgICAgIH07XG5cbiAgICAgICAgZXh0cmEgPSB7fTtcblxuICAgICAgICAvLyBPcHRpb25zIG1hdGNoaW5nLlxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICAvLyBPZiBjb3Vyc2Ugd2UgY29sbGVjdCB0b2tlbnMgaGVyZS5cbiAgICAgICAgb3B0aW9ucy50b2tlbnMgPSB0cnVlO1xuICAgICAgICBleHRyYS50b2tlbnMgPSBbXTtcbiAgICAgICAgZXh0cmEudG9rZW5WYWx1ZXMgPSBbXTtcbiAgICAgICAgZXh0cmEudG9rZW5pemUgPSB0cnVlO1xuICAgICAgICBleHRyYS5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuXG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgdHdvIGZpZWxkcyBhcmUgbmVjZXNzYXJ5IHRvIGNvbXB1dGUgdGhlIFJlZ2V4IHRva2Vucy5cbiAgICAgICAgZXh0cmEub3BlblBhcmVuVG9rZW4gPSAtMTtcbiAgICAgICAgZXh0cmEub3BlbkN1cmx5VG9rZW4gPSAtMTtcblxuICAgICAgICBleHRyYS5yYW5nZSA9ICh0eXBlb2Ygb3B0aW9ucy5yYW5nZSA9PT0gJ2Jvb2xlYW4nKSAmJiBvcHRpb25zLnJhbmdlO1xuICAgICAgICBleHRyYS5sb2MgPSAodHlwZW9mIG9wdGlvbnMubG9jID09PSAnYm9vbGVhbicpICYmIG9wdGlvbnMubG9jO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5jb21tZW50ID09PSAnYm9vbGVhbicgJiYgb3B0aW9ucy5jb21tZW50KSB7XG4gICAgICAgICAgICBleHRyYS5jb21tZW50cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50b2xlcmFudCA9PT0gJ2Jvb2xlYW4nICYmIG9wdGlvbnMudG9sZXJhbnQpIHtcbiAgICAgICAgICAgIGV4dHJhLmVycm9ycyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHBlZWsoKTtcbiAgICAgICAgICAgIGlmIChsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uRU9GKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4dHJhLnRva2VucztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICB3aGlsZSAobG9va2FoZWFkLnR5cGUgIT09IFRva2VuLkVPRikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGxleEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHRyYS5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZEVycm9yKGxleEVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gYnJlYWsgb24gdGhlIGZpcnN0IGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0byBhdm9pZCBpbmZpbml0ZSBsb29wcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbGV4RXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRva2VucyA9IGV4dHJhLnRva2VucztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXh0cmEuZXJyb3JzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRva2Vucy5lcnJvcnMgPSBleHRyYS5lcnJvcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBleHRyYSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2UoY29kZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgcHJvZ3JhbSwgdG9TdHJpbmc7XG5cbiAgICAgICAgdG9TdHJpbmcgPSBTdHJpbmc7XG4gICAgICAgIGlmICh0eXBlb2YgY29kZSAhPT0gJ3N0cmluZycgJiYgIShjb2RlIGluc3RhbmNlb2YgU3RyaW5nKSkge1xuICAgICAgICAgICAgY29kZSA9IHRvU3RyaW5nKGNvZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgc291cmNlID0gY29kZTtcbiAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICBsaW5lTnVtYmVyID0gKHNvdXJjZS5sZW5ndGggPiAwKSA/IDEgOiAwO1xuICAgICAgICBsaW5lU3RhcnQgPSAwO1xuICAgICAgICBzdGFydEluZGV4ID0gaW5kZXg7XG4gICAgICAgIHN0YXJ0TGluZU51bWJlciA9IGxpbmVOdW1iZXI7XG4gICAgICAgIHN0YXJ0TGluZVN0YXJ0ID0gbGluZVN0YXJ0O1xuICAgICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuICAgICAgICBsb29rYWhlYWQgPSBudWxsO1xuICAgICAgICBzdGF0ZSA9IHtcbiAgICAgICAgICAgIGFsbG93SW46IHRydWUsXG4gICAgICAgICAgICBhbGxvd1lpZWxkOiB0cnVlLFxuICAgICAgICAgICAgbGFiZWxTZXQ6IHt9LFxuICAgICAgICAgICAgaW5GdW5jdGlvbkJvZHk6IGZhbHNlLFxuICAgICAgICAgICAgaW5JdGVyYXRpb246IGZhbHNlLFxuICAgICAgICAgICAgaW5Td2l0Y2g6IGZhbHNlLFxuICAgICAgICAgICAgbGFzdENvbW1lbnRTdGFydDogLTEsXG4gICAgICAgICAgICBjdXJseVN0YWNrOiBbXSxcbiAgICAgICAgICAgIHNvdXJjZVR5cGU6ICdzY3JpcHQnXG4gICAgICAgIH07XG4gICAgICAgIHN0cmljdCA9IGZhbHNlO1xuXG4gICAgICAgIGV4dHJhID0ge307XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGV4dHJhLnJhbmdlID0gKHR5cGVvZiBvcHRpb25zLnJhbmdlID09PSAnYm9vbGVhbicpICYmIG9wdGlvbnMucmFuZ2U7XG4gICAgICAgICAgICBleHRyYS5sb2MgPSAodHlwZW9mIG9wdGlvbnMubG9jID09PSAnYm9vbGVhbicpICYmIG9wdGlvbnMubG9jO1xuICAgICAgICAgICAgZXh0cmEuYXR0YWNoQ29tbWVudCA9ICh0eXBlb2Ygb3B0aW9ucy5hdHRhY2hDb21tZW50ID09PSAnYm9vbGVhbicpICYmIG9wdGlvbnMuYXR0YWNoQ29tbWVudDtcblxuICAgICAgICAgICAgaWYgKGV4dHJhLmxvYyAmJiBvcHRpb25zLnNvdXJjZSAhPT0gbnVsbCAmJiBvcHRpb25zLnNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZXh0cmEuc291cmNlID0gdG9TdHJpbmcob3B0aW9ucy5zb3VyY2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMudG9rZW5zID09PSAnYm9vbGVhbicgJiYgb3B0aW9ucy50b2tlbnMpIHtcbiAgICAgICAgICAgICAgICBleHRyYS50b2tlbnMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5jb21tZW50ID09PSAnYm9vbGVhbicgJiYgb3B0aW9ucy5jb21tZW50KSB7XG4gICAgICAgICAgICAgICAgZXh0cmEuY29tbWVudHMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50b2xlcmFudCA9PT0gJ2Jvb2xlYW4nICYmIG9wdGlvbnMudG9sZXJhbnQpIHtcbiAgICAgICAgICAgICAgICBleHRyYS5lcnJvcnMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHRyYS5hdHRhY2hDb21tZW50KSB7XG4gICAgICAgICAgICAgICAgZXh0cmEucmFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGV4dHJhLmNvbW1lbnRzID0gW107XG4gICAgICAgICAgICAgICAgZXh0cmEuYm90dG9tUmlnaHRTdGFjayA9IFtdO1xuICAgICAgICAgICAgICAgIGV4dHJhLnRyYWlsaW5nQ29tbWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICBleHRyYS5sZWFkaW5nQ29tbWVudHMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNvdXJjZVR5cGUgPT09ICdtb2R1bGUnKSB7XG4gICAgICAgICAgICAgICAgLy8gdmVyeSByZXN0cmljdGl2ZSBjb25kaXRpb24gZm9yIG5vd1xuICAgICAgICAgICAgICAgIHN0YXRlLnNvdXJjZVR5cGUgPSBvcHRpb25zLnNvdXJjZVR5cGU7XG4gICAgICAgICAgICAgICAgc3RyaWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwcm9ncmFtID0gcGFyc2VQcm9ncmFtKCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4dHJhLmNvbW1lbnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHByb2dyYW0uY29tbWVudHMgPSBleHRyYS5jb21tZW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXh0cmEudG9rZW5zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGZpbHRlclRva2VuTG9jYXRpb24oKTtcbiAgICAgICAgICAgICAgICBwcm9ncmFtLnRva2VucyA9IGV4dHJhLnRva2VucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXh0cmEuZXJyb3JzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHByb2dyYW0uZXJyb3JzID0gZXh0cmEuZXJyb3JzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgZXh0cmEgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcm9ncmFtO1xuICAgIH1cblxuICAgIC8vIFN5bmMgd2l0aCAqLmpzb24gbWFuaWZlc3RzLlxuICAgIGV4cG9ydHMudmVyc2lvbiA9ICcyLjcuMyc7XG5cbiAgICBleHBvcnRzLnRva2VuaXplID0gdG9rZW5pemU7XG5cbiAgICBleHBvcnRzLnBhcnNlID0gcGFyc2U7XG5cbiAgICAvLyBEZWVwIGNvcHkuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBleHBvcnRzLlN5bnRheCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuYW1lLCB0eXBlcyA9IHt9O1xuXG4gICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdHlwZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChuYW1lIGluIFN5bnRheCkge1xuICAgICAgICAgICAgaWYgKFN5bnRheC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgIHR5cGVzW25hbWVdID0gU3ludGF4W25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBPYmplY3QuZnJlZXplID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBPYmplY3QuZnJlZXplKHR5cGVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0eXBlcztcbiAgICB9KCkpO1xuXG59KSk7XG4vKiB2aW06IHNldCBzdz00IHRzPTQgZXQgdHc9ODAgOiAqL1xuIiwiLypcbiAgQ29weXJpZ2h0IChDKSAyMDEyLTIwMTMgWXVzdWtlIFN1enVraSA8dXRhdGFuZS50ZWFAZ21haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgQXJpeWEgSGlkYXlhdCA8YXJpeWEuaGlkYXlhdEBnbWFpbC5jb20+XG5cbiAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiAgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuICBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgPENPUFlSSUdIVCBIT0xERVI+IEJFIExJQUJMRSBGT1IgQU5ZXG4gIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4gIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbiAgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EXG4gIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRlxuICBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuKi9cbi8qanNsaW50IHZhcnM6ZmFsc2UsIGJpdHdpc2U6dHJ1ZSovXG4vKmpzaGludCBpbmRlbnQ6NCovXG4vKmdsb2JhbCBleHBvcnRzOnRydWUqL1xuKGZ1bmN0aW9uIGNsb25lKGV4cG9ydHMpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgU3ludGF4LFxuICAgICAgICBpc0FycmF5LFxuICAgICAgICBWaXNpdG9yT3B0aW9uLFxuICAgICAgICBWaXNpdG9yS2V5cyxcbiAgICAgICAgb2JqZWN0Q3JlYXRlLFxuICAgICAgICBvYmplY3RLZXlzLFxuICAgICAgICBCUkVBSyxcbiAgICAgICAgU0tJUCxcbiAgICAgICAgUkVNT1ZFO1xuXG4gICAgZnVuY3Rpb24gaWdub3JlSlNIaW50RXJyb3IoKSB7IH1cblxuICAgIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuICAgIGlmICghaXNBcnJheSkge1xuICAgICAgICBpc0FycmF5ID0gZnVuY3Rpb24gaXNBcnJheShhcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnJheSkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVlcENvcHkob2JqKSB7XG4gICAgICAgIHZhciByZXQgPSB7fSwga2V5LCB2YWw7XG4gICAgICAgIGZvciAoa2V5IGluIG9iaikge1xuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gb2JqW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXRba2V5XSA9IGRlZXBDb3B5KHZhbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0W2tleV0gPSB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2hhbGxvd0NvcHkob2JqKSB7XG4gICAgICAgIHZhciByZXQgPSB7fSwga2V5O1xuICAgICAgICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIHJldFtrZXldID0gb2JqW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgaWdub3JlSlNIaW50RXJyb3Ioc2hhbGxvd0NvcHkpO1xuXG4gICAgLy8gYmFzZWQgb24gTExWTSBsaWJjKysgdXBwZXJfYm91bmQgLyBsb3dlcl9ib3VuZFxuICAgIC8vIE1JVCBMaWNlbnNlXG5cbiAgICBmdW5jdGlvbiB1cHBlckJvdW5kKGFycmF5LCBmdW5jKSB7XG4gICAgICAgIHZhciBkaWZmLCBsZW4sIGksIGN1cnJlbnQ7XG5cbiAgICAgICAgbGVuID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICBpID0gMDtcblxuICAgICAgICB3aGlsZSAobGVuKSB7XG4gICAgICAgICAgICBkaWZmID0gbGVuID4+PiAxO1xuICAgICAgICAgICAgY3VycmVudCA9IGkgKyBkaWZmO1xuICAgICAgICAgICAgaWYgKGZ1bmMoYXJyYXlbY3VycmVudF0pKSB7XG4gICAgICAgICAgICAgICAgbGVuID0gZGlmZjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaSA9IGN1cnJlbnQgKyAxO1xuICAgICAgICAgICAgICAgIGxlbiAtPSBkaWZmICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb3dlckJvdW5kKGFycmF5LCBmdW5jKSB7XG4gICAgICAgIHZhciBkaWZmLCBsZW4sIGksIGN1cnJlbnQ7XG5cbiAgICAgICAgbGVuID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICBpID0gMDtcblxuICAgICAgICB3aGlsZSAobGVuKSB7XG4gICAgICAgICAgICBkaWZmID0gbGVuID4+PiAxO1xuICAgICAgICAgICAgY3VycmVudCA9IGkgKyBkaWZmO1xuICAgICAgICAgICAgaWYgKGZ1bmMoYXJyYXlbY3VycmVudF0pKSB7XG4gICAgICAgICAgICAgICAgaSA9IGN1cnJlbnQgKyAxO1xuICAgICAgICAgICAgICAgIGxlbiAtPSBkaWZmICsgMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGVuID0gZGlmZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaTtcbiAgICB9XG4gICAgaWdub3JlSlNIaW50RXJyb3IobG93ZXJCb3VuZCk7XG5cbiAgICBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEYoKSB7IH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIEYucHJvdG90eXBlID0gbztcbiAgICAgICAgICAgIHJldHVybiBuZXcgRigpO1xuICAgICAgICB9O1xuICAgIH0pKCk7XG5cbiAgICBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgdmFyIGtleXMgPSBbXSwga2V5O1xuICAgICAgICBmb3IgKGtleSBpbiBvKSB7XG4gICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5cztcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZXh0ZW5kKHRvLCBmcm9tKSB7XG4gICAgICAgIHZhciBrZXlzID0gb2JqZWN0S2V5cyhmcm9tKSwga2V5LCBpLCBsZW47XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGtleXMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICB0b1trZXldID0gZnJvbVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG5cbiAgICBTeW50YXggPSB7XG4gICAgICAgIEFzc2lnbm1lbnRFeHByZXNzaW9uOiAnQXNzaWdubWVudEV4cHJlc3Npb24nLFxuICAgICAgICBBc3NpZ25tZW50UGF0dGVybjogJ0Fzc2lnbm1lbnRQYXR0ZXJuJyxcbiAgICAgICAgQXJyYXlFeHByZXNzaW9uOiAnQXJyYXlFeHByZXNzaW9uJyxcbiAgICAgICAgQXJyYXlQYXR0ZXJuOiAnQXJyYXlQYXR0ZXJuJyxcbiAgICAgICAgQXJyb3dGdW5jdGlvbkV4cHJlc3Npb246ICdBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbicsXG4gICAgICAgIEF3YWl0RXhwcmVzc2lvbjogJ0F3YWl0RXhwcmVzc2lvbicsIC8vIENBVVRJT046IEl0J3MgZGVmZXJyZWQgdG8gRVM3LlxuICAgICAgICBCbG9ja1N0YXRlbWVudDogJ0Jsb2NrU3RhdGVtZW50JyxcbiAgICAgICAgQmluYXJ5RXhwcmVzc2lvbjogJ0JpbmFyeUV4cHJlc3Npb24nLFxuICAgICAgICBCcmVha1N0YXRlbWVudDogJ0JyZWFrU3RhdGVtZW50JyxcbiAgICAgICAgQ2FsbEV4cHJlc3Npb246ICdDYWxsRXhwcmVzc2lvbicsXG4gICAgICAgIENhdGNoQ2xhdXNlOiAnQ2F0Y2hDbGF1c2UnLFxuICAgICAgICBDbGFzc0JvZHk6ICdDbGFzc0JvZHknLFxuICAgICAgICBDbGFzc0RlY2xhcmF0aW9uOiAnQ2xhc3NEZWNsYXJhdGlvbicsXG4gICAgICAgIENsYXNzRXhwcmVzc2lvbjogJ0NsYXNzRXhwcmVzc2lvbicsXG4gICAgICAgIENvbXByZWhlbnNpb25CbG9jazogJ0NvbXByZWhlbnNpb25CbG9jaycsICAvLyBDQVVUSU9OOiBJdCdzIGRlZmVycmVkIHRvIEVTNy5cbiAgICAgICAgQ29tcHJlaGVuc2lvbkV4cHJlc3Npb246ICdDb21wcmVoZW5zaW9uRXhwcmVzc2lvbicsICAvLyBDQVVUSU9OOiBJdCdzIGRlZmVycmVkIHRvIEVTNy5cbiAgICAgICAgQ29uZGl0aW9uYWxFeHByZXNzaW9uOiAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJyxcbiAgICAgICAgQ29udGludWVTdGF0ZW1lbnQ6ICdDb250aW51ZVN0YXRlbWVudCcsXG4gICAgICAgIERlYnVnZ2VyU3RhdGVtZW50OiAnRGVidWdnZXJTdGF0ZW1lbnQnLFxuICAgICAgICBEaXJlY3RpdmVTdGF0ZW1lbnQ6ICdEaXJlY3RpdmVTdGF0ZW1lbnQnLFxuICAgICAgICBEb1doaWxlU3RhdGVtZW50OiAnRG9XaGlsZVN0YXRlbWVudCcsXG4gICAgICAgIEVtcHR5U3RhdGVtZW50OiAnRW1wdHlTdGF0ZW1lbnQnLFxuICAgICAgICBFeHBvcnRBbGxEZWNsYXJhdGlvbjogJ0V4cG9ydEFsbERlY2xhcmF0aW9uJyxcbiAgICAgICAgRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uOiAnRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uJyxcbiAgICAgICAgRXhwb3J0TmFtZWREZWNsYXJhdGlvbjogJ0V4cG9ydE5hbWVkRGVjbGFyYXRpb24nLFxuICAgICAgICBFeHBvcnRTcGVjaWZpZXI6ICdFeHBvcnRTcGVjaWZpZXInLFxuICAgICAgICBFeHByZXNzaW9uU3RhdGVtZW50OiAnRXhwcmVzc2lvblN0YXRlbWVudCcsXG4gICAgICAgIEZvclN0YXRlbWVudDogJ0ZvclN0YXRlbWVudCcsXG4gICAgICAgIEZvckluU3RhdGVtZW50OiAnRm9ySW5TdGF0ZW1lbnQnLFxuICAgICAgICBGb3JPZlN0YXRlbWVudDogJ0Zvck9mU3RhdGVtZW50JyxcbiAgICAgICAgRnVuY3Rpb25EZWNsYXJhdGlvbjogJ0Z1bmN0aW9uRGVjbGFyYXRpb24nLFxuICAgICAgICBGdW5jdGlvbkV4cHJlc3Npb246ICdGdW5jdGlvbkV4cHJlc3Npb24nLFxuICAgICAgICBHZW5lcmF0b3JFeHByZXNzaW9uOiAnR2VuZXJhdG9yRXhwcmVzc2lvbicsICAvLyBDQVVUSU9OOiBJdCdzIGRlZmVycmVkIHRvIEVTNy5cbiAgICAgICAgSWRlbnRpZmllcjogJ0lkZW50aWZpZXInLFxuICAgICAgICBJZlN0YXRlbWVudDogJ0lmU3RhdGVtZW50JyxcbiAgICAgICAgSW1wb3J0RGVjbGFyYXRpb246ICdJbXBvcnREZWNsYXJhdGlvbicsXG4gICAgICAgIEltcG9ydERlZmF1bHRTcGVjaWZpZXI6ICdJbXBvcnREZWZhdWx0U3BlY2lmaWVyJyxcbiAgICAgICAgSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyOiAnSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyJyxcbiAgICAgICAgSW1wb3J0U3BlY2lmaWVyOiAnSW1wb3J0U3BlY2lmaWVyJyxcbiAgICAgICAgTGl0ZXJhbDogJ0xpdGVyYWwnLFxuICAgICAgICBMYWJlbGVkU3RhdGVtZW50OiAnTGFiZWxlZFN0YXRlbWVudCcsXG4gICAgICAgIExvZ2ljYWxFeHByZXNzaW9uOiAnTG9naWNhbEV4cHJlc3Npb24nLFxuICAgICAgICBNZW1iZXJFeHByZXNzaW9uOiAnTWVtYmVyRXhwcmVzc2lvbicsXG4gICAgICAgIE1ldGFQcm9wZXJ0eTogJ01ldGFQcm9wZXJ0eScsXG4gICAgICAgIE1ldGhvZERlZmluaXRpb246ICdNZXRob2REZWZpbml0aW9uJyxcbiAgICAgICAgTW9kdWxlU3BlY2lmaWVyOiAnTW9kdWxlU3BlY2lmaWVyJyxcbiAgICAgICAgTmV3RXhwcmVzc2lvbjogJ05ld0V4cHJlc3Npb24nLFxuICAgICAgICBPYmplY3RFeHByZXNzaW9uOiAnT2JqZWN0RXhwcmVzc2lvbicsXG4gICAgICAgIE9iamVjdFBhdHRlcm46ICdPYmplY3RQYXR0ZXJuJyxcbiAgICAgICAgUHJvZ3JhbTogJ1Byb2dyYW0nLFxuICAgICAgICBQcm9wZXJ0eTogJ1Byb3BlcnR5JyxcbiAgICAgICAgUmVzdEVsZW1lbnQ6ICdSZXN0RWxlbWVudCcsXG4gICAgICAgIFJldHVyblN0YXRlbWVudDogJ1JldHVyblN0YXRlbWVudCcsXG4gICAgICAgIFNlcXVlbmNlRXhwcmVzc2lvbjogJ1NlcXVlbmNlRXhwcmVzc2lvbicsXG4gICAgICAgIFNwcmVhZEVsZW1lbnQ6ICdTcHJlYWRFbGVtZW50JyxcbiAgICAgICAgU3VwZXI6ICdTdXBlcicsXG4gICAgICAgIFN3aXRjaFN0YXRlbWVudDogJ1N3aXRjaFN0YXRlbWVudCcsXG4gICAgICAgIFN3aXRjaENhc2U6ICdTd2l0Y2hDYXNlJyxcbiAgICAgICAgVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uOiAnVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uJyxcbiAgICAgICAgVGVtcGxhdGVFbGVtZW50OiAnVGVtcGxhdGVFbGVtZW50JyxcbiAgICAgICAgVGVtcGxhdGVMaXRlcmFsOiAnVGVtcGxhdGVMaXRlcmFsJyxcbiAgICAgICAgVGhpc0V4cHJlc3Npb246ICdUaGlzRXhwcmVzc2lvbicsXG4gICAgICAgIFRocm93U3RhdGVtZW50OiAnVGhyb3dTdGF0ZW1lbnQnLFxuICAgICAgICBUcnlTdGF0ZW1lbnQ6ICdUcnlTdGF0ZW1lbnQnLFxuICAgICAgICBVbmFyeUV4cHJlc3Npb246ICdVbmFyeUV4cHJlc3Npb24nLFxuICAgICAgICBVcGRhdGVFeHByZXNzaW9uOiAnVXBkYXRlRXhwcmVzc2lvbicsXG4gICAgICAgIFZhcmlhYmxlRGVjbGFyYXRpb246ICdWYXJpYWJsZURlY2xhcmF0aW9uJyxcbiAgICAgICAgVmFyaWFibGVEZWNsYXJhdG9yOiAnVmFyaWFibGVEZWNsYXJhdG9yJyxcbiAgICAgICAgV2hpbGVTdGF0ZW1lbnQ6ICdXaGlsZVN0YXRlbWVudCcsXG4gICAgICAgIFdpdGhTdGF0ZW1lbnQ6ICdXaXRoU3RhdGVtZW50JyxcbiAgICAgICAgWWllbGRFeHByZXNzaW9uOiAnWWllbGRFeHByZXNzaW9uJ1xuICAgIH07XG5cbiAgICBWaXNpdG9yS2V5cyA9IHtcbiAgICAgICAgQXNzaWdubWVudEV4cHJlc3Npb246IFsnbGVmdCcsICdyaWdodCddLFxuICAgICAgICBBc3NpZ25tZW50UGF0dGVybjogWydsZWZ0JywgJ3JpZ2h0J10sXG4gICAgICAgIEFycmF5RXhwcmVzc2lvbjogWydlbGVtZW50cyddLFxuICAgICAgICBBcnJheVBhdHRlcm46IFsnZWxlbWVudHMnXSxcbiAgICAgICAgQXJyb3dGdW5jdGlvbkV4cHJlc3Npb246IFsncGFyYW1zJywgJ2JvZHknXSxcbiAgICAgICAgQXdhaXRFeHByZXNzaW9uOiBbJ2FyZ3VtZW50J10sIC8vIENBVVRJT046IEl0J3MgZGVmZXJyZWQgdG8gRVM3LlxuICAgICAgICBCbG9ja1N0YXRlbWVudDogWydib2R5J10sXG4gICAgICAgIEJpbmFyeUV4cHJlc3Npb246IFsnbGVmdCcsICdyaWdodCddLFxuICAgICAgICBCcmVha1N0YXRlbWVudDogWydsYWJlbCddLFxuICAgICAgICBDYWxsRXhwcmVzc2lvbjogWydjYWxsZWUnLCAnYXJndW1lbnRzJ10sXG4gICAgICAgIENhdGNoQ2xhdXNlOiBbJ3BhcmFtJywgJ2JvZHknXSxcbiAgICAgICAgQ2xhc3NCb2R5OiBbJ2JvZHknXSxcbiAgICAgICAgQ2xhc3NEZWNsYXJhdGlvbjogWydpZCcsICdzdXBlckNsYXNzJywgJ2JvZHknXSxcbiAgICAgICAgQ2xhc3NFeHByZXNzaW9uOiBbJ2lkJywgJ3N1cGVyQ2xhc3MnLCAnYm9keSddLFxuICAgICAgICBDb21wcmVoZW5zaW9uQmxvY2s6IFsnbGVmdCcsICdyaWdodCddLCAgLy8gQ0FVVElPTjogSXQncyBkZWZlcnJlZCB0byBFUzcuXG4gICAgICAgIENvbXByZWhlbnNpb25FeHByZXNzaW9uOiBbJ2Jsb2NrcycsICdmaWx0ZXInLCAnYm9keSddLCAgLy8gQ0FVVElPTjogSXQncyBkZWZlcnJlZCB0byBFUzcuXG4gICAgICAgIENvbmRpdGlvbmFsRXhwcmVzc2lvbjogWyd0ZXN0JywgJ2NvbnNlcXVlbnQnLCAnYWx0ZXJuYXRlJ10sXG4gICAgICAgIENvbnRpbnVlU3RhdGVtZW50OiBbJ2xhYmVsJ10sXG4gICAgICAgIERlYnVnZ2VyU3RhdGVtZW50OiBbXSxcbiAgICAgICAgRGlyZWN0aXZlU3RhdGVtZW50OiBbXSxcbiAgICAgICAgRG9XaGlsZVN0YXRlbWVudDogWydib2R5JywgJ3Rlc3QnXSxcbiAgICAgICAgRW1wdHlTdGF0ZW1lbnQ6IFtdLFxuICAgICAgICBFeHBvcnRBbGxEZWNsYXJhdGlvbjogWydzb3VyY2UnXSxcbiAgICAgICAgRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uOiBbJ2RlY2xhcmF0aW9uJ10sXG4gICAgICAgIEV4cG9ydE5hbWVkRGVjbGFyYXRpb246IFsnZGVjbGFyYXRpb24nLCAnc3BlY2lmaWVycycsICdzb3VyY2UnXSxcbiAgICAgICAgRXhwb3J0U3BlY2lmaWVyOiBbJ2V4cG9ydGVkJywgJ2xvY2FsJ10sXG4gICAgICAgIEV4cHJlc3Npb25TdGF0ZW1lbnQ6IFsnZXhwcmVzc2lvbiddLFxuICAgICAgICBGb3JTdGF0ZW1lbnQ6IFsnaW5pdCcsICd0ZXN0JywgJ3VwZGF0ZScsICdib2R5J10sXG4gICAgICAgIEZvckluU3RhdGVtZW50OiBbJ2xlZnQnLCAncmlnaHQnLCAnYm9keSddLFxuICAgICAgICBGb3JPZlN0YXRlbWVudDogWydsZWZ0JywgJ3JpZ2h0JywgJ2JvZHknXSxcbiAgICAgICAgRnVuY3Rpb25EZWNsYXJhdGlvbjogWydpZCcsICdwYXJhbXMnLCAnYm9keSddLFxuICAgICAgICBGdW5jdGlvbkV4cHJlc3Npb246IFsnaWQnLCAncGFyYW1zJywgJ2JvZHknXSxcbiAgICAgICAgR2VuZXJhdG9yRXhwcmVzc2lvbjogWydibG9ja3MnLCAnZmlsdGVyJywgJ2JvZHknXSwgIC8vIENBVVRJT046IEl0J3MgZGVmZXJyZWQgdG8gRVM3LlxuICAgICAgICBJZGVudGlmaWVyOiBbXSxcbiAgICAgICAgSWZTdGF0ZW1lbnQ6IFsndGVzdCcsICdjb25zZXF1ZW50JywgJ2FsdGVybmF0ZSddLFxuICAgICAgICBJbXBvcnREZWNsYXJhdGlvbjogWydzcGVjaWZpZXJzJywgJ3NvdXJjZSddLFxuICAgICAgICBJbXBvcnREZWZhdWx0U3BlY2lmaWVyOiBbJ2xvY2FsJ10sXG4gICAgICAgIEltcG9ydE5hbWVzcGFjZVNwZWNpZmllcjogWydsb2NhbCddLFxuICAgICAgICBJbXBvcnRTcGVjaWZpZXI6IFsnaW1wb3J0ZWQnLCAnbG9jYWwnXSxcbiAgICAgICAgTGl0ZXJhbDogW10sXG4gICAgICAgIExhYmVsZWRTdGF0ZW1lbnQ6IFsnbGFiZWwnLCAnYm9keSddLFxuICAgICAgICBMb2dpY2FsRXhwcmVzc2lvbjogWydsZWZ0JywgJ3JpZ2h0J10sXG4gICAgICAgIE1lbWJlckV4cHJlc3Npb246IFsnb2JqZWN0JywgJ3Byb3BlcnR5J10sXG4gICAgICAgIE1ldGFQcm9wZXJ0eTogWydtZXRhJywgJ3Byb3BlcnR5J10sXG4gICAgICAgIE1ldGhvZERlZmluaXRpb246IFsna2V5JywgJ3ZhbHVlJ10sXG4gICAgICAgIE1vZHVsZVNwZWNpZmllcjogW10sXG4gICAgICAgIE5ld0V4cHJlc3Npb246IFsnY2FsbGVlJywgJ2FyZ3VtZW50cyddLFxuICAgICAgICBPYmplY3RFeHByZXNzaW9uOiBbJ3Byb3BlcnRpZXMnXSxcbiAgICAgICAgT2JqZWN0UGF0dGVybjogWydwcm9wZXJ0aWVzJ10sXG4gICAgICAgIFByb2dyYW06IFsnYm9keSddLFxuICAgICAgICBQcm9wZXJ0eTogWydrZXknLCAndmFsdWUnXSxcbiAgICAgICAgUmVzdEVsZW1lbnQ6IFsgJ2FyZ3VtZW50JyBdLFxuICAgICAgICBSZXR1cm5TdGF0ZW1lbnQ6IFsnYXJndW1lbnQnXSxcbiAgICAgICAgU2VxdWVuY2VFeHByZXNzaW9uOiBbJ2V4cHJlc3Npb25zJ10sXG4gICAgICAgIFNwcmVhZEVsZW1lbnQ6IFsnYXJndW1lbnQnXSxcbiAgICAgICAgU3VwZXI6IFtdLFxuICAgICAgICBTd2l0Y2hTdGF0ZW1lbnQ6IFsnZGlzY3JpbWluYW50JywgJ2Nhc2VzJ10sXG4gICAgICAgIFN3aXRjaENhc2U6IFsndGVzdCcsICdjb25zZXF1ZW50J10sXG4gICAgICAgIFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbjogWyd0YWcnLCAncXVhc2knXSxcbiAgICAgICAgVGVtcGxhdGVFbGVtZW50OiBbXSxcbiAgICAgICAgVGVtcGxhdGVMaXRlcmFsOiBbJ3F1YXNpcycsICdleHByZXNzaW9ucyddLFxuICAgICAgICBUaGlzRXhwcmVzc2lvbjogW10sXG4gICAgICAgIFRocm93U3RhdGVtZW50OiBbJ2FyZ3VtZW50J10sXG4gICAgICAgIFRyeVN0YXRlbWVudDogWydibG9jaycsICdoYW5kbGVyJywgJ2ZpbmFsaXplciddLFxuICAgICAgICBVbmFyeUV4cHJlc3Npb246IFsnYXJndW1lbnQnXSxcbiAgICAgICAgVXBkYXRlRXhwcmVzc2lvbjogWydhcmd1bWVudCddLFxuICAgICAgICBWYXJpYWJsZURlY2xhcmF0aW9uOiBbJ2RlY2xhcmF0aW9ucyddLFxuICAgICAgICBWYXJpYWJsZURlY2xhcmF0b3I6IFsnaWQnLCAnaW5pdCddLFxuICAgICAgICBXaGlsZVN0YXRlbWVudDogWyd0ZXN0JywgJ2JvZHknXSxcbiAgICAgICAgV2l0aFN0YXRlbWVudDogWydvYmplY3QnLCAnYm9keSddLFxuICAgICAgICBZaWVsZEV4cHJlc3Npb246IFsnYXJndW1lbnQnXVxuICAgIH07XG5cbiAgICAvLyB1bmlxdWUgaWRcbiAgICBCUkVBSyA9IHt9O1xuICAgIFNLSVAgPSB7fTtcbiAgICBSRU1PVkUgPSB7fTtcblxuICAgIFZpc2l0b3JPcHRpb24gPSB7XG4gICAgICAgIEJyZWFrOiBCUkVBSyxcbiAgICAgICAgU2tpcDogU0tJUCxcbiAgICAgICAgUmVtb3ZlOiBSRU1PVkVcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gUmVmZXJlbmNlKHBhcmVudCwga2V5KSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICB9XG5cbiAgICBSZWZlcmVuY2UucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKG5vZGUpIHtcbiAgICAgICAgdGhpcy5wYXJlbnRbdGhpcy5rZXldID0gbm9kZTtcbiAgICB9O1xuXG4gICAgUmVmZXJlbmNlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgIGlmIChpc0FycmF5KHRoaXMucGFyZW50KSkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQuc3BsaWNlKHRoaXMua2V5LCAxKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZXBsYWNlKG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIEVsZW1lbnQobm9kZSwgcGF0aCwgd3JhcCwgcmVmKSB7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMud3JhcCA9IHdyYXA7XG4gICAgICAgIHRoaXMucmVmID0gcmVmO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIENvbnRyb2xsZXIoKSB7IH1cblxuICAgIC8vIEFQSTpcbiAgICAvLyByZXR1cm4gcHJvcGVydHkgcGF0aCBhcnJheSBmcm9tIHJvb3QgdG8gY3VycmVudCBub2RlXG4gICAgQ29udHJvbGxlci5wcm90b3R5cGUucGF0aCA9IGZ1bmN0aW9uIHBhdGgoKSB7XG4gICAgICAgIHZhciBpLCBpeiwgaiwganosIHJlc3VsdCwgZWxlbWVudDtcblxuICAgICAgICBmdW5jdGlvbiBhZGRUb1BhdGgocmVzdWx0LCBwYXRoKSB7XG4gICAgICAgICAgICBpZiAoaXNBcnJheShwYXRoKSkge1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDAsIGp6ID0gcGF0aC5sZW5ndGg7IGogPCBqejsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhdGhbal0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyByb290IG5vZGVcbiAgICAgICAgaWYgKCF0aGlzLl9fY3VycmVudC5wYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpcnN0IG5vZGUgaXMgc2VudGluZWwsIHNlY29uZCBub2RlIGlzIHJvb3QgZWxlbWVudFxuICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMiwgaXogPSB0aGlzLl9fbGVhdmVsaXN0Lmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSB0aGlzLl9fbGVhdmVsaXN0W2ldO1xuICAgICAgICAgICAgYWRkVG9QYXRoKHJlc3VsdCwgZWxlbWVudC5wYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRUb1BhdGgocmVzdWx0LCB0aGlzLl9fY3VycmVudC5wYXRoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLy8gQVBJOlxuICAgIC8vIHJldHVybiB0eXBlIG9mIGN1cnJlbnQgbm9kZVxuICAgIENvbnRyb2xsZXIucHJvdG90eXBlLnR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5jdXJyZW50KCk7XG4gICAgICAgIHJldHVybiBub2RlLnR5cGUgfHwgdGhpcy5fX2N1cnJlbnQud3JhcDtcbiAgICB9O1xuXG4gICAgLy8gQVBJOlxuICAgIC8vIHJldHVybiBhcnJheSBvZiBwYXJlbnQgZWxlbWVudHNcbiAgICBDb250cm9sbGVyLnByb3RvdHlwZS5wYXJlbnRzID0gZnVuY3Rpb24gcGFyZW50cygpIHtcbiAgICAgICAgdmFyIGksIGl6LCByZXN1bHQ7XG5cbiAgICAgICAgLy8gZmlyc3Qgbm9kZSBpcyBzZW50aW5lbFxuICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMSwgaXogPSB0aGlzLl9fbGVhdmVsaXN0Lmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuX19sZWF2ZWxpc3RbaV0ubm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvLyBBUEk6XG4gICAgLy8gcmV0dXJuIGN1cnJlbnQgbm9kZVxuICAgIENvbnRyb2xsZXIucHJvdG90eXBlLmN1cnJlbnQgPSBmdW5jdGlvbiBjdXJyZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2N1cnJlbnQubm9kZTtcbiAgICB9O1xuXG4gICAgQ29udHJvbGxlci5wcm90b3R5cGUuX19leGVjdXRlID0gZnVuY3Rpb24gX19leGVjdXRlKGNhbGxiYWNrLCBlbGVtZW50KSB7XG4gICAgICAgIHZhciBwcmV2aW91cywgcmVzdWx0O1xuXG4gICAgICAgIHJlc3VsdCA9IHVuZGVmaW5lZDtcblxuICAgICAgICBwcmV2aW91cyAgPSB0aGlzLl9fY3VycmVudDtcbiAgICAgICAgdGhpcy5fX2N1cnJlbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLl9fc3RhdGUgPSBudWxsO1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGNhbGxiYWNrLmNhbGwodGhpcywgZWxlbWVudC5ub2RlLCB0aGlzLl9fbGVhdmVsaXN0W3RoaXMuX19sZWF2ZWxpc3QubGVuZ3RoIC0gMV0ubm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX2N1cnJlbnQgPSBwcmV2aW91cztcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvLyBBUEk6XG4gICAgLy8gbm90aWZ5IGNvbnRyb2wgc2tpcCAvIGJyZWFrXG4gICAgQ29udHJvbGxlci5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gbm90aWZ5KGZsYWcpIHtcbiAgICAgICAgdGhpcy5fX3N0YXRlID0gZmxhZztcbiAgICB9O1xuXG4gICAgLy8gQVBJOlxuICAgIC8vIHNraXAgY2hpbGQgbm9kZXMgb2YgY3VycmVudCBub2RlXG4gICAgQ29udHJvbGxlci5wcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5ub3RpZnkoU0tJUCk7XG4gICAgfTtcblxuICAgIC8vIEFQSTpcbiAgICAvLyBicmVhayB0cmF2ZXJzYWxzXG4gICAgQ29udHJvbGxlci5wcm90b3R5cGVbJ2JyZWFrJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubm90aWZ5KEJSRUFLKTtcbiAgICB9O1xuXG4gICAgLy8gQVBJOlxuICAgIC8vIHJlbW92ZSBub2RlXG4gICAgQ29udHJvbGxlci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm5vdGlmeShSRU1PVkUpO1xuICAgIH07XG5cbiAgICBDb250cm9sbGVyLnByb3RvdHlwZS5fX2luaXRpYWxpemUgPSBmdW5jdGlvbihyb290LCB2aXNpdG9yKSB7XG4gICAgICAgIHRoaXMudmlzaXRvciA9IHZpc2l0b3I7XG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgICAgIHRoaXMuX193b3JrbGlzdCA9IFtdO1xuICAgICAgICB0aGlzLl9fbGVhdmVsaXN0ID0gW107XG4gICAgICAgIHRoaXMuX19jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fX3N0YXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fX2ZhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgaWYgKHZpc2l0b3IuZmFsbGJhY2sgPT09ICdpdGVyYXRpb24nKSB7XG4gICAgICAgICAgICB0aGlzLl9fZmFsbGJhY2sgPSBvYmplY3RLZXlzO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2aXNpdG9yLmZhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLl9fZmFsbGJhY2sgPSB2aXNpdG9yLmZhbGxiYWNrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fX2tleXMgPSBWaXNpdG9yS2V5cztcbiAgICAgICAgaWYgKHZpc2l0b3Iua2V5cykge1xuICAgICAgICAgICAgdGhpcy5fX2tleXMgPSBleHRlbmQob2JqZWN0Q3JlYXRlKHRoaXMuX19rZXlzKSwgdmlzaXRvci5rZXlzKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBpc05vZGUobm9kZSkge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGVvZiBub2RlID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygbm9kZS50eXBlID09PSAnc3RyaW5nJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1Byb3BlcnR5KG5vZGVUeXBlLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIChub2RlVHlwZSA9PT0gU3ludGF4Lk9iamVjdEV4cHJlc3Npb24gfHwgbm9kZVR5cGUgPT09IFN5bnRheC5PYmplY3RQYXR0ZXJuKSAmJiAncHJvcGVydGllcycgPT09IGtleTtcbiAgICB9XG5cbiAgICBDb250cm9sbGVyLnByb3RvdHlwZS50cmF2ZXJzZSA9IGZ1bmN0aW9uIHRyYXZlcnNlKHJvb3QsIHZpc2l0b3IpIHtcbiAgICAgICAgdmFyIHdvcmtsaXN0LFxuICAgICAgICAgICAgbGVhdmVsaXN0LFxuICAgICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICBub2RlVHlwZSxcbiAgICAgICAgICAgIHJldCxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICBjdXJyZW50MixcbiAgICAgICAgICAgIGNhbmRpZGF0ZXMsXG4gICAgICAgICAgICBjYW5kaWRhdGUsXG4gICAgICAgICAgICBzZW50aW5lbDtcblxuICAgICAgICB0aGlzLl9faW5pdGlhbGl6ZShyb290LCB2aXNpdG9yKTtcblxuICAgICAgICBzZW50aW5lbCA9IHt9O1xuXG4gICAgICAgIC8vIHJlZmVyZW5jZVxuICAgICAgICB3b3JrbGlzdCA9IHRoaXMuX193b3JrbGlzdDtcbiAgICAgICAgbGVhdmVsaXN0ID0gdGhpcy5fX2xlYXZlbGlzdDtcblxuICAgICAgICAvLyBpbml0aWFsaXplXG4gICAgICAgIHdvcmtsaXN0LnB1c2gobmV3IEVsZW1lbnQocm9vdCwgbnVsbCwgbnVsbCwgbnVsbCkpO1xuICAgICAgICBsZWF2ZWxpc3QucHVzaChuZXcgRWxlbWVudChudWxsLCBudWxsLCBudWxsLCBudWxsKSk7XG5cbiAgICAgICAgd2hpbGUgKHdvcmtsaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgZWxlbWVudCA9IHdvcmtsaXN0LnBvcCgpO1xuXG4gICAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gc2VudGluZWwpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gbGVhdmVsaXN0LnBvcCgpO1xuXG4gICAgICAgICAgICAgICAgcmV0ID0gdGhpcy5fX2V4ZWN1dGUodmlzaXRvci5sZWF2ZSwgZWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX3N0YXRlID09PSBCUkVBSyB8fCByZXQgPT09IEJSRUFLKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlbGVtZW50Lm5vZGUpIHtcblxuICAgICAgICAgICAgICAgIHJldCA9IHRoaXMuX19leGVjdXRlKHZpc2l0b3IuZW50ZXIsIGVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19zdGF0ZSA9PT0gQlJFQUsgfHwgcmV0ID09PSBCUkVBSykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgd29ya2xpc3QucHVzaChzZW50aW5lbCk7XG4gICAgICAgICAgICAgICAgbGVhdmVsaXN0LnB1c2goZWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX3N0YXRlID09PSBTS0lQIHx8IHJldCA9PT0gU0tJUCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBub2RlID0gZWxlbWVudC5ub2RlO1xuICAgICAgICAgICAgICAgIG5vZGVUeXBlID0gbm9kZS50eXBlIHx8IGVsZW1lbnQud3JhcDtcbiAgICAgICAgICAgICAgICBjYW5kaWRhdGVzID0gdGhpcy5fX2tleXNbbm9kZVR5cGVdO1xuICAgICAgICAgICAgICAgIGlmICghY2FuZGlkYXRlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fX2ZhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGVzID0gdGhpcy5fX2ZhbGxiYWNrKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIG5vZGUgdHlwZSAnICsgbm9kZVR5cGUgKyAnLicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGNhbmRpZGF0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHdoaWxlICgoY3VycmVudCAtPSAxKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IGNhbmRpZGF0ZXNbY3VycmVudF07XG4gICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZSA9IG5vZGVba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5kaWRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkoY2FuZGlkYXRlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudDIgPSBjYW5kaWRhdGUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChjdXJyZW50MiAtPSAxKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5kaWRhdGVbY3VycmVudDJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNQcm9wZXJ0eShub2RlVHlwZSwgY2FuZGlkYXRlc1tjdXJyZW50XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IG5ldyBFbGVtZW50KGNhbmRpZGF0ZVtjdXJyZW50Ml0sIFtrZXksIGN1cnJlbnQyXSwgJ1Byb3BlcnR5JywgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc05vZGUoY2FuZGlkYXRlW2N1cnJlbnQyXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IG5ldyBFbGVtZW50KGNhbmRpZGF0ZVtjdXJyZW50Ml0sIFtrZXksIGN1cnJlbnQyXSwgbnVsbCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtsaXN0LnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNOb2RlKGNhbmRpZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtsaXN0LnB1c2gobmV3IEVsZW1lbnQoY2FuZGlkYXRlLCBrZXksIG51bGwsIG51bGwpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBDb250cm9sbGVyLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShyb290LCB2aXNpdG9yKSB7XG4gICAgICAgIHZhciB3b3JrbGlzdCxcbiAgICAgICAgICAgIGxlYXZlbGlzdCxcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICBub2RlVHlwZSxcbiAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgY3VycmVudDIsXG4gICAgICAgICAgICBjYW5kaWRhdGVzLFxuICAgICAgICAgICAgY2FuZGlkYXRlLFxuICAgICAgICAgICAgc2VudGluZWwsXG4gICAgICAgICAgICBvdXRlcixcbiAgICAgICAgICAgIGtleTtcblxuICAgICAgICBmdW5jdGlvbiByZW1vdmVFbGVtKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBpLFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICBuZXh0RWxlbSxcbiAgICAgICAgICAgICAgICBwYXJlbnQ7XG5cbiAgICAgICAgICAgIGlmIChlbGVtZW50LnJlZi5yZW1vdmUoKSkge1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIHJlZmVyZW5jZSBpcyBhbiBlbGVtZW50IG9mIGFuIGFycmF5LlxuICAgICAgICAgICAgICAgIGtleSA9IGVsZW1lbnQucmVmLmtleTtcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBlbGVtZW50LnJlZi5wYXJlbnQ7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiByZW1vdmVkIGZyb20gYXJyYXksIHRoZW4gZGVjcmVhc2UgZm9sbG93aW5nIGl0ZW1zJyBrZXlzLlxuICAgICAgICAgICAgICAgIGkgPSB3b3JrbGlzdC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0RWxlbSA9IHdvcmtsaXN0W2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dEVsZW0ucmVmICYmIG5leHRFbGVtLnJlZi5wYXJlbnQgPT09IHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgIChuZXh0RWxlbS5yZWYua2V5IDwga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAtLW5leHRFbGVtLnJlZi5rZXk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9faW5pdGlhbGl6ZShyb290LCB2aXNpdG9yKTtcblxuICAgICAgICBzZW50aW5lbCA9IHt9O1xuXG4gICAgICAgIC8vIHJlZmVyZW5jZVxuICAgICAgICB3b3JrbGlzdCA9IHRoaXMuX193b3JrbGlzdDtcbiAgICAgICAgbGVhdmVsaXN0ID0gdGhpcy5fX2xlYXZlbGlzdDtcblxuICAgICAgICAvLyBpbml0aWFsaXplXG4gICAgICAgIG91dGVyID0ge1xuICAgICAgICAgICAgcm9vdDogcm9vdFxuICAgICAgICB9O1xuICAgICAgICBlbGVtZW50ID0gbmV3IEVsZW1lbnQocm9vdCwgbnVsbCwgbnVsbCwgbmV3IFJlZmVyZW5jZShvdXRlciwgJ3Jvb3QnKSk7XG4gICAgICAgIHdvcmtsaXN0LnB1c2goZWxlbWVudCk7XG4gICAgICAgIGxlYXZlbGlzdC5wdXNoKGVsZW1lbnQpO1xuXG4gICAgICAgIHdoaWxlICh3b3JrbGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSB3b3JrbGlzdC5wb3AoKTtcblxuICAgICAgICAgICAgaWYgKGVsZW1lbnQgPT09IHNlbnRpbmVsKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IGxlYXZlbGlzdC5wb3AoKTtcblxuICAgICAgICAgICAgICAgIHRhcmdldCA9IHRoaXMuX19leGVjdXRlKHZpc2l0b3IubGVhdmUsIGVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgLy8gbm9kZSBtYXkgYmUgcmVwbGFjZWQgd2l0aCBudWxsLFxuICAgICAgICAgICAgICAgIC8vIHNvIGRpc3Rpbmd1aXNoIGJldHdlZW4gdW5kZWZpbmVkIGFuZCBudWxsIGluIHRoaXMgcGxhY2VcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ICE9PSB1bmRlZmluZWQgJiYgdGFyZ2V0ICE9PSBCUkVBSyAmJiB0YXJnZXQgIT09IFNLSVAgJiYgdGFyZ2V0ICE9PSBSRU1PVkUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVwbGFjZVxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnJlZi5yZXBsYWNlKHRhcmdldCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19zdGF0ZSA9PT0gUkVNT1ZFIHx8IHRhcmdldCA9PT0gUkVNT1ZFKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUVsZW0oZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19zdGF0ZSA9PT0gQlJFQUsgfHwgdGFyZ2V0ID09PSBCUkVBSykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3V0ZXIucm9vdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRhcmdldCA9IHRoaXMuX19leGVjdXRlKHZpc2l0b3IuZW50ZXIsIGVsZW1lbnQpO1xuXG4gICAgICAgICAgICAvLyBub2RlIG1heSBiZSByZXBsYWNlZCB3aXRoIG51bGwsXG4gICAgICAgICAgICAvLyBzbyBkaXN0aW5ndWlzaCBiZXR3ZWVuIHVuZGVmaW5lZCBhbmQgbnVsbCBpbiB0aGlzIHBsYWNlXG4gICAgICAgICAgICBpZiAodGFyZ2V0ICE9PSB1bmRlZmluZWQgJiYgdGFyZ2V0ICE9PSBCUkVBSyAmJiB0YXJnZXQgIT09IFNLSVAgJiYgdGFyZ2V0ICE9PSBSRU1PVkUpIHtcbiAgICAgICAgICAgICAgICAvLyByZXBsYWNlXG4gICAgICAgICAgICAgICAgZWxlbWVudC5yZWYucmVwbGFjZSh0YXJnZXQpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQubm9kZSA9IHRhcmdldDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuX19zdGF0ZSA9PT0gUkVNT1ZFIHx8IHRhcmdldCA9PT0gUkVNT1ZFKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlRWxlbShlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBlbGVtZW50Lm5vZGUgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fX3N0YXRlID09PSBCUkVBSyB8fCB0YXJnZXQgPT09IEJSRUFLKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dGVyLnJvb3Q7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG5vZGUgbWF5IGJlIG51bGxcbiAgICAgICAgICAgIG5vZGUgPSBlbGVtZW50Lm5vZGU7XG4gICAgICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd29ya2xpc3QucHVzaChzZW50aW5lbCk7XG4gICAgICAgICAgICBsZWF2ZWxpc3QucHVzaChlbGVtZW50KTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX19zdGF0ZSA9PT0gU0tJUCB8fCB0YXJnZXQgPT09IFNLSVApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbm9kZVR5cGUgPSBub2RlLnR5cGUgfHwgZWxlbWVudC53cmFwO1xuICAgICAgICAgICAgY2FuZGlkYXRlcyA9IHRoaXMuX19rZXlzW25vZGVUeXBlXTtcbiAgICAgICAgICAgIGlmICghY2FuZGlkYXRlcykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fZmFsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlcyA9IHRoaXMuX19mYWxsYmFjayhub2RlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbm9kZSB0eXBlICcgKyBub2RlVHlwZSArICcuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdXJyZW50ID0gY2FuZGlkYXRlcy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoKGN1cnJlbnQgLT0gMSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIGtleSA9IGNhbmRpZGF0ZXNbY3VycmVudF07XG4gICAgICAgICAgICAgICAgY2FuZGlkYXRlID0gbm9kZVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICghY2FuZGlkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KGNhbmRpZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudDIgPSBjYW5kaWRhdGUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGN1cnJlbnQyIC09IDEpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2FuZGlkYXRlW2N1cnJlbnQyXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzUHJvcGVydHkobm9kZVR5cGUsIGNhbmRpZGF0ZXNbY3VycmVudF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IG5ldyBFbGVtZW50KGNhbmRpZGF0ZVtjdXJyZW50Ml0sIFtrZXksIGN1cnJlbnQyXSwgJ1Byb3BlcnR5JywgbmV3IFJlZmVyZW5jZShjYW5kaWRhdGUsIGN1cnJlbnQyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzTm9kZShjYW5kaWRhdGVbY3VycmVudDJdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBuZXcgRWxlbWVudChjYW5kaWRhdGVbY3VycmVudDJdLCBba2V5LCBjdXJyZW50Ml0sIG51bGwsIG5ldyBSZWZlcmVuY2UoY2FuZGlkYXRlLCBjdXJyZW50MikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtsaXN0LnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzTm9kZShjYW5kaWRhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtsaXN0LnB1c2gobmV3IEVsZW1lbnQoY2FuZGlkYXRlLCBrZXksIG51bGwsIG5ldyBSZWZlcmVuY2Uobm9kZSwga2V5KSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXRlci5yb290O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiB0cmF2ZXJzZShyb290LCB2aXNpdG9yKSB7XG4gICAgICAgIHZhciBjb250cm9sbGVyID0gbmV3IENvbnRyb2xsZXIoKTtcbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIudHJhdmVyc2Uocm9vdCwgdmlzaXRvcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVwbGFjZShyb290LCB2aXNpdG9yKSB7XG4gICAgICAgIHZhciBjb250cm9sbGVyID0gbmV3IENvbnRyb2xsZXIoKTtcbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIucmVwbGFjZShyb290LCB2aXNpdG9yKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHRlbmRDb21tZW50UmFuZ2UoY29tbWVudCwgdG9rZW5zKSB7XG4gICAgICAgIHZhciB0YXJnZXQ7XG5cbiAgICAgICAgdGFyZ2V0ID0gdXBwZXJCb3VuZCh0b2tlbnMsIGZ1bmN0aW9uIHNlYXJjaCh0b2tlbikge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuLnJhbmdlWzBdID4gY29tbWVudC5yYW5nZVswXTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29tbWVudC5leHRlbmRlZFJhbmdlID0gW2NvbW1lbnQucmFuZ2VbMF0sIGNvbW1lbnQucmFuZ2VbMV1dO1xuXG4gICAgICAgIGlmICh0YXJnZXQgIT09IHRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbW1lbnQuZXh0ZW5kZWRSYW5nZVsxXSA9IHRva2Vuc1t0YXJnZXRdLnJhbmdlWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFyZ2V0IC09IDE7XG4gICAgICAgIGlmICh0YXJnZXQgPj0gMCkge1xuICAgICAgICAgICAgY29tbWVudC5leHRlbmRlZFJhbmdlWzBdID0gdG9rZW5zW3RhcmdldF0ucmFuZ2VbMV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tbWVudDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhdHRhY2hDb21tZW50cyh0cmVlLCBwcm92aWRlZENvbW1lbnRzLCB0b2tlbnMpIHtcbiAgICAgICAgLy8gQXQgZmlyc3QsIHdlIHNob3VsZCBjYWxjdWxhdGUgZXh0ZW5kZWQgY29tbWVudCByYW5nZXMuXG4gICAgICAgIHZhciBjb21tZW50cyA9IFtdLCBjb21tZW50LCBsZW4sIGksIGN1cnNvcjtcblxuICAgICAgICBpZiAoIXRyZWUucmFuZ2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXR0YWNoQ29tbWVudHMgbmVlZHMgcmFuZ2UgaW5mb3JtYXRpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRva2VucyBhcnJheSBpcyBlbXB0eSwgd2UgYXR0YWNoIGNvbW1lbnRzIHRvIHRyZWUgYXMgJ2xlYWRpbmdDb21tZW50cydcbiAgICAgICAgaWYgKCF0b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAocHJvdmlkZWRDb21tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBwcm92aWRlZENvbW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBkZWVwQ29weShwcm92aWRlZENvbW1lbnRzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudC5leHRlbmRlZFJhbmdlID0gWzAsIHRyZWUucmFuZ2VbMF1dO1xuICAgICAgICAgICAgICAgICAgICBjb21tZW50cy5wdXNoKGNvbW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cmVlLmxlYWRpbmdDb21tZW50cyA9IGNvbW1lbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBwcm92aWRlZENvbW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb21tZW50cy5wdXNoKGV4dGVuZENvbW1lbnRSYW5nZShkZWVwQ29weShwcm92aWRlZENvbW1lbnRzW2ldKSwgdG9rZW5zKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGlzIGlzIGJhc2VkIG9uIEpvaG4gRnJlZW1hbidzIGltcGxlbWVudGF0aW9uLlxuICAgICAgICBjdXJzb3IgPSAwO1xuICAgICAgICB0cmF2ZXJzZSh0cmVlLCB7XG4gICAgICAgICAgICBlbnRlcjogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29tbWVudDtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJzb3IgPCBjb21tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudCA9IGNvbW1lbnRzW2N1cnNvcl07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21tZW50LmV4dGVuZGVkUmFuZ2VbMV0gPiBub2RlLnJhbmdlWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21tZW50LmV4dGVuZGVkUmFuZ2VbMV0gPT09IG5vZGUucmFuZ2VbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbm9kZS5sZWFkaW5nQ29tbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmxlYWRpbmdDb21tZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5sZWFkaW5nQ29tbWVudHMucHVzaChjb21tZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnRzLnNwbGljZShjdXJzb3IsIDEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBhbHJlYWR5IG91dCBvZiBvd25lZCBub2RlXG4gICAgICAgICAgICAgICAgaWYgKGN1cnNvciA9PT0gY29tbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBWaXNpdG9yT3B0aW9uLkJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjb21tZW50c1tjdXJzb3JdLmV4dGVuZGVkUmFuZ2VbMF0gPiBub2RlLnJhbmdlWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBWaXNpdG9yT3B0aW9uLlNraXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBjdXJzb3IgPSAwO1xuICAgICAgICB0cmF2ZXJzZSh0cmVlLCB7XG4gICAgICAgICAgICBsZWF2ZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29tbWVudDtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJzb3IgPCBjb21tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudCA9IGNvbW1lbnRzW2N1cnNvcl07XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnJhbmdlWzFdIDwgY29tbWVudC5leHRlbmRlZFJhbmdlWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnJhbmdlWzFdID09PSBjb21tZW50LmV4dGVuZGVkUmFuZ2VbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbm9kZS50cmFpbGluZ0NvbW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS50cmFpbGluZ0NvbW1lbnRzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnRyYWlsaW5nQ29tbWVudHMucHVzaChjb21tZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnRzLnNwbGljZShjdXJzb3IsIDEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBhbHJlYWR5IG91dCBvZiBvd25lZCBub2RlXG4gICAgICAgICAgICAgICAgaWYgKGN1cnNvciA9PT0gY29tbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBWaXNpdG9yT3B0aW9uLkJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjb21tZW50c1tjdXJzb3JdLmV4dGVuZGVkUmFuZ2VbMF0gPiBub2RlLnJhbmdlWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBWaXNpdG9yT3B0aW9uLlNraXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICB9XG5cbiAgICBleHBvcnRzLnZlcnNpb24gPSByZXF1aXJlKCcuL3BhY2thZ2UuanNvbicpLnZlcnNpb247XG4gICAgZXhwb3J0cy5TeW50YXggPSBTeW50YXg7XG4gICAgZXhwb3J0cy50cmF2ZXJzZSA9IHRyYXZlcnNlO1xuICAgIGV4cG9ydHMucmVwbGFjZSA9IHJlcGxhY2U7XG4gICAgZXhwb3J0cy5hdHRhY2hDb21tZW50cyA9IGF0dGFjaENvbW1lbnRzO1xuICAgIGV4cG9ydHMuVmlzaXRvcktleXMgPSBWaXNpdG9yS2V5cztcbiAgICBleHBvcnRzLlZpc2l0b3JPcHRpb24gPSBWaXNpdG9yT3B0aW9uO1xuICAgIGV4cG9ydHMuQ29udHJvbGxlciA9IENvbnRyb2xsZXI7XG4gICAgZXhwb3J0cy5jbG9uZUVudmlyb25tZW50ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY2xvbmUoe30pOyB9O1xuXG4gICAgcmV0dXJuIGV4cG9ydHM7XG59KGV4cG9ydHMpKTtcbi8qIHZpbTogc2V0IHN3PTQgdHM9NCBldCB0dz04MCA6ICovXG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiX2Zyb21cIjogXCJlc3RyYXZlcnNlQF40LjEueFwiLFxuICBcIl9pZFwiOiBcImVzdHJhdmVyc2VANC4yLjBcIixcbiAgXCJfaW5CdW5kbGVcIjogZmFsc2UsXG4gIFwiX2ludGVncml0eVwiOiBcInNoYTEtRGU0LzdUSDgxR2xoak9jMElKbjhHdm9MMnhNPVwiLFxuICBcIl9sb2NhdGlvblwiOiBcIi9lc3RyYXZlcnNlXCIsXG4gIFwiX3BoYW50b21DaGlsZHJlblwiOiB7fSxcbiAgXCJfcmVxdWVzdGVkXCI6IHtcbiAgICBcInR5cGVcIjogXCJyYW5nZVwiLFxuICAgIFwicmVnaXN0cnlcIjogdHJ1ZSxcbiAgICBcInJhd1wiOiBcImVzdHJhdmVyc2VAXjQuMS54XCIsXG4gICAgXCJuYW1lXCI6IFwiZXN0cmF2ZXJzZVwiLFxuICAgIFwiZXNjYXBlZE5hbWVcIjogXCJlc3RyYXZlcnNlXCIsXG4gICAgXCJyYXdTcGVjXCI6IFwiXjQuMS54XCIsXG4gICAgXCJzYXZlU3BlY1wiOiBudWxsLFxuICAgIFwiZmV0Y2hTcGVjXCI6IFwiXjQuMS54XCJcbiAgfSxcbiAgXCJfcmVxdWlyZWRCeVwiOiBbXG4gICAgXCIjVVNFUlwiLFxuICAgIFwiL1wiXG4gIF0sXG4gIFwiX3Jlc29sdmVkXCI6IFwiaHR0cHM6Ly9yZWdpc3RyeS5ucG1qcy5vcmcvZXN0cmF2ZXJzZS8tL2VzdHJhdmVyc2UtNC4yLjAudGd6XCIsXG4gIFwiX3NoYXN1bVwiOiBcIjBkZWUzZmVkMzFmY2Q0Njk2MThjZTczNDIwOTlmYzFhZmEwYmRiMTNcIixcbiAgXCJfc3BlY1wiOiBcImVzdHJhdmVyc2VAXjQuMS54XCIsXG4gIFwiX3doZXJlXCI6IFwiL2RhdGEvY2hhbG1lcnMvcHJvamVjdC9qc2Zsb3dcIixcbiAgXCJidWdzXCI6IHtcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9lc3Rvb2xzL2VzdHJhdmVyc2UvaXNzdWVzXCJcbiAgfSxcbiAgXCJidW5kbGVEZXBlbmRlbmNpZXNcIjogZmFsc2UsXG4gIFwiZGVwcmVjYXRlZFwiOiBmYWxzZSxcbiAgXCJkZXNjcmlwdGlvblwiOiBcIkVDTUFTY3JpcHQgSlMgQVNUIHRyYXZlcnNhbCBmdW5jdGlvbnNcIixcbiAgXCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiYmFiZWwtcHJlc2V0LWVzMjAxNVwiOiBcIl42LjMuMTNcIixcbiAgICBcImJhYmVsLXJlZ2lzdGVyXCI6IFwiXjYuMy4xM1wiLFxuICAgIFwiY2hhaVwiOiBcIl4yLjEuMVwiLFxuICAgIFwiZXNwcmVlXCI6IFwiXjEuMTEuMFwiLFxuICAgIFwiZ3VscFwiOiBcIl4zLjguMTBcIixcbiAgICBcImd1bHAtYnVtcFwiOiBcIl4wLjIuMlwiLFxuICAgIFwiZ3VscC1maWx0ZXJcIjogXCJeMi4wLjBcIixcbiAgICBcImd1bHAtZ2l0XCI6IFwiXjEuMC4xXCIsXG4gICAgXCJndWxwLXRhZy12ZXJzaW9uXCI6IFwiXjEuMi4xXCIsXG4gICAgXCJqc2hpbnRcIjogXCJeMi41LjZcIixcbiAgICBcIm1vY2hhXCI6IFwiXjIuMS4wXCJcbiAgfSxcbiAgXCJlbmdpbmVzXCI6IHtcbiAgICBcIm5vZGVcIjogXCI+PTAuMTAuMFwiXG4gIH0sXG4gIFwiaG9tZXBhZ2VcIjogXCJodHRwczovL2dpdGh1Yi5jb20vZXN0b29scy9lc3RyYXZlcnNlXCIsXG4gIFwibGljZW5zZVwiOiBcIkJTRC0yLUNsYXVzZVwiLFxuICBcIm1haW5cIjogXCJlc3RyYXZlcnNlLmpzXCIsXG4gIFwibWFpbnRhaW5lcnNcIjogW1xuICAgIHtcbiAgICAgIFwibmFtZVwiOiBcIll1c3VrZSBTdXp1a2lcIixcbiAgICAgIFwiZW1haWxcIjogXCJ1dGF0YW5lLnRlYUBnbWFpbC5jb21cIixcbiAgICAgIFwidXJsXCI6IFwiaHR0cDovL2dpdGh1Yi5jb20vQ29uc3RlbGxhdGlvblwiXG4gICAgfVxuICBdLFxuICBcIm5hbWVcIjogXCJlc3RyYXZlcnNlXCIsXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJnaXQrc3NoOi8vZ2l0QGdpdGh1Yi5jb20vZXN0b29scy9lc3RyYXZlcnNlLmdpdFwiXG4gIH0sXG4gIFwic2NyaXB0c1wiOiB7XG4gICAgXCJsaW50XCI6IFwianNoaW50IGVzdHJhdmVyc2UuanNcIixcbiAgICBcInRlc3RcIjogXCJucG0gcnVuLXNjcmlwdCBsaW50ICYmIG5wbSBydW4tc2NyaXB0IHVuaXQtdGVzdFwiLFxuICAgIFwidW5pdC10ZXN0XCI6IFwibW9jaGEgLS1jb21waWxlcnMganM6YmFiZWwtcmVnaXN0ZXJcIlxuICB9LFxuICBcInZlcnNpb25cIjogXCI0LjIuMFwiXG59XG4iLCIvLyAgICAgVW5kZXJzY29yZS5qcyAxLjkuMVxuLy8gICAgIGh0dHA6Ly91bmRlcnNjb3JlanMub3JnXG4vLyAgICAgKGMpIDIwMDktMjAxOCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuLy8gICAgIFVuZGVyc2NvcmUgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5cbihmdW5jdGlvbigpIHtcblxuICAvLyBCYXNlbGluZSBzZXR1cFxuICAvLyAtLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEVzdGFibGlzaCB0aGUgcm9vdCBvYmplY3QsIGB3aW5kb3dgIChgc2VsZmApIGluIHRoZSBicm93c2VyLCBgZ2xvYmFsYFxuICAvLyBvbiB0aGUgc2VydmVyLCBvciBgdGhpc2AgaW4gc29tZSB2aXJ0dWFsIG1hY2hpbmVzLiBXZSB1c2UgYHNlbGZgXG4gIC8vIGluc3RlYWQgb2YgYHdpbmRvd2AgZm9yIGBXZWJXb3JrZXJgIHN1cHBvcnQuXG4gIHZhciByb290ID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZi5zZWxmID09PSBzZWxmICYmIHNlbGYgfHxcbiAgICAgICAgICAgIHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsLmdsb2JhbCA9PT0gZ2xvYmFsICYmIGdsb2JhbCB8fFxuICAgICAgICAgICAgdGhpcyB8fFxuICAgICAgICAgICAge307XG5cbiAgLy8gU2F2ZSB0aGUgcHJldmlvdXMgdmFsdWUgb2YgdGhlIGBfYCB2YXJpYWJsZS5cbiAgdmFyIHByZXZpb3VzVW5kZXJzY29yZSA9IHJvb3QuXztcblxuICAvLyBTYXZlIGJ5dGVzIGluIHRoZSBtaW5pZmllZCAoYnV0IG5vdCBnemlwcGVkKSB2ZXJzaW9uOlxuICB2YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSwgT2JqUHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgU3ltYm9sUHJvdG8gPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyA/IFN5bWJvbC5wcm90b3R5cGUgOiBudWxsO1xuXG4gIC8vIENyZWF0ZSBxdWljayByZWZlcmVuY2UgdmFyaWFibGVzIGZvciBzcGVlZCBhY2Nlc3MgdG8gY29yZSBwcm90b3R5cGVzLlxuICB2YXIgcHVzaCA9IEFycmF5UHJvdG8ucHVzaCxcbiAgICAgIHNsaWNlID0gQXJyYXlQcm90by5zbGljZSxcbiAgICAgIHRvU3RyaW5nID0gT2JqUHJvdG8udG9TdHJpbmcsXG4gICAgICBoYXNPd25Qcm9wZXJ0eSA9IE9ialByb3RvLmhhc093blByb3BlcnR5O1xuXG4gIC8vIEFsbCAqKkVDTUFTY3JpcHQgNSoqIG5hdGl2ZSBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvbnMgdGhhdCB3ZSBob3BlIHRvIHVzZVxuICAvLyBhcmUgZGVjbGFyZWQgaGVyZS5cbiAgdmFyIG5hdGl2ZUlzQXJyYXkgPSBBcnJheS5pc0FycmF5LFxuICAgICAgbmF0aXZlS2V5cyA9IE9iamVjdC5rZXlzLFxuICAgICAgbmF0aXZlQ3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxuICAvLyBOYWtlZCBmdW5jdGlvbiByZWZlcmVuY2UgZm9yIHN1cnJvZ2F0ZS1wcm90b3R5cGUtc3dhcHBpbmcuXG4gIHZhciBDdG9yID0gZnVuY3Rpb24oKXt9O1xuXG4gIC8vIENyZWF0ZSBhIHNhZmUgcmVmZXJlbmNlIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdCBmb3IgdXNlIGJlbG93LlxuICB2YXIgXyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBfKSByZXR1cm4gb2JqO1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBfKSkgcmV0dXJuIG5ldyBfKG9iaik7XG4gICAgdGhpcy5fd3JhcHBlZCA9IG9iajtcbiAgfTtcblxuICAvLyBFeHBvcnQgdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciAqKk5vZGUuanMqKiwgd2l0aFxuICAvLyBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBmb3IgdGhlaXIgb2xkIG1vZHVsZSBBUEkuIElmIHdlJ3JlIGluXG4gIC8vIHRoZSBicm93c2VyLCBhZGQgYF9gIGFzIGEgZ2xvYmFsIG9iamVjdC5cbiAgLy8gKGBub2RlVHlwZWAgaXMgY2hlY2tlZCB0byBlbnN1cmUgdGhhdCBgbW9kdWxlYFxuICAvLyBhbmQgYGV4cG9ydHNgIGFyZSBub3QgSFRNTCBlbGVtZW50cy4pXG4gIGlmICh0eXBlb2YgZXhwb3J0cyAhPSAndW5kZWZpbmVkJyAmJiAhZXhwb3J0cy5ub2RlVHlwZSkge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IF87XG4gICAgfVxuICAgIGV4cG9ydHMuXyA9IF87XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5fID0gXztcbiAgfVxuXG4gIC8vIEN1cnJlbnQgdmVyc2lvbi5cbiAgXy5WRVJTSU9OID0gJzEuOS4xJztcblxuICAvLyBJbnRlcm5hbCBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gZWZmaWNpZW50IChmb3IgY3VycmVudCBlbmdpbmVzKSB2ZXJzaW9uXG4gIC8vIG9mIHRoZSBwYXNzZWQtaW4gY2FsbGJhY2ssIHRvIGJlIHJlcGVhdGVkbHkgYXBwbGllZCBpbiBvdGhlciBVbmRlcnNjb3JlXG4gIC8vIGZ1bmN0aW9ucy5cbiAgdmFyIG9wdGltaXplQ2IgPSBmdW5jdGlvbihmdW5jLCBjb250ZXh0LCBhcmdDb3VudCkge1xuICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHJldHVybiBmdW5jO1xuICAgIHN3aXRjaCAoYXJnQ291bnQgPT0gbnVsbCA/IDMgOiBhcmdDb3VudCkge1xuICAgICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCB2YWx1ZSk7XG4gICAgICB9O1xuICAgICAgLy8gVGhlIDItYXJndW1lbnQgY2FzZSBpcyBvbWl0dGVkIGJlY2F1c2Ugd2XigJlyZSBub3QgdXNpbmcgaXQuXG4gICAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfTtcbiAgICAgIGNhc2UgNDogcmV0dXJuIGZ1bmN0aW9uKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCBhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgYnVpbHRpbkl0ZXJhdGVlO1xuXG4gIC8vIEFuIGludGVybmFsIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGNhbGxiYWNrcyB0aGF0IGNhbiBiZSBhcHBsaWVkIHRvIGVhY2hcbiAgLy8gZWxlbWVudCBpbiBhIGNvbGxlY3Rpb24sIHJldHVybmluZyB0aGUgZGVzaXJlZCByZXN1bHQg4oCUIGVpdGhlciBgaWRlbnRpdHlgLFxuICAvLyBhbiBhcmJpdHJhcnkgY2FsbGJhY2ssIGEgcHJvcGVydHkgbWF0Y2hlciwgb3IgYSBwcm9wZXJ0eSBhY2Nlc3Nvci5cbiAgdmFyIGNiID0gZnVuY3Rpb24odmFsdWUsIGNvbnRleHQsIGFyZ0NvdW50KSB7XG4gICAgaWYgKF8uaXRlcmF0ZWUgIT09IGJ1aWx0aW5JdGVyYXRlZSkgcmV0dXJuIF8uaXRlcmF0ZWUodmFsdWUsIGNvbnRleHQpO1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gXy5pZGVudGl0eTtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKHZhbHVlKSkgcmV0dXJuIG9wdGltaXplQ2IodmFsdWUsIGNvbnRleHQsIGFyZ0NvdW50KTtcbiAgICBpZiAoXy5pc09iamVjdCh2YWx1ZSkgJiYgIV8uaXNBcnJheSh2YWx1ZSkpIHJldHVybiBfLm1hdGNoZXIodmFsdWUpO1xuICAgIHJldHVybiBfLnByb3BlcnR5KHZhbHVlKTtcbiAgfTtcblxuICAvLyBFeHRlcm5hbCB3cmFwcGVyIGZvciBvdXIgY2FsbGJhY2sgZ2VuZXJhdG9yLiBVc2VycyBtYXkgY3VzdG9taXplXG4gIC8vIGBfLml0ZXJhdGVlYCBpZiB0aGV5IHdhbnQgYWRkaXRpb25hbCBwcmVkaWNhdGUvaXRlcmF0ZWUgc2hvcnRoYW5kIHN0eWxlcy5cbiAgLy8gVGhpcyBhYnN0cmFjdGlvbiBoaWRlcyB0aGUgaW50ZXJuYWwtb25seSBhcmdDb3VudCBhcmd1bWVudC5cbiAgXy5pdGVyYXRlZSA9IGJ1aWx0aW5JdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGNiKHZhbHVlLCBjb250ZXh0LCBJbmZpbml0eSk7XG4gIH07XG5cbiAgLy8gU29tZSBmdW5jdGlvbnMgdGFrZSBhIHZhcmlhYmxlIG51bWJlciBvZiBhcmd1bWVudHMsIG9yIGEgZmV3IGV4cGVjdGVkXG4gIC8vIGFyZ3VtZW50cyBhdCB0aGUgYmVnaW5uaW5nIGFuZCB0aGVuIGEgdmFyaWFibGUgbnVtYmVyIG9mIHZhbHVlcyB0byBvcGVyYXRlXG4gIC8vIG9uLiBUaGlzIGhlbHBlciBhY2N1bXVsYXRlcyBhbGwgcmVtYWluaW5nIGFyZ3VtZW50cyBwYXN0IHRoZSBmdW5jdGlvbuKAmXNcbiAgLy8gYXJndW1lbnQgbGVuZ3RoIChvciBhbiBleHBsaWNpdCBgc3RhcnRJbmRleGApLCBpbnRvIGFuIGFycmF5IHRoYXQgYmVjb21lc1xuICAvLyB0aGUgbGFzdCBhcmd1bWVudC4gU2ltaWxhciB0byBFUzbigJlzIFwicmVzdCBwYXJhbWV0ZXJcIi5cbiAgdmFyIHJlc3RBcmd1bWVudHMgPSBmdW5jdGlvbihmdW5jLCBzdGFydEluZGV4KSB7XG4gICAgc3RhcnRJbmRleCA9IHN0YXJ0SW5kZXggPT0gbnVsbCA/IGZ1bmMubGVuZ3RoIC0gMSA6ICtzdGFydEluZGV4O1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsZW5ndGggPSBNYXRoLm1heChhcmd1bWVudHMubGVuZ3RoIC0gc3RhcnRJbmRleCwgMCksXG4gICAgICAgICAgcmVzdCA9IEFycmF5KGxlbmd0aCksXG4gICAgICAgICAgaW5kZXggPSAwO1xuICAgICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHJlc3RbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4ICsgc3RhcnRJbmRleF07XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXMsIHJlc3QpO1xuICAgICAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpcywgYXJndW1lbnRzWzBdLCByZXN0KTtcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXMsIGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdLCByZXN0KTtcbiAgICAgIH1cbiAgICAgIHZhciBhcmdzID0gQXJyYXkoc3RhcnRJbmRleCArIDEpO1xuICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgc3RhcnRJbmRleDsgaW5kZXgrKykge1xuICAgICAgICBhcmdzW2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICB9XG4gICAgICBhcmdzW3N0YXJ0SW5kZXhdID0gcmVzdDtcbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGEgbmV3IG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gYW5vdGhlci5cbiAgdmFyIGJhc2VDcmVhdGUgPSBmdW5jdGlvbihwcm90b3R5cGUpIHtcbiAgICBpZiAoIV8uaXNPYmplY3QocHJvdG90eXBlKSkgcmV0dXJuIHt9O1xuICAgIGlmIChuYXRpdmVDcmVhdGUpIHJldHVybiBuYXRpdmVDcmVhdGUocHJvdG90eXBlKTtcbiAgICBDdG9yLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IEN0b3I7XG4gICAgQ3Rvci5wcm90b3R5cGUgPSBudWxsO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIHNoYWxsb3dQcm9wZXJ0eSA9IGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT0gbnVsbCA/IHZvaWQgMCA6IG9ialtrZXldO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGhhcyA9IGZ1bmN0aW9uKG9iaiwgcGF0aCkge1xuICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcGF0aCk7XG4gIH1cblxuICB2YXIgZGVlcEdldCA9IGZ1bmN0aW9uKG9iaiwgcGF0aCkge1xuICAgIHZhciBsZW5ndGggPSBwYXRoLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAob2JqID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gICAgICBvYmogPSBvYmpbcGF0aFtpXV07XG4gICAgfVxuICAgIHJldHVybiBsZW5ndGggPyBvYmogOiB2b2lkIDA7XG4gIH07XG5cbiAgLy8gSGVscGVyIGZvciBjb2xsZWN0aW9uIG1ldGhvZHMgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBjb2xsZWN0aW9uXG4gIC8vIHNob3VsZCBiZSBpdGVyYXRlZCBhcyBhbiBhcnJheSBvciBhcyBhbiBvYmplY3QuXG4gIC8vIFJlbGF0ZWQ6IGh0dHA6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXRvbGVuZ3RoXG4gIC8vIEF2b2lkcyBhIHZlcnkgbmFzdHkgaU9TIDggSklUIGJ1ZyBvbiBBUk0tNjQuICMyMDk0XG4gIHZhciBNQVhfQVJSQVlfSU5ERVggPSBNYXRoLnBvdygyLCA1MykgLSAxO1xuICB2YXIgZ2V0TGVuZ3RoID0gc2hhbGxvd1Byb3BlcnR5KCdsZW5ndGgnKTtcbiAgdmFyIGlzQXJyYXlMaWtlID0gZnVuY3Rpb24oY29sbGVjdGlvbikge1xuICAgIHZhciBsZW5ndGggPSBnZXRMZW5ndGgoY29sbGVjdGlvbik7XG4gICAgcmV0dXJuIHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgJiYgbGVuZ3RoID49IDAgJiYgbGVuZ3RoIDw9IE1BWF9BUlJBWV9JTkRFWDtcbiAgfTtcblxuICAvLyBDb2xsZWN0aW9uIEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFRoZSBjb3JuZXJzdG9uZSwgYW4gYGVhY2hgIGltcGxlbWVudGF0aW9uLCBha2EgYGZvckVhY2hgLlxuICAvLyBIYW5kbGVzIHJhdyBvYmplY3RzIGluIGFkZGl0aW9uIHRvIGFycmF5LWxpa2VzLiBUcmVhdHMgYWxsXG4gIC8vIHNwYXJzZSBhcnJheS1saWtlcyBhcyBpZiB0aGV5IHdlcmUgZGVuc2UuXG4gIF8uZWFjaCA9IF8uZm9yRWFjaCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBpLCBsZW5ndGg7XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikpIHtcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVyYXRlZShvYmpbaV0sIGksIG9iaik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZXJhdGVlKG9ialtrZXlzW2ldXSwga2V5c1tpXSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdGVlIHRvIGVhY2ggZWxlbWVudC5cbiAgXy5tYXAgPSBfLmNvbGxlY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICAgIHJlc3VsdHMgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICByZXN1bHRzW2luZGV4XSA9IGl0ZXJhdGVlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgcmVkdWNpbmcgZnVuY3Rpb24gaXRlcmF0aW5nIGxlZnQgb3IgcmlnaHQuXG4gIHZhciBjcmVhdGVSZWR1Y2UgPSBmdW5jdGlvbihkaXIpIHtcbiAgICAvLyBXcmFwIGNvZGUgdGhhdCByZWFzc2lnbnMgYXJndW1lbnQgdmFyaWFibGVzIGluIGEgc2VwYXJhdGUgZnVuY3Rpb24gdGhhblxuICAgIC8vIHRoZSBvbmUgdGhhdCBhY2Nlc3NlcyBgYXJndW1lbnRzLmxlbmd0aGAgdG8gYXZvaWQgYSBwZXJmIGhpdC4gKCMxOTkxKVxuICAgIHZhciByZWR1Y2VyID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgbWVtbywgaW5pdGlhbCkge1xuICAgICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aCxcbiAgICAgICAgICBpbmRleCA9IGRpciA+IDAgPyAwIDogbGVuZ3RoIC0gMTtcbiAgICAgIGlmICghaW5pdGlhbCkge1xuICAgICAgICBtZW1vID0gb2JqW2tleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4XTtcbiAgICAgICAgaW5kZXggKz0gZGlyO1xuICAgICAgfVxuICAgICAgZm9yICg7IGluZGV4ID49IDAgJiYgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IGRpcikge1xuICAgICAgICB2YXIgY3VycmVudEtleSA9IGtleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgICBtZW1vID0gaXRlcmF0ZWUobWVtbywgb2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBtZW1vLCBjb250ZXh0KSB7XG4gICAgICB2YXIgaW5pdGlhbCA9IGFyZ3VtZW50cy5sZW5ndGggPj0gMztcbiAgICAgIHJldHVybiByZWR1Y2VyKG9iaiwgb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCwgNCksIG1lbW8sIGluaXRpYWwpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gKipSZWR1Y2UqKiBidWlsZHMgdXAgYSBzaW5nbGUgcmVzdWx0IGZyb20gYSBsaXN0IG9mIHZhbHVlcywgYWthIGBpbmplY3RgLFxuICAvLyBvciBgZm9sZGxgLlxuICBfLnJlZHVjZSA9IF8uZm9sZGwgPSBfLmluamVjdCA9IGNyZWF0ZVJlZHVjZSgxKTtcblxuICAvLyBUaGUgcmlnaHQtYXNzb2NpYXRpdmUgdmVyc2lvbiBvZiByZWR1Y2UsIGFsc28ga25vd24gYXMgYGZvbGRyYC5cbiAgXy5yZWR1Y2VSaWdodCA9IF8uZm9sZHIgPSBjcmVhdGVSZWR1Y2UoLTEpO1xuXG4gIC8vIFJldHVybiB0aGUgZmlyc3QgdmFsdWUgd2hpY2ggcGFzc2VzIGEgdHJ1dGggdGVzdC4gQWxpYXNlZCBhcyBgZGV0ZWN0YC5cbiAgXy5maW5kID0gXy5kZXRlY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBrZXlGaW5kZXIgPSBpc0FycmF5TGlrZShvYmopID8gXy5maW5kSW5kZXggOiBfLmZpbmRLZXk7XG4gICAgdmFyIGtleSA9IGtleUZpbmRlcihvYmosIHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgaWYgKGtleSAhPT0gdm9pZCAwICYmIGtleSAhPT0gLTEpIHJldHVybiBvYmpba2V5XTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyB0aGF0IHBhc3MgYSB0cnV0aCB0ZXN0LlxuICAvLyBBbGlhc2VkIGFzIGBzZWxlY3RgLlxuICBfLmZpbHRlciA9IF8uc2VsZWN0ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgbGlzdCkpIHJlc3VsdHMucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgZm9yIHdoaWNoIGEgdHJ1dGggdGVzdCBmYWlscy5cbiAgXy5yZWplY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHJldHVybiBfLmZpbHRlcihvYmosIF8ubmVnYXRlKGNiKHByZWRpY2F0ZSkpLCBjb250ZXh0KTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgd2hldGhlciBhbGwgb2YgdGhlIGVsZW1lbnRzIG1hdGNoIGEgdHJ1dGggdGVzdC5cbiAgLy8gQWxpYXNlZCBhcyBgYWxsYC5cbiAgXy5ldmVyeSA9IF8uYWxsID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaiksXG4gICAgICAgIGxlbmd0aCA9IChrZXlzIHx8IG9iaikubGVuZ3RoO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICBpZiAoIXByZWRpY2F0ZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaikpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lIGlmIGF0IGxlYXN0IG9uZSBlbGVtZW50IGluIHRoZSBvYmplY3QgbWF0Y2hlcyBhIHRydXRoIHRlc3QuXG4gIC8vIEFsaWFzZWQgYXMgYGFueWAuXG4gIF8uc29tZSA9IF8uYW55ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaiksXG4gICAgICAgIGxlbmd0aCA9IChrZXlzIHx8IG9iaikubGVuZ3RoO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICBpZiAocHJlZGljYXRlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKSkgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgaWYgdGhlIGFycmF5IG9yIG9iamVjdCBjb250YWlucyBhIGdpdmVuIGl0ZW0gKHVzaW5nIGA9PT1gKS5cbiAgLy8gQWxpYXNlZCBhcyBgaW5jbHVkZXNgIGFuZCBgaW5jbHVkZWAuXG4gIF8uY29udGFpbnMgPSBfLmluY2x1ZGVzID0gXy5pbmNsdWRlID0gZnVuY3Rpb24ob2JqLCBpdGVtLCBmcm9tSW5kZXgsIGd1YXJkKSB7XG4gICAgaWYgKCFpc0FycmF5TGlrZShvYmopKSBvYmogPSBfLnZhbHVlcyhvYmopO1xuICAgIGlmICh0eXBlb2YgZnJvbUluZGV4ICE9ICdudW1iZXInIHx8IGd1YXJkKSBmcm9tSW5kZXggPSAwO1xuICAgIHJldHVybiBfLmluZGV4T2Yob2JqLCBpdGVtLCBmcm9tSW5kZXgpID49IDA7XG4gIH07XG5cbiAgLy8gSW52b2tlIGEgbWV0aG9kICh3aXRoIGFyZ3VtZW50cykgb24gZXZlcnkgaXRlbSBpbiBhIGNvbGxlY3Rpb24uXG4gIF8uaW52b2tlID0gcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihvYmosIHBhdGgsIGFyZ3MpIHtcbiAgICB2YXIgY29udGV4dFBhdGgsIGZ1bmM7XG4gICAgaWYgKF8uaXNGdW5jdGlvbihwYXRoKSkge1xuICAgICAgZnVuYyA9IHBhdGg7XG4gICAgfSBlbHNlIGlmIChfLmlzQXJyYXkocGF0aCkpIHtcbiAgICAgIGNvbnRleHRQYXRoID0gcGF0aC5zbGljZSgwLCAtMSk7XG4gICAgICBwYXRoID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICByZXR1cm4gXy5tYXAob2JqLCBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICB2YXIgbWV0aG9kID0gZnVuYztcbiAgICAgIGlmICghbWV0aG9kKSB7XG4gICAgICAgIGlmIChjb250ZXh0UGF0aCAmJiBjb250ZXh0UGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICBjb250ZXh0ID0gZGVlcEdldChjb250ZXh0LCBjb250ZXh0UGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRleHQgPT0gbnVsbCkgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgbWV0aG9kID0gY29udGV4dFtwYXRoXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXRob2QgPT0gbnVsbCA/IG1ldGhvZCA6IG1ldGhvZC5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgbWFwYDogZmV0Y2hpbmcgYSBwcm9wZXJ0eS5cbiAgXy5wbHVjayA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIF8ubWFwKG9iaiwgXy5wcm9wZXJ0eShrZXkpKTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBmaWx0ZXJgOiBzZWxlY3Rpbmcgb25seSBvYmplY3RzXG4gIC8vIGNvbnRhaW5pbmcgc3BlY2lmaWMgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8ud2hlcmUgPSBmdW5jdGlvbihvYmosIGF0dHJzKSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKG9iaiwgXy5tYXRjaGVyKGF0dHJzKSk7XG4gIH07XG5cbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgZmluZGA6IGdldHRpbmcgdGhlIGZpcnN0IG9iamVjdFxuICAvLyBjb250YWluaW5nIHNwZWNpZmljIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLmZpbmRXaGVyZSA9IGZ1bmN0aW9uKG9iaiwgYXR0cnMpIHtcbiAgICByZXR1cm4gXy5maW5kKG9iaiwgXy5tYXRjaGVyKGF0dHJzKSk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBtYXhpbXVtIGVsZW1lbnQgKG9yIGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxuICBfLm1heCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gLUluZmluaXR5LCBsYXN0Q29tcHV0ZWQgPSAtSW5maW5pdHksXG4gICAgICAgIHZhbHVlLCBjb21wdXRlZDtcbiAgICBpZiAoaXRlcmF0ZWUgPT0gbnVsbCB8fCB0eXBlb2YgaXRlcmF0ZWUgPT0gJ251bWJlcicgJiYgdHlwZW9mIG9ialswXSAhPSAnb2JqZWN0JyAmJiBvYmogIT0gbnVsbCkge1xuICAgICAgb2JqID0gaXNBcnJheUxpa2Uob2JqKSA/IG9iaiA6IF8udmFsdWVzKG9iaik7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gb2JqW2ldO1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSA+IHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odiwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2LCBpbmRleCwgbGlzdCk7XG4gICAgICAgIGlmIChjb21wdXRlZCA+IGxhc3RDb21wdXRlZCB8fCBjb21wdXRlZCA9PT0gLUluZmluaXR5ICYmIHJlc3VsdCA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdjtcbiAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBtaW5pbXVtIGVsZW1lbnQgKG9yIGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxuICBfLm1pbiA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IEluZmluaXR5LFxuICAgICAgICB2YWx1ZSwgY29tcHV0ZWQ7XG4gICAgaWYgKGl0ZXJhdGVlID09IG51bGwgfHwgdHlwZW9mIGl0ZXJhdGVlID09ICdudW1iZXInICYmIHR5cGVvZiBvYmpbMF0gIT0gJ29iamVjdCcgJiYgb2JqICE9IG51bGwpIHtcbiAgICAgIG9iaiA9IGlzQXJyYXlMaWtlKG9iaikgPyBvYmogOiBfLnZhbHVlcyhvYmopO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IG9ialtpXTtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiYgdmFsdWUgPCByZXN1bHQpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHYsIGluZGV4LCBsaXN0KSB7XG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUodiwgaW5kZXgsIGxpc3QpO1xuICAgICAgICBpZiAoY29tcHV0ZWQgPCBsYXN0Q29tcHV0ZWQgfHwgY29tcHV0ZWQgPT09IEluZmluaXR5ICYmIHJlc3VsdCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICByZXN1bHQgPSB2O1xuICAgICAgICAgIGxhc3RDb21wdXRlZCA9IGNvbXB1dGVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBTaHVmZmxlIGEgY29sbGVjdGlvbi5cbiAgXy5zaHVmZmxlID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIF8uc2FtcGxlKG9iaiwgSW5maW5pdHkpO1xuICB9O1xuXG4gIC8vIFNhbXBsZSAqKm4qKiByYW5kb20gdmFsdWVzIGZyb20gYSBjb2xsZWN0aW9uIHVzaW5nIHRoZSBtb2Rlcm4gdmVyc2lvbiBvZiB0aGVcbiAgLy8gW0Zpc2hlci1ZYXRlcyBzaHVmZmxlXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlcuKAk1lhdGVzX3NodWZmbGUpLlxuICAvLyBJZiAqKm4qKiBpcyBub3Qgc3BlY2lmaWVkLCByZXR1cm5zIGEgc2luZ2xlIHJhbmRvbSBlbGVtZW50LlxuICAvLyBUaGUgaW50ZXJuYWwgYGd1YXJkYCBhcmd1bWVudCBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBtYXBgLlxuICBfLnNhbXBsZSA9IGZ1bmN0aW9uKG9iaiwgbiwgZ3VhcmQpIHtcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSB7XG4gICAgICBpZiAoIWlzQXJyYXlMaWtlKG9iaikpIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgICByZXR1cm4gb2JqW18ucmFuZG9tKG9iai5sZW5ndGggLSAxKV07XG4gICAgfVxuICAgIHZhciBzYW1wbGUgPSBpc0FycmF5TGlrZShvYmopID8gXy5jbG9uZShvYmopIDogXy52YWx1ZXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0gZ2V0TGVuZ3RoKHNhbXBsZSk7XG4gICAgbiA9IE1hdGgubWF4KE1hdGgubWluKG4sIGxlbmd0aCksIDApO1xuICAgIHZhciBsYXN0ID0gbGVuZ3RoIC0gMTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbjsgaW5kZXgrKykge1xuICAgICAgdmFyIHJhbmQgPSBfLnJhbmRvbShpbmRleCwgbGFzdCk7XG4gICAgICB2YXIgdGVtcCA9IHNhbXBsZVtpbmRleF07XG4gICAgICBzYW1wbGVbaW5kZXhdID0gc2FtcGxlW3JhbmRdO1xuICAgICAgc2FtcGxlW3JhbmRdID0gdGVtcDtcbiAgICB9XG4gICAgcmV0dXJuIHNhbXBsZS5zbGljZSgwLCBuKTtcbiAgfTtcblxuICAvLyBTb3J0IHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24gcHJvZHVjZWQgYnkgYW4gaXRlcmF0ZWUuXG4gIF8uc29ydEJ5ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgcmV0dXJuIF8ucGx1Y2soXy5tYXAob2JqLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBsaXN0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGluZGV4OiBpbmRleCsrLFxuICAgICAgICBjcml0ZXJpYTogaXRlcmF0ZWUodmFsdWUsIGtleSwgbGlzdClcbiAgICAgIH07XG4gICAgfSkuc29ydChmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgICAgdmFyIGEgPSBsZWZ0LmNyaXRlcmlhO1xuICAgICAgdmFyIGIgPSByaWdodC5jcml0ZXJpYTtcbiAgICAgIGlmIChhICE9PSBiKSB7XG4gICAgICAgIGlmIChhID4gYiB8fCBhID09PSB2b2lkIDApIHJldHVybiAxO1xuICAgICAgICBpZiAoYSA8IGIgfHwgYiA9PT0gdm9pZCAwKSByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGVmdC5pbmRleCAtIHJpZ2h0LmluZGV4O1xuICAgIH0pLCAndmFsdWUnKTtcbiAgfTtcblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiB1c2VkIGZvciBhZ2dyZWdhdGUgXCJncm91cCBieVwiIG9wZXJhdGlvbnMuXG4gIHZhciBncm91cCA9IGZ1bmN0aW9uKGJlaGF2aW9yLCBwYXJ0aXRpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHBhcnRpdGlvbiA/IFtbXSwgW11dIDoge307XG4gICAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuICAgICAgICB2YXIga2V5ID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBvYmopO1xuICAgICAgICBiZWhhdmlvcihyZXN1bHQsIHZhbHVlLCBrZXkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gR3JvdXBzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24uIFBhc3MgZWl0aGVyIGEgc3RyaW5nIGF0dHJpYnV0ZVxuICAvLyB0byBncm91cCBieSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGNyaXRlcmlvbi5cbiAgXy5ncm91cEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgaWYgKGhhcyhyZXN1bHQsIGtleSkpIHJlc3VsdFtrZXldLnB1c2godmFsdWUpOyBlbHNlIHJlc3VsdFtrZXldID0gW3ZhbHVlXTtcbiAgfSk7XG5cbiAgLy8gSW5kZXhlcyB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uLCBzaW1pbGFyIHRvIGBncm91cEJ5YCwgYnV0IGZvclxuICAvLyB3aGVuIHlvdSBrbm93IHRoYXQgeW91ciBpbmRleCB2YWx1ZXMgd2lsbCBiZSB1bmlxdWUuXG4gIF8uaW5kZXhCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gIH0pO1xuXG4gIC8vIENvdW50cyBpbnN0YW5jZXMgb2YgYW4gb2JqZWN0IHRoYXQgZ3JvdXAgYnkgYSBjZXJ0YWluIGNyaXRlcmlvbi4gUGFzc1xuICAvLyBlaXRoZXIgYSBzdHJpbmcgYXR0cmlidXRlIHRvIGNvdW50IGJ5LCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbiAgLy8gY3JpdGVyaW9uLlxuICBfLmNvdW50QnkgPSBncm91cChmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICBpZiAoaGFzKHJlc3VsdCwga2V5KSkgcmVzdWx0W2tleV0rKzsgZWxzZSByZXN1bHRba2V5XSA9IDE7XG4gIH0pO1xuXG4gIHZhciByZVN0clN5bWJvbCA9IC9bXlxcdWQ4MDAtXFx1ZGZmZl18W1xcdWQ4MDAtXFx1ZGJmZl1bXFx1ZGMwMC1cXHVkZmZmXXxbXFx1ZDgwMC1cXHVkZmZmXS9nO1xuICAvLyBTYWZlbHkgY3JlYXRlIGEgcmVhbCwgbGl2ZSBhcnJheSBmcm9tIGFueXRoaW5nIGl0ZXJhYmxlLlxuICBfLnRvQXJyYXkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIFtdO1xuICAgIGlmIChfLmlzQXJyYXkob2JqKSkgcmV0dXJuIHNsaWNlLmNhbGwob2JqKTtcbiAgICBpZiAoXy5pc1N0cmluZyhvYmopKSB7XG4gICAgICAvLyBLZWVwIHN1cnJvZ2F0ZSBwYWlyIGNoYXJhY3RlcnMgdG9nZXRoZXJcbiAgICAgIHJldHVybiBvYmoubWF0Y2gocmVTdHJTeW1ib2wpO1xuICAgIH1cbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkgcmV0dXJuIF8ubWFwKG9iaiwgXy5pZGVudGl0eSk7XG4gICAgcmV0dXJuIF8udmFsdWVzKG9iaik7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gYW4gb2JqZWN0LlxuICBfLnNpemUgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiAwO1xuICAgIHJldHVybiBpc0FycmF5TGlrZShvYmopID8gb2JqLmxlbmd0aCA6IF8ua2V5cyhvYmopLmxlbmd0aDtcbiAgfTtcblxuICAvLyBTcGxpdCBhIGNvbGxlY3Rpb24gaW50byB0d28gYXJyYXlzOiBvbmUgd2hvc2UgZWxlbWVudHMgYWxsIHNhdGlzZnkgdGhlIGdpdmVuXG4gIC8vIHByZWRpY2F0ZSwgYW5kIG9uZSB3aG9zZSBlbGVtZW50cyBhbGwgZG8gbm90IHNhdGlzZnkgdGhlIHByZWRpY2F0ZS5cbiAgXy5wYXJ0aXRpb24gPSBncm91cChmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBwYXNzKSB7XG4gICAgcmVzdWx0W3Bhc3MgPyAwIDogMV0ucHVzaCh2YWx1ZSk7XG4gIH0sIHRydWUpO1xuXG4gIC8vIEFycmF5IEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS1cblxuICAvLyBHZXQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYW4gYXJyYXkuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gdGhlIGZpcnN0IE5cbiAgLy8gdmFsdWVzIGluIHRoZSBhcnJheS4gQWxpYXNlZCBhcyBgaGVhZGAgYW5kIGB0YWtlYC4gVGhlICoqZ3VhcmQqKiBjaGVja1xuICAvLyBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBfLm1hcGAuXG4gIF8uZmlyc3QgPSBfLmhlYWQgPSBfLnRha2UgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCB8fCBhcnJheS5sZW5ndGggPCAxKSByZXR1cm4gbiA9PSBudWxsID8gdm9pZCAwIDogW107XG4gICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkgcmV0dXJuIGFycmF5WzBdO1xuICAgIHJldHVybiBfLmluaXRpYWwoYXJyYXksIGFycmF5Lmxlbmd0aCAtIG4pO1xuICB9O1xuXG4gIC8vIFJldHVybnMgZXZlcnl0aGluZyBidXQgdGhlIGxhc3QgZW50cnkgb2YgdGhlIGFycmF5LiBFc3BlY2lhbGx5IHVzZWZ1bCBvblxuICAvLyB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiBhbGwgdGhlIHZhbHVlcyBpblxuICAvLyB0aGUgYXJyYXksIGV4Y2x1ZGluZyB0aGUgbGFzdCBOLlxuICBfLmluaXRpYWwgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgMCwgTWF0aC5tYXgoMCwgYXJyYXkubGVuZ3RoIC0gKG4gPT0gbnVsbCB8fCBndWFyZCA/IDEgOiBuKSkpO1xuICB9O1xuXG4gIC8vIEdldCB0aGUgbGFzdCBlbGVtZW50IG9mIGFuIGFycmF5LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIHRoZSBsYXN0IE5cbiAgLy8gdmFsdWVzIGluIHRoZSBhcnJheS5cbiAgXy5sYXN0ID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwgfHwgYXJyYXkubGVuZ3RoIDwgMSkgcmV0dXJuIG4gPT0gbnVsbCA/IHZvaWQgMCA6IFtdO1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gXy5yZXN0KGFycmF5LCBNYXRoLm1heCgwLCBhcnJheS5sZW5ndGggLSBuKSk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgZmlyc3QgZW50cnkgb2YgdGhlIGFycmF5LiBBbGlhc2VkIGFzIGB0YWlsYCBhbmQgYGRyb3BgLlxuICAvLyBFc3BlY2lhbGx5IHVzZWZ1bCBvbiB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyBhbiAqKm4qKiB3aWxsIHJldHVyblxuICAvLyB0aGUgcmVzdCBOIHZhbHVlcyBpbiB0aGUgYXJyYXkuXG4gIF8ucmVzdCA9IF8udGFpbCA9IF8uZHJvcCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCBuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbik7XG4gIH07XG5cbiAgLy8gVHJpbSBvdXQgYWxsIGZhbHN5IHZhbHVlcyBmcm9tIGFuIGFycmF5LlxuICBfLmNvbXBhY3QgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgQm9vbGVhbik7XG4gIH07XG5cbiAgLy8gSW50ZXJuYWwgaW1wbGVtZW50YXRpb24gb2YgYSByZWN1cnNpdmUgYGZsYXR0ZW5gIGZ1bmN0aW9uLlxuICB2YXIgZmxhdHRlbiA9IGZ1bmN0aW9uKGlucHV0LCBzaGFsbG93LCBzdHJpY3QsIG91dHB1dCkge1xuICAgIG91dHB1dCA9IG91dHB1dCB8fCBbXTtcbiAgICB2YXIgaWR4ID0gb3V0cHV0Lmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGlucHV0KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSBpbnB1dFtpXTtcbiAgICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkgJiYgKF8uaXNBcnJheSh2YWx1ZSkgfHwgXy5pc0FyZ3VtZW50cyh2YWx1ZSkpKSB7XG4gICAgICAgIC8vIEZsYXR0ZW4gY3VycmVudCBsZXZlbCBvZiBhcnJheSBvciBhcmd1bWVudHMgb2JqZWN0LlxuICAgICAgICBpZiAoc2hhbGxvdykge1xuICAgICAgICAgIHZhciBqID0gMCwgbGVuID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChqIDwgbGVuKSBvdXRwdXRbaWR4KytdID0gdmFsdWVbaisrXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmbGF0dGVuKHZhbHVlLCBzaGFsbG93LCBzdHJpY3QsIG91dHB1dCk7XG4gICAgICAgICAgaWR4ID0gb3V0cHV0Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghc3RyaWN0KSB7XG4gICAgICAgIG91dHB1dFtpZHgrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcblxuICAvLyBGbGF0dGVuIG91dCBhbiBhcnJheSwgZWl0aGVyIHJlY3Vyc2l2ZWx5IChieSBkZWZhdWx0KSwgb3IganVzdCBvbmUgbGV2ZWwuXG4gIF8uZmxhdHRlbiA9IGZ1bmN0aW9uKGFycmF5LCBzaGFsbG93KSB7XG4gICAgcmV0dXJuIGZsYXR0ZW4oYXJyYXksIHNoYWxsb3csIGZhbHNlKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSB2ZXJzaW9uIG9mIHRoZSBhcnJheSB0aGF0IGRvZXMgbm90IGNvbnRhaW4gdGhlIHNwZWNpZmllZCB2YWx1ZShzKS5cbiAgXy53aXRob3V0ID0gcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihhcnJheSwgb3RoZXJBcnJheXMpIHtcbiAgICByZXR1cm4gXy5kaWZmZXJlbmNlKGFycmF5LCBvdGhlckFycmF5cyk7XG4gIH0pO1xuXG4gIC8vIFByb2R1Y2UgYSBkdXBsaWNhdGUtZnJlZSB2ZXJzaW9uIG9mIHRoZSBhcnJheS4gSWYgdGhlIGFycmF5IGhhcyBhbHJlYWR5XG4gIC8vIGJlZW4gc29ydGVkLCB5b3UgaGF2ZSB0aGUgb3B0aW9uIG9mIHVzaW5nIGEgZmFzdGVyIGFsZ29yaXRobS5cbiAgLy8gVGhlIGZhc3RlciBhbGdvcml0aG0gd2lsbCBub3Qgd29yayB3aXRoIGFuIGl0ZXJhdGVlIGlmIHRoZSBpdGVyYXRlZVxuICAvLyBpcyBub3QgYSBvbmUtdG8tb25lIGZ1bmN0aW9uLCBzbyBwcm92aWRpbmcgYW4gaXRlcmF0ZWUgd2lsbCBkaXNhYmxlXG4gIC8vIHRoZSBmYXN0ZXIgYWxnb3JpdGhtLlxuICAvLyBBbGlhc2VkIGFzIGB1bmlxdWVgLlxuICBfLnVuaXEgPSBfLnVuaXF1ZSA9IGZ1bmN0aW9uKGFycmF5LCBpc1NvcnRlZCwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpZiAoIV8uaXNCb29sZWFuKGlzU29ydGVkKSkge1xuICAgICAgY29udGV4dCA9IGl0ZXJhdGVlO1xuICAgICAgaXRlcmF0ZWUgPSBpc1NvcnRlZDtcbiAgICAgIGlzU29ydGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpdGVyYXRlZSAhPSBudWxsKSBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIHNlZW4gPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGFycmF5KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpXSxcbiAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUsIGksIGFycmF5KSA6IHZhbHVlO1xuICAgICAgaWYgKGlzU29ydGVkICYmICFpdGVyYXRlZSkge1xuICAgICAgICBpZiAoIWkgfHwgc2VlbiAhPT0gY29tcHV0ZWQpIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgc2VlbiA9IGNvbXB1dGVkO1xuICAgICAgfSBlbHNlIGlmIChpdGVyYXRlZSkge1xuICAgICAgICBpZiAoIV8uY29udGFpbnMoc2VlbiwgY29tcHV0ZWQpKSB7XG4gICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIV8uY29udGFpbnMocmVzdWx0LCB2YWx1ZSkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGUgdW5pb246IGVhY2ggZGlzdGluY3QgZWxlbWVudCBmcm9tIGFsbCBvZlxuICAvLyB0aGUgcGFzc2VkLWluIGFycmF5cy5cbiAgXy51bmlvbiA9IHJlc3RBcmd1bWVudHMoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgcmV0dXJuIF8udW5pcShmbGF0dGVuKGFycmF5cywgdHJ1ZSwgdHJ1ZSkpO1xuICB9KTtcblxuICAvLyBQcm9kdWNlIGFuIGFycmF5IHRoYXQgY29udGFpbnMgZXZlcnkgaXRlbSBzaGFyZWQgYmV0d2VlbiBhbGwgdGhlXG4gIC8vIHBhc3NlZC1pbiBhcnJheXMuXG4gIF8uaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGFyZ3NMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gYXJyYXlbaV07XG4gICAgICBpZiAoXy5jb250YWlucyhyZXN1bHQsIGl0ZW0pKSBjb250aW51ZTtcbiAgICAgIHZhciBqO1xuICAgICAgZm9yIChqID0gMTsgaiA8IGFyZ3NMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAoIV8uY29udGFpbnMoYXJndW1lbnRzW2pdLCBpdGVtKSkgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoaiA9PT0gYXJnc0xlbmd0aCkgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gVGFrZSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIG9uZSBhcnJheSBhbmQgYSBudW1iZXIgb2Ygb3RoZXIgYXJyYXlzLlxuICAvLyBPbmx5IHRoZSBlbGVtZW50cyBwcmVzZW50IGluIGp1c3QgdGhlIGZpcnN0IGFycmF5IHdpbGwgcmVtYWluLlxuICBfLmRpZmZlcmVuY2UgPSByZXN0QXJndW1lbnRzKGZ1bmN0aW9uKGFycmF5LCByZXN0KSB7XG4gICAgcmVzdCA9IGZsYXR0ZW4ocmVzdCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICByZXR1cm4gIV8uY29udGFpbnMocmVzdCwgdmFsdWUpO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBDb21wbGVtZW50IG9mIF8uemlwLiBVbnppcCBhY2NlcHRzIGFuIGFycmF5IG9mIGFycmF5cyBhbmQgZ3JvdXBzXG4gIC8vIGVhY2ggYXJyYXkncyBlbGVtZW50cyBvbiBzaGFyZWQgaW5kaWNlcy5cbiAgXy51bnppcCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ICYmIF8ubWF4KGFycmF5LCBnZXRMZW5ndGgpLmxlbmd0aCB8fCAwO1xuICAgIHZhciByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgcmVzdWx0W2luZGV4XSA9IF8ucGx1Y2soYXJyYXksIGluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBaaXAgdG9nZXRoZXIgbXVsdGlwbGUgbGlzdHMgaW50byBhIHNpbmdsZSBhcnJheSAtLSBlbGVtZW50cyB0aGF0IHNoYXJlXG4gIC8vIGFuIGluZGV4IGdvIHRvZ2V0aGVyLlxuICBfLnppcCA9IHJlc3RBcmd1bWVudHMoXy51bnppcCk7XG5cbiAgLy8gQ29udmVydHMgbGlzdHMgaW50byBvYmplY3RzLiBQYXNzIGVpdGhlciBhIHNpbmdsZSBhcnJheSBvZiBgW2tleSwgdmFsdWVdYFxuICAvLyBwYWlycywgb3IgdHdvIHBhcmFsbGVsIGFycmF5cyBvZiB0aGUgc2FtZSBsZW5ndGggLS0gb25lIG9mIGtleXMsIGFuZCBvbmUgb2ZcbiAgLy8gdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVzLiBQYXNzaW5nIGJ5IHBhaXJzIGlzIHRoZSByZXZlcnNlIG9mIF8ucGFpcnMuXG4gIF8ub2JqZWN0ID0gZnVuY3Rpb24obGlzdCwgdmFsdWVzKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgobGlzdCk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICByZXN1bHRbbGlzdFtpXV0gPSB2YWx1ZXNbaV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRbbGlzdFtpXVswXV0gPSBsaXN0W2ldWzFdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIEdlbmVyYXRvciBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIGZpbmRJbmRleCBhbmQgZmluZExhc3RJbmRleCBmdW5jdGlvbnMuXG4gIHZhciBjcmVhdGVQcmVkaWNhdGVJbmRleEZpbmRlciA9IGZ1bmN0aW9uKGRpcikge1xuICAgIHJldHVybiBmdW5jdGlvbihhcnJheSwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgICAgdmFyIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7XG4gICAgICB2YXIgaW5kZXggPSBkaXIgPiAwID8gMCA6IGxlbmd0aCAtIDE7XG4gICAgICBmb3IgKDsgaW5kZXggPj0gMCAmJiBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gZGlyKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBpbmRleCBvbiBhbiBhcnJheS1saWtlIHRoYXQgcGFzc2VzIGEgcHJlZGljYXRlIHRlc3QuXG4gIF8uZmluZEluZGV4ID0gY3JlYXRlUHJlZGljYXRlSW5kZXhGaW5kZXIoMSk7XG4gIF8uZmluZExhc3RJbmRleCA9IGNyZWF0ZVByZWRpY2F0ZUluZGV4RmluZGVyKC0xKTtcblxuICAvLyBVc2UgYSBjb21wYXJhdG9yIGZ1bmN0aW9uIHRvIGZpZ3VyZSBvdXQgdGhlIHNtYWxsZXN0IGluZGV4IGF0IHdoaWNoXG4gIC8vIGFuIG9iamVjdCBzaG91bGQgYmUgaW5zZXJ0ZWQgc28gYXMgdG8gbWFpbnRhaW4gb3JkZXIuIFVzZXMgYmluYXJ5IHNlYXJjaC5cbiAgXy5zb3J0ZWRJbmRleCA9IGZ1bmN0aW9uKGFycmF5LCBvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCwgMSk7XG4gICAgdmFyIHZhbHVlID0gaXRlcmF0ZWUob2JqKTtcbiAgICB2YXIgbG93ID0gMCwgaGlnaCA9IGdldExlbmd0aChhcnJheSk7XG4gICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgIHZhciBtaWQgPSBNYXRoLmZsb29yKChsb3cgKyBoaWdoKSAvIDIpO1xuICAgICAgaWYgKGl0ZXJhdGVlKGFycmF5W21pZF0pIDwgdmFsdWUpIGxvdyA9IG1pZCArIDE7IGVsc2UgaGlnaCA9IG1pZDtcbiAgICB9XG4gICAgcmV0dXJuIGxvdztcbiAgfTtcblxuICAvLyBHZW5lcmF0b3IgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZSBpbmRleE9mIGFuZCBsYXN0SW5kZXhPZiBmdW5jdGlvbnMuXG4gIHZhciBjcmVhdGVJbmRleEZpbmRlciA9IGZ1bmN0aW9uKGRpciwgcHJlZGljYXRlRmluZCwgc29ydGVkSW5kZXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGlkeCkge1xuICAgICAgdmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpO1xuICAgICAgaWYgKHR5cGVvZiBpZHggPT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKGRpciA+IDApIHtcbiAgICAgICAgICBpID0gaWR4ID49IDAgPyBpZHggOiBNYXRoLm1heChpZHggKyBsZW5ndGgsIGkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxlbmd0aCA9IGlkeCA+PSAwID8gTWF0aC5taW4oaWR4ICsgMSwgbGVuZ3RoKSA6IGlkeCArIGxlbmd0aCArIDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc29ydGVkSW5kZXggJiYgaWR4ICYmIGxlbmd0aCkge1xuICAgICAgICBpZHggPSBzb3J0ZWRJbmRleChhcnJheSwgaXRlbSk7XG4gICAgICAgIHJldHVybiBhcnJheVtpZHhdID09PSBpdGVtID8gaWR4IDogLTE7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbSAhPT0gaXRlbSkge1xuICAgICAgICBpZHggPSBwcmVkaWNhdGVGaW5kKHNsaWNlLmNhbGwoYXJyYXksIGksIGxlbmd0aCksIF8uaXNOYU4pO1xuICAgICAgICByZXR1cm4gaWR4ID49IDAgPyBpZHggKyBpIDogLTE7XG4gICAgICB9XG4gICAgICBmb3IgKGlkeCA9IGRpciA+IDAgPyBpIDogbGVuZ3RoIC0gMTsgaWR4ID49IDAgJiYgaWR4IDwgbGVuZ3RoOyBpZHggKz0gZGlyKSB7XG4gICAgICAgIGlmIChhcnJheVtpZHhdID09PSBpdGVtKSByZXR1cm4gaWR4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBhbiBpdGVtIGluIGFuIGFycmF5LFxuICAvLyBvciAtMSBpZiB0aGUgaXRlbSBpcyBub3QgaW5jbHVkZWQgaW4gdGhlIGFycmF5LlxuICAvLyBJZiB0aGUgYXJyYXkgaXMgbGFyZ2UgYW5kIGFscmVhZHkgaW4gc29ydCBvcmRlciwgcGFzcyBgdHJ1ZWBcbiAgLy8gZm9yICoqaXNTb3J0ZWQqKiB0byB1c2UgYmluYXJ5IHNlYXJjaC5cbiAgXy5pbmRleE9mID0gY3JlYXRlSW5kZXhGaW5kZXIoMSwgXy5maW5kSW5kZXgsIF8uc29ydGVkSW5kZXgpO1xuICBfLmxhc3RJbmRleE9mID0gY3JlYXRlSW5kZXhGaW5kZXIoLTEsIF8uZmluZExhc3RJbmRleCk7XG5cbiAgLy8gR2VuZXJhdGUgYW4gaW50ZWdlciBBcnJheSBjb250YWluaW5nIGFuIGFyaXRobWV0aWMgcHJvZ3Jlc3Npb24uIEEgcG9ydCBvZlxuICAvLyB0aGUgbmF0aXZlIFB5dGhvbiBgcmFuZ2UoKWAgZnVuY3Rpb24uIFNlZVxuICAvLyBbdGhlIFB5dGhvbiBkb2N1bWVudGF0aW9uXShodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvZnVuY3Rpb25zLmh0bWwjcmFuZ2UpLlxuICBfLnJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICBpZiAoc3RvcCA9PSBudWxsKSB7XG4gICAgICBzdG9wID0gc3RhcnQgfHwgMDtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG4gICAgaWYgKCFzdGVwKSB7XG4gICAgICBzdGVwID0gc3RvcCA8IHN0YXJ0ID8gLTEgOiAxO1xuICAgIH1cblxuICAgIHZhciBsZW5ndGggPSBNYXRoLm1heChNYXRoLmNlaWwoKHN0b3AgLSBzdGFydCkgLyBzdGVwKSwgMCk7XG4gICAgdmFyIHJhbmdlID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyssIHN0YXJ0ICs9IHN0ZXApIHtcbiAgICAgIHJhbmdlW2lkeF0gPSBzdGFydDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH07XG5cbiAgLy8gQ2h1bmsgYSBzaW5nbGUgYXJyYXkgaW50byBtdWx0aXBsZSBhcnJheXMsIGVhY2ggY29udGFpbmluZyBgY291bnRgIG9yIGZld2VyXG4gIC8vIGl0ZW1zLlxuICBfLmNodW5rID0gZnVuY3Rpb24oYXJyYXksIGNvdW50KSB7XG4gICAgaWYgKGNvdW50ID09IG51bGwgfHwgY291bnQgPCAxKSByZXR1cm4gW107XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgICByZXN1bHQucHVzaChzbGljZS5jYWxsKGFycmF5LCBpLCBpICs9IGNvdW50KSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gRnVuY3Rpb24gKGFoZW0pIEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBEZXRlcm1pbmVzIHdoZXRoZXIgdG8gZXhlY3V0ZSBhIGZ1bmN0aW9uIGFzIGEgY29uc3RydWN0b3JcbiAgLy8gb3IgYSBub3JtYWwgZnVuY3Rpb24gd2l0aCB0aGUgcHJvdmlkZWQgYXJndW1lbnRzLlxuICB2YXIgZXhlY3V0ZUJvdW5kID0gZnVuY3Rpb24oc291cmNlRnVuYywgYm91bmRGdW5jLCBjb250ZXh0LCBjYWxsaW5nQ29udGV4dCwgYXJncykge1xuICAgIGlmICghKGNhbGxpbmdDb250ZXh0IGluc3RhbmNlb2YgYm91bmRGdW5jKSkgcmV0dXJuIHNvdXJjZUZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgdmFyIHNlbGYgPSBiYXNlQ3JlYXRlKHNvdXJjZUZ1bmMucHJvdG90eXBlKTtcbiAgICB2YXIgcmVzdWx0ID0gc291cmNlRnVuYy5hcHBseShzZWxmLCBhcmdzKTtcbiAgICBpZiAoXy5pc09iamVjdChyZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgIHJldHVybiBzZWxmO1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIGZ1bmN0aW9uIGJvdW5kIHRvIGEgZ2l2ZW4gb2JqZWN0IChhc3NpZ25pbmcgYHRoaXNgLCBhbmQgYXJndW1lbnRzLFxuICAvLyBvcHRpb25hbGx5KS4gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYEZ1bmN0aW9uLmJpbmRgIGlmXG4gIC8vIGF2YWlsYWJsZS5cbiAgXy5iaW5kID0gcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihmdW5jLCBjb250ZXh0LCBhcmdzKSB7XG4gICAgaWYgKCFfLmlzRnVuY3Rpb24oZnVuYykpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JpbmQgbXVzdCBiZSBjYWxsZWQgb24gYSBmdW5jdGlvbicpO1xuICAgIHZhciBib3VuZCA9IHJlc3RBcmd1bWVudHMoZnVuY3Rpb24oY2FsbEFyZ3MpIHtcbiAgICAgIHJldHVybiBleGVjdXRlQm91bmQoZnVuYywgYm91bmQsIGNvbnRleHQsIHRoaXMsIGFyZ3MuY29uY2F0KGNhbGxBcmdzKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGJvdW5kO1xuICB9KTtcblxuICAvLyBQYXJ0aWFsbHkgYXBwbHkgYSBmdW5jdGlvbiBieSBjcmVhdGluZyBhIHZlcnNpb24gdGhhdCBoYXMgaGFkIHNvbWUgb2YgaXRzXG4gIC8vIGFyZ3VtZW50cyBwcmUtZmlsbGVkLCB3aXRob3V0IGNoYW5naW5nIGl0cyBkeW5hbWljIGB0aGlzYCBjb250ZXh0LiBfIGFjdHNcbiAgLy8gYXMgYSBwbGFjZWhvbGRlciBieSBkZWZhdWx0LCBhbGxvd2luZyBhbnkgY29tYmluYXRpb24gb2YgYXJndW1lbnRzIHRvIGJlXG4gIC8vIHByZS1maWxsZWQuIFNldCBgXy5wYXJ0aWFsLnBsYWNlaG9sZGVyYCBmb3IgYSBjdXN0b20gcGxhY2Vob2xkZXIgYXJndW1lbnQuXG4gIF8ucGFydGlhbCA9IHJlc3RBcmd1bWVudHMoZnVuY3Rpb24oZnVuYywgYm91bmRBcmdzKSB7XG4gICAgdmFyIHBsYWNlaG9sZGVyID0gXy5wYXJ0aWFsLnBsYWNlaG9sZGVyO1xuICAgIHZhciBib3VuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBvc2l0aW9uID0gMCwgbGVuZ3RoID0gYm91bmRBcmdzLmxlbmd0aDtcbiAgICAgIHZhciBhcmdzID0gQXJyYXkobGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJnc1tpXSA9IGJvdW5kQXJnc1tpXSA9PT0gcGxhY2Vob2xkZXIgPyBhcmd1bWVudHNbcG9zaXRpb24rK10gOiBib3VuZEFyZ3NbaV07XG4gICAgICB9XG4gICAgICB3aGlsZSAocG9zaXRpb24gPCBhcmd1bWVudHMubGVuZ3RoKSBhcmdzLnB1c2goYXJndW1lbnRzW3Bvc2l0aW9uKytdKTtcbiAgICAgIHJldHVybiBleGVjdXRlQm91bmQoZnVuYywgYm91bmQsIHRoaXMsIHRoaXMsIGFyZ3MpO1xuICAgIH07XG4gICAgcmV0dXJuIGJvdW5kO1xuICB9KTtcblxuICBfLnBhcnRpYWwucGxhY2Vob2xkZXIgPSBfO1xuXG4gIC8vIEJpbmQgYSBudW1iZXIgb2YgYW4gb2JqZWN0J3MgbWV0aG9kcyB0byB0aGF0IG9iamVjdC4gUmVtYWluaW5nIGFyZ3VtZW50c1xuICAvLyBhcmUgdGhlIG1ldGhvZCBuYW1lcyB0byBiZSBib3VuZC4gVXNlZnVsIGZvciBlbnN1cmluZyB0aGF0IGFsbCBjYWxsYmFja3NcbiAgLy8gZGVmaW5lZCBvbiBhbiBvYmplY3QgYmVsb25nIHRvIGl0LlxuICBfLmJpbmRBbGwgPSByZXN0QXJndW1lbnRzKGZ1bmN0aW9uKG9iaiwga2V5cykge1xuICAgIGtleXMgPSBmbGF0dGVuKGtleXMsIGZhbHNlLCBmYWxzZSk7XG4gICAgdmFyIGluZGV4ID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKGluZGV4IDwgMSkgdGhyb3cgbmV3IEVycm9yKCdiaW5kQWxsIG11c3QgYmUgcGFzc2VkIGZ1bmN0aW9uIG5hbWVzJyk7XG4gICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2luZGV4XTtcbiAgICAgIG9ialtrZXldID0gXy5iaW5kKG9ialtrZXldLCBvYmopO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gTWVtb2l6ZSBhbiBleHBlbnNpdmUgZnVuY3Rpb24gYnkgc3RvcmluZyBpdHMgcmVzdWx0cy5cbiAgXy5tZW1vaXplID0gZnVuY3Rpb24oZnVuYywgaGFzaGVyKSB7XG4gICAgdmFyIG1lbW9pemUgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHZhciBjYWNoZSA9IG1lbW9pemUuY2FjaGU7XG4gICAgICB2YXIgYWRkcmVzcyA9ICcnICsgKGhhc2hlciA/IGhhc2hlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDoga2V5KTtcbiAgICAgIGlmICghaGFzKGNhY2hlLCBhZGRyZXNzKSkgY2FjaGVbYWRkcmVzc10gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gY2FjaGVbYWRkcmVzc107XG4gICAgfTtcbiAgICBtZW1vaXplLmNhY2hlID0ge307XG4gICAgcmV0dXJuIG1lbW9pemU7XG4gIH07XG5cbiAgLy8gRGVsYXlzIGEgZnVuY3Rpb24gZm9yIHRoZSBnaXZlbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLCBhbmQgdGhlbiBjYWxsc1xuICAvLyBpdCB3aXRoIHRoZSBhcmd1bWVudHMgc3VwcGxpZWQuXG4gIF8uZGVsYXkgPSByZXN0QXJndW1lbnRzKGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIGFyZ3MpIHtcbiAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0sIHdhaXQpO1xuICB9KTtcblxuICAvLyBEZWZlcnMgYSBmdW5jdGlvbiwgc2NoZWR1bGluZyBpdCB0byBydW4gYWZ0ZXIgdGhlIGN1cnJlbnQgY2FsbCBzdGFjayBoYXNcbiAgLy8gY2xlYXJlZC5cbiAgXy5kZWZlciA9IF8ucGFydGlhbChfLmRlbGF5LCBfLCAxKTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIHdoZW4gaW52b2tlZCwgd2lsbCBvbmx5IGJlIHRyaWdnZXJlZCBhdCBtb3N0IG9uY2VcbiAgLy8gZHVyaW5nIGEgZ2l2ZW4gd2luZG93IG9mIHRpbWUuIE5vcm1hbGx5LCB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHdpbGwgcnVuXG4gIC8vIGFzIG11Y2ggYXMgaXQgY2FuLCB3aXRob3V0IGV2ZXIgZ29pbmcgbW9yZSB0aGFuIG9uY2UgcGVyIGB3YWl0YCBkdXJhdGlvbjtcbiAgLy8gYnV0IGlmIHlvdSdkIGxpa2UgdG8gZGlzYWJsZSB0aGUgZXhlY3V0aW9uIG9uIHRoZSBsZWFkaW5nIGVkZ2UsIHBhc3NcbiAgLy8gYHtsZWFkaW5nOiBmYWxzZX1gLiBUbyBkaXNhYmxlIGV4ZWN1dGlvbiBvbiB0aGUgdHJhaWxpbmcgZWRnZSwgZGl0dG8uXG4gIF8udGhyb3R0bGUgPSBmdW5jdGlvbihmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgdmFyIHRpbWVvdXQsIGNvbnRleHQsIGFyZ3MsIHJlc3VsdDtcbiAgICB2YXIgcHJldmlvdXMgPSAwO1xuICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuXG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICBwcmV2aW91cyA9IG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UgPyAwIDogXy5ub3coKTtcbiAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgIH07XG5cbiAgICB2YXIgdGhyb3R0bGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbm93ID0gXy5ub3coKTtcbiAgICAgIGlmICghcHJldmlvdXMgJiYgb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSkgcHJldmlvdXMgPSBub3c7XG4gICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICBpZiAocmVtYWluaW5nIDw9IDAgfHwgcmVtYWluaW5nID4gd2FpdCkge1xuICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91cyA9IG5vdztcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKCF0aW1lb3V0ICYmIG9wdGlvbnMudHJhaWxpbmcgIT09IGZhbHNlKSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCByZW1haW5pbmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgdGhyb3R0bGVkLmNhbmNlbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgcHJldmlvdXMgPSAwO1xuICAgICAgdGltZW91dCA9IGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRocm90dGxlZDtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIGFzIGxvbmcgYXMgaXQgY29udGludWVzIHRvIGJlIGludm9rZWQsIHdpbGwgbm90XG4gIC8vIGJlIHRyaWdnZXJlZC4gVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGl0IHN0b3BzIGJlaW5nIGNhbGxlZCBmb3JcbiAgLy8gTiBtaWxsaXNlY29uZHMuIElmIGBpbW1lZGlhdGVgIGlzIHBhc3NlZCwgdHJpZ2dlciB0aGUgZnVuY3Rpb24gb24gdGhlXG4gIC8vIGxlYWRpbmcgZWRnZSwgaW5zdGVhZCBvZiB0aGUgdHJhaWxpbmcuXG4gIF8uZGVib3VuY2UgPSBmdW5jdGlvbihmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHtcbiAgICB2YXIgdGltZW91dCwgcmVzdWx0O1xuXG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oY29udGV4dCwgYXJncykge1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICBpZiAoYXJncykgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB9O1xuXG4gICAgdmFyIGRlYm91bmNlZCA9IHJlc3RBcmd1bWVudHMoZnVuY3Rpb24oYXJncykge1xuICAgICAgaWYgKHRpbWVvdXQpIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIGlmIChpbW1lZGlhdGUpIHtcbiAgICAgICAgdmFyIGNhbGxOb3cgPSAhdGltZW91dDtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICAgICAgICBpZiAoY2FsbE5vdykgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbWVvdXQgPSBfLmRlbGF5KGxhdGVyLCB3YWl0LCB0aGlzLCBhcmdzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIGRlYm91bmNlZC5jYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgIH07XG5cbiAgICByZXR1cm4gZGVib3VuY2VkO1xuICB9O1xuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGZ1bmN0aW9uIHBhc3NlZCBhcyBhbiBhcmd1bWVudCB0byB0aGUgc2Vjb25kLFxuICAvLyBhbGxvd2luZyB5b3UgdG8gYWRqdXN0IGFyZ3VtZW50cywgcnVuIGNvZGUgYmVmb3JlIGFuZCBhZnRlciwgYW5kXG4gIC8vIGNvbmRpdGlvbmFsbHkgZXhlY3V0ZSB0aGUgb3JpZ2luYWwgZnVuY3Rpb24uXG4gIF8ud3JhcCA9IGZ1bmN0aW9uKGZ1bmMsIHdyYXBwZXIpIHtcbiAgICByZXR1cm4gXy5wYXJ0aWFsKHdyYXBwZXIsIGZ1bmMpO1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBuZWdhdGVkIHZlcnNpb24gb2YgdGhlIHBhc3NlZC1pbiBwcmVkaWNhdGUuXG4gIF8ubmVnYXRlID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICFwcmVkaWNhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGlzIHRoZSBjb21wb3NpdGlvbiBvZiBhIGxpc3Qgb2YgZnVuY3Rpb25zLCBlYWNoXG4gIC8vIGNvbnN1bWluZyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmdW5jdGlvbiB0aGF0IGZvbGxvd3MuXG4gIF8uY29tcG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciBzdGFydCA9IGFyZ3MubGVuZ3RoIC0gMTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaSA9IHN0YXJ0O1xuICAgICAgdmFyIHJlc3VsdCA9IGFyZ3Nbc3RhcnRdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB3aGlsZSAoaS0tKSByZXN1bHQgPSBhcmdzW2ldLmNhbGwodGhpcywgcmVzdWx0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIG9ubHkgYmUgZXhlY3V0ZWQgb24gYW5kIGFmdGVyIHRoZSBOdGggY2FsbC5cbiAgXy5hZnRlciA9IGZ1bmN0aW9uKHRpbWVzLCBmdW5jKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKC0tdGltZXMgPCAxKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIG9ubHkgYmUgZXhlY3V0ZWQgdXAgdG8gKGJ1dCBub3QgaW5jbHVkaW5nKSB0aGUgTnRoIGNhbGwuXG4gIF8uYmVmb3JlID0gZnVuY3Rpb24odGltZXMsIGZ1bmMpIHtcbiAgICB2YXIgbWVtbztcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS10aW1lcyA+IDApIHtcbiAgICAgICAgbWVtbyA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aW1lcyA8PSAxKSBmdW5jID0gbnVsbDtcbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBhdCBtb3N0IG9uZSB0aW1lLCBubyBtYXR0ZXIgaG93XG4gIC8vIG9mdGVuIHlvdSBjYWxsIGl0LiBVc2VmdWwgZm9yIGxhenkgaW5pdGlhbGl6YXRpb24uXG4gIF8ub25jZSA9IF8ucGFydGlhbChfLmJlZm9yZSwgMik7XG5cbiAgXy5yZXN0QXJndW1lbnRzID0gcmVzdEFyZ3VtZW50cztcblxuICAvLyBPYmplY3QgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBLZXlzIGluIElFIDwgOSB0aGF0IHdvbid0IGJlIGl0ZXJhdGVkIGJ5IGBmb3Iga2V5IGluIC4uLmAgYW5kIHRodXMgbWlzc2VkLlxuICB2YXIgaGFzRW51bUJ1ZyA9ICF7dG9TdHJpbmc6IG51bGx9LnByb3BlcnR5SXNFbnVtZXJhYmxlKCd0b1N0cmluZycpO1xuICB2YXIgbm9uRW51bWVyYWJsZVByb3BzID0gWyd2YWx1ZU9mJywgJ2lzUHJvdG90eXBlT2YnLCAndG9TdHJpbmcnLFxuICAgICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICdoYXNPd25Qcm9wZXJ0eScsICd0b0xvY2FsZVN0cmluZyddO1xuXG4gIHZhciBjb2xsZWN0Tm9uRW51bVByb3BzID0gZnVuY3Rpb24ob2JqLCBrZXlzKSB7XG4gICAgdmFyIG5vbkVudW1JZHggPSBub25FbnVtZXJhYmxlUHJvcHMubGVuZ3RoO1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IG9iai5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgcHJvdG8gPSBfLmlzRnVuY3Rpb24oY29uc3RydWN0b3IpICYmIGNvbnN0cnVjdG9yLnByb3RvdHlwZSB8fCBPYmpQcm90bztcblxuICAgIC8vIENvbnN0cnVjdG9yIGlzIGEgc3BlY2lhbCBjYXNlLlxuICAgIHZhciBwcm9wID0gJ2NvbnN0cnVjdG9yJztcbiAgICBpZiAoaGFzKG9iaiwgcHJvcCkgJiYgIV8uY29udGFpbnMoa2V5cywgcHJvcCkpIGtleXMucHVzaChwcm9wKTtcblxuICAgIHdoaWxlIChub25FbnVtSWR4LS0pIHtcbiAgICAgIHByb3AgPSBub25FbnVtZXJhYmxlUHJvcHNbbm9uRW51bUlkeF07XG4gICAgICBpZiAocHJvcCBpbiBvYmogJiYgb2JqW3Byb3BdICE9PSBwcm90b1twcm9wXSAmJiAhXy5jb250YWlucyhrZXlzLCBwcm9wKSkge1xuICAgICAgICBrZXlzLnB1c2gocHJvcCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIFJldHJpZXZlIHRoZSBuYW1lcyBvZiBhbiBvYmplY3QncyBvd24gcHJvcGVydGllcy5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYE9iamVjdC5rZXlzYC5cbiAgXy5rZXlzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBbXTtcbiAgICBpZiAobmF0aXZlS2V5cykgcmV0dXJuIG5hdGl2ZUtleXMob2JqKTtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGlmIChoYXMob2JqLCBrZXkpKSBrZXlzLnB1c2goa2V5KTtcbiAgICAvLyBBaGVtLCBJRSA8IDkuXG4gICAgaWYgKGhhc0VudW1CdWcpIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKTtcbiAgICByZXR1cm4ga2V5cztcbiAgfTtcblxuICAvLyBSZXRyaWV2ZSBhbGwgdGhlIHByb3BlcnR5IG5hbWVzIG9mIGFuIG9iamVjdC5cbiAgXy5hbGxLZXlzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBbXTtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGtleXMucHVzaChrZXkpO1xuICAgIC8vIEFoZW0sIElFIDwgOS5cbiAgICBpZiAoaGFzRW51bUJ1ZykgY29sbGVjdE5vbkVudW1Qcm9wcyhvYmosIGtleXMpO1xuICAgIHJldHVybiBrZXlzO1xuICB9O1xuXG4gIC8vIFJldHJpZXZlIHRoZSB2YWx1ZXMgb2YgYW4gb2JqZWN0J3MgcHJvcGVydGllcy5cbiAgXy52YWx1ZXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgdmFsdWVzID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWx1ZXNbaV0gPSBvYmpba2V5c1tpXV07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH07XG5cbiAgLy8gUmV0dXJucyB0aGUgcmVzdWx0cyBvZiBhcHBseWluZyB0aGUgaXRlcmF0ZWUgdG8gZWFjaCBlbGVtZW50IG9mIHRoZSBvYmplY3QuXG4gIC8vIEluIGNvbnRyYXN0IHRvIF8ubWFwIGl0IHJldHVybnMgYW4gb2JqZWN0LlxuICBfLm1hcE9iamVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopLFxuICAgICAgICBsZW5ndGggPSBrZXlzLmxlbmd0aCxcbiAgICAgICAgcmVzdWx0cyA9IHt9O1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5c1tpbmRleF07XG4gICAgICByZXN1bHRzW2N1cnJlbnRLZXldID0gaXRlcmF0ZWUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBDb252ZXJ0IGFuIG9iamVjdCBpbnRvIGEgbGlzdCBvZiBgW2tleSwgdmFsdWVdYCBwYWlycy5cbiAgLy8gVGhlIG9wcG9zaXRlIG9mIF8ub2JqZWN0LlxuICBfLnBhaXJzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIHBhaXJzID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBwYWlyc1tpXSA9IFtrZXlzW2ldLCBvYmpba2V5c1tpXV1dO1xuICAgIH1cbiAgICByZXR1cm4gcGFpcnM7XG4gIH07XG5cbiAgLy8gSW52ZXJ0IHRoZSBrZXlzIGFuZCB2YWx1ZXMgb2YgYW4gb2JqZWN0LiBUaGUgdmFsdWVzIG11c3QgYmUgc2VyaWFsaXphYmxlLlxuICBfLmludmVydCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHRbb2JqW2tleXNbaV1dXSA9IGtleXNbaV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgc29ydGVkIGxpc3Qgb2YgdGhlIGZ1bmN0aW9uIG5hbWVzIGF2YWlsYWJsZSBvbiB0aGUgb2JqZWN0LlxuICAvLyBBbGlhc2VkIGFzIGBtZXRob2RzYC5cbiAgXy5mdW5jdGlvbnMgPSBfLm1ldGhvZHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKG9ialtrZXldKSkgbmFtZXMucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZXMuc29ydCgpO1xuICB9O1xuXG4gIC8vIEFuIGludGVybmFsIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhc3NpZ25lciBmdW5jdGlvbnMuXG4gIHZhciBjcmVhdGVBc3NpZ25lciA9IGZ1bmN0aW9uKGtleXNGdW5jLCBkZWZhdWx0cykge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgaWYgKGRlZmF1bHRzKSBvYmogPSBPYmplY3Qob2JqKTtcbiAgICAgIGlmIChsZW5ndGggPCAyIHx8IG9iaiA9PSBudWxsKSByZXR1cm4gb2JqO1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2luZGV4XSxcbiAgICAgICAgICAgIGtleXMgPSBrZXlzRnVuYyhzb3VyY2UpLFxuICAgICAgICAgICAgbCA9IGtleXMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmICghZGVmYXVsdHMgfHwgb2JqW2tleV0gPT09IHZvaWQgMCkgb2JqW2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEV4dGVuZCBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgcHJvcGVydGllcyBpbiBwYXNzZWQtaW4gb2JqZWN0KHMpLlxuICBfLmV4dGVuZCA9IGNyZWF0ZUFzc2lnbmVyKF8uYWxsS2V5cyk7XG5cbiAgLy8gQXNzaWducyBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgb3duIHByb3BlcnRpZXMgaW4gdGhlIHBhc3NlZC1pbiBvYmplY3QocykuXG4gIC8vIChodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvYXNzaWduKVxuICBfLmV4dGVuZE93biA9IF8uYXNzaWduID0gY3JlYXRlQXNzaWduZXIoXy5rZXlzKTtcblxuICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBrZXkgb24gYW4gb2JqZWN0IHRoYXQgcGFzc2VzIGEgcHJlZGljYXRlIHRlc3QuXG4gIF8uZmluZEtleSA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopLCBrZXk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAocHJlZGljYXRlKG9ialtrZXldLCBrZXksIG9iaikpIHJldHVybiBrZXk7XG4gICAgfVxuICB9O1xuXG4gIC8vIEludGVybmFsIHBpY2sgaGVscGVyIGZ1bmN0aW9uIHRvIGRldGVybWluZSBpZiBgb2JqYCBoYXMga2V5IGBrZXlgLlxuICB2YXIga2V5SW5PYmogPSBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmopIHtcbiAgICByZXR1cm4ga2V5IGluIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgb25seSBjb250YWluaW5nIHRoZSB3aGl0ZWxpc3RlZCBwcm9wZXJ0aWVzLlxuICBfLnBpY2sgPSByZXN0QXJndW1lbnRzKGZ1bmN0aW9uKG9iaiwga2V5cykge1xuICAgIHZhciByZXN1bHQgPSB7fSwgaXRlcmF0ZWUgPSBrZXlzWzBdO1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdDtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKGl0ZXJhdGVlKSkge1xuICAgICAgaWYgKGtleXMubGVuZ3RoID4gMSkgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBrZXlzWzFdKTtcbiAgICAgIGtleXMgPSBfLmFsbEtleXMob2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaXRlcmF0ZWUgPSBrZXlJbk9iajtcbiAgICAgIGtleXMgPSBmbGF0dGVuKGtleXMsIGZhbHNlLCBmYWxzZSk7XG4gICAgICBvYmogPSBPYmplY3Qob2JqKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgdmFyIHZhbHVlID0gb2JqW2tleV07XG4gICAgICBpZiAoaXRlcmF0ZWUodmFsdWUsIGtleSwgb2JqKSkgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSk7XG5cbiAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IHdpdGhvdXQgdGhlIGJsYWNrbGlzdGVkIHByb3BlcnRpZXMuXG4gIF8ub21pdCA9IHJlc3RBcmd1bWVudHMoZnVuY3Rpb24ob2JqLCBrZXlzKSB7XG4gICAgdmFyIGl0ZXJhdGVlID0ga2V5c1swXSwgY29udGV4dDtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKGl0ZXJhdGVlKSkge1xuICAgICAgaXRlcmF0ZWUgPSBfLm5lZ2F0ZShpdGVyYXRlZSk7XG4gICAgICBpZiAoa2V5cy5sZW5ndGggPiAxKSBjb250ZXh0ID0ga2V5c1sxXTtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5cyA9IF8ubWFwKGZsYXR0ZW4oa2V5cywgZmFsc2UsIGZhbHNlKSwgU3RyaW5nKTtcbiAgICAgIGl0ZXJhdGVlID0gZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICByZXR1cm4gIV8uY29udGFpbnMoa2V5cywga2V5KTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBfLnBpY2sob2JqLCBpdGVyYXRlZSwgY29udGV4dCk7XG4gIH0pO1xuXG4gIC8vIEZpbGwgaW4gYSBnaXZlbiBvYmplY3Qgd2l0aCBkZWZhdWx0IHByb3BlcnRpZXMuXG4gIF8uZGVmYXVsdHMgPSBjcmVhdGVBc3NpZ25lcihfLmFsbEtleXMsIHRydWUpO1xuXG4gIC8vIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGUgZ2l2ZW4gcHJvdG90eXBlIG9iamVjdC5cbiAgLy8gSWYgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIGFyZSBwcm92aWRlZCB0aGVuIHRoZXkgd2lsbCBiZSBhZGRlZCB0byB0aGVcbiAgLy8gY3JlYXRlZCBvYmplY3QuXG4gIF8uY3JlYXRlID0gZnVuY3Rpb24ocHJvdG90eXBlLCBwcm9wcykge1xuICAgIHZhciByZXN1bHQgPSBiYXNlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgaWYgKHByb3BzKSBfLmV4dGVuZE93bihyZXN1bHQsIHByb3BzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIChzaGFsbG93LWNsb25lZCkgZHVwbGljYXRlIG9mIGFuIG9iamVjdC5cbiAgXy5jbG9uZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gb2JqO1xuICAgIHJldHVybiBfLmlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogXy5leHRlbmQoe30sIG9iaik7XG4gIH07XG5cbiAgLy8gSW52b2tlcyBpbnRlcmNlcHRvciB3aXRoIHRoZSBvYmosIGFuZCB0aGVuIHJldHVybnMgb2JqLlxuICAvLyBUaGUgcHJpbWFyeSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIFwidGFwIGludG9cIiBhIG1ldGhvZCBjaGFpbiwgaW5cbiAgLy8gb3JkZXIgdG8gcGVyZm9ybSBvcGVyYXRpb25zIG9uIGludGVybWVkaWF0ZSByZXN1bHRzIHdpdGhpbiB0aGUgY2hhaW4uXG4gIF8udGFwID0gZnVuY3Rpb24ob2JqLCBpbnRlcmNlcHRvcikge1xuICAgIGludGVyY2VwdG9yKG9iaik7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm5zIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHNldCBvZiBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5pc01hdGNoID0gZnVuY3Rpb24ob2JqZWN0LCBhdHRycykge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKGF0dHJzKSwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSByZXR1cm4gIWxlbmd0aDtcbiAgICB2YXIgb2JqID0gT2JqZWN0KG9iamVjdCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoYXR0cnNba2V5XSAhPT0gb2JqW2tleV0gfHwgIShrZXkgaW4gb2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuXG4gIC8vIEludGVybmFsIHJlY3Vyc2l2ZSBjb21wYXJpc29uIGZ1bmN0aW9uIGZvciBgaXNFcXVhbGAuXG4gIHZhciBlcSwgZGVlcEVxO1xuICBlcSA9IGZ1bmN0aW9uKGEsIGIsIGFTdGFjaywgYlN0YWNrKSB7XG4gICAgLy8gSWRlbnRpY2FsIG9iamVjdHMgYXJlIGVxdWFsLiBgMCA9PT0gLTBgLCBidXQgdGhleSBhcmVuJ3QgaWRlbnRpY2FsLlxuICAgIC8vIFNlZSB0aGUgW0hhcm1vbnkgYGVnYWxgIHByb3Bvc2FsXShodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1oYXJtb255OmVnYWwpLlxuICAgIGlmIChhID09PSBiKSByZXR1cm4gYSAhPT0gMCB8fCAxIC8gYSA9PT0gMSAvIGI7XG4gICAgLy8gYG51bGxgIG9yIGB1bmRlZmluZWRgIG9ubHkgZXF1YWwgdG8gaXRzZWxmIChzdHJpY3QgY29tcGFyaXNvbikuXG4gICAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICAvLyBgTmFOYHMgYXJlIGVxdWl2YWxlbnQsIGJ1dCBub24tcmVmbGV4aXZlLlxuICAgIGlmIChhICE9PSBhKSByZXR1cm4gYiAhPT0gYjtcbiAgICAvLyBFeGhhdXN0IHByaW1pdGl2ZSBjaGVja3NcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBhO1xuICAgIGlmICh0eXBlICE9PSAnZnVuY3Rpb24nICYmIHR5cGUgIT09ICdvYmplY3QnICYmIHR5cGVvZiBiICE9ICdvYmplY3QnKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIGRlZXBFcShhLCBiLCBhU3RhY2ssIGJTdGFjayk7XG4gIH07XG5cbiAgLy8gSW50ZXJuYWwgcmVjdXJzaXZlIGNvbXBhcmlzb24gZnVuY3Rpb24gZm9yIGBpc0VxdWFsYC5cbiAgZGVlcEVxID0gZnVuY3Rpb24oYSwgYiwgYVN0YWNrLCBiU3RhY2spIHtcbiAgICAvLyBVbndyYXAgYW55IHdyYXBwZWQgb2JqZWN0cy5cbiAgICBpZiAoYSBpbnN0YW5jZW9mIF8pIGEgPSBhLl93cmFwcGVkO1xuICAgIGlmIChiIGluc3RhbmNlb2YgXykgYiA9IGIuX3dyYXBwZWQ7XG4gICAgLy8gQ29tcGFyZSBgW1tDbGFzc11dYCBuYW1lcy5cbiAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbChhKTtcbiAgICBpZiAoY2xhc3NOYW1lICE9PSB0b1N0cmluZy5jYWxsKGIpKSByZXR1cm4gZmFsc2U7XG4gICAgc3dpdGNoIChjbGFzc05hbWUpIHtcbiAgICAgIC8vIFN0cmluZ3MsIG51bWJlcnMsIHJlZ3VsYXIgZXhwcmVzc2lvbnMsIGRhdGVzLCBhbmQgYm9vbGVhbnMgYXJlIGNvbXBhcmVkIGJ5IHZhbHVlLlxuICAgICAgY2FzZSAnW29iamVjdCBSZWdFeHBdJzpcbiAgICAgIC8vIFJlZ0V4cHMgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncyBmb3IgY29tcGFyaXNvbiAoTm90ZTogJycgKyAvYS9pID09PSAnL2EvaScpXG4gICAgICBjYXNlICdbb2JqZWN0IFN0cmluZ10nOlxuICAgICAgICAvLyBQcmltaXRpdmVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIG9iamVjdCB3cmFwcGVycyBhcmUgZXF1aXZhbGVudDsgdGh1cywgYFwiNVwiYCBpc1xuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIGBuZXcgU3RyaW5nKFwiNVwiKWAuXG4gICAgICAgIHJldHVybiAnJyArIGEgPT09ICcnICsgYjtcbiAgICAgIGNhc2UgJ1tvYmplY3QgTnVtYmVyXSc6XG4gICAgICAgIC8vIGBOYU5gcyBhcmUgZXF1aXZhbGVudCwgYnV0IG5vbi1yZWZsZXhpdmUuXG4gICAgICAgIC8vIE9iamVjdChOYU4pIGlzIGVxdWl2YWxlbnQgdG8gTmFOLlxuICAgICAgICBpZiAoK2EgIT09ICthKSByZXR1cm4gK2IgIT09ICtiO1xuICAgICAgICAvLyBBbiBgZWdhbGAgY29tcGFyaXNvbiBpcyBwZXJmb3JtZWQgZm9yIG90aGVyIG51bWVyaWMgdmFsdWVzLlxuICAgICAgICByZXR1cm4gK2EgPT09IDAgPyAxIC8gK2EgPT09IDEgLyBiIDogK2EgPT09ICtiO1xuICAgICAgY2FzZSAnW29iamVjdCBEYXRlXSc6XG4gICAgICBjYXNlICdbb2JqZWN0IEJvb2xlYW5dJzpcbiAgICAgICAgLy8gQ29lcmNlIGRhdGVzIGFuZCBib29sZWFucyB0byBudW1lcmljIHByaW1pdGl2ZSB2YWx1ZXMuIERhdGVzIGFyZSBjb21wYXJlZCBieSB0aGVpclxuICAgICAgICAvLyBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnMuIE5vdGUgdGhhdCBpbnZhbGlkIGRhdGVzIHdpdGggbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zXG4gICAgICAgIC8vIG9mIGBOYU5gIGFyZSBub3QgZXF1aXZhbGVudC5cbiAgICAgICAgcmV0dXJuICthID09PSArYjtcbiAgICAgIGNhc2UgJ1tvYmplY3QgU3ltYm9sXSc6XG4gICAgICAgIHJldHVybiBTeW1ib2xQcm90by52YWx1ZU9mLmNhbGwoYSkgPT09IFN5bWJvbFByb3RvLnZhbHVlT2YuY2FsbChiKTtcbiAgICB9XG5cbiAgICB2YXIgYXJlQXJyYXlzID0gY2xhc3NOYW1lID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIGlmICghYXJlQXJyYXlzKSB7XG4gICAgICBpZiAodHlwZW9mIGEgIT0gJ29iamVjdCcgfHwgdHlwZW9mIGIgIT0gJ29iamVjdCcpIHJldHVybiBmYWxzZTtcblxuICAgICAgLy8gT2JqZWN0cyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVpdmFsZW50LCBidXQgYE9iamVjdGBzIG9yIGBBcnJheWBzXG4gICAgICAvLyBmcm9tIGRpZmZlcmVudCBmcmFtZXMgYXJlLlxuICAgICAgdmFyIGFDdG9yID0gYS5jb25zdHJ1Y3RvciwgYkN0b3IgPSBiLmNvbnN0cnVjdG9yO1xuICAgICAgaWYgKGFDdG9yICE9PSBiQ3RvciAmJiAhKF8uaXNGdW5jdGlvbihhQ3RvcikgJiYgYUN0b3IgaW5zdGFuY2VvZiBhQ3RvciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uaXNGdW5jdGlvbihiQ3RvcikgJiYgYkN0b3IgaW5zdGFuY2VvZiBiQ3RvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgKCdjb25zdHJ1Y3RvcicgaW4gYSAmJiAnY29uc3RydWN0b3InIGluIGIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQXNzdW1lIGVxdWFsaXR5IGZvciBjeWNsaWMgc3RydWN0dXJlcy4gVGhlIGFsZ29yaXRobSBmb3IgZGV0ZWN0aW5nIGN5Y2xpY1xuICAgIC8vIHN0cnVjdHVyZXMgaXMgYWRhcHRlZCBmcm9tIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMsIGFic3RyYWN0IG9wZXJhdGlvbiBgSk9gLlxuXG4gICAgLy8gSW5pdGlhbGl6aW5nIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgIC8vIEl0J3MgZG9uZSBoZXJlIHNpbmNlIHdlIG9ubHkgbmVlZCB0aGVtIGZvciBvYmplY3RzIGFuZCBhcnJheXMgY29tcGFyaXNvbi5cbiAgICBhU3RhY2sgPSBhU3RhY2sgfHwgW107XG4gICAgYlN0YWNrID0gYlN0YWNrIHx8IFtdO1xuICAgIHZhciBsZW5ndGggPSBhU3RhY2subGVuZ3RoO1xuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgLy8gTGluZWFyIHNlYXJjaC4gUGVyZm9ybWFuY2UgaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbCB0byB0aGUgbnVtYmVyIG9mXG4gICAgICAvLyB1bmlxdWUgbmVzdGVkIHN0cnVjdHVyZXMuXG4gICAgICBpZiAoYVN0YWNrW2xlbmd0aF0gPT09IGEpIHJldHVybiBiU3RhY2tbbGVuZ3RoXSA9PT0gYjtcbiAgICB9XG5cbiAgICAvLyBBZGQgdGhlIGZpcnN0IG9iamVjdCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgYVN0YWNrLnB1c2goYSk7XG4gICAgYlN0YWNrLnB1c2goYik7XG5cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICBpZiAoYXJlQXJyYXlzKSB7XG4gICAgICAvLyBDb21wYXJlIGFycmF5IGxlbmd0aHMgdG8gZGV0ZXJtaW5lIGlmIGEgZGVlcCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeS5cbiAgICAgIGxlbmd0aCA9IGEubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIC8vIERlZXAgY29tcGFyZSB0aGUgY29udGVudHMsIGlnbm9yaW5nIG5vbi1udW1lcmljIHByb3BlcnRpZXMuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKCFlcShhW2xlbmd0aF0sIGJbbGVuZ3RoXSwgYVN0YWNrLCBiU3RhY2spKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIERlZXAgY29tcGFyZSBvYmplY3RzLlxuICAgICAgdmFyIGtleXMgPSBfLmtleXMoYSksIGtleTtcbiAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgICAgLy8gRW5zdXJlIHRoYXQgYm90aCBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUgbnVtYmVyIG9mIHByb3BlcnRpZXMgYmVmb3JlIGNvbXBhcmluZyBkZWVwIGVxdWFsaXR5LlxuICAgICAgaWYgKF8ua2V5cyhiKS5sZW5ndGggIT09IGxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIC8vIERlZXAgY29tcGFyZSBlYWNoIG1lbWJlclxuICAgICAgICBrZXkgPSBrZXlzW2xlbmd0aF07XG4gICAgICAgIGlmICghKGhhcyhiLCBrZXkpICYmIGVxKGFba2V5XSwgYltrZXldLCBhU3RhY2ssIGJTdGFjaykpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFJlbW92ZSB0aGUgZmlyc3Qgb2JqZWN0IGZyb20gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgIGFTdGFjay5wb3AoKTtcbiAgICBiU3RhY2sucG9wKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLy8gUGVyZm9ybSBhIGRlZXAgY29tcGFyaXNvbiB0byBjaGVjayBpZiB0d28gb2JqZWN0cyBhcmUgZXF1YWwuXG4gIF8uaXNFcXVhbCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gZXEoYSwgYik7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiBhcnJheSwgc3RyaW5nLCBvciBvYmplY3QgZW1wdHk/XG4gIC8vIEFuIFwiZW1wdHlcIiBvYmplY3QgaGFzIG5vIGVudW1lcmFibGUgb3duLXByb3BlcnRpZXMuXG4gIF8uaXNFbXB0eSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikgJiYgKF8uaXNBcnJheShvYmopIHx8IF8uaXNTdHJpbmcob2JqKSB8fCBfLmlzQXJndW1lbnRzKG9iaikpKSByZXR1cm4gb2JqLmxlbmd0aCA9PT0gMDtcbiAgICByZXR1cm4gXy5rZXlzKG9iaikubGVuZ3RoID09PSAwO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBET00gZWxlbWVudD9cbiAgXy5pc0VsZW1lbnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gISEob2JqICYmIG9iai5ub2RlVHlwZSA9PT0gMSk7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhbiBhcnJheT9cbiAgLy8gRGVsZWdhdGVzIHRvIEVDTUE1J3MgbmF0aXZlIEFycmF5LmlzQXJyYXlcbiAgXy5pc0FycmF5ID0gbmF0aXZlSXNBcnJheSB8fCBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFyaWFibGUgYW4gb2JqZWN0P1xuICBfLmlzT2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2Ygb2JqO1xuICAgIHJldHVybiB0eXBlID09PSAnZnVuY3Rpb24nIHx8IHR5cGUgPT09ICdvYmplY3QnICYmICEhb2JqO1xuICB9O1xuXG4gIC8vIEFkZCBzb21lIGlzVHlwZSBtZXRob2RzOiBpc0FyZ3VtZW50cywgaXNGdW5jdGlvbiwgaXNTdHJpbmcsIGlzTnVtYmVyLCBpc0RhdGUsIGlzUmVnRXhwLCBpc0Vycm9yLCBpc01hcCwgaXNXZWFrTWFwLCBpc1NldCwgaXNXZWFrU2V0LlxuICBfLmVhY2goWydBcmd1bWVudHMnLCAnRnVuY3Rpb24nLCAnU3RyaW5nJywgJ051bWJlcicsICdEYXRlJywgJ1JlZ0V4cCcsICdFcnJvcicsICdTeW1ib2wnLCAnTWFwJywgJ1dlYWtNYXAnLCAnU2V0JywgJ1dlYWtTZXQnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIF9bJ2lzJyArIG5hbWVdID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCAnICsgbmFtZSArICddJztcbiAgICB9O1xuICB9KTtcblxuICAvLyBEZWZpbmUgYSBmYWxsYmFjayB2ZXJzaW9uIG9mIHRoZSBtZXRob2QgaW4gYnJvd3NlcnMgKGFoZW0sIElFIDwgOSksIHdoZXJlXG4gIC8vIHRoZXJlIGlzbid0IGFueSBpbnNwZWN0YWJsZSBcIkFyZ3VtZW50c1wiIHR5cGUuXG4gIGlmICghXy5pc0FyZ3VtZW50cyhhcmd1bWVudHMpKSB7XG4gICAgXy5pc0FyZ3VtZW50cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIGhhcyhvYmosICdjYWxsZWUnKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gT3B0aW1pemUgYGlzRnVuY3Rpb25gIGlmIGFwcHJvcHJpYXRlLiBXb3JrIGFyb3VuZCBzb21lIHR5cGVvZiBidWdzIGluIG9sZCB2OCxcbiAgLy8gSUUgMTEgKCMxNjIxKSwgU2FmYXJpIDggKCMxOTI5KSwgYW5kIFBoYW50b21KUyAoIzIyMzYpLlxuICB2YXIgbm9kZWxpc3QgPSByb290LmRvY3VtZW50ICYmIHJvb3QuZG9jdW1lbnQuY2hpbGROb2RlcztcbiAgaWYgKHR5cGVvZiAvLi8gIT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgSW50OEFycmF5ICE9ICdvYmplY3QnICYmIHR5cGVvZiBub2RlbGlzdCAhPSAnZnVuY3Rpb24nKSB7XG4gICAgXy5pc0Z1bmN0aW9uID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PSAnZnVuY3Rpb24nIHx8IGZhbHNlO1xuICAgIH07XG4gIH1cblxuICAvLyBJcyBhIGdpdmVuIG9iamVjdCBhIGZpbml0ZSBudW1iZXI/XG4gIF8uaXNGaW5pdGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gIV8uaXNTeW1ib2wob2JqKSAmJiBpc0Zpbml0ZShvYmopICYmICFpc05hTihwYXJzZUZsb2F0KG9iaikpO1xuICB9O1xuXG4gIC8vIElzIHRoZSBnaXZlbiB2YWx1ZSBgTmFOYD9cbiAgXy5pc05hTiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBfLmlzTnVtYmVyKG9iaikgJiYgaXNOYU4ob2JqKTtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgYm9vbGVhbj9cbiAgXy5pc0Jvb2xlYW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB0cnVlIHx8IG9iaiA9PT0gZmFsc2UgfHwgdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBCb29sZWFuXSc7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBlcXVhbCB0byBudWxsP1xuICBfLmlzTnVsbCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IG51bGw7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSB1bmRlZmluZWQ/XG4gIF8uaXNVbmRlZmluZWQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB2b2lkIDA7XG4gIH07XG5cbiAgLy8gU2hvcnRjdXQgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBwcm9wZXJ0eSBkaXJlY3RseVxuICAvLyBvbiBpdHNlbGYgKGluIG90aGVyIHdvcmRzLCBub3Qgb24gYSBwcm90b3R5cGUpLlxuICBfLmhhcyA9IGZ1bmN0aW9uKG9iaiwgcGF0aCkge1xuICAgIGlmICghXy5pc0FycmF5KHBhdGgpKSB7XG4gICAgICByZXR1cm4gaGFzKG9iaiwgcGF0aCk7XG4gICAgfVxuICAgIHZhciBsZW5ndGggPSBwYXRoLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gcGF0aFtpXTtcbiAgICAgIGlmIChvYmogPT0gbnVsbCB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgb2JqID0gb2JqW2tleV07XG4gICAgfVxuICAgIHJldHVybiAhIWxlbmd0aDtcbiAgfTtcblxuICAvLyBVdGlsaXR5IEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFJ1biBVbmRlcnNjb3JlLmpzIGluICpub0NvbmZsaWN0KiBtb2RlLCByZXR1cm5pbmcgdGhlIGBfYCB2YXJpYWJsZSB0byBpdHNcbiAgLy8gcHJldmlvdXMgb3duZXIuIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0LlxuICBfLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICByb290Ll8gPSBwcmV2aW91c1VuZGVyc2NvcmU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gS2VlcCB0aGUgaWRlbnRpdHkgZnVuY3Rpb24gYXJvdW5kIGZvciBkZWZhdWx0IGl0ZXJhdGVlcy5cbiAgXy5pZGVudGl0eSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIC8vIFByZWRpY2F0ZS1nZW5lcmF0aW5nIGZ1bmN0aW9ucy4gT2Z0ZW4gdXNlZnVsIG91dHNpZGUgb2YgVW5kZXJzY29yZS5cbiAgXy5jb25zdGFudCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gIH07XG5cbiAgXy5ub29wID0gZnVuY3Rpb24oKXt9O1xuXG4gIC8vIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIHBhc3NlZCBhbiBvYmplY3QsIHdpbGwgdHJhdmVyc2UgdGhhdCBvYmplY3TigJlzXG4gIC8vIHByb3BlcnRpZXMgZG93biB0aGUgZ2l2ZW4gYHBhdGhgLCBzcGVjaWZpZWQgYXMgYW4gYXJyYXkgb2Yga2V5cyBvciBpbmRleGVzLlxuICBfLnByb3BlcnR5ID0gZnVuY3Rpb24ocGF0aCkge1xuICAgIGlmICghXy5pc0FycmF5KHBhdGgpKSB7XG4gICAgICByZXR1cm4gc2hhbGxvd1Byb3BlcnR5KHBhdGgpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gZGVlcEdldChvYmosIHBhdGgpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gR2VuZXJhdGVzIGEgZnVuY3Rpb24gZm9yIGEgZ2l2ZW4gb2JqZWN0IHRoYXQgcmV0dXJucyBhIGdpdmVuIHByb3BlcnR5LlxuICBfLnByb3BlcnR5T2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpe307XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICByZXR1cm4gIV8uaXNBcnJheShwYXRoKSA/IG9ialtwYXRoXSA6IGRlZXBHZXQob2JqLCBwYXRoKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBwcmVkaWNhdGUgZm9yIGNoZWNraW5nIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHNldCBvZlxuICAvLyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5tYXRjaGVyID0gXy5tYXRjaGVzID0gZnVuY3Rpb24oYXR0cnMpIHtcbiAgICBhdHRycyA9IF8uZXh0ZW5kT3duKHt9LCBhdHRycyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIF8uaXNNYXRjaChvYmosIGF0dHJzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJ1biBhIGZ1bmN0aW9uICoqbioqIHRpbWVzLlxuICBfLnRpbWVzID0gZnVuY3Rpb24obiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgYWNjdW0gPSBBcnJheShNYXRoLm1heCgwLCBuKSk7XG4gICAgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBjb250ZXh0LCAxKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykgYWNjdW1baV0gPSBpdGVyYXRlZShpKTtcbiAgICByZXR1cm4gYWNjdW07XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgcmFuZG9tIGludGVnZXIgYmV0d2VlbiBtaW4gYW5kIG1heCAoaW5jbHVzaXZlKS5cbiAgXy5yYW5kb20gPSBmdW5jdGlvbihtaW4sIG1heCkge1xuICAgIGlmIChtYXggPT0gbnVsbCkge1xuICAgICAgbWF4ID0gbWluO1xuICAgICAgbWluID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIG1pbiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSk7XG4gIH07XG5cbiAgLy8gQSAocG9zc2libHkgZmFzdGVyKSB3YXkgdG8gZ2V0IHRoZSBjdXJyZW50IHRpbWVzdGFtcCBhcyBhbiBpbnRlZ2VyLlxuICBfLm5vdyA9IERhdGUubm93IHx8IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgfTtcblxuICAvLyBMaXN0IG9mIEhUTUwgZW50aXRpZXMgZm9yIGVzY2FwaW5nLlxuICB2YXIgZXNjYXBlTWFwID0ge1xuICAgICcmJzogJyZhbXA7JyxcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7JyxcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICBcIidcIjogJyYjeDI3OycsXG4gICAgJ2AnOiAnJiN4NjA7J1xuICB9O1xuICB2YXIgdW5lc2NhcGVNYXAgPSBfLmludmVydChlc2NhcGVNYXApO1xuXG4gIC8vIEZ1bmN0aW9ucyBmb3IgZXNjYXBpbmcgYW5kIHVuZXNjYXBpbmcgc3RyaW5ncyB0by9mcm9tIEhUTUwgaW50ZXJwb2xhdGlvbi5cbiAgdmFyIGNyZWF0ZUVzY2FwZXIgPSBmdW5jdGlvbihtYXApIHtcbiAgICB2YXIgZXNjYXBlciA9IGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgICByZXR1cm4gbWFwW21hdGNoXTtcbiAgICB9O1xuICAgIC8vIFJlZ2V4ZXMgZm9yIGlkZW50aWZ5aW5nIGEga2V5IHRoYXQgbmVlZHMgdG8gYmUgZXNjYXBlZC5cbiAgICB2YXIgc291cmNlID0gJyg/OicgKyBfLmtleXMobWFwKS5qb2luKCd8JykgKyAnKSc7XG4gICAgdmFyIHRlc3RSZWdleHAgPSBSZWdFeHAoc291cmNlKTtcbiAgICB2YXIgcmVwbGFjZVJlZ2V4cCA9IFJlZ0V4cChzb3VyY2UsICdnJyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gc3RyaW5nID09IG51bGwgPyAnJyA6ICcnICsgc3RyaW5nO1xuICAgICAgcmV0dXJuIHRlc3RSZWdleHAudGVzdChzdHJpbmcpID8gc3RyaW5nLnJlcGxhY2UocmVwbGFjZVJlZ2V4cCwgZXNjYXBlcikgOiBzdHJpbmc7XG4gICAgfTtcbiAgfTtcbiAgXy5lc2NhcGUgPSBjcmVhdGVFc2NhcGVyKGVzY2FwZU1hcCk7XG4gIF8udW5lc2NhcGUgPSBjcmVhdGVFc2NhcGVyKHVuZXNjYXBlTWFwKTtcblxuICAvLyBUcmF2ZXJzZXMgdGhlIGNoaWxkcmVuIG9mIGBvYmpgIGFsb25nIGBwYXRoYC4gSWYgYSBjaGlsZCBpcyBhIGZ1bmN0aW9uLCBpdFxuICAvLyBpcyBpbnZva2VkIHdpdGggaXRzIHBhcmVudCBhcyBjb250ZXh0LiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgZmluYWxcbiAgLy8gY2hpbGQsIG9yIGBmYWxsYmFja2AgaWYgYW55IGNoaWxkIGlzIHVuZGVmaW5lZC5cbiAgXy5yZXN1bHQgPSBmdW5jdGlvbihvYmosIHBhdGgsIGZhbGxiYWNrKSB7XG4gICAgaWYgKCFfLmlzQXJyYXkocGF0aCkpIHBhdGggPSBbcGF0aF07XG4gICAgdmFyIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICByZXR1cm4gXy5pc0Z1bmN0aW9uKGZhbGxiYWNrKSA/IGZhbGxiYWNrLmNhbGwob2JqKSA6IGZhbGxiYWNrO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHJvcCA9IG9iaiA9PSBudWxsID8gdm9pZCAwIDogb2JqW3BhdGhbaV1dO1xuICAgICAgaWYgKHByb3AgPT09IHZvaWQgMCkge1xuICAgICAgICBwcm9wID0gZmFsbGJhY2s7XG4gICAgICAgIGkgPSBsZW5ndGg7IC8vIEVuc3VyZSB3ZSBkb24ndCBjb250aW51ZSBpdGVyYXRpbmcuXG4gICAgICB9XG4gICAgICBvYmogPSBfLmlzRnVuY3Rpb24ocHJvcCkgPyBwcm9wLmNhbGwob2JqKSA6IHByb3A7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGUgYSB1bmlxdWUgaW50ZWdlciBpZCAodW5pcXVlIHdpdGhpbiB0aGUgZW50aXJlIGNsaWVudCBzZXNzaW9uKS5cbiAgLy8gVXNlZnVsIGZvciB0ZW1wb3JhcnkgRE9NIGlkcy5cbiAgdmFyIGlkQ291bnRlciA9IDA7XG4gIF8udW5pcXVlSWQgPSBmdW5jdGlvbihwcmVmaXgpIHtcbiAgICB2YXIgaWQgPSArK2lkQ291bnRlciArICcnO1xuICAgIHJldHVybiBwcmVmaXggPyBwcmVmaXggKyBpZCA6IGlkO1xuICB9O1xuXG4gIC8vIEJ5IGRlZmF1bHQsIFVuZGVyc2NvcmUgdXNlcyBFUkItc3R5bGUgdGVtcGxhdGUgZGVsaW1pdGVycywgY2hhbmdlIHRoZVxuICAvLyBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXG4gIF8udGVtcGxhdGVTZXR0aW5ncyA9IHtcbiAgICBldmFsdWF0ZTogLzwlKFtcXHNcXFNdKz8pJT4vZyxcbiAgICBpbnRlcnBvbGF0ZTogLzwlPShbXFxzXFxTXSs/KSU+L2csXG4gICAgZXNjYXBlOiAvPCUtKFtcXHNcXFNdKz8pJT4vZ1xuICB9O1xuXG4gIC8vIFdoZW4gY3VzdG9taXppbmcgYHRlbXBsYXRlU2V0dGluZ3NgLCBpZiB5b3UgZG9uJ3Qgd2FudCB0byBkZWZpbmUgYW5cbiAgLy8gaW50ZXJwb2xhdGlvbiwgZXZhbHVhdGlvbiBvciBlc2NhcGluZyByZWdleCwgd2UgbmVlZCBvbmUgdGhhdCBpc1xuICAvLyBndWFyYW50ZWVkIG5vdCB0byBtYXRjaC5cbiAgdmFyIG5vTWF0Y2ggPSAvKC4pXi87XG5cbiAgLy8gQ2VydGFpbiBjaGFyYWN0ZXJzIG5lZWQgdG8gYmUgZXNjYXBlZCBzbyB0aGF0IHRoZXkgY2FuIGJlIHB1dCBpbnRvIGFcbiAgLy8gc3RyaW5nIGxpdGVyYWwuXG4gIHZhciBlc2NhcGVzID0ge1xuICAgIFwiJ1wiOiBcIidcIixcbiAgICAnXFxcXCc6ICdcXFxcJyxcbiAgICAnXFxyJzogJ3InLFxuICAgICdcXG4nOiAnbicsXG4gICAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuICAgICdcXHUyMDI5JzogJ3UyMDI5J1xuICB9O1xuXG4gIHZhciBlc2NhcGVSZWdFeHAgPSAvXFxcXHwnfFxccnxcXG58XFx1MjAyOHxcXHUyMDI5L2c7XG5cbiAgdmFyIGVzY2FwZUNoYXIgPSBmdW5jdGlvbihtYXRjaCkge1xuICAgIHJldHVybiAnXFxcXCcgKyBlc2NhcGVzW21hdGNoXTtcbiAgfTtcblxuICAvLyBKYXZhU2NyaXB0IG1pY3JvLXRlbXBsYXRpbmcsIHNpbWlsYXIgdG8gSm9obiBSZXNpZydzIGltcGxlbWVudGF0aW9uLlxuICAvLyBVbmRlcnNjb3JlIHRlbXBsYXRpbmcgaGFuZGxlcyBhcmJpdHJhcnkgZGVsaW1pdGVycywgcHJlc2VydmVzIHdoaXRlc3BhY2UsXG4gIC8vIGFuZCBjb3JyZWN0bHkgZXNjYXBlcyBxdW90ZXMgd2l0aGluIGludGVycG9sYXRlZCBjb2RlLlxuICAvLyBOQjogYG9sZFNldHRpbmdzYCBvbmx5IGV4aXN0cyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gIF8udGVtcGxhdGUgPSBmdW5jdGlvbih0ZXh0LCBzZXR0aW5ncywgb2xkU2V0dGluZ3MpIHtcbiAgICBpZiAoIXNldHRpbmdzICYmIG9sZFNldHRpbmdzKSBzZXR0aW5ncyA9IG9sZFNldHRpbmdzO1xuICAgIHNldHRpbmdzID0gXy5kZWZhdWx0cyh7fSwgc2V0dGluZ3MsIF8udGVtcGxhdGVTZXR0aW5ncyk7XG5cbiAgICAvLyBDb21iaW5lIGRlbGltaXRlcnMgaW50byBvbmUgcmVndWxhciBleHByZXNzaW9uIHZpYSBhbHRlcm5hdGlvbi5cbiAgICB2YXIgbWF0Y2hlciA9IFJlZ0V4cChbXG4gICAgICAoc2V0dGluZ3MuZXNjYXBlIHx8IG5vTWF0Y2gpLnNvdXJjZSxcbiAgICAgIChzZXR0aW5ncy5pbnRlcnBvbGF0ZSB8fCBub01hdGNoKS5zb3VyY2UsXG4gICAgICAoc2V0dGluZ3MuZXZhbHVhdGUgfHwgbm9NYXRjaCkuc291cmNlXG4gICAgXS5qb2luKCd8JykgKyAnfCQnLCAnZycpO1xuXG4gICAgLy8gQ29tcGlsZSB0aGUgdGVtcGxhdGUgc291cmNlLCBlc2NhcGluZyBzdHJpbmcgbGl0ZXJhbHMgYXBwcm9wcmlhdGVseS5cbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBzb3VyY2UgPSBcIl9fcCs9J1wiO1xuICAgIHRleHQucmVwbGFjZShtYXRjaGVyLCBmdW5jdGlvbihtYXRjaCwgZXNjYXBlLCBpbnRlcnBvbGF0ZSwgZXZhbHVhdGUsIG9mZnNldCkge1xuICAgICAgc291cmNlICs9IHRleHQuc2xpY2UoaW5kZXgsIG9mZnNldCkucmVwbGFjZShlc2NhcGVSZWdFeHAsIGVzY2FwZUNoYXIpO1xuICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG5cbiAgICAgIGlmIChlc2NhcGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBlc2NhcGUgKyBcIikpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xcbidcIjtcbiAgICAgIH0gZWxzZSBpZiAoaW50ZXJwb2xhdGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBpbnRlcnBvbGF0ZSArIFwiKSk9PW51bGw/Jyc6X190KStcXG4nXCI7XG4gICAgICB9IGVsc2UgaWYgKGV2YWx1YXRlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZSArIFwiXFxuX19wKz0nXCI7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkb2JlIFZNcyBuZWVkIHRoZSBtYXRjaCByZXR1cm5lZCB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IG9mZnNldC5cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcbiAgICBzb3VyY2UgKz0gXCInO1xcblwiO1xuXG4gICAgLy8gSWYgYSB2YXJpYWJsZSBpcyBub3Qgc3BlY2lmaWVkLCBwbGFjZSBkYXRhIHZhbHVlcyBpbiBsb2NhbCBzY29wZS5cbiAgICBpZiAoIXNldHRpbmdzLnZhcmlhYmxlKSBzb3VyY2UgPSAnd2l0aChvYmp8fHt9KXtcXG4nICsgc291cmNlICsgJ31cXG4nO1xuXG4gICAgc291cmNlID0gXCJ2YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4sXCIgK1xuICAgICAgXCJwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xcblwiICtcbiAgICAgIHNvdXJjZSArICdyZXR1cm4gX19wO1xcbic7XG5cbiAgICB2YXIgcmVuZGVyO1xuICAgIHRyeSB7XG4gICAgICByZW5kZXIgPSBuZXcgRnVuY3Rpb24oc2V0dGluZ3MudmFyaWFibGUgfHwgJ29iaicsICdfJywgc291cmNlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuXG4gICAgdmFyIHRlbXBsYXRlID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgcmV0dXJuIHJlbmRlci5jYWxsKHRoaXMsIGRhdGEsIF8pO1xuICAgIH07XG5cbiAgICAvLyBQcm92aWRlIHRoZSBjb21waWxlZCBzb3VyY2UgYXMgYSBjb252ZW5pZW5jZSBmb3IgcHJlY29tcGlsYXRpb24uXG4gICAgdmFyIGFyZ3VtZW50ID0gc2V0dGluZ3MudmFyaWFibGUgfHwgJ29iaic7XG4gICAgdGVtcGxhdGUuc291cmNlID0gJ2Z1bmN0aW9uKCcgKyBhcmd1bWVudCArICcpe1xcbicgKyBzb3VyY2UgKyAnfSc7XG5cbiAgICByZXR1cm4gdGVtcGxhdGU7XG4gIH07XG5cbiAgLy8gQWRkIGEgXCJjaGFpblwiIGZ1bmN0aW9uLiBTdGFydCBjaGFpbmluZyBhIHdyYXBwZWQgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8uY2hhaW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBfKG9iaik7XG4gICAgaW5zdGFuY2UuX2NoYWluID0gdHJ1ZTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH07XG5cbiAgLy8gT09QXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxuICAvLyBJZiBVbmRlcnNjb3JlIGlzIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLCBpdCByZXR1cm5zIGEgd3JhcHBlZCBvYmplY3QgdGhhdFxuICAvLyBjYW4gYmUgdXNlZCBPTy1zdHlsZS4gVGhpcyB3cmFwcGVyIGhvbGRzIGFsdGVyZWQgdmVyc2lvbnMgb2YgYWxsIHRoZVxuICAvLyB1bmRlcnNjb3JlIGZ1bmN0aW9ucy4gV3JhcHBlZCBvYmplY3RzIG1heSBiZSBjaGFpbmVkLlxuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjb250aW51ZSBjaGFpbmluZyBpbnRlcm1lZGlhdGUgcmVzdWx0cy5cbiAgdmFyIGNoYWluUmVzdWx0ID0gZnVuY3Rpb24oaW5zdGFuY2UsIG9iaikge1xuICAgIHJldHVybiBpbnN0YW5jZS5fY2hhaW4gPyBfKG9iaikuY2hhaW4oKSA6IG9iajtcbiAgfTtcblxuICAvLyBBZGQgeW91ciBvd24gY3VzdG9tIGZ1bmN0aW9ucyB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubWl4aW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICBfLmVhY2goXy5mdW5jdGlvbnMob2JqKSwgZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBfW25hbWVdID0gb2JqW25hbWVdO1xuICAgICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbdGhpcy5fd3JhcHBlZF07XG4gICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIGNoYWluUmVzdWx0KHRoaXMsIGZ1bmMuYXBwbHkoXywgYXJncykpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gXztcbiAgfTtcblxuICAvLyBBZGQgYWxsIG9mIHRoZSBVbmRlcnNjb3JlIGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlciBvYmplY3QuXG4gIF8ubWl4aW4oXyk7XG5cbiAgLy8gQWRkIGFsbCBtdXRhdG9yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgXy5lYWNoKFsncG9wJywgJ3B1c2gnLCAncmV2ZXJzZScsICdzaGlmdCcsICdzb3J0JywgJ3NwbGljZScsICd1bnNoaWZ0J10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgbWV0aG9kID0gQXJyYXlQcm90b1tuYW1lXTtcbiAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG9iaiA9IHRoaXMuX3dyYXBwZWQ7XG4gICAgICBtZXRob2QuYXBwbHkob2JqLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKChuYW1lID09PSAnc2hpZnQnIHx8IG5hbWUgPT09ICdzcGxpY2UnKSAmJiBvYmoubGVuZ3RoID09PSAwKSBkZWxldGUgb2JqWzBdO1xuICAgICAgcmV0dXJuIGNoYWluUmVzdWx0KHRoaXMsIG9iaik7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gQWRkIGFsbCBhY2Nlc3NvciBBcnJheSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIuXG4gIF8uZWFjaChbJ2NvbmNhdCcsICdqb2luJywgJ3NsaWNlJ10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgbWV0aG9kID0gQXJyYXlQcm90b1tuYW1lXTtcbiAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGNoYWluUmVzdWx0KHRoaXMsIG1ldGhvZC5hcHBseSh0aGlzLl93cmFwcGVkLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBFeHRyYWN0cyB0aGUgcmVzdWx0IGZyb20gYSB3cmFwcGVkIGFuZCBjaGFpbmVkIG9iamVjdC5cbiAgXy5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JhcHBlZDtcbiAgfTtcblxuICAvLyBQcm92aWRlIHVud3JhcHBpbmcgcHJveHkgZm9yIHNvbWUgbWV0aG9kcyB1c2VkIGluIGVuZ2luZSBvcGVyYXRpb25zXG4gIC8vIHN1Y2ggYXMgYXJpdGhtZXRpYyBhbmQgSlNPTiBzdHJpbmdpZmljYXRpb24uXG4gIF8ucHJvdG90eXBlLnZhbHVlT2YgPSBfLnByb3RvdHlwZS50b0pTT04gPSBfLnByb3RvdHlwZS52YWx1ZTtcblxuICBfLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBTdHJpbmcodGhpcy5fd3JhcHBlZCk7XG4gIH07XG5cbiAgLy8gQU1EIHJlZ2lzdHJhdGlvbiBoYXBwZW5zIGF0IHRoZSBlbmQgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBBTUQgbG9hZGVyc1xuICAvLyB0aGF0IG1heSBub3QgZW5mb3JjZSBuZXh0LXR1cm4gc2VtYW50aWNzIG9uIG1vZHVsZXMuIEV2ZW4gdGhvdWdoIGdlbmVyYWxcbiAgLy8gcHJhY3RpY2UgZm9yIEFNRCByZWdpc3RyYXRpb24gaXMgdG8gYmUgYW5vbnltb3VzLCB1bmRlcnNjb3JlIHJlZ2lzdGVyc1xuICAvLyBhcyBhIG5hbWVkIG1vZHVsZSBiZWNhdXNlLCBsaWtlIGpRdWVyeSwgaXQgaXMgYSBiYXNlIGxpYnJhcnkgdGhhdCBpc1xuICAvLyBwb3B1bGFyIGVub3VnaCB0byBiZSBidW5kbGVkIGluIGEgdGhpcmQgcGFydHkgbGliLCBidXQgbm90IGJlIHBhcnQgb2ZcbiAgLy8gYW4gQU1EIGxvYWQgcmVxdWVzdC4gVGhvc2UgY2FzZXMgY291bGQgZ2VuZXJhdGUgYW4gZXJyb3Igd2hlbiBhblxuICAvLyBhbm9ueW1vdXMgZGVmaW5lKCkgaXMgY2FsbGVkIG91dHNpZGUgb2YgYSBsb2FkZXIgcmVxdWVzdC5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKCd1bmRlcnNjb3JlJywgW10sIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF87XG4gICAgfSk7XG4gIH1cbn0oKSk7XG4iLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2YWx1ZXNfMSA9IHJlcXVpcmUoXCIuLi92YWx1ZXNcIik7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZShcIi4uL2NvbnN0YW50c1wiKTtcbnZhciBmdW5jdGlvbl8xID0gcmVxdWlyZShcIi4uL2Z1bmN0aW9uXCIpO1xudmFyIGxhYmVsXzEgPSByZXF1aXJlKFwiLi4vbGFiZWxcIik7XG52YXIgZWNtYV8xID0gcmVxdWlyZShcIi4uL2VjbWFcIik7XG52YXIgQXJyYXlPYmplY3RfMSA9IHJlcXVpcmUoXCIuLi9PYmplY3RzL0FycmF5T2JqZWN0XCIpO1xudmFyIEhhc0luc3RhbmNlXzEgPSByZXF1aXJlKFwiLi4vSGFzSW5zdGFuY2VcIik7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIDE1LjQuM1xudmFyIEFycmF5Q29uc3RydWN0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFycmF5Q29uc3RydWN0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXJyYXlDb25zdHJ1Y3Rvcihob3N0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLkNsYXNzID0gJ0Z1bmN0aW9uJztcbiAgICAgICAgX3RoaXMuRXh0ZW5zaWJsZSA9IHRydWU7XG4gICAgICAgIF90aGlzLmhvc3QgPSBob3N0O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEFycmF5Q29uc3RydWN0b3IucHJvdG90eXBlLlNldHVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLlByb3RvdHlwZSA9IG5ldyB2YWx1ZXNfMS5WYWx1ZShtb25pdG9yLmluc3RhbmNlcy5GdW5jdGlvblByb3RvdHlwZSwgbGFiZWxfMS5ib3QpO1xuICAgICAgICBlY21hXzEuRGVmaW5lRkZGKHRoaXMsIGNvbnN0YW50cy5sZW5ndGgsIDEpO1xuICAgICAgICBlY21hXzEuRGVmaW5lRkZGKHRoaXMsIGNvbnN0YW50cy5wcm90b3R5cGUsIG1vbml0b3IuaW5zdGFuY2VzLkFycmF5UHJvdG90eXBlKTtcbiAgICAgICAgZWNtYV8xLkRlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuaXNBcnJheSwgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KGlzQXJyYXksIDEsIEFycmF5LmlzQXJyYXkpKTtcbiAgICB9O1xuICAgIEFycmF5Q29uc3RydWN0b3IucHJvdG90eXBlLkhhc0luc3RhbmNlID0gZnVuY3Rpb24gKFYpIHtcbiAgICAgICAgcmV0dXJuIEhhc0luc3RhbmNlXzEuSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBWKTtcbiAgICB9O1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIEFycmF5Q29uc3RydWN0b3IucHJvdG90eXBlLkNhbGwgPSBmdW5jdGlvbiAodGhpc0FyZywgYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5Db25zdHJ1Y3QoYXJncyk7XG4gICAgfTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBBcnJheUNvbnN0cnVjdG9yLnByb3RvdHlwZS5Db25zdHJ1Y3QgPSBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICB2YXIgYXJyYXk7XG4gICAgICAgIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiA9PT0gMCB8fCBsZW4gPj0gMikge1xuICAgICAgICAgICAgYXJyYXkgPSBBcnJheU9iamVjdF8xLkFycmF5T2JqZWN0LmZyb21WYWx1ZUFycmF5KGFyZ3MsIGxhYmVsXzEuYm90KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBhcmcgPSBhcmdzWzBdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmcudmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgYXJyYXkgPSBuZXcgQXJyYXlPYmplY3RfMS5BcnJheU9iamVjdCgpO1xuICAgICAgICAgICAgICAgIGFycmF5LnByb3BlcnRpZXMubGVuZ3RoID0gYXJnLnZhbHVlO1xuICAgICAgICAgICAgICAgIGFycmF5LmxhYmVscy5sZW5ndGggPSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBhcmcubGFiZWwsXG4gICAgICAgICAgICAgICAgICAgIGV4aXN0ZW5jZTogbGFiZWxfMS5ib3RcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXJyYXkgPSBBcnJheU9iamVjdF8xLkFycmF5T2JqZWN0LmZyb21WYWx1ZUFycmF5KGFyZ3MsIGxhYmVsXzEuYm90KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IHZhbHVlc18xLlZhbHVlKGFycmF5LCBsYWJlbF8xLmJvdCk7XG4gICAgfTtcbiAgICByZXR1cm4gQXJyYXlDb25zdHJ1Y3Rvcjtcbn0oZWNtYV8xLkVjbWEpKTtcbmV4cG9ydHMuQXJyYXlDb25zdHJ1Y3RvciA9IEFycmF5Q29uc3RydWN0b3I7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGlzQXJyYXksIDE1LjQuMy4xXG52YXIgaXNBcnJheSA9IGZ1bmN0aW9uICh0aGlzQXJnLCBhcmdzKSB7XG4gICAgdmFyIGFyZyA9IGFyZ3NbMF0gfHwgbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgbGFiZWxfMS5ib3QpO1xuICAgIGlmIChhcmcudmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIGFyZy52YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZShmYWxzZSwgYXJnLmxhYmVsKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZShhcmcudmFsdWUuQ2xhc3MgPT09ICdBcnJheScsIGFyZy5sYWJlbCk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXJyYXlDb25zdHJ1Y3Rvci5qcy5tYXAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2YWx1ZXNfMSA9IHJlcXVpcmUoXCIuLi92YWx1ZXNcIik7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZShcIi4uL2NvbnN0YW50c1wiKTtcbnZhciBIYXNJbnN0YW5jZV8xID0gcmVxdWlyZShcIi4uL0hhc0luc3RhbmNlXCIpO1xudmFyIGVjbWFfMSA9IHJlcXVpcmUoXCIuLi9lY21hXCIpO1xudmFyIGxhYmVsXzEgPSByZXF1aXJlKFwiLi4vbGFiZWxcIik7XG52YXIgQm9vbGVhbk9iamVjdF8xID0gcmVxdWlyZShcIi4uL09iamVjdHMvQm9vbGVhbk9iamVjdFwiKTtcbnZhciBUb0Jvb2xlYW5fMSA9IHJlcXVpcmUoXCIuLi9Db252ZXJzaW9uL1RvQm9vbGVhblwiKTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gMTUuNi4yIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgQm9vbGVhbkNvbnN0cnVjdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCb29sZWFuQ29uc3RydWN0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQm9vbGVhbkNvbnN0cnVjdG9yKGhvc3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuQ2xhc3MgPSAnRnVuY3Rpb24nO1xuICAgICAgICBfdGhpcy5FeHRlbnNpYmxlID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMuaG9zdCA9IGhvc3Q7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQm9vbGVhbkNvbnN0cnVjdG9yLnByb3RvdHlwZS5TZXR1cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5Qcm90b3R5cGUgPSBuZXcgdmFsdWVzXzEuVmFsdWUobW9uaXRvci5pbnN0YW5jZXMuRnVuY3Rpb25Qcm90b3R5cGUsIGxhYmVsXzEuYm90KTtcbiAgICAgICAgZWNtYV8xLkRlZmluZUZGRih0aGlzLCBjb25zdGFudHMubGVuZ3RoLCAxKTsgLy9SRU1PVkUgP1xuICAgICAgICBlY21hXzEuRGVmaW5lRkZGKHRoaXMsIGNvbnN0YW50cy5wcm90b3R5cGUsIG1vbml0b3IuaW5zdGFuY2VzLkJvb2xlYW5Qcm90b3R5cGUpO1xuICAgIH07XG4gICAgQm9vbGVhbkNvbnN0cnVjdG9yLnByb3RvdHlwZS5IYXNJbnN0YW5jZSA9IGZ1bmN0aW9uIChWKSB7XG4gICAgICAgIEhhc0luc3RhbmNlXzEuSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBWKTtcbiAgICB9O1xuICAgIC8vIDE1LjYuMS4xXG4gICAgQm9vbGVhbkNvbnN0cnVjdG9yLnByb3RvdHlwZS5DYWxsID0gZnVuY3Rpb24gKHRoaXNBcmcsIGFyZ3MpIHtcbiAgICAgICAgdmFyIGFyZzAgPSBhcmdzWzBdID8gYXJnc1swXSA6IG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIGxhYmVsXzEuYm90KTtcbiAgICAgICAgcmV0dXJuIFRvQm9vbGVhbl8xLlRvQm9vbGVhbihhcmcwKTtcbiAgICB9O1xuICAgIC8vIDE1LjYuMi4xXG4gICAgQm9vbGVhbkNvbnN0cnVjdG9yLnByb3RvdHlwZS5Db25zdHJ1Y3QgPSBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICB2YXIgYXJnMCA9IGFyZ3NbMF0gPyBhcmdzWzBdIDogbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgbGFiZWxfMS5ib3QpO1xuICAgICAgICB2YXIgYiA9IFRvQm9vbGVhbl8xLlRvQm9vbGVhbihhcmcwKTtcbiAgICAgICAgdmFyIG9iaiA9IG5ldyBCb29sZWFuT2JqZWN0XzEuQm9vbGVhbk9iamVjdChiLnZhbHVlLCBiLmxhYmVsKTtcbiAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZShvYmosIGxhYmVsXzEuYm90KTtcbiAgICB9O1xuICAgIHJldHVybiBCb29sZWFuQ29uc3RydWN0b3I7XG59KGVjbWFfMS5FY21hKSk7XG5leHBvcnRzLkJvb2xlYW5Db25zdHJ1Y3RvciA9IEJvb2xlYW5Db25zdHJ1Y3Rvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJvb2xlYW5Db25zdHJ1Y3Rvci5qcy5tYXAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBsYWJlbF8xID0gcmVxdWlyZShcIi4uL2xhYmVsXCIpO1xudmFyIHZhbHVlc18xID0gcmVxdWlyZShcIi4uL3ZhbHVlc1wiKTtcbnZhciBlY21hXzEgPSByZXF1aXJlKFwiLi4vZWNtYVwiKTtcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzXCIpO1xudmFyIEZ1bmN0aW9uT2JqZWN0XzEgPSByZXF1aXJlKFwiLi4vT2JqZWN0cy9GdW5jdGlvbk9iamVjdFwiKTtcbnZhciBIYXNJbnN0YW5jZV8xID0gcmVxdWlyZShcIi4uL0hhc0luc3RhbmNlXCIpO1xudmFyIGVzcHJpbWEgPSByZXF1aXJlKFwiZXNwcmltYVwiKTtcbnZhciBUb1N0cmluZ18xID0gcmVxdWlyZShcIi4uL0NvbnZlcnNpb24vVG9TdHJpbmdcIik7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEZ1bmN0aW9uIENvbnN0cnVjdG9yLCAxNS4zLjIgKDE1LjMuMSwgMTUuMy4xLjEpXG52YXIgRnVuY3Rpb25Db25zdHJ1Y3RvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRnVuY3Rpb25Db25zdHJ1Y3RvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGdW5jdGlvbkNvbnN0cnVjdG9yKGhvc3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgLy8gUHJvcGVydGllcywgMTUuMy4zLlxuICAgICAgICBfdGhpcy5DbGFzcyA9ICdGdW5jdGlvbic7XG4gICAgICAgIF90aGlzLmhvc3QgPSBob3N0O1xuICAgICAgICBfdGhpcy5FeHRlbnNpYmxlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBGdW5jdGlvbkNvbnN0cnVjdG9yLnByb3RvdHlwZS5TZXR1cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gMTUuMy4zLjEgXG4gICAgICAgIGVjbWFfMS5EZWZpbmVGRkYodGhpcywgY29uc3RhbnRzLnByb3RvdHlwZSwgbW9uaXRvci5pbnN0YW5jZXMuRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgICAgICB0aGlzLlByb3RvdHlwZSA9IG5ldyB2YWx1ZXNfMS5WYWx1ZShtb25pdG9yLmluc3RhbmNlcy5GdW5jdGlvblByb3RvdHlwZSwgbGFiZWxfMS5ib3QpO1xuICAgICAgICAvLyAxNS4zLjMuMiBcbiAgICAgICAgZWNtYV8xLkRlZmluZUZGRih0aGlzLCBjb25zdGFudHMubGVuZ3RoLCAxKTtcbiAgICB9O1xuICAgIC8vIC0tLVxuICAgIEZ1bmN0aW9uQ29uc3RydWN0b3IucHJvdG90eXBlLkhhc0luc3RhbmNlID0gZnVuY3Rpb24gKFYpIHtcbiAgICAgICAgcmV0dXJuIEhhc0luc3RhbmNlXzEuSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBWKTtcbiAgICB9O1xuICAgIC8vIDE1LjMuMVxuICAgIEZ1bmN0aW9uQ29uc3RydWN0b3IucHJvdG90eXBlLkNhbGwgPSBmdW5jdGlvbiAodGhpc0FyZywgYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5Db25zdHJ1Y3QoYXJncyk7XG4gICAgfTtcbiAgICAvLyAxNS4zLjJcbiAgICBGdW5jdGlvbkNvbnN0cnVjdG9yLnByb3RvdHlwZS5Db25zdHJ1Y3QgPSBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICB2YXIgYXJnQ291bnQgPSBhcmdzLmxlbmd0aDtcbiAgICAgICAgdmFyIFAgPSAnJztcbiAgICAgICAgdmFyIGJvZHk7XG4gICAgICAgIHZhciBsYWJlbCA9IGxhYmVsXzEuYm90O1xuICAgICAgICBpZiAoYXJnQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIGJvZHkgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJycsIGxhYmVsXzEuYm90KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcmdDb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgYm9keSA9IGFyZ3NbMF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZmlyc3RBcmcgPSBUb1N0cmluZ18xLlRvU3RyaW5nKGFyZ3NbMF0pO1xuICAgICAgICAgICAgbGFiZWwgPSBsYWJlbF8xLmx1YihsYWJlbCwgZmlyc3RBcmcubGFiZWwpO1xuICAgICAgICAgICAgUCA9IGZpcnN0QXJnLnZhbHVlO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmdDb3VudCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0QXJnID0gVG9TdHJpbmdfMS5Ub1N0cmluZyhhcmdzW2ldKTtcbiAgICAgICAgICAgICAgICBsYWJlbCA9IGxhYmVsXzEubHViKGxhYmVsLCBmaXJzdEFyZy5sYWJlbCk7XG4gICAgICAgICAgICAgICAgUCArPSAnLCAnICsgbmV4dEFyZy52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJvZHkgPSBhcmdzW2FyZ0NvdW50IC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgYm9keSA9IFRvU3RyaW5nXzEuVG9TdHJpbmcoYm9keSk7XG4gICAgICAgIGxhYmVsID0gbGFiZWxfMS5sdWIobGFiZWwsIGJvZHkubGFiZWwpO1xuICAgICAgICBQID0gJyhmdW5jdGlvbiAoJyArIFAgKyAnKSB7ICcgKyBib2R5LnZhbHVlICsgJ30pOyc7XG4gICAgICAgIHZhciBwcm9nO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcHJvZyA9IGVzcHJpbWEucGFyc2UoUCwgeyBsb2M6IHRydWUsIHNvdXJjZTogJ0Z1bmN0aW9uJyB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbW9uaXRvci5UaHJvdyhtb25pdG9yLm1vZHVsZXMuZXJyb3IuU3ludGF4RXJyb3JPYmplY3QsIGUubWVzc2FnZSwgbGFiZWwpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhcnNpbmcgcmV0dXJucyBhIHByb2dyYW0gLS0tIHdlIGFyZSBpbnRlcmVzdGVkIGluIGZ1bmN0aW9uIGRlY2xhcmF0aW9uXG4gICAgICAgIHZhciBmdW5jID0gcHJvZy5ib2R5WzBdLmV4cHJlc3Npb247XG4gICAgICAgIHZhciBGID0gbmV3IEZ1bmN0aW9uT2JqZWN0XzEuRnVuY3Rpb25PYmplY3QoZnVuYy5wYXJhbXMsIGZ1bmMuYm9keSwgbmV3IHZhbHVlc18xLlZhbHVlKG1vbml0b3IuaW5zdGFuY2VzLmdsb2JhbEVudmlyb25tZW50LCBsYWJlbF8xLmJvdCkpO1xuICAgICAgICAvLyBGb3IgcHJldHR5IHByaW50aW5nXG4gICAgICAgIEYuU291cmNlID0gZnVuYztcbiAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZShGLCBsYWJlbCk7XG4gICAgfTtcbiAgICByZXR1cm4gRnVuY3Rpb25Db25zdHJ1Y3Rvcjtcbn0oZWNtYV8xLkVjbWEpKTtcbmV4cG9ydHMuRnVuY3Rpb25Db25zdHJ1Y3RvciA9IEZ1bmN0aW9uQ29uc3RydWN0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GdW5jdGlvbkNvbnN0cnVjdG9yLmpzLm1hcCIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGxhYmVsXzEgPSByZXF1aXJlKFwiLi4vbGFiZWxcIik7XG52YXIgdmFsdWVzXzEgPSByZXF1aXJlKFwiLi4vdmFsdWVzXCIpO1xudmFyIGVjbWFfMSA9IHJlcXVpcmUoXCIuLi9lY21hXCIpO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHNcIik7XG52YXIgSGFzSW5zdGFuY2VfMSA9IHJlcXVpcmUoXCIuLi9IYXNJbnN0YW5jZVwiKTtcbnZhciBOdW1iZXJPYmplY3RfMSA9IHJlcXVpcmUoXCIuLi9PYmplY3RzL051bWJlck9iamVjdFwiKTtcbnZhciBUb051bWJlcl8xID0gcmVxdWlyZShcIi4uL0NvbnZlcnNpb24vVG9OdW1iZXJcIik7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFRoZSBOdW1iZXIgQ29uc3RydWN0b3IsIDE1LjcuMlxudmFyIE51bWJlckNvbnN0cnVjdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOdW1iZXJDb25zdHJ1Y3RvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOdW1iZXJDb25zdHJ1Y3Rvcihob3N0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLkNsYXNzID0gJ0Z1bmN0aW9uJztcbiAgICAgICAgLy8gbm90IG1hbmRhdGVkIGJ5IHN0YW5kYXJkXG4gICAgICAgIF90aGlzLkV4dGVuc2libGUgPSB0cnVlO1xuICAgICAgICBfdGhpcy5ob3N0ID0gaG9zdDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBOdW1iZXJDb25zdHJ1Y3Rvci5wcm90b3R5cGUuU2V0dXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuUHJvdG90eXBlID0gbmV3IHZhbHVlc18xLlZhbHVlKG1vbml0b3IuaW5zdGFuY2VzLkZ1bmN0aW9uUHJvdG90eXBlLCBsYWJlbF8xLmJvdCk7XG4gICAgICAgIGVjbWFfMS5EZWZpbmVGRkYodGhpcywgY29uc3RhbnRzLnByb3RvdHlwZSwgbW9uaXRvci5pbnN0YW5jZXMuTnVtYmVyUHJvdG90eXBlKTtcbiAgICAgICAgZWNtYV8xLkRlZmluZUZGRih0aGlzLCBjb25zdGFudHMubGVuZ3RoLCAxKTtcbiAgICAgICAgZWNtYV8xLkRlZmluZUZGRih0aGlzLCBjb25zdGFudHMuTUFYX1ZBTFVFLCB0aGlzLmhvc3QuTUFYX1ZBTFVFKTtcbiAgICAgICAgZWNtYV8xLkRlZmluZUZGRih0aGlzLCBjb25zdGFudHMuTUlOX1ZBTFVFLCB0aGlzLmhvc3QuTUlOX1ZBTFVFKTtcbiAgICAgICAgZWNtYV8xLkRlZmluZUZGRih0aGlzLCBjb25zdGFudHMuTmFOLCB0aGlzLmhvc3QuTmFOKTtcbiAgICAgICAgZWNtYV8xLkRlZmluZUZGRih0aGlzLCBjb25zdGFudHMuTkVHQVRJVkVfSU5GSU5JVFksIHRoaXMuaG9zdC5ORUdBVElWRV9JTkZJTklUWSk7XG4gICAgICAgIGVjbWFfMS5EZWZpbmVGRkYodGhpcywgY29uc3RhbnRzLlBPU0lUSVZFX0lORklOSVRZLCB0aGlzLmhvc3QuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgIH07XG4gICAgTnVtYmVyQ29uc3RydWN0b3IucHJvdG90eXBlLkhhc0luc3RhbmNlID0gZnVuY3Rpb24gKFYpIHtcbiAgICAgICAgcmV0dXJuIEhhc0luc3RhbmNlXzEuSGFzSW5zdGFuY2UoVik7XG4gICAgfTtcbiAgICAvLyAxNS43LjEuMVxuICAgIE51bWJlckNvbnN0cnVjdG9yLnByb3RvdHlwZS5DYWxsID0gZnVuY3Rpb24gKHRoaXNBcmcsIGFyZ3MpIHtcbiAgICAgICAgaWYgKCFhcmdzWzBdKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHZhbHVlc18xLlZhbHVlKDAsIGxhYmVsXzEuYm90KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVG9OdW1iZXJfMS5Ub051bWJlcihhcmdzWzBdKTtcbiAgICB9O1xuICAgIC8vIDE1LjcuMi4xXG4gICAgTnVtYmVyQ29uc3RydWN0b3IucHJvdG90eXBlLkNvbnN0cnVjdCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgIHZhciBhcmcwID0gYXJnc1swXSA/IFRvTnVtYmVyXzEuVG9OdW1iZXIoYXJnc1swXSkgOiBuZXcgdmFsdWVzXzEuVmFsdWUoMCwgbGFiZWxfMS5ib3QpO1xuICAgICAgICB2YXIgcmVzID0gbmV3IE51bWJlck9iamVjdF8xLk51bWJlck9iamVjdChhcmcwLnZhbHVlLCBhcmcwLmxhYmVsKTtcbiAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZShyZXMsIGxhYmVsXzEuYm90KTtcbiAgICB9O1xuICAgIHJldHVybiBOdW1iZXJDb25zdHJ1Y3Rvcjtcbn0oZWNtYV8xLkVjbWEpKTtcbmV4cG9ydHMuTnVtYmVyQ29uc3RydWN0b3IgPSBOdW1iZXJDb25zdHJ1Y3Rvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU51bWJlckNvbnN0cnVjdG9yLmpzLm1hcCIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGxhYmVsXzEgPSByZXF1aXJlKFwiLi4vbGFiZWxcIik7XG52YXIgdmFsdWVzXzEgPSByZXF1aXJlKFwiLi4vdmFsdWVzXCIpO1xudmFyIGVjbWFfMSA9IHJlcXVpcmUoXCIuLi9lY21hXCIpO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHNcIik7XG52YXIgZnVuY3Rpb25fMSA9IHJlcXVpcmUoXCIuLi9mdW5jdGlvblwiKTtcbnZhciBPYmplY3RPYmplY3RfMSA9IHJlcXVpcmUoXCIuLi9PYmplY3RzL09iamVjdE9iamVjdFwiKTtcbnZhciBBcnJheU9iamVjdF8xID0gcmVxdWlyZShcIi4uL09iamVjdHMvQXJyYXlPYmplY3RcIik7XG52YXIgVG9Cb29sZWFuXzEgPSByZXF1aXJlKFwiLi4vQ29udmVyc2lvbi9Ub0Jvb2xlYW5cIik7XG52YXIgSGFzSW5zdGFuY2VfMSA9IHJlcXVpcmUoXCIuLi9IYXNJbnN0YW5jZVwiKTtcbnZhciBUb1N0cmluZ18xID0gcmVxdWlyZShcIi4uL0NvbnZlcnNpb24vVG9TdHJpbmdcIik7XG52YXIgVG9PYmplY3RfMSA9IHJlcXVpcmUoXCIuLi9Db252ZXJzaW9uL1RvT2JqZWN0XCIpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBPYmplY3QgQ29uc3RydWN0b3IsIDE1LjIuM1xudmFyIE9iamVjdENvbnN0cnVjdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhPYmplY3RDb25zdHJ1Y3RvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBPYmplY3RDb25zdHJ1Y3Rvcihob3N0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLkNsYXNzID0gJ0Z1bmN0aW9uJztcbiAgICAgICAgX3RoaXMuaG9zdCA9IGhvc3Q7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0Q29uc3RydWN0b3IucHJvdG90eXBlLlNldHVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBlY21hXzEuRGVmaW5lRkZGKHRoaXMsIGNvbnN0YW50cy5sZW5ndGgsIDEpO1xuICAgICAgICAvLyAxNS4yLjNcbiAgICAgICAgdGhpcy5Qcm90b3R5cGUgPSBuZXcgdmFsdWVzXzEuVmFsdWUobW9uaXRvci5pbnN0YW5jZXMuRnVuY3Rpb25Qcm90b3R5cGUsIGxhYmVsXzEuYm90KTtcbiAgICAgICAgLy8gMTUuMi4zLjFcbiAgICAgICAgZWNtYV8xLkRlZmluZUZGRih0aGlzLCBjb25zdGFudHMucHJvdG90eXBlLCBtb25pdG9yLmluc3RhbmNlcy5PYmplY3RQcm90b3R5cGUpO1xuICAgICAgICBlY21hXzEuRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5nZXRQcm90b3R5cGVPZiwgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KGdldFByb3RvdHlwZU9mLCAxLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YpKTtcbiAgICAgICAgZWNtYV8xLkRlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLCBuZXcgZnVuY3Rpb25fMS5CdWlsdGluRnVuY3Rpb25PYmplY3QoZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLCAyLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKSk7XG4gICAgICAgIGVjbWFfMS5EZWZpbmVURlQodGhpcywgY29uc3RhbnRzLmdldE93blByb3BlcnR5TmFtZXMsIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdChnZXRPd25Qcm9wZXJ0eU5hbWVzLCAxLCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcykpO1xuICAgICAgICBlY21hXzEuRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5jcmVhdGUsIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdChjcmVhdGUsIDIsIE9iamVjdC5jcmVhdGUpKTtcbiAgICAgICAgZWNtYV8xLkRlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuZGVmaW5lUHJvcGVydHksIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdChkZWZpbmVQcm9wZXJ0eSwgMywgT2JqZWN0LmRlZmluZVByb3BlcnR5KSk7XG4gICAgICAgIGVjbWFfMS5EZWZpbmVURlQodGhpcywgY29uc3RhbnRzLmRlZmluZVByb3BlcnRpZXMsIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdChkZWZpbmVQcm9wZXJ0aWVzLCAyLCBPYmplY3QuZGVmaW5lUHJvcGVydGllcykpO1xuICAgICAgICBlY21hXzEuRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5zZWFsLCBuZXcgZnVuY3Rpb25fMS5CdWlsdGluRnVuY3Rpb25PYmplY3Qoc2VhbCwgMSwgT2JqZWN0LnNlYWwpKTtcbiAgICAgICAgZWNtYV8xLkRlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuZnJlZXplLCBuZXcgZnVuY3Rpb25fMS5CdWlsdGluRnVuY3Rpb25PYmplY3QoZnJlZXplLCAxLCBPYmplY3QuZnJlZXplKSk7XG4gICAgICAgIGVjbWFfMS5EZWZpbmVURlQodGhpcywgY29uc3RhbnRzLnByZXZlbnRFeHRlbnNpb25zLCBuZXcgZnVuY3Rpb25fMS5CdWlsdGluRnVuY3Rpb25PYmplY3QocHJldmVudEV4dGVuc2lvbnMsIDEsIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucykpO1xuICAgICAgICBlY21hXzEuRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5pc1NlYWxlZCwgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KGlzU2VhbGVkLCAxLCBPYmplY3QuaXNTZWFsZWQpKTtcbiAgICAgICAgZWNtYV8xLkRlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuaXNGcm96ZW4sIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdChpc0Zyb3plbiwgMSwgT2JqZWN0LmlzRnJvemVuKSk7XG4gICAgICAgIGVjbWFfMS5EZWZpbmVURlQodGhpcywgY29uc3RhbnRzLmlzRXh0ZW5zaWJsZSwgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KGlzRXh0ZW5zaWJsZSwgMSwgT2JqZWN0LmlzRXh0ZW5zaWJsZSkpO1xuICAgICAgICBlY21hXzEuRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5rZXlzLCBuZXcgZnVuY3Rpb25fMS5CdWlsdGluRnVuY3Rpb25PYmplY3Qoa2V5cywgMSwgT2JqZWN0LmtleXMpKTtcbiAgICB9O1xuICAgIE9iamVjdENvbnN0cnVjdG9yLnByb3RvdHlwZS5IYXNJbnN0YW5jZSA9IGZ1bmN0aW9uIChWKSB7XG4gICAgICAgIHJldHVybiBIYXNJbnN0YW5jZV8xLkhhc0luc3RhbmNlLmNhbGwoVik7XG4gICAgfTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyAxNS4yLjEuMVxuICAgIE9iamVjdENvbnN0cnVjdG9yLnByb3RvdHlwZS5DYWxsID0gZnVuY3Rpb24gKHRoaXNBcmcsIGFyZ3MpIHtcbiAgICAgICAgdmFyIGFyZzAgPSBhcmdzWzBdIHx8IG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIGxhYmVsXzEuYm90KTtcbiAgICAgICAgdmFyIHJlcztcbiAgICAgICAgbW9uaXRvci5jb250ZXh0LnB1c2hQQyhhcmcwLmxhYmVsKTtcbiAgICAgICAgaWYgKGFyZzAudmFsdWUgPT09IHVuZGVmaW5lZCB8fCBhcmcwLnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXMgPSB0aGlzLkNvbnN0cnVjdChhcmdzKTtcbiAgICAgICAgICAgIHJlcy5yYWlzZShhcmcwLmxhYmVsKTtcbiAgICAgICAgICAgIG1vbml0b3IuY29udGV4dC5wb3BQQygpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgICByZXMgPSBUb09iamVjdF8xLlRvT2JqZWN0KGFyZzApO1xuICAgICAgICBtb25pdG9yLmNvbnRleHQucG9wUEMoKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIDE1LjIuMi4xXG4gICAgT2JqZWN0Q29uc3RydWN0b3IucHJvdG90eXBlLkNvbnN0cnVjdCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgIHZhciBhcmcwID0gYXJnc1swXSB8fCBuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCBsYWJlbF8xLmJvdCk7XG4gICAgICAgIG1vbml0b3IuY29udGV4dC5wdXNoUEMoYXJnMC5sYWJlbCk7XG4gICAgICAgIHZhciByZXM7XG4gICAgICAgIGlmIChhcmcwLnZhbHVlID09PSB1bmRlZmluZWQgfHwgYXJnMC52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIG8gPSBuZXcgT2JqZWN0T2JqZWN0XzEuT2JqZWN0T2JqZWN0KCk7XG4gICAgICAgICAgICByZXMgPSBuZXcgdmFsdWVzXzEuVmFsdWUobywgYXJnMC5sYWJlbCk7XG4gICAgICAgICAgICBtb25pdG9yLmNvbnRleHQucG9wUEMoKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBhcmcwLnZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmVzID0gbmV3IHZhbHVlc18xLlZhbHVlKGFyZzAudmFsdWUsIGFyZzAubGFiZWwpO1xuICAgICAgICAgICAgbW9uaXRvci5jb250ZXh0LnBvcFBDKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIHJlcyA9IFRvT2JqZWN0XzEuVG9PYmplY3QoYXJnMCk7XG4gICAgICAgIG1vbml0b3IuY29udGV4dC5wb3BQQygpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgcmV0dXJuIE9iamVjdENvbnN0cnVjdG9yO1xufShlY21hXzEuRWNtYSkpO1xuZXhwb3J0cy5PYmplY3RDb25zdHJ1Y3RvciA9IE9iamVjdENvbnN0cnVjdG9yO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBhc3NlcnRPYmplY3QoYXJnLCBjYWxsZWUpIHtcbiAgICBpZiAodHlwZW9mIGFyZy52YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgbW9uaXRvci5jb250ZXh0LnB1c2hQQyhhcmcubGFiZWwpO1xuICAgICAgICBtb25pdG9yLlRocm93KG1vbml0b3IubW9kdWxlcy5lcnJvci5UeXBlRXJyb3JPYmplY3QsIGNhbGxlZSArICcgY2FsbGVkIG9uIG5vbi1vYmplY3QnLCBhcmcubGFiZWwpO1xuICAgIH1cbn1cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gMTUuMi4zLjJcbmZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKHRoaXNBcmcsIGFyZ3MpIHtcbiAgICB2YXIgTyA9IGFyZ3NbMF0gfHwgbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgbGFiZWxfMS5ib3QpO1xuICAgIGFzc2VydE9iamVjdChPLCAnT2JqZWN0LmdldFByb3RvdHlwZU9mJyk7XG4gICAgdmFyIHByb3RvID0gTy52YWx1ZS5Qcm90b3R5cGU7XG4gICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZShwcm90by52YWx1ZSwgbGFiZWxfMS5sdWIocHJvdG8ubGFiZWwsIE8ubGFiZWwpKTtcbn1cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gMTUuMi4zLjNcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiAodGhpc0FyZywgYXJncykge1xuICAgIHZhciBPID0gYXJnc1swXSB8fCBuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCBsYWJlbF8xLmJvdCk7XG4gICAgdmFyIFAgPSBhcmdzWzFdIHx8IG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIGxhYmVsXzEuYm90KTtcbiAgICBhc3NlcnRPYmplY3QoTywgJ09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3InKTtcbiAgICB2YXIgbmFtZSA9IFRvU3RyaW5nXzEuVG9TdHJpbmcoUCk7XG4gICAgdmFyIGRlc2MgPSBPLkdldE93blByb3BlcnR5KG5hbWUpO1xuICAgIGlmIChkZXNjLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGRlc2M7XG4gICAgfVxuICAgIHZhciBvYmogPSBuZXcgT2JqZWN0T2JqZWN0XzEuT2JqZWN0T2JqZWN0KCk7XG4gICAgaWYgKGVjbWFfMS5Jc0RhdGFEZXNjcmlwdG9yKGRlc2MudmFsdWUpKSB7XG4gICAgICAgIG9iai5EZWZpbmVPd25Qcm9wZXJ0eShjb25zdGFudHMudmFsdWUsIHtcbiAgICAgICAgICAgIHZhbHVlOiBkZXNjLnZhbHVlLnZhbHVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGxhYmVsOiBkZXNjLnZhbHVlLmxhYmVsXG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgb2JqLkRlZmluZU93blByb3BlcnR5KGNvbnN0YW50cy53cml0YWJsZSwge1xuICAgICAgICAgICAgdmFsdWU6IGRlc2MudmFsdWUud3JpdGFibGUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgbGFiZWw6IGRlc2MudmFsdWUubGFiZWxcbiAgICAgICAgfSwgZmFsc2UpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGdldCA9IGRlc2MudmFsdWUuZ2V0ID8gZGVzYy52YWx1ZS5nZXQuYWN0dWFsRnVuY3Rpb24gOiBkZXNjLnZhbHVlLmdldDtcbiAgICAgICAgb2JqLkRlZmluZU93blByb3BlcnR5KGNvbnN0YW50cy5nZXQsIHtcbiAgICAgICAgICAgIHZhbHVlOiBnZXQsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgbGFiZWw6IGRlc2MudmFsdWUubGFiZWxcbiAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICB2YXIgc2V0ID0gZGVzYy52YWx1ZS5zZXQgPyBkZXNjLnZhbHVlLnNldC5hY3R1YWxGdW5jdGlvbiA6IGRlc2MudmFsdWUuc2V0O1xuICAgICAgICBvYmouRGVmaW5lT3duUHJvcGVydHkoY29uc3RhbnRzLnNldCwge1xuICAgICAgICAgICAgdmFsdWU6IHNldCxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBsYWJlbDogZGVzYy52YWx1ZS5sYWJlbFxuICAgICAgICB9LCBmYWxzZSk7XG4gICAgfVxuICAgIG9iai5EZWZpbmVPd25Qcm9wZXJ0eShjb25zdGFudHMuZW51bWVyYWJsZSwge1xuICAgICAgICB2YWx1ZTogZGVzYy52YWx1ZS5lbnVtZXJhYmxlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBsYWJlbDogZGVzYy52YWx1ZS5sYWJlbFxuICAgIH0sIGZhbHNlKTtcbiAgICBvYmouRGVmaW5lT3duUHJvcGVydHkoY29uc3RhbnRzLmNvbmZpZ3VyYWJsZSwge1xuICAgICAgICB2YWx1ZTogZGVzYy52YWx1ZS5jb25maWd1cmFibGUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGxhYmVsOiBkZXNjLnZhbHVlLmxhYmVsXG4gICAgfSwgZmFsc2UpO1xuICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUob2JqLCBkZXNjLmxhYmVsKTtcbn07XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIDE1LjIuMy40XG5mdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXNBcmcsIGFyZ3MpIHtcbiAgICB2YXIgTyA9IGFyZ3NbMF0gfHwgbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgbGFiZWxfMS5ib3QpO1xuICAgIGFzc2VydE9iamVjdChPLCAnT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMnKTtcbiAgICB2YXIgcHJvcGVydHlOYW1lcyA9IE8udmFsdWUuZ2V0T3duUHJvcGVydHlOYW1lcyhPLmxhYmVsKTtcbiAgICB2YXIgYXJyYXkgPSBBcnJheU9iamVjdF8xLkFycmF5T2JqZWN0LmZyb21Qcm9wZXJ0eUFycmF5KHByb3BlcnR5TmFtZXMsIE8udmFsdWUuc3RydWN0KTtcbiAgICByZXR1cm4gbmV3IHZhbHVlc18xLlZhbHVlKGFycmF5LCBsYWJlbF8xLmJvdCk7XG59XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIDE1LjIuMy41XG5mdW5jdGlvbiBjcmVhdGUodGhpc0FyZywgYXJncykge1xuICAgIHZhciBPID0gYXJnc1swXSB8fCBuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCBsYWJlbF8xLmJvdCk7XG4gICAgdmFyIFByb3BlcnRpZXMgPSBhcmdzWzFdIHx8IG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIGxhYmVsXzEuYm90KTtcbiAgICBpZiAoTy52YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICBhc3NlcnRPYmplY3QoTywgJ09iamVjdC5jcmVhdGUnKTtcbiAgICB9XG4gICAgdmFyIG9iaiA9IG5ldyBPYmplY3RPYmplY3RfMS5PYmplY3RPYmplY3QoKTtcbiAgICBvYmouUHJvdG90eXBlID0gTztcbiAgICB2YXIgb2JqVmFsdWUgPSBuZXcgdmFsdWVzXzEuVmFsdWUob2JqLCBsYWJlbF8xLmJvdCk7XG4gICAgaWYgKFByb3BlcnRpZXMudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXNBcmcsIFtvYmpWYWx1ZSwgUHJvcGVydGllc10pO1xuICAgIH1cbiAgICByZXR1cm4gb2JqVmFsdWU7XG59XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIFRvUHJvcGVydHlEZXNjcmlwdG9yKE9iaikge1xuICAgIGFzc2VydE9iamVjdChPYmosICdPYmplY3QuVG9Qcm9wZXJ0eURlc2NyaXB0b3InKTtcbiAgICB2YXIgYyA9IG1vbml0b3IuY29udGV4dDtcbiAgICB2YXIgbGJsID0gbmV3IGxhYmVsXzEuTGFiZWwoKTtcbiAgICB2YXIgZGVzYyA9IHt9O1xuICAgIHZhciBiO1xuICAgIHZhciB4O1xuICAgIHZhciBwcm9wZXJ0eU5hbWU7XG4gICAgLy8gZW51bWVyYWJsZVxuICAgIHByb3BlcnR5TmFtZSA9IGNvbnN0YW50cy5lbnVtZXJhYmxlO1xuICAgIGIgPSBPYmouSGFzUHJvcGVydHkocHJvcGVydHlOYW1lKTtcbiAgICBsYmwubHViKGIubGFiZWwpO1xuICAgIGlmIChiLnZhbHVlKSB7XG4gICAgICAgIGMucHVzaFBDKGIubGFiZWwpO1xuICAgICAgICB4ID0gVG9Cb29sZWFuXzEuVG9Cb29sZWFuKE9iai5HZXQocHJvcGVydHlOYW1lKSk7XG4gICAgICAgIGMucG9wUEMoKTtcbiAgICAgICAgbGJsLmx1Yih4LmxhYmVsKTtcbiAgICAgICAgZGVzY1twcm9wZXJ0eU5hbWUudmFsdWVdID0geC52YWx1ZTtcbiAgICB9XG4gICAgLy8gY29uZmlndXJhYmxlXG4gICAgcHJvcGVydHlOYW1lID0gY29uc3RhbnRzLmNvbmZpZ3VyYWJsZTtcbiAgICBiID0gT2JqLkhhc1Byb3BlcnR5KHByb3BlcnR5TmFtZSk7XG4gICAgbGJsLmx1YihiLmxhYmVsKTtcbiAgICBpZiAoYi52YWx1ZSkge1xuICAgICAgICBjLnB1c2hQQyhiLmxhYmVsKTtcbiAgICAgICAgeCA9IFRvQm9vbGVhbl8xLlRvQm9vbGVhbihPYmouR2V0KHByb3BlcnR5TmFtZSkpO1xuICAgICAgICBjLnBvcFBDKCk7XG4gICAgICAgIGxibC5sdWIoeC5sYWJlbCk7XG4gICAgICAgIGRlc2NbcHJvcGVydHlOYW1lLnZhbHVlXSA9IHgudmFsdWU7XG4gICAgfVxuICAgIC8vIHZhbHVlXG4gICAgcHJvcGVydHlOYW1lID0gY29uc3RhbnRzLnZhbHVlO1xuICAgIGIgPSBPYmouSGFzUHJvcGVydHkocHJvcGVydHlOYW1lKTtcbiAgICBsYmwubHViKGIubGFiZWwpO1xuICAgIGlmIChiLnZhbHVlKSB7XG4gICAgICAgIGMucHVzaFBDKGIubGFiZWwpO1xuICAgICAgICB4ID0gT2JqLkdldChwcm9wZXJ0eU5hbWUpO1xuICAgICAgICBjLnBvcFBDKCk7XG4gICAgICAgIGxibC5sdWIoeC5sYWJlbCk7XG4gICAgICAgIGRlc2NbcHJvcGVydHlOYW1lLnZhbHVlXSA9IHgudmFsdWU7XG4gICAgfVxuICAgIC8vIHdyaXRhYmxlXG4gICAgcHJvcGVydHlOYW1lID0gY29uc3RhbnRzLndyaXRhYmxlO1xuICAgIGIgPSBPYmouSGFzUHJvcGVydHkocHJvcGVydHlOYW1lKTtcbiAgICBsYmwubHViKGIubGFiZWwpO1xuICAgIGlmIChiLnZhbHVlKSB7XG4gICAgICAgIGMucHVzaFBDKGIubGFiZWwpO1xuICAgICAgICB4ID0gVG9Cb29sZWFuXzEuVG9Cb29sZWFuKE9iai5HZXQocHJvcGVydHlOYW1lKSk7XG4gICAgICAgIGMucG9wUEMoKTtcbiAgICAgICAgbGJsLmx1Yih4LmxhYmVsKTtcbiAgICAgICAgZGVzY1twcm9wZXJ0eU5hbWUudmFsdWVdID0geC52YWx1ZTtcbiAgICB9XG4gICAgLy8gZ2V0XG4gICAgcHJvcGVydHlOYW1lID0gY29uc3RhbnRzLmdldDtcbiAgICBiID0gT2JqLkhhc1Byb3BlcnR5KHByb3BlcnR5TmFtZSk7XG4gICAgbGJsLmx1YihiLmxhYmVsKTtcbiAgICBpZiAoYi52YWx1ZSkge1xuICAgICAgICBjLnB1c2hQQyhiLmxhYmVsKTtcbiAgICAgICAgeCA9IE9iai5HZXQocHJvcGVydHlOYW1lKTtcbiAgICAgICAgYy5wb3BQQygpO1xuICAgICAgICBsYmwubHViKHgubGFiZWwpO1xuICAgICAgICBkZXNjW3Byb3BlcnR5TmFtZS52YWx1ZV0gPSB4LnZhbHVlO1xuICAgIH1cbiAgICAvLyBzZXRcbiAgICBwcm9wZXJ0eU5hbWUgPSBjb25zdGFudHMuc2V0O1xuICAgIGIgPSBPYmouSGFzUHJvcGVydHkocHJvcGVydHlOYW1lKTtcbiAgICBsYmwubHViKGIubGFiZWwpO1xuICAgIGlmIChiLnZhbHVlKSB7XG4gICAgICAgIGMucHVzaFBDKGIubGFiZWwpO1xuICAgICAgICB4ID0gT2JqLkdldChwcm9wZXJ0eU5hbWUpO1xuICAgICAgICBjLnBvcFBDKCk7XG4gICAgICAgIGxibC5sdWIoeC5sYWJlbCk7XG4gICAgICAgIGRlc2NbcHJvcGVydHlOYW1lLnZhbHVlXSA9IHgudmFsdWU7XG4gICAgfVxuICAgIGRlc2MubGFiZWwgPSBsYmw7XG4gICAgcmV0dXJuIGRlc2M7XG59XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIDE1LjIuMy42XG5mdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eSh0aGlzQXJnLCBhcmdzKSB7XG4gICAgdmFyIE8gPSBhcmdzWzBdIHx8IG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIGxhYmVsXzEuYm90KTtcbiAgICB2YXIgUCA9IGFyZ3NbMV0gfHwgbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgbGFiZWxfMS5ib3QpO1xuICAgIHZhciBBdHRyaWJ1dGVzID0gYXJnc1syXSB8fCBuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCBsYWJlbF8xLmJvdCk7XG4gICAgYXNzZXJ0T2JqZWN0KE8sICdPYmplY3QuZGVmaW5lUHJvcGVydHknKTtcbiAgICB2YXIgbmFtZSA9IFRvU3RyaW5nXzEuVG9TdHJpbmcoUCk7XG4gICAgdmFyIGRlc2MgPSBUb1Byb3BlcnR5RGVzY3JpcHRvcihBdHRyaWJ1dGVzKTtcbiAgICBPLkRlZmluZU93blByb3BlcnR5KG5hbWUsIGRlc2MsIHRydWUpO1xuICAgIHJldHVybiBPO1xufVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAxNS4yLjMuN1xuZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0aGlzQXJnLCBhcmdzKSB7XG4gICAgdmFyIE8gPSBhcmdzWzBdIHx8IG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIGxhYmVsXzEuYm90KTtcbiAgICB2YXIgUHJvcGVydGllcyA9IGFyZ3NbMV0gfHwgbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgbGFiZWxfMS5ib3QpO1xuICAgIGFzc2VydE9iamVjdChPLCAnT2JqZWN0LmRlZmluZVByb3BlcnRpZXMnKTtcbiAgICB2YXIgcHJvcHMgPSBUb09iamVjdF8xLlRvT2JqZWN0KFByb3BlcnRpZXMpO1xuICAgIHZhciBuYW1lcyA9IHByb3BzLnZhbHVlLmdldE93bkVudW1lcmFibGVQcm9wZXJ0eU5hbWVzKHByb3BzLmxhYmVsKTtcbiAgICB2YXIgZGVzY3JpcHRvcnMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIFBfMSA9IG5hbWVzW2ldO1xuICAgICAgICB2YXIgZGVzY09iamVjdCA9IHByb3BzLkdldChQXzEpO1xuICAgICAgICB2YXIgZGVzYyA9IFRvUHJvcGVydHlEZXNjcmlwdG9yKGRlc2NPYmplY3QpO1xuICAgICAgICBkZXNjcmlwdG9ycy5wdXNoKFBfMSk7XG4gICAgICAgIGRlc2NyaXB0b3JzLnB1c2goZGVzYyk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkZXNjcmlwdG9ycy5sZW5ndGg7IGkgPCBsZW47IGkgPSBpICsgMikge1xuICAgICAgICB2YXIgUCA9IGRlc2NyaXB0b3JzW2ldO1xuICAgICAgICB2YXIgZGVzYyA9IGRlc2NyaXB0b3JzW2kgKyAxXTtcbiAgICAgICAgTy5EZWZpbmVPd25Qcm9wZXJ0eShQLCBkZXNjLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIE87XG59XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIDE1LjIuMy44XG5mdW5jdGlvbiBzZWFsKHRoaXNBcmcsIGFyZ3MpIHtcbiAgICB2YXIgTyA9IGFyZ3NbMF0gfHwgbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgbGFiZWxfMS5ib3QpO1xuICAgIGFzc2VydE9iamVjdChPLCAnT2JqZWN0LmRlZmluZVByb3BlcnRpZXMnKTtcbiAgICB2YXIgY29udGV4dCA9IGxhYmVsXzEubHViKG1vbml0b3IuY29udGV4dC5lZmZlY3RpdmVQQywgTy5sYWJlbCk7XG4gICAgbW9uaXRvci5hc3NlcnQobGFiZWxfMS5sZShjb250ZXh0LCBPLnZhbHVlLnN0cnVjdCksICdPYmplY3Quc2VhbDogY29udGV4dCBsYWJlbCAnICsgY29udGV4dCArICcgbm90IGJlbG93IHN0cnVjdHVyYWwgbGFiZWwgJyArIE8udmFsdWUuc3RydWN0ICsgJyBvZiBvYmplY3QnKTtcbiAgICB2YXIgbGFiZWxzID0gTy52YWx1ZS5sYWJlbHM7XG4gICAgZm9yICh2YXIgeCBpbiBsYWJlbHMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGxhYmVscywgeCkpIHtcbiAgICAgICAgICAgIG1vbml0b3IuYXNzZXJ0KGxhYmVsXzEubGUoY29udGV4dCwgbGFiZWxzW3hdLnZhbHVlKSwgJ09iamVjdC5zZWFsOiBjb250ZXh0IGxhYmVsICcgKyBjb250ZXh0ICsgJyBub3QgYmVsb3cgbGFiZWwgJyArIGxhYmVsc1t4XS52YWx1ZSArICcgb2YgJyArIHgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5zZWFsKE8udmFsdWUucHJvcGVydGllcyk7XG4gICAgTy52YWx1ZS5FeHRlbnNpYmxlID0gZmFsc2U7XG4gICAgcmV0dXJuIE87XG59XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIDE1LjIuMy45XG5mdW5jdGlvbiBmcmVlemUodGhpc0FyZywgYXJncykge1xuICAgIHZhciBPID0gYXJnc1swXSB8fCBuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCBsYWJlbF8xLmJvdCk7XG4gICAgYXNzZXJ0T2JqZWN0KE8sICdPYmplY3QuZnJlZXplJyk7XG4gICAgdmFyIGNvbnRleHQgPSBsYWJlbF8xLmx1Yihtb25pdG9yLmNvbnRleHQuZWZmZWN0aXZlUEMsIE8ubGFiZWwpO1xuICAgIG1vbml0b3IuYXNzZXJ0KGxhYmVsXzEubGUoY29udGV4dCwgTy52YWx1ZS5zdHJ1Y3QpLCAnT2JqZWN0LmZyZWV6ZTogY29udGV4dCBsYWJlbCAnICsgY29udGV4dCArICcgbm90IGJlbG93IHN0cnVjdHVyYWwgbGFiZWwgJyArIE8udmFsdWUuc3RydWN0ICsgJyBvZiBvYmplY3QnKTtcbiAgICB2YXIgbGFiZWxzID0gTy52YWx1ZS5sYWJlbHM7XG4gICAgdmFyIHByb3BlcnRpZXMgPSBPLnZhbHVlLnByb3BlcnRpZXM7XG4gICAgZm9yICh2YXIgeCBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChwcm9wZXJ0aWVzLCB4KSkge1xuICAgICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3BlcnRpZXMsIHgpO1xuICAgICAgICAgICAgaWYgKGRlc2MuZW51bWVyYWJsZSkge1xuICAgICAgICAgICAgICAgIG1vbml0b3IuYXNzZXJ0KGxhYmVsXzEubGUoY29udGV4dCwgbGFiZWxzW3hdLnZhbHVlKSwgJ09iamVjdC5mcmVlemU6IGNvbnRleHQgbGFiZWwgJyArIGNvbnRleHQgKyAnIG5vdCBiZWxvdyBsYWJlbCAnICsgbGFiZWxzW3hdLnZhbHVlICsgJyBvZiAnICsgeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmZyZWV6ZShPLnZhbHVlLnByb3BlcnRpZXMpO1xuICAgIE8udmFsdWUuRXh0ZW5zaWJsZSA9IGZhbHNlO1xuICAgIHJldHVybiBPO1xufVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAxNS4yLjMuMTBcbmZ1bmN0aW9uIHByZXZlbnRFeHRlbnNpb25zKHRoaXNBcmcsIGFyZ3MpIHtcbiAgICB2YXIgTyA9IGFyZ3NbMF0gfHwgbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgbGFiZWxfMS5ib3QpO1xuICAgIGFzc2VydE9iamVjdChPLCAnT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zJyk7XG4gICAgdmFyIGNvbnRleHQgPSBsYWJlbF8xLmx1Yihtb25pdG9yLmNvbnRleHQuZWZmZWN0aXZlUEMsIE8ubGFiZWwpO1xuICAgIG1vbml0b3IuYXNzZXJ0KGxhYmVsXzEubGUoY29udGV4dCwgTy52YWx1ZS5zdHJ1Y3QpLCAnT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zOiBjb250ZXh0IGxhYmVsICcgKyBjb250ZXh0ICsgJyBub3QgYmVsb3cgc3RydWN0dXJhbCBsYWJlbCAnICsgTy52YWx1ZS5zdHJ1Y3QgKyAnIG9mIG9iamVjdCcpO1xuICAgIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyhPLnZhbHVlLnByb3BlcnRpZXMpO1xuICAgIE8udmFsdWUuRXh0ZW5zaWJsZSA9IGZhbHNlO1xuICAgIHJldHVybiBPO1xufVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAxNS4yLjMuMTFcbmZ1bmN0aW9uIGlzU2VhbGVkKHRoaXNBcmcsIGFyZ3MpIHtcbiAgICB2YXIgTyA9IGFyZ3NbMF0gfHwgbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgbGFiZWxfMS5ib3QpO1xuICAgIGFzc2VydE9iamVjdChPLCAnT2JqZWN0LmlzU2VhbGVkJyk7XG4gICAgdmFyIHJlc3VsdCA9IE9iamVjdC5pc1NlYWxlZChPLnZhbHVlLnByb3BlcnRpZXMpO1xuICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUocmVzdWx0LCBsYWJlbF8xLmx1YihPLmxhYmVsLCBPLnZhbHVlLnN0cnVjdCkpO1xufVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAxNS4yLjMuMTJcbmZ1bmN0aW9uIGlzRnJvemVuKHRoaXNBcmcsIGFyZ3MpIHtcbiAgICB2YXIgTyA9IGFyZ3NbMF0gfHwgbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgbGFiZWxfMS5ib3QpO1xuICAgIGFzc2VydE9iamVjdChPLCAnT2JqZWN0LmlzRnJvemVuJyk7XG4gICAgdmFyIHJlc3VsdCA9IE9iamVjdC5pc0Zyb3plbihPLnZhbHVlLnByb3BlcnRpZXMpO1xuICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUocmVzdWx0LCBsYWJlbF8xLmx1YihPLmxhYmVsLCBPLnZhbHVlLnN0cnVjdCkpO1xufVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAxNS4yLjMuMTNcbmZ1bmN0aW9uIGlzRXh0ZW5zaWJsZSh0aGlzQXIsIGFyZ3MpIHtcbiAgICB2YXIgTyA9IGFyZ3NbMF0gfHwgbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgbGFiZWxfMS5ib3QpO1xuICAgIGFzc2VydE9iamVjdChPLCAnT2JqZWN0LmlzRXh0ZW5zaWJsZScpO1xuICAgIHZhciByZXN1bHQgPSBPYmplY3QuaXNFeHRlbnNpYmxlKE8udmFsdWUucHJvcGVydGllcyk7XG4gICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZShyZXN1bHQsIGxhYmVsXzEubHViKE8ubGFiZWwsIE8udmFsdWUuc3RydWN0KSk7XG59XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIDE1LjIuMy4xNFxuZnVuY3Rpb24ga2V5cyh0aGlzQXJnLCBhcmdzKSB7XG4gICAgdmFyIE8gPSBhcmdzWzBdIHx8IG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIGxhYmVsXzEuYm90KTtcbiAgICBhc3NlcnRPYmplY3QoTywgJ09iamVjdC5rZXlzJyk7XG4gICAgdmFyIGVudW1lcmFibGUgPSBPLnZhbHVlLmdldE93bkVudW1lcmFibGVQcm9wZXJ0eU5hbWVzKE8ubGFiZWwpO1xuICAgIHZhciBhcnJheSA9IEFycmF5T2JqZWN0XzEuQXJyYXlPYmplY3QuZnJvbVByb3BlcnR5QXJyYXkoZW51bWVyYWJsZSwgTy52YWx1ZS5zdHJ1Y3QpO1xuICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUoYXJyYXksIGxhYmVsXzEuYm90KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9iamVjdENvbnN0cnVjdG9yLmpzLm1hcCIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2YWx1ZXNfMSA9IHJlcXVpcmUoXCIuLi92YWx1ZXNcIik7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBUb0Jvb2xlYW4sIDkuMlxuZnVuY3Rpb24gVG9Cb29sZWFuKHgpIHtcbiAgICByZXR1cm4gbmV3IHZhbHVlc18xLlZhbHVlKEJvb2xlYW4oeC52YWx1ZSksIHgubGFiZWwpO1xufVxuZXhwb3J0cy5Ub0Jvb2xlYW4gPSBUb0Jvb2xlYW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ub0Jvb2xlYW4uanMubWFwIiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFRvTnVtYmVyXzEgPSByZXF1aXJlKFwiLi9Ub051bWJlclwiKTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFRvSW50MzIsIDkuNVxuZnVuY3Rpb24gVG9JbnQzMih4KSB7XG4gICAgcmV0dXJuIFRvTnVtYmVyXzEuVG9OdW1iZXIoeCk7XG59XG5leHBvcnRzLlRvSW50MzIgPSBUb0ludDMyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VG9JbnQzMi5qcy5tYXAiLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmFsdWVzXzEgPSByZXF1aXJlKFwiLi4vdmFsdWVzXCIpO1xudmFyIFRvTnVtYmVyXzEgPSByZXF1aXJlKFwiLi9Ub051bWJlclwiKTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFRvSW50ZWdlciwgOS40XG4vLyAgICAgICAgVXNpbmcgVG9OdW1iZXIgdG8gY2FwdHVyZSB0aGUgVG9QcmltaXRpdmVcbi8vICAgICAgICBhbmQgcmVseSBvbiB0aGUgaW50ZXJuYWwgY29udmVyc2lvbiBhdCB0aGUgcG9pbnQgb2YgdXNlXG4vLyAgICAgICAgc2hvdWxkIHN1ZmZpY2UuXG5mdW5jdGlvbiBUb0ludGVnZXIoeCkge1xuICAgIHZhciBudW1iZXIgPSBUb051bWJlcl8xLlRvTnVtYmVyKHgpO1xuICAgIHZhciBzaWduID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgaWYgKG4gPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH07XG4gICAgaWYgKGlzTmFOKG51bWJlci52YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZSgwLCBudW1iZXIubGFiZWwpO1xuICAgIH1cbiAgICBlbHNlIGlmIChudW1iZXIudmFsdWUgPT09IDAgfHxcbiAgICAgICAgbnVtYmVyLnZhbHVlID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgfHxcbiAgICAgICAgbnVtYmVyLnZhbHVlID09PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpIHtcbiAgICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUoc2lnbihudW1iZXIudmFsdWUpICogTWF0aC5mbG9vcihNYXRoLmFicyhudW1iZXIudmFsdWUpKSwgbnVtYmVyLmxhYmVsKTtcbiAgICB9XG59XG5leHBvcnRzLlRvSW50ZWdlciA9IFRvSW50ZWdlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRvSW50ZWdlci5qcy5tYXAiLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmFsdWVzXzEgPSByZXF1aXJlKFwiLi4vdmFsdWVzXCIpO1xudmFyIFRvUHJpbWl0aXZlXzEgPSByZXF1aXJlKFwiLi9Ub1ByaW1pdGl2ZVwiKTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFRvTnVtYmVyLCA5LjNcbmZ1bmN0aW9uIFRvTnVtYmVyKHgpIHtcbiAgICBpZiAodHlwZW9mIHgudmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUoTnVtYmVyKHgudmFsdWUpLCB4LmxhYmVsKTtcbiAgICB9XG4gICAgbW9uaXRvci5jb250ZXh0LnB1c2hQQyh4LmxhYmVsKTtcbiAgICB2YXIgcHJpbVZhbHVlID0gVG9QcmltaXRpdmVfMS5Ub1ByaW1pdGl2ZSh4LCAnbnVtYmVyJyk7XG4gICAgbW9uaXRvci5jb250ZXh0LnBvcFBDKCk7XG4gICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZShOdW1iZXIocHJpbVZhbHVlLnZhbHVlKSwgcHJpbVZhbHVlLmxhYmVsKTtcbn1cbmV4cG9ydHMuVG9OdW1iZXIgPSBUb051bWJlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRvTnVtYmVyLmpzLm1hcCIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2YWx1ZXNfMSA9IHJlcXVpcmUoXCIuLi92YWx1ZXNcIik7XG52YXIgbGFiZWxfMSA9IHJlcXVpcmUoXCIuLi9sYWJlbFwiKTtcbnZhciBCb29sZWFuT2JqZWN0XzEgPSByZXF1aXJlKFwiLi4vT2JqZWN0cy9Cb29sZWFuT2JqZWN0XCIpO1xudmFyIE51bWJlck9iamVjdF8xID0gcmVxdWlyZShcIi4uL09iamVjdHMvTnVtYmVyT2JqZWN0XCIpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVG9PYmplY3QsIDkuOVxuZnVuY3Rpb24gVG9PYmplY3QoeCkge1xuICAgIC8vIG51bGwgb3IgdW5kZWZpbmVkLCBoZW5jZSA9PVxuICAgIGlmICh4LnZhbHVlID09PSBudWxsIHx8IHgudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtb25pdG9yLmNvbnRleHQucHVzaFBDKHgubGFiZWwpO1xuICAgICAgICBtb25pdG9yLlRocm93KG1vbml0b3IubW9kdWxlcy5lcnJvci5UeXBlRXJyb3JPYmplY3QsICdjYW5ub3QgY29udmVydCAnICsgU3RyaW5nKHgudmFsdWUpICsgJyB0byBvYmplY3QnLCBsYWJlbF8xLmJvdCk7XG4gICAgfVxuICAgIHZhciByZXMgPSBuZXcgdmFsdWVzXzEuVmFsdWUoeC52YWx1ZSwgeC5sYWJlbCk7XG4gICAgbW9uaXRvci5jb250ZXh0LnB1c2hQQyh4LmxhYmVsKTtcbiAgICBzd2l0Y2ggKHR5cGVvZiB4LnZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgcmVzLnZhbHVlID0gbmV3IEJvb2xlYW5PYmplY3RfMS5Cb29sZWFuT2JqZWN0KHgudmFsdWUsIHgubGFiZWwpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICByZXMudmFsdWUgPSBuZXcgTnVtYmVyT2JqZWN0XzEuTnVtYmVyT2JqZWN0KHgudmFsdWUsIHgubGFiZWwpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICByZXMudmFsdWUgPSBuZXcgbW9uaXRvci5tb2R1bGVzLnN0cmluZy5TdHJpbmdPYmplY3QoeC52YWx1ZSwgeC5sYWJlbCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgbW9uaXRvci5jb250ZXh0LnBvcFBDKCk7XG4gICAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydHMuVG9PYmplY3QgPSBUb09iamVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRvT2JqZWN0LmpzLm1hcCIsIi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFRvUHJpbWl0aXZlLCA5LjEgIFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gVG9QcmltaXRpdmUoeCwgUHJlZmVycmVkVHlwZSkge1xuICAgIGlmICh4LnZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB4LnZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gICAgLy8gd2lsbCBydW4gaW50IHRoZSBjb250ZXh0IG9mIHggZHVlIHRvIHZhbHVlIGxpZnRpbmdcbiAgICB2YXIgcmVzID0geC5EZWZhdWx0VmFsdWUoUHJlZmVycmVkVHlwZSk7XG4gICAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydHMuVG9QcmltaXRpdmUgPSBUb1ByaW1pdGl2ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRvUHJpbWl0aXZlLmpzLm1hcCIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2YWx1ZXNfMSA9IHJlcXVpcmUoXCIuLi92YWx1ZXNcIik7XG52YXIgVG9QcmltaXRpdmVfMSA9IHJlcXVpcmUoXCIuL1RvUHJpbWl0aXZlXCIpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVG9TdHJpbmcsIDkuOFxuZnVuY3Rpb24gVG9TdHJpbmcoeCkge1xuICAgIGlmICh0eXBlb2YgeC52YWx1ZSAhPT0gJ29iamVjdCcpXG4gICAgICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUoU3RyaW5nKHgudmFsdWUpLCB4LmxhYmVsKTtcbiAgICBtb25pdG9yLmNvbnRleHQucHVzaFBDKHgubGFiZWwpO1xuICAgIHZhciBwcmltVmFsdWUgPSBUb1ByaW1pdGl2ZV8xLlRvUHJpbWl0aXZlKHgsICdzdHJpbmcnKTtcbiAgICBtb25pdG9yLmNvbnRleHQucG9wUEMoKTtcbiAgICByZXR1cm4gbmV3IHZhbHVlc18xLlZhbHVlKFN0cmluZyhwcmltVmFsdWUudmFsdWUpLCBwcmltVmFsdWUubGFiZWwpO1xufVxuZXhwb3J0cy5Ub1N0cmluZyA9IFRvU3RyaW5nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VG9TdHJpbmcuanMubWFwIiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZhbHVlc18xID0gcmVxdWlyZShcIi4uL3ZhbHVlc1wiKTtcbnZhciBUb051bWJlcl8xID0gcmVxdWlyZShcIi4vVG9OdW1iZXJcIik7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBUb1VJbnQxNiwgOS43XG5mdW5jdGlvbiBUb1VJbnQxNih4KSB7XG4gICAgdmFyIHNpZ24gPSBmdW5jdGlvbiAobikge1xuICAgICAgICBpZiAobiA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG4gPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICB2YXIgbnVtYmVyID0gVG9OdW1iZXJfMS5Ub051bWJlcih4KTtcbiAgICBpZiAoaXNOYU4obnVtYmVyLnZhbHVlKSB8fFxuICAgICAgICBudW1iZXIudmFsdWUgPT09IDAgfHxcbiAgICAgICAgbnVtYmVyLnZhbHVlID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgfHxcbiAgICAgICAgbnVtYmVyLnZhbHVlID09PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZSgwLCBudW1iZXIubGFiZWwpO1xuICAgIH1cbiAgICB2YXIgcG9zSW50ID0gc2lnbihudW1iZXIudmFsdWUpICogTWF0aC5mbG9vcihNYXRoLmFicyhudW1iZXIudmFsdWUpKTtcbiAgICB2YXIgaW50MTZiaXQgPSBwb3NJbnQgJSBNYXRoLnBvdygyLCAxNik7XG4gICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZShpbnQxNmJpdCwgbnVtYmVyLmxhYmVsKTtcbn1cbmV4cG9ydHMuVG9VSW50MTYgPSBUb1VJbnQxNjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRvVUludDE2LmpzLm1hcCIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBUb051bWJlcl8xID0gcmVxdWlyZShcIi4vVG9OdW1iZXJcIik7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBUb1VJbnQzMiwgOS42XG5mdW5jdGlvbiBUb1VJbnQzMih4KSB7XG4gICAgcmV0dXJuIFRvTnVtYmVyXzEuVG9OdW1iZXIoeCk7XG59XG5leHBvcnRzLlRvVUludDMyID0gVG9VSW50MzI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ub1VJbnQzMi5qcy5tYXAiLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbGFiZWxfMSA9IHJlcXVpcmUoXCIuL2xhYmVsXCIpO1xudmFyIHZhbHVlc18xID0gcmVxdWlyZShcIi4vdmFsdWVzXCIpO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gSGFzSW5zdGFuY2UoVikge1xuICAgIHZhciBGID0gdGhpcztcbiAgICBpZiAodHlwZW9mIFYudmFsdWUgIT09ICdvYmplY3QnKVxuICAgICAgICByZXR1cm4gbmV3IHZhbHVlc18xLlZhbHVlKGZhbHNlLCBWLmxhYmVsKTtcbiAgICB2YXIgbCA9IFYubGFiZWw7XG4gICAgdmFyIE8gPSBGLkdldChjb25zdGFudHMucHJvdG90eXBlKTtcbiAgICBpZiAodHlwZW9mIE8udmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIG1vbml0b3IuVGhyb3cobW9uaXRvci5tb2R1bGVzLmVycm9yLlR5cGVFcnJvck9iamVjdCwgJ0hhc0luc3RhbmNlJywgbGFiZWxfMS5ib3QpO1xuICAgIH1cbiAgICB3aGlsZSAoVi52YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICBWID0gVi52YWx1ZS5Qcm90b3R5cGU7XG4gICAgICAgIGwgPSBsYWJlbF8xLmx1YihsLCBWLmxhYmVsKTtcbiAgICAgICAgaWYgKE8udmFsdWUgPT09IFYudmFsdWUpXG4gICAgICAgICAgICByZXR1cm4gbmV3IHZhbHVlc18xLlZhbHVlKHRydWUsIGwpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHZhbHVlc18xLlZhbHVlKGZhbHNlLCBsKTtcbn1cbmV4cG9ydHMuSGFzSW5zdGFuY2UgPSBIYXNJbnN0YW5jZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUhhc0luc3RhbmNlLmpzLm1hcCIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZhbHVlc18xID0gcmVxdWlyZShcIi4uL3ZhbHVlc1wiKTtcbnZhciBfID0gcmVxdWlyZShcInVuZGVyc2NvcmVcIik7XG52YXIgZWNtYV8xID0gcmVxdWlyZShcIi4uL2VjbWFcIik7XG52YXIgbGFiZWxfMSA9IHJlcXVpcmUoXCIuLi9sYWJlbFwiKTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gMTUuNC4yLjEsIGFuZCAxNS40LjIuMlxudmFyIEFycmF5T2JqZWN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBcnJheU9iamVjdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBcnJheU9iamVjdChzdHJ1Y3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuQ2xhc3MgPSAnQXJyYXknO1xuICAgICAgICBfdGhpcy5Qcm90b3R5cGUgPSBuZXcgdmFsdWVzXzEuVmFsdWUobW9uaXRvci5pbnN0YW5jZXMuQXJyYXlQcm90b3R5cGUsIGxhYmVsXzEuYm90KTtcbiAgICAgICAgX3RoaXMuRXh0ZW5zaWJsZSA9IHRydWU7XG4gICAgICAgIF90aGlzLnByb3BlcnRpZXMgPSBbXTtcbiAgICAgICAgX3RoaXMubGFiZWxzID0ge307XG4gICAgICAgIHN0cnVjdCA9IHN0cnVjdCB8fCBsYWJlbF8xLmJvdDtcbiAgICAgICAgX3RoaXMubGFiZWxzLmxlbmd0aCA9IHtcbiAgICAgICAgICAgIHZhbHVlOiBzdHJ1Y3QsXG4gICAgICAgICAgICBleGlzdGVuY2U6IGxhYmVsXzEuYm90XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnN0cnVjdCA9IHN0cnVjdDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvLyAtLS1cbiAgICBBcnJheU9iamVjdC5mcm9tVmFsdWVBcnJheSA9IGZ1bmN0aW9uICh2YWx1ZXMsIHN0cnVjdCkge1xuICAgICAgICB2YXIgYXJyYXkgPSBuZXcgQXJyYXlPYmplY3Qoc3RydWN0KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbHVlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgYXJyYXkucHJvcGVydGllc1tpXSA9IHZhbHVlLnZhbHVlO1xuICAgICAgICAgICAgYXJyYXkubGFiZWxzW2ldID0ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZS5sYWJlbCxcbiAgICAgICAgICAgICAgICBleGlzdGVuY2U6IGxhYmVsXzEuYm90XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnJheTtcbiAgICB9O1xuICAgIC8vIC0tLVxuICAgIEFycmF5T2JqZWN0LmZyb21Qcm9wZXJ0eUFycmF5ID0gZnVuY3Rpb24gKHZhbHVlcywgc3RydWN0KSB7XG4gICAgICAgIHZhciBhcnJheSA9IG5ldyBBcnJheU9iamVjdChzdHJ1Y3QpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdmFsdWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAgICAgICBhcnJheS5wcm9wZXJ0aWVzW2ldID0gdmFsdWUudmFsdWU7XG4gICAgICAgICAgICBhcnJheS5sYWJlbHNbaV0gPSB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLmxhYmVsLFxuICAgICAgICAgICAgICAgIGV4aXN0ZW5jZTogdmFsdWUubGFiZWxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH07XG4gICAgLy8gLS0tXG4gICAgQXJyYXlPYmplY3QuZnJvbUFycmF5ID0gZnVuY3Rpb24gKHZhbHVlcywgbGFiZWwsIGV4aXN0ZW5jZSkge1xuICAgICAgICB2YXIgYXJyYXkgPSBuZXcgQXJyYXlPYmplY3QoZXhpc3RlbmNlKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbHVlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgYXJyYXkucHJvcGVydGllc1tpXSA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgIGFycmF5LmxhYmVsc1tpXSA9IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbGFiZWwsXG4gICAgICAgICAgICAgICAgZXhpc3RlbmNlOiBleGlzdGVuY2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH07XG4gICAgLy8gLS0tXG4gICAgQXJyYXlPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLnRvU3RyaW5nKCk7XG4gICAgfTtcbiAgICAvLyAtLS1cbiAgICBBcnJheU9iamVjdC5wcm90b3R5cGUuRGVmaW5lT3duUHJvcGVydHkgPSBmdW5jdGlvbiAocywgZGVzYywgVGhyb3cpIHtcbiAgICAgICAgdmFyIGMgPSBtb25pdG9yLmNvbnRleHQ7XG4gICAgICAgIC8qIEluc3RlYWQgb2YgbGVuZ3RoQ29udGV4dCA9IGx1YihjLmVmZmVjdGl2ZVBDLCBzLmxhYmVsKSwgcHVzaCBzLmxhYmVsIHRvXG4gICAgICAgICAgIHBjLXN0YWNrLCBhbmQgdXNlIHBjICh0byBtYWtlIHRhaW50TW9kZSBlYXNpZXIpICovXG4gICAgICAgIGMucGNTdGFjay5wdXNoKHMubGFiZWwpO1xuICAgICAgICBpZiAoIWxhYmVsXzEubGUoYy5lZmZlY3RpdmVQQywgdGhpcy5sYWJlbHMubGVuZ3RoLnZhbHVlKSkge1xuICAgICAgICAgICAgdmFyIG1zZ3QgPSBfLnRlbXBsYXRlKCdBcnJheS5wcm90b3R5cGUuRGVmaW5lT3duUHJvcGVydHk6IHdyaXRlIGNvbnRleHQgPCU9d2MlPiBub3QgYmVsb3cgbGVuZ3RoIGxhYmVsIDwlPWxsJT4nKTtcbiAgICAgICAgICAgIG1vbml0b3Iuc2VjdXJpdHlFcnJvcihtc2d0KHsgd2M6IGxlbmd0aENvbnRleHQsIGxsOiB0aGlzLmxhYmVscy5sZW5ndGgudmFsdWUgfSkpO1xuICAgICAgICAgICAgLy8gRm9yIG9ic2VydmFibGUgZmxvd3NcbiAgICAgICAgICAgIHRoaXMubGFiZWxzLmxlbmd0aC52YWx1ZS5sdWIobGVuZ3RoQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgYy5wY1N0YWNrLnBvcCgpO1xuICAgICAgICByZXR1cm4gZWNtYV8xLkVjbWEucHJvdG90eXBlLkRlZmluZU93blByb3BlcnR5LmNhbGwodGhpcywgcywgZGVzYywgVGhyb3cpO1xuICAgIH07XG4gICAgcmV0dXJuIEFycmF5T2JqZWN0O1xufShlY21hXzEuRWNtYSkpO1xuZXhwb3J0cy5BcnJheU9iamVjdCA9IEFycmF5T2JqZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXJyYXlPYmplY3QuanMubWFwIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmFsdWVzXzEgPSByZXF1aXJlKFwiLi4vdmFsdWVzXCIpO1xudmFyIGVjbWFfMSA9IHJlcXVpcmUoXCIuLi9lY21hXCIpO1xudmFyIGxhYmVsXzEgPSByZXF1aXJlKFwiLi4vbGFiZWxcIik7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEJvb2xlYW4gT2JqZWN0LCAxNS42LjVcbnZhciBCb29sZWFuT2JqZWN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCb29sZWFuT2JqZWN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJvb2xlYW5PYmplY3QodmFsLCBsYmwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuQ2xhc3MgPSAnQm9vbGVhbic7XG4gICAgICAgIF90aGlzLlByaW1pdGl2ZVZhbHVlID0gbmV3IEJvb2xlYW4odmFsKTtcbiAgICAgICAgX3RoaXMuUHJpbWl0aXZlTGFiZWwgPSBsYmw7XG4gICAgICAgIF90aGlzLkV4dGVuc2libGUgPSB0cnVlO1xuICAgICAgICBfdGhpcy5Qcm90b3R5cGUgPSBuZXcgdmFsdWVzXzEuVmFsdWUobW9uaXRvci5pbnN0YW5jZXMuQm9vbGVhblByb3RvdHlwZSwgbGFiZWxfMS5ib3QpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBCb29sZWFuT2JqZWN0O1xufShlY21hXzEuRWNtYSkpO1xuZXhwb3J0cy5Cb29sZWFuT2JqZWN0ID0gQm9vbGVhbk9iamVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJvb2xlYW5PYmplY3QuanMubWFwIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbGFiZWxfMSA9IHJlcXVpcmUoXCIuLi9sYWJlbFwiKTtcbnZhciB2YWx1ZXNfMSA9IHJlcXVpcmUoXCIuLi92YWx1ZXNcIik7XG52YXIgZWNtYV8xID0gcmVxdWlyZShcIi4uL2VjbWFcIik7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZShcIi4uL2NvbnN0YW50c1wiKTtcbnZhciBmdW5jdGlvbl8xID0gcmVxdWlyZShcIi4uL2Z1bmN0aW9uXCIpO1xudmFyIE9iamVjdE9iamVjdF8xID0gcmVxdWlyZShcIi4uL09iamVjdHMvT2JqZWN0T2JqZWN0XCIpO1xudmFyIEhhc0luc3RhbmNlXzEgPSByZXF1aXJlKFwiLi4vSGFzSW5zdGFuY2VcIik7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEZ1bmN0aW9uIG9iamVjdHMsIDEzLjJcbnZhciBGdW5jdGlvbk9iamVjdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRnVuY3Rpb25PYmplY3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRnVuY3Rpb25PYmplY3QocGFybXMsIGNvZGUsIHNjb3BlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLkNsYXNzID0gJ0Z1bmN0aW9uJztcbiAgICAgICAgX3RoaXMuUHJvdG90eXBlID0gbmV3IHZhbHVlc18xLlZhbHVlKG1vbml0b3IuaW5zdGFuY2VzLkZ1bmN0aW9uUHJvdG90eXBlLCBsYWJlbF8xLmJvdCk7XG4gICAgICAgIF90aGlzLlNjb3BlID0gc2NvcGU7XG4gICAgICAgIF90aGlzLkZvcm1hbFBhcmFtZXRlcnMgPSBwYXJtcyA/IHBhcm1zIDogeyBsZW5ndGg6IDAgfTtcbiAgICAgICAgX3RoaXMuQ29kZSA9IGNvZGU7XG4gICAgICAgIF90aGlzLkV4dGVuc2libGUgPSB0cnVlO1xuICAgICAgICBlY21hXzEuRGVmaW5lRkZUKF90aGlzLCBjb25zdGFudHMubGVuZ3RoLCBfdGhpcy5Gb3JtYWxQYXJhbWV0ZXJzLmxlbmd0aCk7XG4gICAgICAgIC8vIE5PVEU6IHdpbGwgYmUgdXBkYXRlZCB3aGVuIGNhbGxlZCBhbmQgc2luY2Ugd2UgcGlnZ3liYWNrIHByb3BlcnRpZXMgb24gbmF0aXZlIHByb3BlcnRpZXNcbiAgICAgICAgLy8gZGVmaW5pbmcgYXMgRkZGIHdpbGwgY2F1c2UgZnV0dXJlIHVwZGF0ZXMgdG8gZmFpbC4gVGh1cyB3ZSBkZWZpbmUgaXQgYXMgVEZUIGV2ZW4gdGhvdWdoXG4gICAgICAgIC8vIHRoaXMgdmlvbGF0ZXMgdGhlIHN0YW5kYXJkLlxuICAgICAgICBlY21hXzEuRGVmaW5lVEZUKF90aGlzLCBjb25zdGFudHMuYXJndW1lbnRzLCBudWxsKTtcbiAgICAgICAgZWNtYV8xLkRlZmluZUZGRihfdGhpcywgY29uc3RhbnRzLmNhbGxlciwgbnVsbCk7XG4gICAgICAgIHZhciBwcm90byA9IG5ldyBPYmplY3RPYmplY3RfMS5PYmplY3RPYmplY3QoKTtcbiAgICAgICAgZWNtYV8xLkRlZmluZVRGVChwcm90bywgY29uc3RhbnRzLmNvbnN0cnVjdG9yLCBfdGhpcyk7XG4gICAgICAgIGVjbWFfMS5EZWZpbmVURkYoX3RoaXMsIGNvbnN0YW50cy5wcm90b3R5cGUsIHByb3RvKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvLyAtLS1cbiAgICBGdW5jdGlvbk9iamVjdC5wcm90b3R5cGUuQXN5bmNDYWxsID0gZnVuY3Rpb24gKHRoaXNBcmcsIGFyZ3MpIHtcbiAgICAgICAgLy8gc3RlcCAxLCBhcyBpbiAxMC40LjMgZW1ib2RpZWQgaW4gZW50ZXJGdW5jdGlvbkNvZGVcbiAgICAgICAgdmFyIGZ1bmNDdHggPSBmdW5jdGlvbl8xLmVudGVyRnVuY3Rpb25Db2RlKHRoaXMsIHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICAvLyBmb3Igc3RhY2sgdHJhY2VcbiAgICAgICAgZnVuY0N0eC5vd25lciA9IHRoaXMuTmFtZTtcbiAgICAgICAgbW9uaXRvci5jb250ZXh0U3RhY2sucHVzaChmdW5jQ3R4KTtcbiAgICAgICAgdmFyIGlwID0gZnVuY0N0eC53b3JrTGlzdC50b3AoKTtcbiAgICAgICAgdmFyIHJlcztcbiAgICAgICAgaWYgKHRoaXMuQ29kZSkge1xuICAgICAgICAgICAgaXAudGhlbih0aGlzLkNvZGUpO1xuICAgICAgICAgICAgaXAudGhlbihBc3luY0NhbGxFbmQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaXAudGhlbihBc3luY0NhbGxFbmQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyAtLS1cbiAgICAvLyAxMy4yLjEgXG4gICAgRnVuY3Rpb25PYmplY3QucHJvdG90eXBlLkNhbGwgPSBmdW5jdGlvbiAodGhpc0FyZywgYXJncykge1xuICAgICAgICAvLyBzdGVwIDEsIGFzIGluIDEwLjQuMyBlbWJvZGllZCBpbiBlbnRlckZ1bmN0aW9uQ29kZVxuICAgICAgICB2YXIgZnVuY0N0eCA9IGZ1bmN0aW9uXzEuZW50ZXJGdW5jdGlvbkNvZGUodGhpcywgdGhpc0FyZywgYXJncyk7XG4gICAgICAgIC8vIGZvciBzdGFjayB0cmFjZVxuICAgICAgICBmdW5jQ3R4Lm93bmVyID0gdGhpcy5OYW1lO1xuICAgICAgICB2YXIgcmVzO1xuICAgICAgICBtb25pdG9yLmNvbnRleHRTdGFjay5wdXNoKGZ1bmNDdHgpO1xuICAgICAgICBpZiAodGhpcy5Db2RlKSB7XG4gICAgICAgICAgICByZXMgPSBtb25pdG9yLm1vZHVsZXMuZXhlYy5leGVjdXRlKHRoaXMuQ29kZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmdW5jQ3R4LnJlc3VsdC52YWx1ZSkge1xuICAgICAgICAgICAgZnVuY0N0eC5yZXN1bHQudmFsdWUucmFpc2UoZnVuY0N0eC5sYWJlbHMucmV0KTtcbiAgICAgICAgfVxuICAgICAgICBtb25pdG9yLmNvbnRleHRTdGFjay5wb3AoKTtcbiAgICAgICAgLy8gY29weSBvdXQgdGhlIGlubmVyIGV4Y2VwdGlvbiBsZXZlbFxuICAgICAgICBtb25pdG9yLmNvbnRleHQubGFiZWxzLmV4YyA9IGxhYmVsXzEubHViKG1vbml0b3IuY29udGV4dC5sYWJlbHMuZXhjLCBmdW5jQ3R4LmxhYmVscy5leGMpO1xuICAgICAgICBzd2l0Y2ggKHJlcy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICd0aHJvdyc6XG4gICAgICAgICAgICAgICAgdGhyb3cgcmVzLnZhbHVlO1xuICAgICAgICAgICAgY2FzZSAncmV0dXJuJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCBmdW5jQ3R4LmxhYmVscy5yZXQpO1xuICAgIH07XG4gICAgLy8gLS0tXG4gICAgRnVuY3Rpb25PYmplY3QucHJvdG90eXBlLkFzeW5jQ29uc3RydWN0ID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgdmFyIG9iaiA9IG5ldyBlY21hXzEuRWNtYSgpO1xuICAgICAgICBvYmouQ2xhc3MgPSAnT2JqZWN0JztcbiAgICAgICAgb2JqLkV4dGVuc2libGUgPSB0cnVlO1xuICAgICAgICB2YXIgcHJvdG8gPSB0aGlzLkdldChjb25zdGFudHMucHJvdG90eXBlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm90by52YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHByb3RvLnZhbHVlID0gbmV3IHZhbHVlc18xLlZhbHVlKG1vbml0b3IuaW5zdGFuY2VzLk9iamVjdFByb3RvdHlwZSwgbGFiZWxfMS5ib3QpO1xuICAgICAgICB9XG4gICAgICAgIG9iai5Qcm90b3R5cGUgPSBwcm90bztcbiAgICAgICAgdmFyIGlwID0gbW9uaXRvci5jb250ZXh0LndvcmtMaXN0LnRvcCgpO1xuICAgICAgICB0aGlzLkFzeW5jQ2FsbChuZXcgdmFsdWVzXzEuVmFsdWUob2JqLCBsYWJlbF8xLmJvdCksIGFyZ3MpO1xuICAgICAgICBpcC50aGVuKEFzeW5jQ29uc3RydWN0RW5kLCB7IG9iamVjdDogb2JqIH0pO1xuICAgICAgICByZXR1cm4gaXA7XG4gICAgfTtcbiAgICAvLyAtLS1cbiAgICAvLyAtLS1cbiAgICAvLyAxMy4yLjJcbiAgICBGdW5jdGlvbk9iamVjdC5wcm90b3R5cGUuQ29uc3RydWN0ID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgdmFyIG9iaiA9IG5ldyBlY21hXzEuRWNtYSgpO1xuICAgICAgICBvYmouQ2xhc3MgPSAnT2JqZWN0JztcbiAgICAgICAgb2JqLkV4dGVuc2libGUgPSB0cnVlO1xuICAgICAgICB2YXIgcHJvdG8gPSB0aGlzLkdldChjb25zdGFudHMucHJvdG90eXBlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm90by52YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHByb3RvLnZhbHVlID0gbmV3IHZhbHVlc18xLlZhbHVlKG1vbml0b3IuaW5zdGFuY2VzLk9iamVjdFByb3RvdHlwZSwgbGFiZWxfMS5ib3QpO1xuICAgICAgICB9XG4gICAgICAgIG9iai5Qcm90b3R5cGUgPSBwcm90bztcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuQ2FsbChuZXcgdmFsdWVzXzEuVmFsdWUob2JqLCBsYWJlbF8xLmJvdCksIGFyZ3MpO1xuICAgICAgICBpZiAocmVzdWx0LnZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IHZhbHVlc18xLlZhbHVlKG9iaiwgbGFiZWxfMS5ib3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBGdW5jdGlvbk9iamVjdC5wcm90b3R5cGUuSGFzSW5zdGFuY2UgPSBmdW5jdGlvbiAoVikge1xuICAgICAgICByZXR1cm4gSGFzSW5zdGFuY2VfMS5IYXNJbnN0YW5jZS5jYWxsKHRoaXMsIFYpO1xuICAgIH07XG4gICAgRnVuY3Rpb25PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5Tb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBwcC5wcmV0dHkodGhpcy5Tb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaG9zdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaG9zdC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICdob3N0IHVuZGVmaW5lZCBmb3IgJyArIHRoaXMuQ2xhc3M7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBGdW5jdGlvbk9iamVjdDtcbn0oZWNtYV8xLkVjbWEpKTtcbmV4cG9ydHMuRnVuY3Rpb25PYmplY3QgPSBGdW5jdGlvbk9iamVjdDtcbi8vIC0tLVxuZnVuY3Rpb24gQXN5bmNDYWxsRW5kKCkge1xuICAgIHZhciBjYWxsQ29udGV4dCA9IG1vbml0b3IuY29udGV4dDtcbiAgICBtb25pdG9yLmNvbnRleHRTdGFjay5wb3AoKTtcbiAgICB2YXIgY2FsbGVyQ29udGV4dCA9IG1vbml0b3IuY29udGV4dDtcbiAgICB2YXIgcmVzdWx0ID0gY2FsbENvbnRleHQucmVzdWx0O1xuICAgIHZhciByZXRsYWJlbCA9IGNhbGxDb250ZXh0LmxhYmVscy5yZXQ7XG4gICAgaWYgKHJlc3VsdC50eXBlICE9PSAnbm9ybWFsJyAmJiByZXN1bHQudmFsdWUpIHtcbiAgICAgICAgcmVzdWx0LnZhbHVlLnJhaXNlKHJldGxhYmVsKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdC52YWx1ZSA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIHJldGxhYmVsKTtcbiAgICB9XG4gICAgLy8gY29weSBvdXQgdGhlIGlubmVyIGV4Y2VwdGlvbiBsZXZlbFxuICAgIGNhbGxlckNvbnRleHQubGFiZWxzLmV4YyA9IGxhYmVsXzEubHViKGNhbGxlckNvbnRleHQubGFiZWxzLmV4YywgY2FsbENvbnRleHQubGFiZWxzLmV4Yyk7XG4gICAgY2FsbGVyQ29udGV4dC52YWx1ZVN0YWNrLnB1c2gocmVzdWx0KTtcbn1cbmV4cG9ydHMuQXN5bmNDYWxsRW5kID0gQXN5bmNDYWxsRW5kO1xuQXN5bmNDYWxsRW5kLnJ1bmZvciA9IHsgJ3JldHVybic6IHRydWUsICd0aHJvdyc6IHRydWUgfTtcbmZ1bmN0aW9uIEFzeW5jQ29uc3RydWN0RW5kKCkge1xuICAgIHZhciByZXR2YWwgPSBtb25pdG9yLmNvbnRleHQudmFsdWVTdGFjay5wZWVrKCk7XG4gICAgaWYgKHR5cGVvZiByZXR2YWwudmFsdWUudmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHZhbC52YWx1ZSA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSh0aGlzLm9iamVjdCwgbGFiZWxfMS5ib3QpO1xuICAgIH1cbn1cbmV4cG9ydHMuQXN5bmNDb25zdHJ1Y3RFbmQgPSBBc3luY0NvbnN0cnVjdEVuZDtcbkFzeW5jQ29uc3RydWN0RW5kLnJ1bmZvciA9IHsgJ3JldHVybic6IHRydWUsICd0aHJvdyc6IHRydWUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZ1bmN0aW9uT2JqZWN0LmpzLm1hcCIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGxhYmVsXzEgPSByZXF1aXJlKFwiLi4vbGFiZWxcIik7XG52YXIgdmFsdWVzXzEgPSByZXF1aXJlKFwiLi4vdmFsdWVzXCIpO1xudmFyIGVjbWFfMSA9IHJlcXVpcmUoXCIuLi9lY21hXCIpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBOdW1iZXIgT2JqZWN0LCAxNS43LjVcbnZhciBOdW1iZXJPYmplY3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE51bWJlck9iamVjdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOdW1iZXJPYmplY3QodmFsLCBsYmwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuQ2xhc3MgPSAnTnVtYmVyJztcbiAgICAgICAgX3RoaXMuUHJpbWl0aXZlVmFsdWUgPSBuZXcgTnVtYmVyKHZhbCk7XG4gICAgICAgIF90aGlzLlByaW1pdGl2ZUxhYmVsID0gbGJsO1xuICAgICAgICBfdGhpcy5FeHRlbnNpYmxlID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMuUHJvdG90eXBlID0gbmV3IHZhbHVlc18xLlZhbHVlKG1vbml0b3IuaW5zdGFuY2VzLk51bWJlclByb3RvdHlwZSwgbGFiZWxfMS5ib3QpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBOdW1iZXJPYmplY3Q7XG59KGVjbWFfMS5FY21hKSk7XG5leHBvcnRzLk51bWJlck9iamVjdCA9IE51bWJlck9iamVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU51bWJlck9iamVjdC5qcy5tYXAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBsYWJlbF8xID0gcmVxdWlyZShcIi4uL2xhYmVsXCIpO1xudmFyIHZhbHVlc18xID0gcmVxdWlyZShcIi4uL3ZhbHVlc1wiKTtcbnZhciBlY21hXzEgPSByZXF1aXJlKFwiLi4vZWNtYVwiKTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT2JqZWN0IG9iamVjdHMsIDE1LjIuMi4xXG52YXIgT2JqZWN0T2JqZWN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhPYmplY3RPYmplY3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gT2JqZWN0T2JqZWN0KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5Qcm90b3R5cGUgPSBuZXcgdmFsdWVzXzEuVmFsdWUobW9uaXRvci5pbnN0YW5jZXMuT2JqZWN0UHJvdG90eXBlLCBsYWJlbF8xLmJvdCk7XG4gICAgICAgIF90aGlzLkNsYXNzID0gJ09iamVjdCc7XG4gICAgICAgIF90aGlzLkV4dGVuc2libGUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIC8vIHRoaXMuaG9zdCAgICAgID0ge307XG4gICAgfVxuICAgIHJldHVybiBPYmplY3RPYmplY3Q7XG59KGVjbWFfMS5FY21hKSk7XG5leHBvcnRzLk9iamVjdE9iamVjdCA9IE9iamVjdE9iamVjdDtcbi8vIC0tLVxuT2JqZWN0T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvcGVydGllcyA9IFtdO1xuICAgIGZvciAoeCBpbiB0aGlzLnByb3BlcnRpZXMpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eSh4KSkge1xuICAgICAgICAgICAgcHJvcGVydGllcy5wdXNoKHggKyAnOiAnICsgdGhpcy5wcm9wZXJ0aWVzW3hdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJ3snICsgcHJvcGVydGllcy5qb2luKCcsICcpICsgJ30nO1xufTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T2JqZWN0T2JqZWN0LmpzLm1hcCIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZhbHVlc18xID0gcmVxdWlyZShcIi4uL3ZhbHVlc1wiKTtcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzXCIpO1xudmFyIGZ1bmN0aW9uXzEgPSByZXF1aXJlKFwiLi4vZnVuY3Rpb25cIik7XG52YXIgbGFiZWxfMSA9IHJlcXVpcmUoXCIuLi9sYWJlbFwiKTtcbnZhciBlY21hXzEgPSByZXF1aXJlKFwiLi4vZWNtYVwiKTtcbnZhciBBcnJheU9iamVjdF8xID0gcmVxdWlyZShcIi4uL09iamVjdHMvQXJyYXlPYmplY3RcIik7XG52YXIgVG9Cb29sZWFuXzEgPSByZXF1aXJlKFwiLi4vQ29udmVyc2lvbi9Ub0Jvb2xlYW5cIik7XG52YXIgVG9JbnRlZ2VyXzEgPSByZXF1aXJlKFwiLi4vQ29udmVyc2lvbi9Ub0ludGVnZXJcIik7XG52YXIgVG9TdHJpbmdfMSA9IHJlcXVpcmUoXCIuLi9Db252ZXJzaW9uL1RvU3RyaW5nXCIpO1xudmFyIFRvT2JqZWN0XzEgPSByZXF1aXJlKFwiLi4vQ29udmVyc2lvbi9Ub09iamVjdFwiKTtcbnZhciBJc0NhbGxhYmxlXzEgPSByZXF1aXJlKFwiLi4vVXRpbGl0eS9Jc0NhbGxhYmxlXCIpO1xudmFyIFRvVUludDMyXzEgPSByZXF1aXJlKFwiLi4vQ29udmVyc2lvbi9Ub1VJbnQzMlwiKTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gMTUuNC40XG52YXIgQXJyYXlQcm90b3R5cGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFycmF5UHJvdG90eXBlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFycmF5UHJvdG90eXBlKGhvc3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuQ2xhc3MgPSAnQXJyYXknO1xuICAgICAgICBfdGhpcy5ob3N0ID0gaG9zdDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBcnJheVByb3RvdHlwZS5wcm90b3R5cGUuU2V0dXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuUHJvdG90eXBlID0gbmV3IHZhbHVlc18xLlZhbHVlKG1vbml0b3IuaW5zdGFuY2VzLk9iamVjdFByb3RvdHlwZSwgbGFiZWxfMS5ib3QpO1xuICAgICAgICBlY21hXzEuRGVmaW5lKHRoaXMsIGNvbnN0YW50cy5sZW5ndGgsIDAsIHsgd3JpdGFibGU6IHRydWUgfSk7XG4gICAgICAgIGVjbWFfMS5EZWZpbmVURlQodGhpcywgY29uc3RhbnRzLmNvbnN0cnVjdG9yLCBtb25pdG9yLmluc3RhbmNlcy5BcnJheUNvbnN0cnVjdG9yKTtcbiAgICAgICAgZWNtYV8xLkRlZmluZVRGVCh0aGlzLCBjb25zdGFudHMudG9TdHJpbmcsIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdCh0b1N0cmluZywgMCwgQXJyYXkucHJvdG90eXBlLnRvU3RyaW5nKSk7XG4gICAgICAgIGVjbWFfMS5EZWZpbmVURlQodGhpcywgY29uc3RhbnRzLnRvTG9jYWxlU3RyaW5nLCBuZXcgZnVuY3Rpb25fMS5CdWlsdGluRnVuY3Rpb25PYmplY3QodG9Mb2NhbGVTdHJpbmcsIDAsIEFycmF5LnByb3RvdHlwZS50b0xvY2FsZVN0cmluZykpO1xuICAgICAgICBlY21hXzEuRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5jb25jYXQsIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdChjb25jYXQsIDEsIEFycmF5LnByb3RvdHlwZS5jb25jYXQpKTtcbiAgICAgICAgZWNtYV8xLkRlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuam9pbiwgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KGpvaW4sIDEsIEFycmF5LnByb3RvdHlwZS5qb2luKSk7XG4gICAgICAgIGVjbWFfMS5EZWZpbmVURlQodGhpcywgY29uc3RhbnRzLnBvcCwgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHBvcCwgMCwgQXJyYXkucHJvdG90eXBlLnBvcCkpO1xuICAgICAgICBlY21hXzEuRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5wdXNoLCBuZXcgZnVuY3Rpb25fMS5CdWlsdGluRnVuY3Rpb25PYmplY3QocHVzaCwgMSwgQXJyYXkucHJvdG90eXBlLnB1c2gpKTtcbiAgICAgICAgZWNtYV8xLkRlZmluZVRGVCh0aGlzLCBjb25zdGFudHMucmV2ZXJzZSwgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHJldmVyc2UsIDAsIEFycmF5LnByb3RvdHlwZS5yZXZlcnNlKSk7XG4gICAgICAgIGVjbWFfMS5EZWZpbmVURlQodGhpcywgY29uc3RhbnRzLnNoaWZ0LCBuZXcgZnVuY3Rpb25fMS5CdWlsdGluRnVuY3Rpb25PYmplY3Qoc2hpZnQsIDAsIEFycmF5LnByb3RvdHlwZS5zaGlmdCkpO1xuICAgICAgICBlY21hXzEuRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5zbGljZSwgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHNsaWNlLCAyLCBBcnJheS5wcm90b3R5cGUuc2xpY2UpKTtcbiAgICAgICAgZWNtYV8xLkRlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuc29ydCwgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHNvcnQsIDEsIEFycmF5LnByb3RvdHlwZS5zb3J0KSk7XG4gICAgICAgIGVjbWFfMS5EZWZpbmVURlQodGhpcywgY29uc3RhbnRzLnNwbGljZSwgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHNwbGljZSwgMiwgQXJyYXkucHJvdG90eXBlLnNwbGljZSkpO1xuICAgICAgICBlY21hXzEuRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy51bnNoaWZ0LCBuZXcgZnVuY3Rpb25fMS5CdWlsdGluRnVuY3Rpb25PYmplY3QodW5zaGlmdCwgMSwgQXJyYXkucHJvdG90eXBlLnVuc2hpZnQpKTtcbiAgICAgICAgZWNtYV8xLkRlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuaW5kZXhPZiwgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KGluZGV4T2YsIDEsIEFycmF5LnByb3RvdHlwZS5pbmRleE9mKSk7XG4gICAgICAgIGVjbWFfMS5EZWZpbmVURlQodGhpcywgY29uc3RhbnRzLmxhc3RJbmRleE9mLCBuZXcgZnVuY3Rpb25fMS5CdWlsdGluRnVuY3Rpb25PYmplY3QobGFzdEluZGV4T2YsIDEsIEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZikpO1xuICAgICAgICBlY21hXzEuRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5ldmVyeSwgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KGV2ZXJ5LCAxLCBBcnJheS5wcm90b3R5cGUuZXZlcnkpKTtcbiAgICAgICAgZWNtYV8xLkRlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuc29tZSwgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHNvbWUsIDEsIEFycmF5LnByb3RvdHlwZS5zb21lKSk7XG4gICAgICAgIGVjbWFfMS5EZWZpbmVURlQodGhpcywgY29uc3RhbnRzLmZvckVhY2gsIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdChmb3JFYWNoLCAxLCBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCkpO1xuICAgICAgICBlY21hXzEuRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5tYXAsIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdChtYXAsIDEsIEFycmF5LnByb3RvdHlwZS5tYXApKTtcbiAgICAgICAgZWNtYV8xLkRlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuZmlsdGVyLCBuZXcgZnVuY3Rpb25fMS5CdWlsdGluRnVuY3Rpb25PYmplY3QoZmlsdGVyLCAxLCBBcnJheS5wcm90b3R5cGUuZmlsdGVyKSk7XG4gICAgICAgIGVjbWFfMS5EZWZpbmVURlQodGhpcywgY29uc3RhbnRzLnJlZHVjZSwgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHJlZHVjZSwgMSwgQXJyYXkucHJvdG90eXBlLnJlZHVjZSkpO1xuICAgICAgICBlY21hXzEuRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5yZWR1Y2VSaWdodCwgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHJlZHVjZVJpZ2h0LCAxLCBBcnJheS5wcm90b3R5cGUucmVkdWNlUmlnaHQpKTtcbiAgICB9O1xuICAgIHJldHVybiBBcnJheVByb3RvdHlwZTtcbn0oZWNtYV8xLkVjbWEpKTtcbmV4cG9ydHMuQXJyYXlQcm90b3R5cGUgPSBBcnJheVByb3RvdHlwZTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdG9TdHJpbmcsIDE1LjQuNC4yXG52YXIgdG9TdHJpbmcgPSBmdW5jdGlvbiAodGhpc0FyZywgYXJncykge1xuICAgIHZhciBhcnJheSA9IFRvT2JqZWN0XzEuVG9PYmplY3QodGhpc0FyZyk7XG4gICAgdmFyIGZ1bmMgPSBhcnJheS5HZXQoY29uc3RhbnRzLmpvaW4pO1xuICAgIGlmICghSXNDYWxsYWJsZV8xLklzQ2FsbGFibGUoZnVuYykudmFsdWUpIHtcbiAgICAgICAgZnVuYyA9IG1vbml0b3IuaW5zdGFuY2VzLk9iamVjdFByb3RvdHlwZS5HZXQoY29uc3RhbnRzLnRvU3RyaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmMudmFsdWUuQ2FsbChhcnJheSwgW10pO1xufTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdG9Mb2NhbGVTdHJpbmcsIDE1LjQuNC4zXG52YXIgdG9Mb2NhbGVTdHJpbmcgPSBmdW5jdGlvbiAodGhpc0FyZykge1xuICAgIHZhciBhcnJheSwgYXJyYXlMZW4sIGxlbiwgc2VwYXJhdG9yLCBmaXJzdEVsZW1lbnQsIFIsIGVsZW1lbnRPYmosIGZ1bmMsIGssIFMsIG5leHRFbGVtZW50O1xuICAgIGFycmF5ID0gVG9PYmplY3RfMS5Ub09iamVjdCh0aGlzQXJnKTtcbiAgICBhcnJheUxlbiA9IGFycmF5LkdldChuZXcgdmFsdWVzXzEuVmFsdWUoXCJsZW5ndGhcIiwgbGFiZWxfMS5ib3QpKTtcbiAgICBsZW4gPSBUb1VJbnQzMl8xLlRvVUludDMyKGFycmF5TGVuKTtcbiAgICBzZXBhcmF0b3IgPSAnLCc7XG4gICAgdmFyIGxhYmVsID0gbGFiZWxfMS5sdWIobW9uaXRvci5jb250ZXh0LmVmZmVjdGl2ZVBDLCBhcnJheS5sYWJlbCk7XG4gICAgaWYgKGxlbi52YWx1ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbmV3IHZhbHVlc18xLlZhbHVlKFwiXCIsIGxhYmVsKTtcbiAgICB9XG4gICAgZmlyc3RFbGVtZW50ID0gYXJyYXkuR2V0KG5ldyB2YWx1ZXNfMS5WYWx1ZShcIjBcIiwgbGFiZWxfMS5ib3QpKTtcbiAgICBpZiAoZmlyc3RFbGVtZW50LnZhbHVlID09PSB1bmRlZmluZWQgfHwgZmlyc3RFbGVtZW50LnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIFIgPSBuZXcgdmFsdWVzXzEuVmFsdWUoXCJcIiwgbGFiZWwpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZWxlbWVudE9iaiA9IFRvT2JqZWN0XzEuVG9PYmplY3QoZmlyc3RFbGVtZW50KTtcbiAgICAgICAgZnVuYyA9IGVsZW1lbnRPYmouR2V0KG5ldyB2YWx1ZXNfMS5WYWx1ZShcInRvTG9jYWxlU3RyaW5nXCIsIGxhYmVsXzEuYm90KSk7XG4gICAgICAgIGlmIChJc0NhbGxhYmxlXzEuSXNDYWxsYWJsZShmdW5jKS52YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG1vbml0b3IuVGhyb3cobW9uaXRvci5tb2R1bGVzLmVycm9yLlR5cGVFcnJvck9iamVjdCwgJ0FycmF5LnByb3RvdHlwZS50b0xvY2FsZVN0cmluZzogbm90IGEgZnVuY3Rpb24nLCBsYWJlbF8xLmJvdCk7XG4gICAgICAgIH1cbiAgICAgICAgUiA9IGZ1bmMudmFsdWUuQ2FsbChlbGVtZW50T2JqLCBbXSk7XG4gICAgfVxuICAgIGsgPSAxO1xuICAgIHdoaWxlIChrIDwgbGVuLnZhbHVlKSB7XG4gICAgICAgIFMgPSBSLnZhbHVlLmNvbmNhdChzZXBhcmF0b3IpO1xuICAgICAgICBuZXh0RWxlbWVudCA9IGFycmF5LkdldChuZXcgdmFsdWVzXzEuVmFsdWUoJycgKyBrLCBsYWJlbF8xLmJvdCkpO1xuICAgICAgICBpZiAobmV4dEVsZW1lbnQudmFsdWUgPT09IHVuZGVmaW5lZCB8fCBmaXJzdEVsZW1lbnQudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIFIgPSBuZXcgdmFsdWVzXzEuVmFsdWUoXCJcIiwgbGFiZWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudE9iaiA9IFRvT2JqZWN0XzEuVG9PYmplY3QobmV4dEVsZW1lbnQpO1xuICAgICAgICAgICAgZnVuYyA9IGVsZW1lbnRPYmouR2V0KG5ldyB2YWx1ZXNfMS5WYWx1ZShcInRvTG9jYWxlU3RyaW5nXCIsIGxhYmVsXzEuYm90KSk7XG4gICAgICAgICAgICBpZiAoSXNDYWxsYWJsZV8xLklzQ2FsbGFibGUoZnVuYykudmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgbW9uaXRvci5UaHJvdyhtb25pdG9yLm1vZHVsZXMuZXJyb3IuVHlwZUVycm9yT2JqZWN0LCAnQXJyYXkucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nOiBub3QgYSBmdW5jdGlvbicsIGxhYmVsXzEuYm90KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFIgPSBmdW5jLnZhbHVlLkNhbGwoZWxlbWVudE9iaiwgW10pO1xuICAgICAgICB9XG4gICAgICAgIFIgPSBuZXcgdmFsdWVzXzEuVmFsdWUoUy5jb25jYXQoUi52YWx1ZSksIFIubGFiZWwpO1xuICAgICAgICBrKys7XG4gICAgfVxuICAgIFIucmFpc2UobGFiZWwpO1xuICAgIHJldHVybiBSO1xufTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gY29uY2F0LCAxNS40LjQuNFxudmFyIGNvbmNhdCA9IGZ1bmN0aW9uICh0aGlzQXJnLCBhcmdzKSB7XG4gICAgdmFyIE8gPSBUb09iamVjdF8xLlRvT2JqZWN0KHRoaXNBcmcpO1xuICAgIHZhciBBID0gbmV3IEFycmF5T2JqZWN0XzEuQXJyYXlPYmplY3QoKTtcbiAgICB2YXIgbiA9IDA7XG4gICAgdmFyIGMgPSBtb25pdG9yLmNvbnRleHQ7XG4gICAgdmFyIGxhYmVsID0gbmV3IGxhYmVsXzEuTGFiZWwoKTtcbiAgICBmdW5jdGlvbiBhdXgoRSkge1xuICAgICAgICBjLnB1c2hQQyhFLmxhYmVsKTtcbiAgICAgICAgbGFiZWwubHViKEUubGFiZWwpO1xuICAgICAgICBpZiAoRS52YWx1ZSAmJiBFLnZhbHVlLkNsYXNzID09PSAnQXJyYXknKSB7XG4gICAgICAgICAgICB2YXIgayA9IDA7XG4gICAgICAgICAgICB2YXIgbGVuID0gRS5HZXQoY29uc3RhbnRzLmxlbmd0aCk7XG4gICAgICAgICAgICBsYWJlbC5sdWIobGVuLmxhYmVsKTtcbiAgICAgICAgICAgIG1vbml0b3IuY29udGV4dC5wdXNoUEMobGVuLmxhYmVsKTtcbiAgICAgICAgICAgIHdoaWxlIChrIDwgbGVuLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9rID0gbmV3IHZhbHVlc18xLlZhbHVlKGssIGxhYmVsXzEuYm90KTtcbiAgICAgICAgICAgICAgICB2YXIgZXhpc3RzID0gRS5IYXNQcm9wZXJ0eShfayk7XG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0cy52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBtb25pdG9yLmNvbnRleHQucHVzaFBDKGV4aXN0cy5sYWJlbCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdWJFbGVtZW50ID0gRS5HZXQoX2spO1xuICAgICAgICAgICAgICAgICAgICBBLkRlZmluZU93blByb3BlcnR5KG5ldyB2YWx1ZXNfMS5WYWx1ZShuLCBsYWJlbCksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBzdWJFbGVtZW50LnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IHN1YkVsZW1lbnQubGFiZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBtb25pdG9yLmNvbnRleHQucG9wUEMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbisrO1xuICAgICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1vbml0b3IuY29udGV4dC5wb3BQQygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgQS5EZWZpbmVPd25Qcm9wZXJ0eShuZXcgdmFsdWVzXzEuVmFsdWUobiwgbGFiZWwpLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IEUudmFsdWUsXG4gICAgICAgICAgICAgICAgbGFiZWw6IEUubGFiZWwsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgICAgIG4rKztcbiAgICAgICAgfVxuICAgICAgICBjLnBvcFBDKCk7XG4gICAgfVxuICAgIGF1eChPKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBhdXgoYXJnc1tpXSk7XG4gICAgfVxuICAgIC8vIFRoaXMgaXMgYSBmaXggdGhleSBhZGRlZCBpbiBFQ01BLTI2MiB2NiBzdGFuZGFyZCwgYnV0IGJyb3dzZXJzIHVzZWQgaXRcbiAgICAvLyBpbiBFQ01BLTI2MiB2NSBhcyB3ZWxsLlxuICAgIEEuUHV0KG5ldyB2YWx1ZXNfMS5WYWx1ZShcImxlbmd0aFwiLCBsYWJlbF8xLmJvdCksIG5ldyB2YWx1ZXNfMS5WYWx1ZShuLCBsYWJlbF8xLmJvdCkpO1xuICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUoQSwgbGFiZWxfMS5ib3QpO1xufTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gam9pbiwgMTUuNC40LjVcbmZ1bmN0aW9uIGpvaW4odGhpc0FyZywgYXJncykge1xuICAgIHZhciBPID0gVG9PYmplY3RfMS5Ub09iamVjdCh0aGlzQXJnKTtcbiAgICB2YXIgbGVuID0gVG9VSW50MzJfMS5Ub1VJbnQzMihPLkdldChjb25zdGFudHMubGVuZ3RoKSk7XG4gICAgdmFyIHNlcGFyYXRvciA9IGFyZ3NbMF07XG4gICAgaWYgKHNlcGFyYXRvcikge1xuICAgICAgICBpZiAoc2VwYXJhdG9yLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNlcGFyYXRvci52YWx1ZSA9ICcsJztcbiAgICAgICAgfVxuICAgICAgICBzZXBhcmF0b3IgPSBUb1N0cmluZ18xLlRvU3RyaW5nKHNlcGFyYXRvcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzZXBhcmF0b3IgPSBuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCBsYWJlbF8xLmJvdCk7XG4gICAgfVxuICAgIHZhciBsYWJlbCA9IGxhYmVsXzEubHViKGxlbi5sYWJlbCwgc2VwYXJhdG9yLmxhYmVsKTtcbiAgICB2YXIgYXJyID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW4udmFsdWU7IGkrKykge1xuICAgICAgICB2YXIgdiA9IE8uR2V0KG5ldyB2YWx1ZXNfMS5WYWx1ZShpLCBsYWJlbF8xLmJvdCkpO1xuICAgICAgICB2YXIgeTtcbiAgICAgICAgaWYgKHYudmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2LnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICB5ID0gbmV3IHZhbHVlc18xLlZhbHVlKCcnLCB2LmxhYmVsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHkgPSBUb1N0cmluZ18xLlRvU3RyaW5nKHYpO1xuICAgICAgICB9XG4gICAgICAgIGFycltpXSA9IHkudmFsdWU7XG4gICAgICAgIGxhYmVsID0gbGFiZWxfMS5sdWIobGFiZWwsIHkubGFiZWwpO1xuICAgIH1cbiAgICB2YXIgcmVzID0gYXJyLmpvaW4oc2VwYXJhdG9yLnZhbHVlKTtcbiAgICByZXR1cm4gbmV3IHZhbHVlc18xLlZhbHVlKHJlcywgbGFiZWwpO1xufVxuO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBwb3AsIDE1LjQuNC42XG5mdW5jdGlvbiBwb3AodGhpc0FyZywgYXJncykge1xuICAgIHZhciBPID0gVG9PYmplY3RfMS5Ub09iamVjdCh0aGlzQXJnKTtcbiAgICB2YXIgbGVuID0gVG9VSW50MzJfMS5Ub1VJbnQzMihPLkdldChjb25zdGFudHMubGVuZ3RoKSk7XG4gICAgaWYgKGxlbi52YWx1ZSA9PT0gMCkge1xuICAgICAgICBPLlB1dChjb25zdGFudHMubGVuZ3RoLCBsZW4sIHRydWUpO1xuICAgICAgICByZXR1cm4gbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgbGVuLmxhYmVsKTtcbiAgICB9XG4gICAgdmFyIGluZHggPSBuZXcgdmFsdWVzXzEuVmFsdWUobGVuLnZhbHVlIC0gMSwgbGVuLmxhYmVsKTtcbiAgICB2YXIgZWxlbWVudCA9IE8uR2V0KGluZHgpO1xuICAgIE8uRGVsZXRlKGluZHgsIHRydWUpO1xuICAgIE8uUHV0KGNvbnN0YW50cy5sZW5ndGgsIGluZHgsIHRydWUpO1xuICAgIHJldHVybiBlbGVtZW50O1xufVxuO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBwdXNoLCAxNS40LjQuN1xuZnVuY3Rpb24gcHVzaCh0aGlzQXJnLCBhcmdzKSB7XG4gICAgdmFyIE8gPSBUb09iamVjdF8xLlRvT2JqZWN0KHRoaXNBcmcpO1xuICAgIHZhciBuID0gVG9VSW50MzJfMS5Ub1VJbnQzMihPLkdldChjb25zdGFudHMubGVuZ3RoKSk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIEUgPSBhcmdzW2ldO1xuICAgICAgICBPLlB1dChuLCBFKTtcbiAgICAgICAgbi52YWx1ZSsrO1xuICAgIH1cbiAgICBPLlB1dChjb25zdGFudHMubGVuZ3RoLCBuLCB0cnVlKTtcbiAgICByZXR1cm4gbjtcbn1cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gcmV2ZXJzZSwgMTUuNC40LjhcbmZ1bmN0aW9uIHJldmVyc2UodGhpc0FyZywgYXJncykge1xuICAgIHZhciBPID0gVG9PYmplY3RfMS5Ub09iamVjdCh0aGlzQXJnKTtcbiAgICB2YXIgbGVuID0gVG9VSW50MzJfMS5Ub1VJbnQzMihPLkdldChjb25zdGFudHMubGVuZ3RoKSk7XG4gICAgdmFyIFAgPSBsZW47XG4gICAgbGVuID0gbGVuLnZhbHVlO1xuICAgIHZhciBtaWRkbGUgPSBNYXRoLmZsb29yKGxlbiAvIDIpO1xuICAgIHZhciBsb3dlciA9IDA7XG4gICAgdmFyIGMgPSBtb25pdG9yLmNvbnRleHQ7XG4gICAgd2hpbGUgKGxvd2VyICE9PSBtaWRkbGUgJiYgbG93ZXIgPiAtMikge1xuICAgICAgICB2YXIgdXBwZXIgPSBsZW4gLSBsb3dlciAtIDE7XG4gICAgICAgIFAudmFsdWUgPSBsb3dlcjtcbiAgICAgICAgdmFyIGxvd2VyVmFsdWUgPSBPLkdldChQKTtcbiAgICAgICAgUC52YWx1ZSA9IHVwcGVyO1xuICAgICAgICB2YXIgdXBwZXJWYWx1ZSA9IE8uR2V0KFApO1xuICAgICAgICBQLnZhbHVlID0gbG93ZXI7XG4gICAgICAgIHZhciBsb3dlckV4aXN0cyA9IE8uSGFzUHJvcGVydHkoUCk7XG4gICAgICAgIFAudmFsdWUgPSB1cHBlcjtcbiAgICAgICAgdmFyIHVwcGVyRXhpc3RzID0gTy5IYXNQcm9wZXJ0eShQKTtcbiAgICAgICAgYy5wdXNoUEMobGFiZWxfMS5sdWIobG93ZXJFeGlzdHMubGFiZWwsIHVwcGVyRXhpc3RzLmxhYmVsKSk7XG4gICAgICAgIGlmIChsb3dlckV4aXN0cy52YWx1ZSAmJiB1cHBlckV4aXN0cy52YWx1ZSkge1xuICAgICAgICAgICAgUC52YWx1ZSA9IGxvd2VyO1xuICAgICAgICAgICAgTy5QdXQoUCwgdXBwZXJWYWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICBQLnZhbHVlID0gdXBwZXI7XG4gICAgICAgICAgICBPLlB1dChQLCBsb3dlclZhbHVlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghbG93ZXJFeGlzdHMudmFsdWUgJiYgdXBwZXJFeGlzdHMudmFsdWUpIHtcbiAgICAgICAgICAgIFAudmFsdWUgPSBsb3dlcjtcbiAgICAgICAgICAgIE8uUHV0KFAsIHVwcGVyVmFsdWUsIHRydWUpO1xuICAgICAgICAgICAgUC52YWx1ZSA9IHVwcGVyO1xuICAgICAgICAgICAgTy5EZWxldGUoUCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobG93ZXJFeGlzdHMudmFsdWUgJiYgIXVwcGVyRXhpc3RzLnZhbHVlKSB7XG4gICAgICAgICAgICBQLnZhbHVlID0gbG93ZXI7XG4gICAgICAgICAgICBPLkRlbGV0ZShQLCB0cnVlKTtcbiAgICAgICAgICAgIFAudmFsdWUgPSB1cHBlcjtcbiAgICAgICAgICAgIE8uUHV0KFAsIGxvd2VyVmFsdWUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGMucG9wUEMoKTtcbiAgICAgICAgbG93ZXIrKztcbiAgICB9XG4gICAgcmV0dXJuIE87XG59XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHNoaWZ0LCAxNS40LjQuOVxuZnVuY3Rpb24gc2hpZnQodGhpc0FyZywgYXJncykge1xuICAgIHZhciBPID0gVG9PYmplY3RfMS5Ub09iamVjdCh0aGlzQXJnKTtcbiAgICB2YXIgbGVuVmFsID0gTy5HZXQoY29uc3RhbnRzLmxlbmd0aCk7XG4gICAgdmFyIGxlbiA9IFRvVUludDMyXzEuVG9VSW50MzIobGVuVmFsKTtcbiAgICBpZiAobGVuLnZhbHVlID09PSAwKSB7XG4gICAgICAgIG1vbml0b3IuY29udGV4dC5wdXNoUEMobGVuLmxhYmVsKTtcbiAgICAgICAgTy5QdXQoY29uc3RhbnRzLmxlbmd0aCwgbGVuLCB0cnVlKTtcbiAgICAgICAgbW9uaXRvci5jb250ZXh0LnBvcFBDKCk7XG4gICAgICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCBsZW4ubGFiZWwpO1xuICAgIH1cbiAgICB2YXIgZmlyc3QgPSBPLkdldChuZXcgdmFsdWVzXzEuVmFsdWUoMCwgbGFiZWxfMS5ib3QpKTtcbiAgICB2YXIgayA9IDE7XG4gICAgbW9uaXRvci5jb250ZXh0LnB1c2hQQyhsZW4ubGFiZWwpO1xuICAgIHdoaWxlIChrIDwgbGVuLnZhbHVlKSB7XG4gICAgICAgIHZhciBmcm9tID0gaztcbiAgICAgICAgdmFyIF9mcm9tID0gbmV3IHZhbHVlc18xLlZhbHVlKGZyb20sIGxlbi5sYWJlbCk7XG4gICAgICAgIHZhciB0byA9IGsgLSAxO1xuICAgICAgICB2YXIgX3RvID0gbmV3IHZhbHVlc18xLlZhbHVlKHRvLCBsZW4ubGFiZWwpO1xuICAgICAgICB2YXIgZnJvbVByZXNlbnQgPSBPLkhhc1Byb3BlcnR5KF9mcm9tKTtcbiAgICAgICAgaWYgKGZyb21QcmVzZW50LnZhbHVlKSB7XG4gICAgICAgICAgICBtb25pdG9yLmNvbnRleHQucHVzaFBDKGZyb21QcmVzZW50LmxhYmVsKTtcbiAgICAgICAgICAgIHZhciBmcm9tVmFsID0gTy5HZXQoX2Zyb20pO1xuICAgICAgICAgICAgTy5QdXQoX3RvLCBmcm9tVmFsLCB0cnVlKTtcbiAgICAgICAgICAgIG1vbml0b3IuY29udGV4dC5wb3BQQygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgTy5EZWxldGUoX3RvLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBrKys7XG4gICAgfVxuICAgIG1vbml0b3IuY29udGV4dC5wb3BQQygpO1xuICAgIGxlbi52YWx1ZS0tO1xuICAgIE8uRGVsZXRlKGxlbiwgdHJ1ZSk7XG4gICAgTy5QdXQoY29uc3RhbnRzLmxlbmd0aCwgbGVuLCB0cnVlKTtcbiAgICByZXR1cm4gZmlyc3Q7XG59XG47XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHNsaWNlLCAxNS40LjQuMTBcbmZ1bmN0aW9uIHNsaWNlKHRoaXNBcmcsIGFyZ3MpIHtcbiAgICB2YXIgTyA9IFRvT2JqZWN0XzEuVG9PYmplY3QodGhpc0FyZyk7XG4gICAgdmFyIEEgPSBuZXcgQXJyYXlPYmplY3RfMS5BcnJheU9iamVjdCgpO1xuICAgIHZhciBsZW5WYWwgPSBPLkdldChjb25zdGFudHMubGVuZ3RoKTtcbiAgICB2YXIgbGVuID0gVG9VSW50MzJfMS5Ub1VJbnQzMihsZW5WYWwpO1xuICAgIHZhciBzdGFydCA9IGFyZ3NbMF0gPyBhcmdzWzBdIDogbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgbGFiZWxfMS5ib3QpO1xuICAgIHZhciBlbmQgPSBhcmdzWzFdID8gYXJnc1sxXSA6IG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIGxhYmVsXzEuYm90KTtcbiAgICB2YXIgcmVsYXRpdmVTdGFydCA9IFRvSW50ZWdlcl8xLlRvSW50ZWdlcihzdGFydCk7XG4gICAgdmFyIGsgPSBuZXcgdmFsdWVzXzEuVmFsdWUoMCwgbGFiZWxfMS5sdWIobGVuLmxhYmVsLCByZWxhdGl2ZVN0YXJ0LmxhYmVsKSk7XG4gICAgaWYgKHJlbGF0aXZlU3RhcnQudmFsdWUgPCAwKSB7XG4gICAgICAgIGsudmFsdWUgPSBNYXRoLm1heChsZW4udmFsdWUgKyByZWxhdGl2ZVN0YXJ0LnZhbHVlLCAwKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGsudmFsdWUgPSBNYXRoLm1pbihyZWxhdGl2ZVN0YXJ0LnZhbHVlLCBsZW4udmFsdWUpO1xuICAgIH1cbiAgICB2YXIgcmVsYXRpdmVFbmQ7XG4gICAgaWYgKGVuZC52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlbGF0aXZlRW5kID0gbGVuO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVsYXRpdmVFbmQgPSBUb0ludGVnZXJfMS5Ub0ludGVnZXIoZW5kKTtcbiAgICB9XG4gICAgdmFyIF9maW5hbCA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgwLCBsYWJlbF8xLmx1YihsZW4ubGFiZWwsIHJlbGF0aXZlU3RhcnQubGFiZWwpKTtcbiAgICBpZiAocmVsYXRpdmVFbmQudmFsdWUgPCAwKSB7XG4gICAgICAgIF9maW5hbC52YWx1ZSA9IE1hdGgubWF4KGxlbi52YWx1ZSArIHJlbGF0aXZlRW5kLnZhbHVlLCAwKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIF9maW5hbC52YWx1ZSA9IE1hdGgubWluKHJlbGF0aXZlRW5kLnZhbHVlLCBsZW4udmFsdWUpO1xuICAgIH1cbiAgICB2YXIgbiA9IDA7XG4gICAgbW9uaXRvci5jb250ZXh0LnB1c2hQQyhsYWJlbF8xLmx1YihrLmxhYmVsLCBfZmluYWwubGFiZWwpKTtcbiAgICB3aGlsZSAoay52YWx1ZSA8IF9maW5hbC52YWx1ZSkge1xuICAgICAgICB2YXIgUGsgPSBUb1N0cmluZ18xLlRvU3RyaW5nKGspO1xuICAgICAgICB2YXIga1ByZXNlbnQgPSBPLkhhc1Byb3BlcnR5KFBrKTtcbiAgICAgICAgaWYgKGtQcmVzZW50LnZhbHVlKSB7XG4gICAgICAgICAgICB2YXIga1ZhbHVlID0gTy5HZXQoUGspO1xuICAgICAgICAgICAgQS5EZWZpbmVPd25Qcm9wZXJ0eShuZXcgdmFsdWVzXzEuVmFsdWUobiwgbGFiZWxfMS5ib3QpLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGtWYWx1ZS52YWx1ZSxcbiAgICAgICAgICAgICAgICBsYWJlbDoga1ZhbHVlLmxhYmVsLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgay52YWx1ZSsrO1xuICAgICAgICBuKys7XG4gICAgfVxuICAgIG1vbml0b3IuY29udGV4dC5wb3BQQygpO1xuICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUoQSwgbGFiZWxfMS5ib3QpO1xufVxuO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBzb3J0LCAxNS40LjQuMTFcbnZhciBzb3J0ID0gZnVuY3Rpb24gKHRoaXNBcmcsIGFyZ3MpIHtcbiAgICB2YXIgY29tcGFyZWZ1biA9IGFyZ3NbMF0gfHwgbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgbGFiZWxfMS5ib3QpO1xuICAgIHZhciBPID0gVG9PYmplY3RfMS5Ub09iamVjdCh0aGlzQXJnKTtcbiAgICB2YXIgbGVuVmFsID0gTy5HZXQoY29uc3RhbnRzLmxlbmd0aCk7XG4gICAgdmFyIGxlbiA9IFRvVUludDMyXzEuVG9VSW50MzIobGVuVmFsKTtcbiAgICB2YXIgbGFiZWwgPSBuZXcgbGFiZWxfMS5MYWJlbCgpO1xuICAgIGxhYmVsLmx1YihPLmxhYmVsLCBsZW4ubGFiZWwpO1xuICAgIHZhciBjID0gbW9uaXRvci5jb250ZXh0O1xuICAgIGMucHVzaFBDKGxlbi5sYWJlbCk7XG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgdmFyIGsgPSBuZXcgdmFsdWVzXzEuVmFsdWUoMCwgbGVuLmxhYmVsKTtcbiAgICB3aGlsZSAoay52YWx1ZSA8IGxlbi52YWx1ZSkge1xuICAgICAgICB2YXIga1ByZXNlbnQgPSBPLkhhc1Byb3BlcnR5KGspO1xuICAgICAgICBjLmxhYmVscy5wYy5sdWIoa1ByZXNlbnQubGFiZWwpO1xuICAgICAgICBsYWJlbC5sdWIoa1ByZXNlbnQubGFiZWwpO1xuICAgICAgICBpZiAoa1ByZXNlbnQudmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBrVmFsdWUgPSBPLkdldChrKTtcbiAgICAgICAgICAgIGtWYWx1ZS5yYWlzZShsYWJlbCk7XG4gICAgICAgICAgICBhcnJheVtrLnZhbHVlXSA9IGtWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBrLnZhbHVlKys7XG4gICAgfVxuICAgIHZhciBpc0NhbGxhYmxlID0gSXNDYWxsYWJsZV8xLklzQ2FsbGFibGUoY29tcGFyZWZ1bik7XG4gICAgYy5sYWJlbHMucGMubHViKGlzQ2FsbGFibGUubGFiZWwpO1xuICAgIGlmIChjb21wYXJlZnVuLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWlzQ2FsbGFibGUudmFsdWUpIHtcbiAgICAgICAgbW9uaXRvci5UaHJvdyhtb25pdG9yLm1vZHVsZXMuZXJyb3IuVHlwZUVycm9yT2JqZWN0LCAnQXJyYXkucHJvdG90eXBlLnNvcnQ6IG5vdCBhIGZ1bmN0aW9uJywgbGFiZWxfMS5ib3QpO1xuICAgIH1cbiAgICB2YXIgY29tcGFyZWZ1bldyYXBwZXI7XG4gICAgaWYgKGNvbXBhcmVmdW4udmFsdWUpIHtcbiAgICAgICAgY29tcGFyZWZ1bldyYXBwZXIgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgaWYgKHgudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxhYmVsLmx1Yih4LmxhYmVsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh5LnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsYWJlbC5sdWIoeS5sYWJlbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGNvbXBhcmVmdW4uQ2FsbChuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCBsYWJlbF8xLmJvdCksIFt4LCB5XSk7XG4gICAgICAgICAgICBjLmxhYmVscy5wYy5sdWIocmVzdWx0LmxhYmVsLCB4LmxhYmVsLCB5LmxhYmVsKTtcbiAgICAgICAgICAgIGxhYmVsLmx1YihyZXN1bHQubGFiZWwsIHgubGFiZWwsIHkubGFiZWwpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbXBhcmVmdW5XcmFwcGVyID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIGlmICh4LnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsYWJlbC5sdWIoeC5sYWJlbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeS52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbGFiZWwubHViKHkubGFiZWwpO1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB4U3RyaW5nID0gVG9TdHJpbmdfMS5Ub1N0cmluZyh4KTtcbiAgICAgICAgICAgIHZhciB5U3RyaW5nID0gVG9TdHJpbmdfMS5Ub1N0cmluZyh5KTtcbiAgICAgICAgICAgIGMubGFiZWxzLnBjLmx1Yih4U3RyaW5nLmxhYmVsLCB5U3RyaW5nLmxhYmVsKTtcbiAgICAgICAgICAgIGxhYmVsLmx1Yih4U3RyaW5nLmxhYmVsLCB5U3RyaW5nLmxhYmVsKTtcbiAgICAgICAgICAgIGlmICh4U3RyaW5nLnZhbHVlIDwgeVN0cmluZy52YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4U3RyaW5nLnZhbHVlID4geVN0cmluZy52YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGFycmF5ID0gYXJyYXkuc29ydChjb21wYXJlZnVuV3JhcHBlcik7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciB2ID0gYXJyYXlbaV07XG4gICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICBPLlB1dChuZXcgdmFsdWVzXzEuVmFsdWUoaSwgbGFiZWwpLCB2LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIE8uRGVsZXRlKG5ldyB2YWx1ZXNfMS5WYWx1ZShpLCBsYWJlbCksIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGMucG9wUEMoKTtcbiAgICByZXR1cm4gTztcbn07XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHNwbGljZSwgMTUuNC40LjEyXG5mdW5jdGlvbiBzcGxpY2UodGhpc0FyZywgYXJncykge1xuICAgIHZhciBzdGFydCA9IGFyZ3NbMF0gfHwgbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgbGFiZWxfMS5ib3QpO1xuICAgIHZhciBkZWxldGVDb3VudCA9IGFyZ3NbMV0gfHwgbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgbGFiZWxfMS5ib3QpO1xuICAgIHZhciBPID0gVG9PYmplY3RfMS5Ub09iamVjdCh0aGlzQXJnKTtcbiAgICB2YXIgQSA9IG5ldyBBcnJheU9iamVjdF8xLkFycmF5T2JqZWN0KCk7XG4gICAgdmFyIGxlblZhbCA9IE8uR2V0KGNvbnN0YW50cy5sZW5ndGgpO1xuICAgIHZhciBsZW4gPSBUb1VJbnQzMl8xLlRvVUludDMyKGxlblZhbCk7XG4gICAgdmFyIHJlbGF0aXZlU3RhcnQgPSBUb0ludGVnZXJfMS5Ub0ludGVnZXIoc3RhcnQpO1xuICAgIHZhciBhY3R1YWxTdGFydCA9IG5ldyB2YWx1ZXNfMS5WYWx1ZShudWxsLCBsYWJlbF8xLmx1YihsZW4ubGFiZWwsIHJlbGF0aXZlU3RhcnQubGFiZWwpKTtcbiAgICBpZiAocmVsYXRpdmVTdGFydC52YWx1ZSA8IDApIHtcbiAgICAgICAgYWN0dWFsU3RhcnQudmFsdWUgPSBNYXRoLm1heCgobGVuLnZhbHVlICsgcmVsYXRpdmVTdGFydC52YWx1ZSksIDApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYWN0dWFsU3RhcnQudmFsdWUgPSBNYXRoLm1pbihyZWxhdGl2ZVN0YXJ0LnZhbHVlLCBsZW4udmFsdWUpO1xuICAgIH1cbiAgICBkZWxldGVDb3VudCA9IFRvSW50ZWdlcl8xLlRvSW50ZWdlcihkZWxldGVDb3VudCk7XG4gICAgdmFyIGFjdHVhbERlbGV0ZUNvdW50ID0gbmV3IHZhbHVlc18xLlZhbHVlKG51bGwsIGxhYmVsXzEubHViKGRlbGV0ZUNvdW50LmxhYmVsLCBhY3R1YWxTdGFydC5sYWJlbCkpO1xuICAgIGFjdHVhbERlbGV0ZUNvdW50LnZhbHVlID0gTWF0aC5taW4oTWF0aC5tYXgoZGVsZXRlQ291bnQudmFsdWUsIDApLCBsZW4udmFsdWUgLSBhY3R1YWxTdGFydC52YWx1ZSk7XG4gICAgdmFyIGsgPSAwO1xuICAgIG1vbml0b3IuY29udGV4dC5wdXNoUEMoYWN0dWFsRGVsZXRlQ291bnQubGFiZWwpO1xuICAgIHdoaWxlIChrIDwgYWN0dWFsRGVsZXRlQ291bnQudmFsdWUpIHtcbiAgICAgICAgdmFyIGZyb20gPSBuZXcgdmFsdWVzXzEuVmFsdWUoYWN0dWFsU3RhcnQudmFsdWUgKyBrLCBhY3R1YWxTdGFydC5sYWJlbCk7XG4gICAgICAgIHZhciBmcm9tUHJlc2VudCA9IE8uSGFzUHJvcGVydHkoZnJvbSk7XG4gICAgICAgIG1vbml0b3IuY29udGV4dC5wdXNoUEMoZnJvbVByZXNlbnQubGFiZWwpO1xuICAgICAgICBpZiAoZnJvbVByZXNlbnQudmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBmcm9tVmFsdWUgPSBPLkdldChmcm9tKTtcbiAgICAgICAgICAgIEEuRGVmaW5lT3duUHJvcGVydHkobmV3IHZhbHVlc18xLlZhbHVlKGssIGFjdHVhbERlbGV0ZUNvdW50LmxhYmVsKSwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBmcm9tVmFsdWUudmFsdWUsXG4gICAgICAgICAgICAgICAgbGFiZWw6IGZyb21WYWx1ZS5sYWJlbCxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtYmVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIG1vbml0b3IuY29udGV4dC5wb3BQQygpO1xuICAgICAgICBrKys7XG4gICAgfVxuICAgIG1vbml0b3IuY29udGV4dC5wb3BQQygpO1xuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGggLSAyOyBpKyspIHtcbiAgICAgICAgaXRlbXNbaV0gPSBhcmdzW2kgKyAyXTtcbiAgICB9XG4gICAgdmFyIGl0ZW1Db3VudCA9IGl0ZW1zLmxlbmd0aDtcbiAgICBpZiAoaXRlbUNvdW50IDwgYWN0dWFsRGVsZXRlQ291bnQudmFsdWUpIHtcbiAgICAgICAgdmFyIGsgPSBhY3R1YWxTdGFydC52YWx1ZTtcbiAgICAgICAgbW9uaXRvci5jb250ZXh0LnB1c2hQQyhhY3R1YWxTdGFydC5sYWJlbCk7XG4gICAgICAgIHdoaWxlIChrIDwgbGVuLnZhbHVlIC0gYWN0dWFsRGVsZXRlQ291bnQudmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBmcm9tID0gbmV3IHZhbHVlc18xLlZhbHVlKGsgKyBhY3R1YWxEZWxldGVDb3VudC52YWx1ZSwgbGFiZWxfMS5sdWIoYWN0dWFsU3RhcnQubGFiZWwsIGFjdHVhbERlbGV0ZUNvdW50LmxhYmVsKSk7XG4gICAgICAgICAgICB2YXIgdG8gPSBuZXcgdmFsdWVzXzEuVmFsdWUoayArIGl0ZW1Db3VudCwgYWN0dWFsU3RhcnQubGFiZWwpO1xuICAgICAgICAgICAgdmFyIGZyb21QcmVzZW50ID0gTy5IYXNQcm9wZXJ0eShmcm9tKTtcbiAgICAgICAgICAgIG1vbml0b3IuY29udGV4dC5wdXNoUEMoZnJvbVByZXNlbnQubGFiZWwpO1xuICAgICAgICAgICAgaWYgKGZyb21QcmVzZW50LnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZyb21WYWx1ZSA9IE8uR2V0KGZyb20pO1xuICAgICAgICAgICAgICAgIE8uUHV0KHRvLCBmcm9tVmFsdWUsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgTy5EZWxldGUodG8sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaysrO1xuICAgICAgICAgICAgbW9uaXRvci5jb250ZXh0LnBvcFBDKCk7XG4gICAgICAgIH1cbiAgICAgICAgbW9uaXRvci5jb250ZXh0LnBvcFBDKCk7XG4gICAgICAgIGsgPSBsZW4udmFsdWU7XG4gICAgICAgIG1vbml0b3IuY29udGV4dC5wdXNoUEMobGFiZWxfMS5sdWIobGVuLmxhYmVsLCBhY3R1YWxEZWxldGVDb3VudC5sYWJlbCkpO1xuICAgICAgICB3aGlsZSAoayA+IChsZW4udmFsdWUgLSBhY3R1YWxEZWxldGVDb3VudC52YWx1ZSArIGl0ZW1Db3VudCkpIHtcbiAgICAgICAgICAgIE8uRGVsZXRlKG5ldyB2YWx1ZXNfMS5WYWx1ZShrLCBsZW4ubGFiZWwpKTtcbiAgICAgICAgICAgIGstLTtcbiAgICAgICAgfVxuICAgICAgICBtb25pdG9yLmNvbnRleHQucG9wUEMoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXRlbUNvdW50ID4gYWN0dWFsRGVsZXRlQ291bnQudmFsdWUpIHtcbiAgICAgICAgdmFyIGsgPSBsZW4udmFsdWUgLSBhY3R1YWxEZWxldGVDb3VudC52YWx1ZTtcbiAgICAgICAgbW9uaXRvci5jb250ZXh0LnB1c2hQQyhsYWJlbF8xLmx1YihsZW4ubGFiZWwsIGFjdHVhbERlbGV0ZUNvdW50LmxhYmVsKSk7XG4gICAgICAgIHdoaWxlIChrID4gYWN0dWFsU3RhcnQudmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBmcm9tID0gbmV3IHZhbHVlc18xLlZhbHVlKGsgKyBhY3R1YWxEZWxldGVDb3VudC52YWx1ZSAtIDEsIGFjdHVhbERlbGV0ZUNvdW50LmxhYmVsKTtcbiAgICAgICAgICAgIHZhciB0byA9IG5ldyB2YWx1ZXNfMS5WYWx1ZShrICsgaXRlbUNvdW50IC0gMSwgbGFiZWxfMS5ib3QpO1xuICAgICAgICAgICAgdmFyIGZyb21QcmVzZW50ID0gTy5IYXNQcm9wZXJ0eShmcm9tKTtcbiAgICAgICAgICAgIGlmIChmcm9tUHJlc2VudC52YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBmcm9tVmFsdWUgPSBPLkdldChmcm9tKTtcbiAgICAgICAgICAgICAgICBPLlB1dCh0bywgZnJvbVZhbHVlLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIE8uRGVsZXRlKHRvLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGstLTtcbiAgICAgICAgfVxuICAgICAgICBtb25pdG9yLmNvbnRleHQucG9wUEMoKTtcbiAgICB9XG4gICAgayA9IGFjdHVhbFN0YXJ0LnZhbHVlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgTy5QdXQobmV3IHZhbHVlc18xLlZhbHVlKGsgKyBpLCBhY3R1YWxTdGFydC5sYWJlbCksIGl0ZW1zW2ldLCB0cnVlKTtcbiAgICB9XG4gICAgTy5QdXQoY29uc3RhbnRzLmxlbmd0aCwgbmV3IHZhbHVlc18xLlZhbHVlKGxlbi52YWx1ZSAtIGFjdHVhbERlbGV0ZUNvdW50LnZhbHVlICsgaXRlbUNvdW50LCBsYWJlbF8xLmx1YihsZW4ubGFiZWwsIGFjdHVhbERlbGV0ZUNvdW50LmxhYmVsKSksIHRydWUpO1xuICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUoQSwgbGFiZWxfMS5ib3QpO1xufVxuO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyB1bnNoaWZ0LCAxNS40LjQuMTNcbmZ1bmN0aW9uIHVuc2hpZnQodGhpc0FyZywgYXJncykge1xuICAgIHZhciBPID0gVG9PYmplY3RfMS5Ub09iamVjdCh0aGlzQXJnKTtcbiAgICB2YXIgbGVuVmFsID0gTy5HZXQoY29uc3RhbnRzLmxlbmd0aCk7XG4gICAgdmFyIGxlbiA9IFRvVUludDMyXzEuVG9VSW50MzIobGVuVmFsKTtcbiAgICB2YXIgYXJnQ291bnQgPSBhcmdzLmxlbmd0aDtcbiAgICB2YXIgayA9IGxlbi52YWx1ZTtcbiAgICBtb25pdG9yLmNvbnRleHQucHVzaFBDKGxlbi5sYWJlbCk7XG4gICAgd2hpbGUgKGsgPiAwKSB7XG4gICAgICAgIHZhciBmcm9tID0gbmV3IHZhbHVlc18xLlZhbHVlKGsgLSAxLCBsZW4ubGFiZWwpO1xuICAgICAgICB2YXIgdG8gPSBuZXcgdmFsdWVzXzEuVmFsdWUoayArIGFyZ0NvdW50IC0gMSwgbGVuLmxhYmVsKTtcbiAgICAgICAgdmFyIGZyb21QcmVzZW50ID0gTy5IYXNQcm9wZXJ0eShmcm9tKTtcbiAgICAgICAgbW9uaXRvci5jb250ZXh0LnB1c2hQQyhmcm9tUHJlc2VudC5sYWJlbCk7XG4gICAgICAgIGlmIChmcm9tUHJlc2VudC52YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGZyb21WYWx1ZSA9IE8uR2V0KGZyb20pO1xuICAgICAgICAgICAgTy5QdXQodG8sIGZyb21WYWx1ZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBPLkRlbGV0ZSh0bywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbW9uaXRvci5jb250ZXh0LnBvcFBDKCk7XG4gICAgICAgIGstLTtcbiAgICB9XG4gICAgbW9uaXRvci5jb250ZXh0LnBvcFBDKCk7XG4gICAgdmFyIGogPSAwO1xuICAgIHZhciBpdGVtcyA9IGFyZ3M7XG4gICAgZm9yICg7IGogPCBhcmdDb3VudDsgaisrKSB7XG4gICAgICAgIHZhciBFID0gaXRlbXNbal07XG4gICAgICAgIE8uUHV0KG5ldyB2YWx1ZXNfMS5WYWx1ZShqLCBsYWJlbF8xLmJvdCksIEUsIHRydWUpO1xuICAgIH1cbiAgICBPLlB1dChjb25zdGFudHMubGVuZ3RoLCBuZXcgdmFsdWVzXzEuVmFsdWUobGVuLnZhbHVlICsgYXJnQ291bnQsIGxlbi5sYWJlbCkpO1xuICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUobGVuLnZhbHVlICsgYXJnQ291bnQsIGxlbi5sYWJlbCk7XG59XG47XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGluZGV4T2YsIDE1LjQuNC4xNFxuZnVuY3Rpb24gaW5kZXhPZih0aGlzQXJnLCBhcmdzKSB7XG4gICAgdmFyIHNlYXJjaEVsZW1lbnQgPSBhcmdzWzBdIHx8IG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIGxhYmVsXzEuYm90KTtcbiAgICB2YXIgZnJvbUluZGV4ID0gYXJnc1sxXTtcbiAgICB2YXIgTyA9IFRvT2JqZWN0XzEuVG9PYmplY3QodGhpc0FyZyk7XG4gICAgdmFyIGxlblZhbCA9IE8uR2V0KGNvbnN0YW50cy5sZW5ndGgpO1xuICAgIHZhciBsZW4gPSBUb1VJbnQzMl8xLlRvVUludDMyKGxlblZhbCk7XG4gICAgdmFyIGMgPSBtb25pdG9yLmNvbnRleHQ7XG4gICAgaWYgKGxlbi52YWx1ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbmV3IHZhbHVlc18xLlZhbHVlKC0xLCBsZW4ubGFiZWwpO1xuICAgIH1cbiAgICB2YXIgbGFiZWwgPSBuZXcgbGFiZWxfMS5MYWJlbCgpO1xuICAgIGMucHVzaFBDKGxlbi5sYWJlbCk7XG4gICAgbGFiZWwubHViKGxlbi5sYWJlbCk7XG4gICAgdmFyIG4gPSBmcm9tSW5kZXggPyBUb0ludGVnZXJfMS5Ub0ludGVnZXIoZnJvbUluZGV4KSA6IG5ldyB2YWx1ZXNfMS5WYWx1ZSgwLCBsYWJlbF8xLmJvdCk7XG4gICAgYy5sYWJlbHMucGMubHViKG4ubGFiZWwpO1xuICAgIGxhYmVsLmx1YihuLmxhYmVsKTtcbiAgICBpZiAobi52YWx1ZSA+PSBsZW4udmFsdWUpIHtcbiAgICAgICAgYy5wb3BQQygpO1xuICAgICAgICByZXR1cm4gbmV3IHZhbHVlc18xLlZhbHVlKC0xLCBsYWJlbCk7XG4gICAgfVxuICAgIHZhciBrO1xuICAgIGlmIChuLnZhbHVlID49IDApIHtcbiAgICAgICAgayA9IG47XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBrID0gbmV3IHZhbHVlc18xLlZhbHVlKGxlbi52YWx1ZSAtIE1hdGguYWJzKG4udmFsdWUpLCBsYWJlbF8xLmx1YihsZW4ubGFiZWwsIG4ubGFiZWwpKTtcbiAgICAgICAgaWYgKGsudmFsdWUgPCAwKSB7XG4gICAgICAgICAgICBrLnZhbHVlID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAoay52YWx1ZSA8IGxlbi52YWx1ZSkge1xuICAgICAgICB2YXIga1N0cmluZyA9IFRvU3RyaW5nXzEuVG9TdHJpbmcoayk7XG4gICAgICAgIHZhciBrUHJlc2VudCA9IE8uSGFzUHJvcGVydHkoa1N0cmluZyk7XG4gICAgICAgIGMubGFiZWxzLnBjLmx1YihrUHJlc2VudC5sYWJlbCk7XG4gICAgICAgIGxhYmVsLmx1YihrUHJlc2VudC5sYWJlbCk7XG4gICAgICAgIGlmIChrUHJlc2VudC52YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnRLID0gTy5HZXQoa1N0cmluZyk7XG4gICAgICAgICAgICBjLmxhYmVscy5wYy5sdWIoZWxlbWVudEsubGFiZWwpO1xuICAgICAgICAgICAgbGFiZWwubHViKGVsZW1lbnRLLmxhYmVsKTtcbiAgICAgICAgICAgIHZhciBzYW1lID0gc2VhcmNoRWxlbWVudC52YWx1ZSA9PT0gZWxlbWVudEsudmFsdWU7XG4gICAgICAgICAgICBpZiAoc2FtZSkge1xuICAgICAgICAgICAgICAgIGsubGFiZWwgPSBsYWJlbDtcbiAgICAgICAgICAgICAgICBjLnBvcFBDKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgay52YWx1ZSsrO1xuICAgIH1cbiAgICBjLnBvcFBDKCk7XG4gICAgay52YWx1ZSA9IC0xO1xuICAgIGsubGFiZWwgPSBsYWJlbDtcbiAgICByZXR1cm4gaztcbn1cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gbGFzdEluZGV4T2YsIDE1LjQuNC4xNVxuZnVuY3Rpb24gbGFzdEluZGV4T2YodGhpc0FyZywgYXJncykge1xuICAgIHZhciBzZWFyY2hFbGVtZW50ID0gYXJnc1swXSB8fCBuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCBsYWJlbF8xLmJvdCk7XG4gICAgdmFyIGZyb21JbmRleCA9IGFyZ3NbMV07XG4gICAgdmFyIE8gPSBUb09iamVjdF8xLlRvT2JqZWN0KHRoaXNBcmcpO1xuICAgIHZhciBsZW5WYWwgPSBPLkdldChjb25zdGFudHMubGVuZ3RoKTtcbiAgICB2YXIgbGVuID0gVG9VSW50MzJfMS5Ub1VJbnQzMihsZW5WYWwpO1xuICAgIHZhciBjID0gbW9uaXRvci5jb250ZXh0O1xuICAgIGlmIChsZW4udmFsdWUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZSgtMSwgbGVuLmxhYmVsKTtcbiAgICB9XG4gICAgdmFyIGxhYmVsID0gbmV3IGxhYmVsXzEuTGFiZWwoKTtcbiAgICBjLnB1c2hQQyhsZW4ubGFiZWwpO1xuICAgIGxhYmVsLmx1YihsZW4ubGFiZWwpO1xuICAgIHZhciBuID0gZnJvbUluZGV4ID8gVG9JbnRlZ2VyXzEuVG9JbnRlZ2VyKGZyb21JbmRleCkgOiBuZXcgdmFsdWVzXzEuVmFsdWUobGVuLnZhbHVlIC0gMSwgbGVuLmxhYmVsKTtcbiAgICB2YXIgaztcbiAgICBpZiAobi52YWx1ZSA+PSAwKSB7XG4gICAgICAgIGsgPSBuZXcgdmFsdWVzXzEuVmFsdWUoTWF0aC5taW4obi52YWx1ZSwgbGVuLnZhbHVlIC0gMSksIGxhYmVsXzEubHViKG4ubGFiZWwsIGxlbi5sYWJlbCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgayA9IG5ldyB2YWx1ZXNfMS5WYWx1ZShsZW4udmFsdWUgLSBNYXRoLmFicyhuLnZhbHVlKSwgbGFiZWxfMS5sdWIobi5sYWJlbCwgbGVuLmxhYmVsKSk7XG4gICAgfVxuICAgIGMubGFiZWxzLnBjLmx1YihrLmxhYmVsKTtcbiAgICBsYWJlbC5sdWIoay5sYWJlbCk7XG4gICAgd2hpbGUgKGsudmFsdWUgPj0gMCkge1xuICAgICAgICB2YXIga1ByZXNlbnQgPSBPLkhhc1Byb3BlcnR5KGspO1xuICAgICAgICBjLmxhYmVscy5wYy5sdWIoa1ByZXNlbnQubGFiZWwpO1xuICAgICAgICBsYWJlbC5sdWIoa1ByZXNlbnQubGFiZWwpO1xuICAgICAgICBpZiAoa1ByZXNlbnQudmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50SyA9IE8uR2V0KGspO1xuICAgICAgICAgICAgYy5sYWJlbHMucGMubHViKGVsZW1lbnRLLmxhYmVsKTtcbiAgICAgICAgICAgIGxhYmVsLmx1YihlbGVtZW50Sy5sYWJlbCk7XG4gICAgICAgICAgICB2YXIgc2FtZSA9IHNlYXJjaEVsZW1lbnQudmFsdWUgPT09IGVsZW1lbnRLLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHNhbWUpIHtcbiAgICAgICAgICAgICAgICBrLmxhYmVsID0gbGFiZWw7XG4gICAgICAgICAgICAgICAgYy5wb3BQQygpO1xuICAgICAgICAgICAgICAgIHJldHVybiBrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGsudmFsdWUtLTtcbiAgICB9XG4gICAgYy5wb3BQQygpO1xuICAgIGsudmFsdWUgPSAtMTtcbiAgICBrLmxhYmVsID0gbGFiZWw7XG4gICAgcmV0dXJuIGs7XG59XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGV2ZXJ5LCAxNS40LjQuMTZcbmZ1bmN0aW9uIGV2ZXJ5KHRoaXNBcmcsIGFyZ3MpIHtcbiAgICB2YXIgY2FsbGJhY2tmbiA9IGFyZ3NbMF0gfHwgbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgbGFiZWxfMS5ib3QpO1xuICAgIHZhciBjYWxsYmFja3RoaXNBcmcgPSBhcmdzWzFdIHx8IG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIGxhYmVsXzEuYm90KTtcbiAgICB2YXIgTyA9IFRvT2JqZWN0XzEuVG9PYmplY3QodGhpc0FyZyk7XG4gICAgdmFyIGxlblZhbCA9IE8uR2V0KGNvbnN0YW50cy5sZW5ndGgpO1xuICAgIHZhciBsZW4gPSBUb1VJbnQzMl8xLlRvVUludDMyKGxlblZhbCk7XG4gICAgdmFyIGMgPSBtb25pdG9yLmNvbnRleHQ7XG4gICAgdmFyIGlzQ2FsbGFibGUgPSBJc0NhbGxhYmxlXzEuSXNDYWxsYWJsZShjYWxsYmFja2ZuKTtcbiAgICB2YXIgbGFiZWwgPSBuZXcgbGFiZWxfMS5MYWJlbCgpO1xuICAgIGxhYmVsLmx1Yihpc0NhbGxhYmxlLmxhYmVsKTtcbiAgICBjLnB1c2hQQyhpc0NhbGxhYmxlLmxhYmVsKTtcbiAgICBpZiAoIWlzQ2FsbGFibGUudmFsdWUpIHtcbiAgICAgICAgbW9uaXRvci5UaHJvdyhtb25pdG9yLm1vZHVsZXMuZXJyb3IuVHlwZUVycm9yT2JqZWN0LCAnQXJyYXkucHJvdG90eXBlLmV2ZXJ5OiBub3QgYSBmdW5jdGlvbicsIGxhYmVsXzEuYm90KTtcbiAgICB9XG4gICAgdmFyIGsgPSBuZXcgdmFsdWVzXzEuVmFsdWUoMCwgbGVuLmxhYmVsKTtcbiAgICBjLmxhYmVscy5wYy5sdWIobGVuLmxhYmVsKTtcbiAgICBsYWJlbC5sdWIobGVuLmxhYmVsKTtcbiAgICB3aGlsZSAoay52YWx1ZSA8IGxlbi52YWx1ZSkge1xuICAgICAgICB2YXIga1ByZXNlbnQgPSBPLkhhc1Byb3BlcnR5KGspO1xuICAgICAgICBjLmxhYmVscy5wYy5sdWIoa1ByZXNlbnQubGFiZWwpO1xuICAgICAgICBsYWJlbC5sdWIoa1ByZXNlbnQubGFiZWwpO1xuICAgICAgICBpZiAoa1ByZXNlbnQudmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBrVmFsdWUgPSBPLkdldChrKTtcbiAgICAgICAgICAgIHZhciB0ZXN0UmVzdWx0ID0gY2FsbGJhY2tmbi5DYWxsKGNhbGxiYWNrdGhpc0FyZywgW2tWYWx1ZSwgaywgT10pO1xuICAgICAgICAgICAgdmFyIGIgPSBUb0Jvb2xlYW5fMS5Ub0Jvb2xlYW4odGVzdFJlc3VsdCk7XG4gICAgICAgICAgICBjLmxhYmVscy5wYy5sdWIoYi5sYWJlbCk7XG4gICAgICAgICAgICBsYWJlbC5sdWIoYi5sYWJlbCk7XG4gICAgICAgICAgICBpZiAoIWIudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjLnBvcFBDKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZShmYWxzZSwgbGFiZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGsudmFsdWUrKztcbiAgICB9XG4gICAgYy5wb3BQQygpO1xuICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUodHJ1ZSwgbGFiZWwpO1xufVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBzb21lLCAxNS40LjQuMTdcbmZ1bmN0aW9uIHNvbWUodGhpc0FyZywgYXJncykge1xuICAgIHZhciBjYWxsYmFja2ZuID0gYXJnc1swXSB8fCBuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCBsYWJlbF8xLmJvdCk7XG4gICAgdmFyIGNhbGxiYWNrdGhpc0FyZyA9IGFyZ3NbMV0gfHwgbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgbGFiZWxfMS5ib3QpO1xuICAgIHZhciBPID0gVG9PYmplY3RfMS5Ub09iamVjdCh0aGlzQXJnKTtcbiAgICB2YXIgbGVuVmFsID0gTy5HZXQoY29uc3RhbnRzLmxlbmd0aCk7XG4gICAgdmFyIGxlbiA9IFRvVUludDMyXzEuVG9VSW50MzIobGVuVmFsKTtcbiAgICB2YXIgYyA9IG1vbml0b3IuY29udGV4dDtcbiAgICB2YXIgaXNDYWxsYWJsZSA9IElzQ2FsbGFibGVfMS5Jc0NhbGxhYmxlKGNhbGxiYWNrZm4pO1xuICAgIHZhciBsYWJlbCA9IG5ldyBsYWJlbF8xLkxhYmVsKCk7XG4gICAgbGFiZWwubHViKGlzQ2FsbGFibGUubGFiZWwpO1xuICAgIGMucHVzaFBDKGlzQ2FsbGFibGUubGFiZWwpO1xuICAgIGlmICghaXNDYWxsYWJsZS52YWx1ZSkge1xuICAgICAgICBtb25pdG9yLlRocm93KG1vbml0b3IubW9kdWxlcy5lcnJvci5UeXBlRXJyb3JPYmplY3QsICdBcnJheS5wcm90b3R5cGUuZXZlcnk6IG5vdCBhIGZ1bmN0aW9uJywgbGFiZWxfMS5ib3QpO1xuICAgIH1cbiAgICB2YXIgayA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgwLCBsZW4ubGFiZWwpO1xuICAgIGMubGFiZWxzLnBjLmx1YihsZW4ubGFiZWwpO1xuICAgIGxhYmVsLmx1YihsZW4ubGFiZWwpO1xuICAgIHdoaWxlIChrLnZhbHVlIDwgbGVuLnZhbHVlKSB7XG4gICAgICAgIHZhciBrUHJlc2VudCA9IE8uSGFzUHJvcGVydHkoayk7XG4gICAgICAgIGMubGFiZWxzLnBjLmx1YihrUHJlc2VudC5sYWJlbCk7XG4gICAgICAgIGxhYmVsLmx1YihrUHJlc2VudC5sYWJlbCk7XG4gICAgICAgIGlmIChrUHJlc2VudC52YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGtWYWx1ZSA9IE8uR2V0KGspO1xuICAgICAgICAgICAgdmFyIHRlc3RSZXN1bHQgPSBjYWxsYmFja2ZuLkNhbGwoY2FsbGJhY2t0aGlzQXJnLCBba1ZhbHVlLCBrLCBPXSk7XG4gICAgICAgICAgICB2YXIgYiA9IFRvQm9vbGVhbl8xLlRvQm9vbGVhbih0ZXN0UmVzdWx0KTtcbiAgICAgICAgICAgIGMubGFiZWxzLnBjLmx1YihiLmxhYmVsKTtcbiAgICAgICAgICAgIGxhYmVsLmx1YihiLmxhYmVsKTtcbiAgICAgICAgICAgIGlmIChiLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYy5wb3BQQygpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUodHJ1ZSwgbGFiZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGsudmFsdWUrKztcbiAgICB9XG4gICAgYy5wb3BQQygpO1xuICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUoZmFsc2UsIGxhYmVsKTtcbn1cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gZm9yRWFjaCwgMTUuNC40LjE4XG5mdW5jdGlvbiBmb3JFYWNoKHRoaXNBcmcsIGFyZ3MpIHtcbiAgICB2YXIgY2FsbGJhY2tmbiA9IGFyZ3NbMF0gfHwgbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgbGFiZWxfMS5ib3QpO1xuICAgIHZhciBjYWxsYmFja3RoaXNBcmcgPSBhcmdzWzFdIHx8IG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIGxhYmVsXzEuYm90KTtcbiAgICB2YXIgTyA9IFRvT2JqZWN0XzEuVG9PYmplY3QodGhpc0FyZyk7XG4gICAgdmFyIGxlblZhbCA9IE8uR2V0KGNvbnN0YW50cy5sZW5ndGgpO1xuICAgIHZhciBsZW4gPSBUb1VJbnQzMl8xLlRvVUludDMyKGxlblZhbCk7XG4gICAgdmFyIGMgPSBtb25pdG9yLmNvbnRleHQ7XG4gICAgdmFyIGlzQ2FsbGFibGUgPSBJc0NhbGxhYmxlXzEuSXNDYWxsYWJsZShjYWxsYmFja2ZuKTtcbiAgICBjLnB1c2hQQyhpc0NhbGxhYmxlLmxhYmVsKTtcbiAgICBpZiAoIWlzQ2FsbGFibGUudmFsdWUpIHtcbiAgICAgICAgbW9uaXRvci5UaHJvdyhtb25pdG9yLm1vZHVsZXMuZXJyb3IuVHlwZUVycm9yT2JqZWN0LCAnQXJyYXkucHJvdG90eXBlLmV2ZXJ5OiBub3QgYSBmdW5jdGlvbicsIGxhYmVsXzEuYm90KTtcbiAgICB9XG4gICAgdmFyIGsgPSBuZXcgdmFsdWVzXzEuVmFsdWUoMCwgbGVuLmxhYmVsKTtcbiAgICBjLmxhYmVscy5wYy5sdWIobGVuLmxhYmVsKTtcbiAgICB3aGlsZSAoay52YWx1ZSA8IGxlbi52YWx1ZSkge1xuICAgICAgICB2YXIga1ByZXNlbnQgPSBPLkhhc1Byb3BlcnR5KGspO1xuICAgICAgICBjLmxhYmVscy5wYy5sdWIoa1ByZXNlbnQubGFiZWwpO1xuICAgICAgICBpZiAoa1ByZXNlbnQudmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBrVmFsdWUgPSBPLkdldChrKTtcbiAgICAgICAgICAgIGNhbGxiYWNrZm4uQ2FsbChjYWxsYmFja3RoaXNBcmcsIFtrVmFsdWUsIGssIE9dKTtcbiAgICAgICAgfVxuICAgICAgICBrLnZhbHVlKys7XG4gICAgfVxuICAgIGMucG9wUEMoKTtcbiAgICByZXR1cm4gbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgbGFiZWxfMS5ib3QpO1xufVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBtYXAsIDE1LjQuNC4xOVxuZnVuY3Rpb24gbWFwKHRoaXNBcmcsIGFyZ3MpIHtcbiAgICB2YXIgY2FsbGJhY2tmbiA9IGFyZ3NbMF0gfHwgbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgbGFiZWxfMS5ib3QpO1xuICAgIHZhciBjYWxsYmFja3RoaXNBcmcgPSBhcmdzWzFdIHx8IG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIGxhYmVsXzEuYm90KTtcbiAgICB2YXIgTyA9IFRvT2JqZWN0XzEuVG9PYmplY3QodGhpc0FyZyk7XG4gICAgdmFyIGxlblZhbCA9IE8uR2V0KGNvbnN0YW50cy5sZW5ndGgpO1xuICAgIHZhciBsZW4gPSBUb1VJbnQzMl8xLlRvVUludDMyKGxlblZhbCk7XG4gICAgdmFyIGMgPSBtb25pdG9yLmNvbnRleHQ7XG4gICAgdmFyIGlzQ2FsbGFibGUgPSBJc0NhbGxhYmxlXzEuSXNDYWxsYWJsZShjYWxsYmFja2ZuKTtcbiAgICBjLnB1c2hQQyhpc0NhbGxhYmxlLmxhYmVsKTtcbiAgICBpZiAoIWlzQ2FsbGFibGUudmFsdWUpIHtcbiAgICAgICAgbW9uaXRvci5UaHJvdyhtb25pdG9yLm1vZHVsZXMuZXJyb3IuVHlwZUVycm9yT2JqZWN0LCAnQXJyYXkucHJvdG90eXBlLmV2ZXJ5OiBub3QgYSBmdW5jdGlvbicsIGxhYmVsXzEuYm90KTtcbiAgICB9XG4gICAgdmFyIEEgPSBuZXcgQXJyYXlPYmplY3RfMS5BcnJheU9iamVjdCgpO1xuICAgIEEucHJvcGVydGllcy5sZW5ndGggPSBsZW4udmFsdWU7XG4gICAgQS5sYWJlbHMubGVuZ3RoID0ge1xuICAgICAgICB2YWx1ZTogbGVuLmxhYmVsLFxuICAgICAgICBleGlzdGVuY2U6IGxhYmVsXzEuYm90XG4gICAgfTtcbiAgICB2YXIgayA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgwLCBsZW4ubGFiZWwpO1xuICAgIGMubGFiZWxzLnBjLmx1YihsZW4ubGFiZWwpO1xuICAgIHdoaWxlIChrLnZhbHVlIDwgbGVuLnZhbHVlKSB7XG4gICAgICAgIHZhciBrUHJlc2VudCA9IE8uSGFzUHJvcGVydHkoayk7XG4gICAgICAgIGMubGFiZWxzLnBjLmx1YihrUHJlc2VudC5sYWJlbCk7XG4gICAgICAgIGlmIChrUHJlc2VudC52YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGtWYWx1ZSA9IE8uR2V0KGspO1xuICAgICAgICAgICAgdmFyIG1hcHBlZFZhbHVlID0gY2FsbGJhY2tmbi5DYWxsKGNhbGxiYWNrdGhpc0FyZywgW2tWYWx1ZSwgaywgT10pO1xuICAgICAgICAgICAgQS5EZWZpbmVPd25Qcm9wZXJ0eShrLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG1hcHBlZFZhbHVlLnZhbHVlLFxuICAgICAgICAgICAgICAgIGxhYmVsOiBtYXBwZWRWYWx1ZS5sYWJlbCxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGsudmFsdWUrKztcbiAgICB9XG4gICAgYy5wb3BQQygpO1xuICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUoQSwgbGFiZWxfMS5ib3QpO1xufVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBmaWx0ZXIsIDE1LjQuNC4yMFxuZnVuY3Rpb24gZmlsdGVyKHRoaXNBcmcsIGFyZ3MpIHtcbiAgICB2YXIgY2FsbGJhY2tmbiA9IGFyZ3NbMF0gfHwgbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgbGFiZWxfMS5ib3QpO1xuICAgIHZhciBjYWxsYmFja3RoaXNBcmcgPSBhcmdzWzFdIHx8IG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIGxhYmVsXzEuYm90KTtcbiAgICB2YXIgTyA9IFRvT2JqZWN0XzEuVG9PYmplY3QodGhpc0FyZyk7XG4gICAgdmFyIGxlblZhbCA9IE8uR2V0KGNvbnN0YW50cy5sZW5ndGgpO1xuICAgIHZhciBsZW4gPSBUb1VJbnQzMl8xLlRvVUludDMyKGxlblZhbCk7XG4gICAgdmFyIGMgPSBtb25pdG9yLmNvbnRleHQ7XG4gICAgdmFyIGlzQ2FsbGFibGUgPSBJc0NhbGxhYmxlXzEuSXNDYWxsYWJsZShjYWxsYmFja2ZuKTtcbiAgICBjLnB1c2hQQyhpc0NhbGxhYmxlLmxhYmVsKTtcbiAgICBpZiAoIWlzQ2FsbGFibGUudmFsdWUpIHtcbiAgICAgICAgbW9uaXRvci5UaHJvdyhtb25pdG9yLm1vZHVsZXMuZXJyb3IuVHlwZUVycm9yT2JqZWN0LCAnQXJyYXkucHJvdG90eXBlLmV2ZXJ5OiBub3QgYSBmdW5jdGlvbicsIGxhYmVsXzEuYm90KTtcbiAgICB9XG4gICAgdmFyIEEgPSBuZXcgQXJyYXlPYmplY3RfMS5BcnJheU9iamVjdCgpO1xuICAgIHZhciBrID0gbmV3IHZhbHVlc18xLlZhbHVlKDAsIGxlbi5sYWJlbCk7XG4gICAgdmFyIHRvID0gbmV3IHZhbHVlc18xLlZhbHVlKDAsIGxlbi5sYWJlbCk7XG4gICAgYy5sYWJlbHMucGMubHViKGxlbi5sYWJlbCk7XG4gICAgd2hpbGUgKGsudmFsdWUgPCBsZW4udmFsdWUpIHtcbiAgICAgICAgdmFyIGtQcmVzZW50ID0gTy5IYXNQcm9wZXJ0eShrKTtcbiAgICAgICAgYy5sYWJlbHMucGMubHViKGtQcmVzZW50LmxhYmVsKTtcbiAgICAgICAgaWYgKGtQcmVzZW50LnZhbHVlKSB7XG4gICAgICAgICAgICB2YXIga1ZhbHVlID0gTy5HZXQoayk7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWQgPSBjYWxsYmFja2ZuLkNhbGwoY2FsbGJhY2t0aGlzQXJnLCBba1ZhbHVlLCBrLCBPXSk7XG4gICAgICAgICAgICBzZWxlY3RlZCA9IFRvQm9vbGVhbl8xLlRvQm9vbGVhbihzZWxlY3RlZCk7XG4gICAgICAgICAgICBjLmxhYmVscy5wYy5sdWIoc2VsZWN0ZWQubGFiZWwpO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgQS5EZWZpbmVPd25Qcm9wZXJ0eSh0bywge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZToga1ZhbHVlLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbDoga1ZhbHVlLmxhYmVsLFxuICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHRvLnZhbHVlKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgay52YWx1ZSsrO1xuICAgIH1cbiAgICBjLnBvcFBDKCk7XG4gICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZShBLCBsYWJlbF8xLmJvdCk7XG59XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHJlZHVjZSwgMTUuNC40LjIxXG5mdW5jdGlvbiByZWR1Y2UodGhpc0FyZywgYXJncykge1xuICAgIHZhciBjYWxsYmFja2ZuID0gYXJnc1swXSB8fCBuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCBsYWJlbF8xLmJvdCk7XG4gICAgdmFyIGluaXRpYWxWYWx1ZSA9IGFyZ3NbMV07XG4gICAgdmFyIE8gPSBUb09iamVjdF8xLlRvT2JqZWN0KHRoaXNBcmcpO1xuICAgIHZhciBsZW5WYWwgPSBPLkdldChjb25zdGFudHMubGVuZ3RoKTtcbiAgICB2YXIgbGVuID0gVG9VSW50MzJfMS5Ub1VJbnQzMihsZW5WYWwpO1xuICAgIHZhciBjID0gbW9uaXRvci5jb250ZXh0O1xuICAgIHZhciBpc0NhbGxhYmxlID0gSXNDYWxsYWJsZV8xLklzQ2FsbGFibGUoY2FsbGJhY2tmbik7XG4gICAgdmFyIGxhYmVsID0gbmV3IGxhYmVsXzEuTGFiZWwoKTtcbiAgICBsYWJlbC5sdWIoaXNDYWxsYWJsZS5sYWJlbCk7XG4gICAgYy5wdXNoUEMoaXNDYWxsYWJsZS5sYWJlbCk7XG4gICAgaWYgKCFpc0NhbGxhYmxlLnZhbHVlKSB7XG4gICAgICAgIG1vbml0b3IuVGhyb3cobW9uaXRvci5tb2R1bGVzLmVycm9yLlR5cGVFcnJvck9iamVjdCwgJ0FycmF5LnByb3RvdHlwZS5ldmVyeTogbm90IGEgZnVuY3Rpb24nLCBsYWJlbF8xLmJvdCk7XG4gICAgfVxuICAgIHZhciBrID0gbmV3IHZhbHVlc18xLlZhbHVlKDAsIGxlbi5sYWJlbCk7XG4gICAgdmFyIGFjY3VtdWxhdG9yO1xuICAgIGlmIChpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgYWNjdW11bGF0b3IgPSBpbml0aWFsVmFsdWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIga1ByZXNlbnQgPSBuZXcgdmFsdWVzXzEuVmFsdWUoZmFsc2UsIGxhYmVsXzEuYm90KTtcbiAgICAgICAgYy5sYWJlbHMucGMubHViKGxlbi5sYWJlbCk7XG4gICAgICAgIGxhYmVsLmx1YihsZW4ubGFiZWwpO1xuICAgICAgICB3aGlsZSAoIWtQcmVzZW50LnZhbHVlICYmIGsudmFsdWUgPCBsZW4udmFsdWUpIHtcbiAgICAgICAgICAgIGtQcmVzZW50ID0gTy5IYXNQcm9wZXJ0eShrKTtcbiAgICAgICAgICAgIGMubGFiZWxzLnBjLmx1YihrUHJlc2VudC5sYWJlbCk7XG4gICAgICAgICAgICBsYWJlbC5sdWIoa1ByZXNlbnQubGFiZWwpO1xuICAgICAgICAgICAgaWYgKGtQcmVzZW50LnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYWNjdW11bGF0b3IgPSBPLkdldChrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGsudmFsdWUrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWtQcmVzZW50LnZhbHVlKSB7XG4gICAgICAgICAgICBtb25pdG9yLlRocm93KG1vbml0b3IubW9kdWxlcy5lcnJvci5UeXBlRXJyb3JPYmplY3QsICdBcnJheS5wcm90b3R5cGUucmVkdWNlOiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnLCBsYWJlbF8xLmJvdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUgKGsudmFsdWUgPCBsZW4udmFsdWUpIHtcbiAgICAgICAgdmFyIGtQcmVzZW50ID0gTy5IYXNQcm9wZXJ0eShrKTtcbiAgICAgICAgYy5sYWJlbHMucGMubHViKGtQcmVzZW50LmxhYmVsKTtcbiAgICAgICAgbGFiZWwubHViKGtQcmVzZW50LmxhYmVsKTtcbiAgICAgICAgaWYgKGtQcmVzZW50LnZhbHVlKSB7XG4gICAgICAgICAgICB2YXIga1ZhbHVlID0gTy5HZXQoayk7XG4gICAgICAgICAgICBhY2N1bXVsYXRvciA9IGNhbGxiYWNrZm4uQ2FsbChuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCBsYWJlbF8xLmJvdCksIFthY2N1bXVsYXRvciwga1ZhbHVlLCBrLCBPXSk7XG4gICAgICAgIH1cbiAgICAgICAgay52YWx1ZSsrO1xuICAgIH1cbiAgICBjLnBvcFBDKCk7XG4gICAgYWNjdW11bGF0b3IucmFpc2UobGFiZWwpO1xuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbn1cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gcmVkdWNlUmlnaHQsIDE1LjQuNC4yMlxuZnVuY3Rpb24gcmVkdWNlUmlnaHQodGhpc0FyZywgYXJncykge1xuICAgIHZhciBjYWxsYmFja2ZuID0gYXJnc1swXSB8fCBuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCBsYWJlbF8xLmJvdCk7XG4gICAgdmFyIGluaXRpYWxWYWx1ZSA9IGFyZ3NbMV07XG4gICAgdmFyIE8gPSBUb09iamVjdF8xLlRvT2JqZWN0KHRoaXNBcmcpO1xuICAgIHZhciBsZW5WYWwgPSBPLkdldChjb25zdGFudHMubGVuZ3RoKTtcbiAgICB2YXIgbGVuID0gVG9VSW50MzJfMS5Ub1VJbnQzMihsZW5WYWwpO1xuICAgIHZhciBjID0gbW9uaXRvci5jb250ZXh0O1xuICAgIHZhciBpc0NhbGxhYmxlID0gSXNDYWxsYWJsZV8xLklzQ2FsbGFibGUoY2FsbGJhY2tmbik7XG4gICAgdmFyIGxhYmVsID0gbmV3IGxhYmVsXzEuTGFiZWwoKTtcbiAgICBsYWJlbC5sdWIoaXNDYWxsYWJsZS5sYWJlbCk7XG4gICAgYy5wdXNoUEMoaXNDYWxsYWJsZS5sYWJlbCk7XG4gICAgaWYgKCFpc0NhbGxhYmxlLnZhbHVlKSB7XG4gICAgICAgIG1vbml0b3IuVGhyb3cobW9uaXRvci5tb2R1bGVzLmVycm9yLlR5cGVFcnJvck9iamVjdCwgJ0FycmF5LnByb3RvdHlwZS5ldmVyeTogbm90IGEgZnVuY3Rpb24nLCBsYWJlbF8xLmJvdCk7XG4gICAgfVxuICAgIHZhciBrID0gbmV3IHZhbHVlc18xLlZhbHVlKGxlbi52YWx1ZSAtIDEsIGxlbi5sYWJlbCk7XG4gICAgdmFyIGFjY3VtdWxhdG9yO1xuICAgIGlmIChpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgYWNjdW11bGF0b3IgPSBpbml0aWFsVmFsdWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIga1ByZXNlbnQgPSBuZXcgdmFsdWVzXzEuVmFsdWUoZmFsc2UsIGxhYmVsXzEuYm90KTtcbiAgICAgICAgYy5sYWJlbHMucGMubHViKGxlbi5sYWJlbCk7XG4gICAgICAgIGxhYmVsLmx1YihsZW4ubGFiZWwpO1xuICAgICAgICB3aGlsZSAoIWtQcmVzZW50LnZhbHVlICYmIGsudmFsdWUgPj0gMCkge1xuICAgICAgICAgICAga1ByZXNlbnQgPSBPLkhhc1Byb3BlcnR5KGspO1xuICAgICAgICAgICAgYy5sYWJlbHMucGMubHViKGtQcmVzZW50LmxhYmVsKTtcbiAgICAgICAgICAgIGxhYmVsLmx1YihrUHJlc2VudC5sYWJlbCk7XG4gICAgICAgICAgICBpZiAoa1ByZXNlbnQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBhY2N1bXVsYXRvciA9IE8uR2V0KGspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgay52YWx1ZS0tO1xuICAgICAgICB9XG4gICAgICAgIGlmICgha1ByZXNlbnQudmFsdWUpIHtcbiAgICAgICAgICAgIG1vbml0b3IuVGhyb3cobW9uaXRvci5tb2R1bGVzLmVycm9yLlR5cGVFcnJvck9iamVjdCwgJ0FycmF5LnByb3RvdHlwZS5yZWR1Y2U6IGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScsIGxhYmVsXzEuYm90KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAoay52YWx1ZSA+PSAwKSB7XG4gICAgICAgIHZhciBrUHJlc2VudCA9IE8uSGFzUHJvcGVydHkoayk7XG4gICAgICAgIGMubGFiZWxzLnBjLmx1YihrUHJlc2VudC5sYWJlbCk7XG4gICAgICAgIGxhYmVsLmx1YihrUHJlc2VudC5sYWJlbCk7XG4gICAgICAgIGlmIChrUHJlc2VudC52YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGtWYWx1ZSA9IE8uR2V0KGspO1xuICAgICAgICAgICAgYWNjdW11bGF0b3IgPSBjYWxsYmFja2ZuLkNhbGwobmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgbGFiZWxfMS5ib3QpLCBbYWNjdW11bGF0b3IsIGtWYWx1ZSwgaywgT10pO1xuICAgICAgICB9XG4gICAgICAgIGsudmFsdWUtLTtcbiAgICB9XG4gICAgYy5wb3BQQygpO1xuICAgIGFjY3VtdWxhdG9yLnJhaXNlKGxhYmVsKTtcbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BcnJheVByb3RvdHlwZS5qcy5tYXAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2YWx1ZXNfMSA9IHJlcXVpcmUoXCIuLi92YWx1ZXNcIik7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZShcIi4uL2NvbnN0YW50c1wiKTtcbnZhciBmdW5jdGlvbl8xID0gcmVxdWlyZShcIi4uL2Z1bmN0aW9uXCIpO1xudmFyIGVjbWFfMSA9IHJlcXVpcmUoXCIuLi9lY21hXCIpO1xudmFyIGxhYmVsXzEgPSByZXF1aXJlKFwiLi4vbGFiZWxcIik7XG4vLyAxNS42LjQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgQm9vbGVhblByb3RvdHlwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQm9vbGVhblByb3RvdHlwZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCb29sZWFuUHJvdG90eXBlKGhvc3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuQ2xhc3MgPSAnQm9vbGVhbic7XG4gICAgICAgIF90aGlzLlByaW1pdGl2ZVZhbHVlID0gbmV3IEJvb2xlYW4oZmFsc2UpO1xuICAgICAgICBfdGhpcy5ob3N0ID0gaG9zdDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBCb29sZWFuUHJvdG90eXBlLnByb3RvdHlwZS5TZXR1cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5Qcm90b3R5cGUgPSBuZXcgdmFsdWVzXzEuVmFsdWUobW9uaXRvci5pbnN0YW5jZXMuT2JqZWN0UHJvdG90eXBlLCBsYWJlbF8xLmJvdCk7XG4gICAgICAgIGVjbWFfMS5EZWZpbmVGRkYodGhpcywgY29uc3RhbnRzLmxlbmd0aCwgMSk7XG4gICAgICAgIGVjbWFfMS5EZWZpbmVURlQodGhpcywgY29uc3RhbnRzLmNvbnN0cnVjdG9yLCBtb25pdG9yLmluc3RhbmNlcy5Cb29sZWFuQ29uc3RydWN0b3IpO1xuICAgICAgICBlY21hXzEuRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy50b1N0cmluZywgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHRvU3RyaW5nLCAwLCB0aGlzLmhvc3QudG9TdHJpbmcpKTtcbiAgICAgICAgZWNtYV8xLkRlZmluZVRGVCh0aGlzLCBuZXcgdmFsdWVzXzEuVmFsdWUoJ3ZhbHVlT2YnLCBsYWJlbF8xLmJvdCksIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdCh2YWx1ZU9mLCAwLCB0aGlzLmhvc3QudmFsdWVPZikpO1xuICAgIH07XG4gICAgcmV0dXJuIEJvb2xlYW5Qcm90b3R5cGU7XG59KGVjbWFfMS5FY21hKSk7XG5leHBvcnRzLkJvb2xlYW5Qcm90b3R5cGUgPSBCb29sZWFuUHJvdG90eXBlO1xuLy8gdG9TdHJpbmcsIDE1LjYuNC4yIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgdG9TdHJpbmcgPSBmdW5jdGlvbiAodGhpc0FyZywgYXJncykge1xuICAgIHZhciBiID0gdmFsdWVPZih0aGlzQXJnKTtcbiAgICB2YXIgcyA9IGIudmFsdWUgPyAndHJ1ZScgOiAnZmFsc2UnO1xuICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUocywgYi5sYWJlbCk7XG59O1xuLy8gdmFsdWVPZiwgMTUuNi40LjMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFxudmFyIHZhbHVlT2YgPSBmdW5jdGlvbiAodGhpc0FyZywgYXJncykge1xuICAgIGlmICh0eXBlb2YgdGhpc0FyZy52YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiB0aGlzQXJnO1xuICAgIH1cbiAgICBpZiAodGhpc0FyZy52YWx1ZSAhPT0gbnVsbCAmJlxuICAgICAgICB0eXBlb2YgdGhpc0FyZy52YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgdGhpc0FyZy52YWx1ZS5DbGFzcyA9PT0gJ0Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUodGhpc0FyZy52YWx1ZS5QcmltaXRpdmVWYWx1ZS52YWx1ZU9mKCksIHRoaXNBcmcubGFiZWwpO1xuICAgIH1cbiAgICBtb25pdG9yLlRocm93KG1vbml0b3IubW9kdWxlcy5lcnJvci5UeXBlRXJyb3JPYmplY3QsICdCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mIGlzIG5vdCBnZW5lcmljJywgdGhpc0FyZy5sYWJlbCk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Qm9vbGVhblByb3RvdHlwZS5qcy5tYXAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBsYWJlbF8xID0gcmVxdWlyZShcIi4uL2xhYmVsXCIpO1xudmFyIHBwID0gcmVxdWlyZShcIi4uL3BwXCIpO1xudmFyIHZhbHVlc18xID0gcmVxdWlyZShcIi4uL3ZhbHVlc1wiKTtcbnZhciBlY21hXzEgPSByZXF1aXJlKFwiLi4vZWNtYVwiKTtcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzXCIpO1xudmFyIGZ1bmN0aW9uXzEgPSByZXF1aXJlKFwiLi4vZnVuY3Rpb25cIik7XG52YXIgVG9VSW50MzJfMSA9IHJlcXVpcmUoXCIuLi9Db252ZXJzaW9uL1RvVUludDMyXCIpO1xudmFyIElzQ2FsbGFibGVfMSA9IHJlcXVpcmUoXCIuLi9VdGlsaXR5L0lzQ2FsbGFibGVcIik7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEZ1bmN0aW9uIFByb3RvdHlwZSwgMTUuMy40XG52YXIgRnVuY3Rpb25Qcm90b3R5cGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZ1bmN0aW9uUHJvdG90eXBlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZ1bmN0aW9uUHJvdG90eXBlKGhvc3QpIHtcbiAgICAgICAgdmFyIF90aGlzXzEgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICAvLyAxNS4zLjRcbiAgICAgICAgX3RoaXNfMS5DbGFzcyA9ICdGdW5jdGlvbic7XG4gICAgICAgIF90aGlzXzEuRXh0ZW5zaWJsZSA9IHRydWU7XG4gICAgICAgIF90aGlzXzEuaG9zdCA9IGhvc3Q7XG4gICAgICAgIHJldHVybiBfdGhpc18xO1xuICAgIH1cbiAgICBGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUuU2V0dXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIDE1LjMuNC4xXG4gICAgICAgIGVjbWFfMS5EZWZpbmVURlQodGhpcywgY29uc3RhbnRzLmNvbnN0cnVjdG9yLCBtb25pdG9yLmluc3RhbmNlcy5GdW5jdGlvbkNvbnN0cnVjdG9yKTtcbiAgICAgICAgdGhpcy5Qcm90b3R5cGUgPSBuZXcgdmFsdWVzXzEuVmFsdWUobW9uaXRvci5pbnN0YW5jZXMuT2JqZWN0UHJvdG90eXBlLCBsYWJlbF8xLmJvdCk7XG4gICAgICAgIGVjbWFfMS5EZWZpbmVGRkYodGhpcywgY29uc3RhbnRzLmxlbmd0aCwgMCk7XG4gICAgICAgIGVjbWFfMS5EZWZpbmVURlQodGhpcywgY29uc3RhbnRzLnRvU3RyaW5nLCBuZXcgZnVuY3Rpb25fMS5CdWlsdGluRnVuY3Rpb25PYmplY3QodG9TdHJpbmcsIDAsIEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZykpO1xuICAgICAgICBlY21hXzEuRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5hcHBseSwgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KGFwcGx5LCAyLCBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkpKTtcbiAgICAgICAgZWNtYV8xLkRlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuY2FsbCwgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KGNhbGwsIDEsIEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsKSk7XG4gICAgICAgIGVjbWFfMS5EZWZpbmVURlQodGhpcywgY29uc3RhbnRzLmJpbmQsIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdChiaW5kLCAxLCBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCkpO1xuICAgIH07XG4gICAgLy8gMTUuMy40XG4gICAgRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlLkNhbGwgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCBsYWJlbF8xLmJvdCk7IH07XG4gICAgO1xuICAgIEZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZS5Db25zdHJ1Y3QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCBsYWJlbF8xLmJvdCk7IH07XG4gICAgO1xuICAgIHJldHVybiBGdW5jdGlvblByb3RvdHlwZTtcbn0oZWNtYV8xLkVjbWEpKTtcbmV4cG9ydHMuRnVuY3Rpb25Qcm90b3R5cGUgPSBGdW5jdGlvblByb3RvdHlwZTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gMTUuMy40LjIgLSBJbXBsZW1lbnRhdGlvbiBEZXBlbmRlbnRcbnZhciB0b1N0cmluZyA9IGZ1bmN0aW9uICh0aGlzQXJnLCBhcmdzKSB7XG4gICAgaWYgKHRoaXNBcmcudmFsdWUuU291cmNlKSB7XG4gICAgICAgIHZhciBzdHIgPSBwcC5wcmV0dHkodGhpc0FyZy52YWx1ZS5Tb3VyY2UpO1xuICAgICAgICByZXR1cm4gbmV3IHZhbHVlc18xLlZhbHVlKHN0ciwgdGhpc0FyZy5sYWJlbCk7XG4gICAgfVxuICAgIGlmICh0aGlzQXJnLnZhbHVlLmhvc3QpIHtcbiAgICAgICAgdmFyIHN0ciA9IHRoaXNBcmcudmFsdWUuaG9zdC50b1N0cmluZygpO1xuICAgICAgICByZXR1cm4gbmV3IHZhbHVlc18xLlZhbHVlKHN0ciwgdGhpc0FyZy5sYWJlbCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUoJ2Z1bmN0aW9uJywgdGhpc0FyZy5sYWJlbCk7XG59O1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAxNS4zLjQuM1xudmFyIGFwcGx5ID0gZnVuY3Rpb24gKHRoaXNBcmcsIGFyZ3MpIHtcbiAgICB2YXIgX3RoaXMgPSBhcmdzWzBdID8gYXJnc1swXSA6IG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIGxhYmVsXzEuYm90KTtcbiAgICB2YXIgYXJnQXJyYXkgPSBhcmdzWzFdID8gYXJnc1sxXSA6IG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIGxhYmVsXzEuYm90KTtcbiAgICBtb25pdG9yLmNvbnRleHQucHVzaFBDKHRoaXNBcmcubGFiZWwpO1xuICAgIGlmICghSXNDYWxsYWJsZV8xLklzQ2FsbGFibGUodGhpc0FyZykudmFsdWUpIHtcbiAgICAgICAgbW9uaXRvci5UaHJvdyhtb25pdG9yLm1vZHVsZXMuZXJyb3IuVHlwZUVycm9yT2JqZWN0LCAnYXBwbHksIG5vdCBhIGZ1bmN0aW9uJywgbGFiZWxfMS5ib3QpO1xuICAgIH1cbiAgICBtb25pdG9yLmNvbnRleHQucmFpc2VQQyhhcmdBcnJheS5sYWJlbCk7XG4gICAgaWYgKGFyZ0FycmF5LnZhbHVlID09PSBudWxsIHx8IGFyZ0FycmF5LnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHJlcyA9IHRoaXNBcmcuQ2FsbChfdGhpcywgW10pO1xuICAgICAgICBtb25pdG9yLmNvbnRleHQucG9wUEMoKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhcmdBcnJheS52YWx1ZSAhPT0gJ29iamVjdCcgfHwgYXJnQXJyYXkudmFsdWUuQ2xhc3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtb25pdG9yLlRocm93KG1vbml0b3IubW9kdWxlcy5lcnJvci5UeXBlRXJyb3JPYmplY3QsICdhcHBseSwgYXJndW1lbnQgYXJyYXkgbm90IGFuIG9iamVjdCcsIGxhYmVsXzEuYm90KTtcbiAgICB9XG4gICAgdmFyIGxlbiA9IGFyZ0FycmF5LkdldChjb25zdGFudHMubGVuZ3RoKTtcbiAgICB2YXIgbiA9IFRvVUludDMyXzEuVG9VSW50MzIobGVuKTtcbiAgICB2YXIgYXJnTGlzdCA9IFtdO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBuLnZhbHVlOyBpbmRleCsrKSB7XG4gICAgICAgIHZhciBuZXh0QXJnID0gYXJnQXJyYXkuR2V0KG5ldyB2YWx1ZXNfMS5WYWx1ZShpbmRleCwgbi5sYWJlbCkpO1xuICAgICAgICBhcmdMaXN0LnB1c2gobmV4dEFyZyk7XG4gICAgfVxuICAgIC8vIFNpbmNlIHdlIGNhbm5vdCB0cmFuc2ZlciB0aGUgc3RydWN0dXJhbCBvciBleGlzdGVuY2UgaW5mbyB0b1xuICAgIC8vICB0aGUgYXJyYXkgdXNlZCBieSBDYWxsLCB3ZSByYWlzZSB0aGUgY29udGV4dCBhY2NvcmRpbmdseS5cbiAgICAvLyAgVGhpcyBpcyBzb3VuZCwgYnV0IHBvdGVudGlhbGx5IGFuIG92ZXIgYXBwcm94aW1hdGlvbi5cbiAgICBtb25pdG9yLmNvbnRleHQucmFpc2VQQyhuLmxhYmVsKTtcbiAgICB2YXIgcmVzID0gdGhpc0FyZy5DYWxsKF90aGlzLCBhcmdMaXN0KTtcbiAgICBtb25pdG9yLmNvbnRleHQucG9wUEMoKTtcbiAgICByZXR1cm4gcmVzO1xufTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gMTUuMy40LjRcbnZhciBjYWxsID0gZnVuY3Rpb24gKHRoaXNBcmcsIGFyZ3MpIHtcbiAgICB2YXIgX3RoaXMgPSBhcmdzWzBdID8gYXJnc1swXSA6IG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIGxhYmVsXzEuYm90KTtcbiAgICB2YXIgYXJnTGlzdCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcmdMaXN0W2kgLSAxXSA9IGFyZ3NbaV07XG4gICAgfVxuICAgIGFyZ0xpc3QubGVuZ3RoID0gYXJncy5sZW5ndGggLSAxO1xuICAgIG1vbml0b3IuY29udGV4dC5wdXNoUEModGhpc0FyZy5sYWJlbCk7XG4gICAgaWYgKCFJc0NhbGxhYmxlXzEuSXNDYWxsYWJsZSh0aGlzQXJnKS52YWx1ZSkge1xuICAgICAgICBtb25pdG9yLlRocm93KG1vbml0b3IubW9kdWxlcy5lcnJvci5UeXBlRXJyb3JPYmplY3QsICdjYWxsLCBub3QgYSBmdW5jdGlvbicsIGxhYmVsXzEuYm90KTtcbiAgICB9XG4gICAgdmFyIHJlcyA9IHRoaXNBcmcuQ2FsbChfdGhpcywgYXJnTGlzdCk7XG4gICAgbW9uaXRvci5jb250ZXh0LnBvcFBDKCk7XG4gICAgcmV0dXJuIHJlcztcbn07XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIDE1LjMuNC41XG52YXIgYmluZCA9IGZ1bmN0aW9uICh0aGlzQXJnLCBhcmdzKSB7XG4gICAgdmFyIFRhcmdldCA9IHRoaXNBcmc7XG4gICAgdmFyIF90aGlzID0gYXJnc1swXSA/IGFyZ3NbMF0gOiBuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCBsYWJlbF8xLmJvdCk7XG4gICAgdmFyIGFyZ0xpc3QgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJnTGlzdFtpIC0gMV0gPSBhcmdzW2ldO1xuICAgIH1cbiAgICBpZiAoIUlzQ2FsbGFibGVfMS5Jc0NhbGxhYmxlKFRhcmdldCkudmFsdWUpIHtcbiAgICAgICAgbW9uaXRvci5UaHJvdyhtb25pdG9yLm1vZHVsZXMuZXJyb3IuVHlwZUVycm9yT2JqZWN0LCAnYmluZDogVGFyZ2V0IGlzIG5vdCBhIGZ1bmN0aW9uJywgbGFiZWxfMS5ib3QpO1xuICAgIH1cbiAgICB2YXIgRiA9IG5ldyBlY21hXzEuRWNtYSgpO1xuICAgIEYuVGFyZ2V0RnVuY3Rpb24gPSBUYXJnZXQ7XG4gICAgRi5Cb3VuZFRoaXMgPSBfdGhpcztcbiAgICBGLkJvdW5kQXJncyA9IGFyZ0xpc3Q7XG4gICAgRi5DbGFzcyA9ICdGdW5jdGlvbic7XG4gICAgRi5Qcm90b3R5cGUgPSBuZXcgdmFsdWVzXzEuVmFsdWUobW9uaXRvci5pbnN0YW5jZXMuRnVuY3Rpb25Qcm90b3R5cGUsIGxhYmVsXzEuYm90KTtcbiAgICBGLkNhbGwgPSBmdW5jdGlvbiAoX3RoaXNWYWwsIEV4dHJhQXJncykge1xuICAgICAgICB2YXIgYm91bmRBcmdzID0gRi5Cb3VuZEFyZ3M7XG4gICAgICAgIHZhciBib3VuZFRoaXMgPSBGLkJvdW5kVGhpcztcbiAgICAgICAgdmFyIHRhcmdldCA9IEYuVGFyZ2V0RnVuY3Rpb247XG4gICAgICAgIHZhciBhcmdzID0gYm91bmRBcmdzLmNvbmNhdChFeHRyYUFyZ3MpO1xuICAgICAgICByZXR1cm4gdGFyZ2V0LkNhbGwoYm91bmRUaGlzLCBhcmdzKTtcbiAgICB9O1xuICAgIEYuQ29uc3RydWN0ID0gZnVuY3Rpb24gKEV4dHJhQXJncykge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gRi5UYXJnZXRGdW5jdGlvbjtcbiAgICAgICAgaWYgKCF0YXJnZXQuQ29uc3RydWN0KSB7XG4gICAgICAgICAgICBtb25pdG9yLlRocm93KG1vbml0b3IubW9kdWxlcy5lcnJvci5UeXBlRXJyb3JPYmplY3QsICdiaW5kIGNvbnN0cnVjdDogbm8gaW50ZXJuYWwgbWV0aG9kIENvbnN0cnVjdCcsIGxhYmVsXzEuYm90KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYm91bmRBcmdzID0gRi5Cb3VuZEFyZ3M7XG4gICAgICAgIHZhciBhcmdzID0gYm91bmRBcmdzLmNvbmNhdChFeHRyYUFyZ3MpO1xuICAgICAgICByZXR1cm4gdGFyZ2V0LkNvbnN0cnVjdChhcmdzKTtcbiAgICB9O1xuICAgIEYuSGFzSW5zdGFuY2UgPSBmdW5jdGlvbiAoVikge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gRi5UYXJnZXRGdW5jdGlvbjtcbiAgICAgICAgaWYgKCF0YXJnZXQuSGFzSW5zdGFuY2UpIHtcbiAgICAgICAgICAgIG1vbml0b3IuVGhyb3cobW9uaXRvci5tb2R1bGVzLmVycm9yLlR5cGVFcnJvck9iamVjdCwgJ2JpbmQgSGFzSW5zdGFuY2U6IG5vIGludGVybmFsIG1ldGhvZCBIYXNJbnN0YW5jZScsIGxhYmVsXzEuYm90KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0Lkhhc0luc3RhbmNlKFYpO1xuICAgIH07XG4gICAgaWYgKFRhcmdldC5DbGFzcyA9PT0gXCJGdW5jdGlvblwiKSB7XG4gICAgICAgIHZhciBMID0gVGFyZ2V0Lmxlbmd0aCAtIGFyZ3MubGVuZ3RoO1xuICAgICAgICBGLmxlbmd0aCA9IEwgPiAwID8gTCA6IDA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBGLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIGVjbWFfMS5EZWZpbmVGRkYoRiwgY29uc3RhbnRzLmxlbmd0aCwgRi5sZW5ndGgpO1xuICAgIEYuRXh0ZW5zaWJsZSA9IHRydWU7XG4gICAgdmFyIHRocm93ZXIgPSBtb25pdG9yLmluc3RhbmNlcy5UaHJvd1R5cGVFcnJvcjtcbiAgICBGLkRlZmluZU93blByb3BlcnR5KGNvbnN0YW50cy5jYWxsZXIsIHtcbiAgICAgICAgZ2V0OiB0aHJvd2VyLFxuICAgICAgICBzZXQ6IHRocm93ZXIsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBsYWJlbDogbGFiZWxfMS5ib3RcbiAgICB9LCBmYWxzZSk7XG4gICAgRi5EZWZpbmVPd25Qcm9wZXJ0eShjb25zdGFudHMuYXJndW1lbnRzLCB7XG4gICAgICAgIGdldDogdGhyb3dlcixcbiAgICAgICAgc2V0OiB0aHJvd2VyLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgbGFiZWw6IGxhYmVsXzEuYm90XG4gICAgfSwgZmFsc2UpO1xuICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUoRiwgbGFiZWxfMS5ib3QpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZ1bmN0aW9uUHJvdG90eXBlLmpzLm1hcCIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGxhYmVsXzEgPSByZXF1aXJlKFwiLi4vbGFiZWxcIik7XG52YXIgdmFsdWVzXzEgPSByZXF1aXJlKFwiLi4vdmFsdWVzXCIpO1xudmFyIGVjbWFfMSA9IHJlcXVpcmUoXCIuLi9lY21hXCIpO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHNcIik7XG52YXIgZnVuY3Rpb25fMSA9IHJlcXVpcmUoXCIuLi9mdW5jdGlvblwiKTtcbnZhciBUb0ludGVnZXJfMSA9IHJlcXVpcmUoXCIuLi9Db252ZXJzaW9uL1RvSW50ZWdlclwiKTtcbnZhciBUb1N0cmluZ18xID0gcmVxdWlyZShcIi4uL0NvbnZlcnNpb24vVG9TdHJpbmdcIik7XG52YXIgVG9PYmplY3RfMSA9IHJlcXVpcmUoXCIuLi9Db252ZXJzaW9uL1RvT2JqZWN0XCIpO1xudmFyIENoZWNrT2JqZWN0Q29lcmNpYmxlXzEgPSByZXF1aXJlKFwiLi4vVXRpbGl0eS9DaGVja09iamVjdENvZXJjaWJsZVwiKTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVGhlIE51bWJlciBQcm90b3R5cGUsIDE1LjcuNFxudmFyIE51bWJlclByb3RvdHlwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTnVtYmVyUHJvdG90eXBlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE51bWJlclByb3RvdHlwZShob3N0KSB7XG4gICAgICAgIHZhciBfdGhpc18xID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXNfMS5DbGFzcyA9ICdOdW1iZXInO1xuICAgICAgICBfdGhpc18xLlByaW1pdGl2ZVZhbHVlID0gbmV3IE51bWJlcigwKTtcbiAgICAgICAgX3RoaXNfMS5QcmltaXRpdmVMYWJlbCA9IGxhYmVsXzEuYm90O1xuICAgICAgICBfdGhpc18xLmhvc3QgPSBob3N0O1xuICAgICAgICByZXR1cm4gX3RoaXNfMTtcbiAgICB9XG4gICAgTnVtYmVyUHJvdG90eXBlLnByb3RvdHlwZS5TZXR1cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5Qcm90b3R5cGUgPSBuZXcgdmFsdWVzXzEuVmFsdWUobW9uaXRvci5pbnN0YW5jZXMuT2JqZWN0UHJvdG90eXBlLCBsYWJlbF8xLmJvdCk7XG4gICAgICAgIGVjbWFfMS5EZWZpbmVURlQodGhpcywgY29uc3RhbnRzLmNvbnN0cnVjdG9yLCBtb25pdG9yLmluc3RhbmNlcy5OdW1iZXJDb25zdHJ1Y3Rvcik7XG4gICAgICAgIGVjbWFfMS5EZWZpbmVGRkYodGhpcywgY29uc3RhbnRzLmxlbmd0aCwgMCk7XG4gICAgICAgIGVjbWFfMS5EZWZpbmVURlQodGhpcywgY29uc3RhbnRzLnRvU3RyaW5nLCBuZXcgZnVuY3Rpb25fMS5CdWlsdGluRnVuY3Rpb25PYmplY3QodG9TdHJpbmcsIDEsIHRoaXMuaG9zdC50b1N0cmluZykpO1xuICAgICAgICBlY21hXzEuRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy50b0xvY2FsZVN0cmluZywgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHRvTG9jYWxlU3RyaW5nLCAwLCB0aGlzLmhvc3QudG9Mb2NhbGVTdHJpbmcpKTtcbiAgICAgICAgZWNtYV8xLkRlZmluZVRGVCh0aGlzLCBuZXcgdmFsdWVzXzEuVmFsdWUoJ3ZhbHVlT2YnLCBsYWJlbF8xLmJvdCksIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdCh2YWx1ZU9mLCAwLCB0aGlzLmhvc3QudmFsdWVPZikpO1xuICAgICAgICBlY21hXzEuRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy50b0ZpeGVkLCBuZXcgZnVuY3Rpb25fMS5CdWlsdGluRnVuY3Rpb25PYmplY3QodG9GaXhlZCwgMCwgdGhpcy5ob3N0LnRvRml4ZWQpKTtcbiAgICAgICAgZWNtYV8xLkRlZmluZVRGVCh0aGlzLCBjb25zdGFudHMudG9FeHBvbmVudGlhbCwgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHRvRXhwb25lbnRpYWwsIDAsIHRoaXMuaG9zdC50b0V4cG9uZW50aWFsKSk7XG4gICAgICAgIGVjbWFfMS5EZWZpbmVURlQodGhpcywgY29uc3RhbnRzLnRvUHJlY2lzaW9uLCBuZXcgZnVuY3Rpb25fMS5CdWlsdGluRnVuY3Rpb25PYmplY3QodG9QcmVjaXNpb24sIDAsIHRoaXMuaG9zdC50b1ByZWNpc2lvbikpO1xuICAgIH07XG4gICAgcmV0dXJuIE51bWJlclByb3RvdHlwZTtcbn0oZWNtYV8xLkVjbWEpKTtcbmV4cG9ydHMuTnVtYmVyUHJvdG90eXBlID0gTnVtYmVyUHJvdG90eXBlO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyB0b1N0cmluZywgMTUuNy40LjJcbnZhciB0b1N0cmluZyA9IGZ1bmN0aW9uICh0aGlzQXJnLCBhcmdzKSB7XG4gICAgdmFyIGVycm9yID0gbW9uaXRvci5yZXF1aXJlKCdlcnJvcicpO1xuICAgIGlmICghKHR5cGVvZiB0aGlzQXJnLnZhbHVlID09PSAnbnVtYmVyJyB8fCAodGhpc0FyZy52YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdGhpc0FyZy52YWx1ZSA9PT0gJ29iamVjdCcgJiYgdGhpc0FyZy52YWx1ZS5DbGFzcyA9PT0gJ051bWJlcicpKSkge1xuICAgICAgICBtb25pdG9yLlRocm93KGVycm9yLlR5cGVFcnJvck9iamVjdCwgJ051bWJlci5wcm90b3R5cGUudG9TdHJpbmcgaXMgbm90IGdlbmVyaWMnLCB0aGlzQXJnLmxhYmVsKTtcbiAgICB9XG4gICAgdmFyIHJhZGl4ID0gYXJnc1swXSB8fCBuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCBsYWJlbF8xLmJvdCk7XG4gICAgaWYgKHJhZGl4LnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmFkaXgudmFsdWUgPSAxMDtcbiAgICB9XG4gICAgcmFkaXggPSBUb0ludGVnZXJfMS5Ub0ludGVnZXIocmFkaXgpO1xuICAgIHZhciByZXN1bHQ7XG4gICAgaWYgKHR5cGVvZiB0aGlzQXJnLnZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXN1bHQgPSB0aGlzQXJnLnZhbHVlLnRvU3RyaW5nKHJhZGl4LnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZShyZXN1bHQsIGxhYmVsXzEubHViKHRoaXNBcmcubGFiZWwsIHJhZGl4LmxhYmVsKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSB0aGlzQXJnLnZhbHVlLlByaW1pdGl2ZVZhbHVlLnRvU3RyaW5nKHJhZGl4LnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZShyZXN1bHQsIGxhYmVsXzEubHViKHRoaXNBcmcudmFsdWUuUHJpbWl0aXZlTGFiZWwsIHJhZGl4LmxhYmVsKSk7XG4gICAgfVxufTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdG9Mb2NhbGVTdHJpbmcsIDE1LjcuNC4zXG52YXIgdG9Mb2NhbGVTdHJpbmcgPSBmdW5jdGlvbiAodGhpc0FyZywgYXJncykge1xuICAgIHZhciBPID0gVG9PYmplY3RfMS5Ub09iamVjdCh0aGlzQXJnKTtcbiAgICB2YXIgcmVzdWx0ID0gTy52YWx1ZS5QcmltaXRpdmVWYWx1ZS50b0xvY2FsZVN0cmluZygpO1xuICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUocmVzdWx0LCBPLnZhbHVlLlByaW1pdGl2ZUxhYmVsKTtcbn07XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHZhbHVlT2YsIDE1LjcuNC40XG52YXIgdmFsdWVPZiA9IGZ1bmN0aW9uICh0aGlzQXJnLCBhcmdzKSB7XG4gICAgdmFyIGVycm9yID0gbW9uaXRvci5yZXF1aXJlKCdlcnJvcicpO1xuICAgIGlmICghKHR5cGVvZiB0aGlzQXJnLnZhbHVlID09PSAnbnVtYmVyJyB8fCAodGhpc0FyZy52YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdGhpc0FyZy52YWx1ZSA9PT0gJ29iamVjdCcgJiYgdGhpc0FyZy52YWx1ZS5DbGFzcyA9PT0gJ051bWJlcicpKSkge1xuICAgICAgICBtb25pdG9yLlRocm93KGVycm9yLlR5cGVFcnJvck9iamVjdCwgJ051bWJlci5wcm90b3R5cGUudmFsdWVPZiBpcyBub3QgZ2VuZXJpYycsIHRoaXNBcmcubGFiZWwpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRoaXNBcmcudmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB0aGlzQXJnO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gdGhpc0FyZy52YWx1ZS5QcmltaXRpdmVWYWx1ZS52YWx1ZU9mKCk7XG4gICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZShyZXN1bHQsIHRoaXNBcmcudmFsdWUuUHJpbWl0aXZlTGFiZWwpO1xufTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdG9GaXhlZCwgMTUuNy40LjVcbnZhciB0b0ZpeGVkID0gZnVuY3Rpb24gKHRoaXNBcmcsIGFyZ3MpIHtcbiAgICB2YXIgcHJlY2lzaW9uID0gYXJnc1swXSA/IFRvSW50ZWdlcl8xLlRvSW50ZWdlcihhcmdzWzBdKSA6IG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIGxhYmVsXzEuYm90KTtcbiAgICBDaGVja09iamVjdENvZXJjaWJsZV8xLkNoZWNrT2JqZWN0Q29lcmNpYmxlKHRoaXNBcmcpO1xuICAgIHZhciBfdGhpcyA9IFRvT2JqZWN0XzEuVG9PYmplY3QodGhpc0FyZyk7XG4gICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZShfdGhpcy52YWx1ZS5QcmltaXRpdmVWYWx1ZS50b0ZpeGVkKHByZWNpc2lvbi52YWx1ZSksIGxhYmVsXzEubHViKHByZWNpc2lvbi5sYWJlbCwgX3RoaXMubGFiZWwpKTtcbn07XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHRvRXhwb25lbnRpYWwsIDE1LjcuNC42XG52YXIgdG9FeHBvbmVudGlhbCA9IGZ1bmN0aW9uICh0aGlzQXJnLCBhcmdzKSB7XG4gICAgdmFyIHByZWNpc2lvbiA9IGFyZ3NbMF0gPyBUb0ludGVnZXJfMS5Ub0ludGVnZXIoYXJnc1swXSkgOiBuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCBsYWJlbF8xLmJvdCk7XG4gICAgQ2hlY2tPYmplY3RDb2VyY2libGVfMS5DaGVja09iamVjdENvZXJjaWJsZSh0aGlzQXJnKTtcbiAgICB2YXIgX3RoaXMgPSBUb09iamVjdF8xLlRvT2JqZWN0KHRoaXNBcmcpO1xuICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUoX3RoaXMudmFsdWUuUHJpbWl0aXZlVmFsdWUudG9FeHBvbmVudGlhbChwcmVjaXNpb24udmFsdWUpLCBsYWJlbF8xLmx1YihwcmVjaXNpb24ubGFiZWwsIF90aGlzLmxhYmVsKSk7XG59O1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyB0b1ByZWNpc2lvbiwgMTUuNy40LjdcbnZhciB0b1ByZWNpc2lvbiA9IGZ1bmN0aW9uICh0aGlzQXJnLCBhcmdzKSB7XG4gICAgdmFyIHByZWNpc2lvbiA9IGFyZ3NbMF0gPyBhcmdzWzBdIDogbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgbGFiZWxfMS5ib3QpO1xuICAgIHZhciBsYmwgPSBsYWJlbF8xLmx1YihwcmVjaXNpb24ubGFiZWwsIHRoaXNBcmcubGFiZWwpO1xuICAgIGlmIChwcmVjaXNpb24udmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgc3RyWCA9IFRvU3RyaW5nXzEuVG9TdHJpbmcodGhpc0FyZyk7IC8vc3RlcCAyXG4gICAgICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUoc3RyWC52YWx1ZSwgbGJsKTtcbiAgICB9XG4gICAgdmFyIHAgPSBUb0ludGVnZXJfMS5Ub0ludGVnZXIocHJlY2lzaW9uKTsgLy9zdGVwIDNcbiAgICBpZiAodGhpc0FyZy52YWx1ZSA9PT0gTmFOKVxuICAgICAgICByZXR1cm4gbmV3IHZhbHVlc18xLlZhbHVlKCdOYU4nLCBsYmwpOyAvL3N0ZXAgNFxuICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUodGhpc0FyZy52YWx1ZS50b1ByZWNpc2lvbihwcmVjaXNpb24udmFsdWUpLCBsYmwpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU51bWJlclByb3RvdHlwZS5qcy5tYXAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBsYWJlbF8xID0gcmVxdWlyZShcIi4uL2xhYmVsXCIpO1xudmFyIHZhbHVlc18xID0gcmVxdWlyZShcIi4uL3ZhbHVlc1wiKTtcbnZhciBlY21hXzEgPSByZXF1aXJlKFwiLi4vZWNtYVwiKTtcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzXCIpO1xudmFyIGZ1bmN0aW9uXzEgPSByZXF1aXJlKFwiLi4vZnVuY3Rpb25cIik7XG52YXIgVG9TdHJpbmdfMSA9IHJlcXVpcmUoXCIuLi9Db252ZXJzaW9uL1RvU3RyaW5nXCIpO1xudmFyIFRvT2JqZWN0XzEgPSByZXF1aXJlKFwiLi4vQ29udmVyc2lvbi9Ub09iamVjdFwiKTtcbnZhciBJc0NhbGxhYmxlXzEgPSByZXF1aXJlKFwiLi4vVXRpbGl0eS9Jc0NhbGxhYmxlXCIpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBUaGUgb2JqZWN0IHByb3RvdHlwZSwgMTUuMi40XG52YXIgT2JqZWN0UHJvdG90eXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhPYmplY3RQcm90b3R5cGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gT2JqZWN0UHJvdG90eXBlKGhvc3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuUHJvdG90eXBlID0gbmV3IHZhbHVlc18xLlZhbHVlKG51bGwsIGxhYmVsXzEuYm90KTtcbiAgICAgICAgX3RoaXMuQ2xhc3MgPSAnT2JqZWN0JztcbiAgICAgICAgX3RoaXMuRXh0ZW5zaWJsZSA9IHRydWU7XG4gICAgICAgIF90aGlzLmhvc3QgPSBob3N0O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdFByb3RvdHlwZS5wcm90b3R5cGUuU2V0dXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIDE1LjIuNC4xXG4gICAgICAgIGVjbWFfMS5EZWZpbmVURlQodGhpcywgY29uc3RhbnRzLmNvbnN0cnVjdG9yLCBtb25pdG9yLmluc3RhbmNlcy5PYmplY3RDb25zdHJ1Y3Rvcik7XG4gICAgICAgIGVjbWFfMS5EZWZpbmVURlQodGhpcywgY29uc3RhbnRzLnRvU3RyaW5nLCBuZXcgZnVuY3Rpb25fMS5CdWlsdGluRnVuY3Rpb25PYmplY3QodG9TdHJpbmcsIDAsIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpKTtcbiAgICAgICAgZWNtYV8xLkRlZmluZVRGVCh0aGlzLCBjb25zdGFudHMudG9Mb2NhbGVTdHJpbmcsIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdCh0b0xvY2FsZVN0cmluZywgMCwgT2JqZWN0LnByb3RvdHlwZS50b0xvY2FsZVN0cmluZykpO1xuICAgICAgICBlY21hXzEuRGVmaW5lVEZUKHRoaXMsIG5ldyB2YWx1ZXNfMS5WYWx1ZSgndmFsdWVPZicsIGxhYmVsXzEuYm90KSwgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHZhbHVlT2YsIDAsIE9iamVjdC5wcm90b3R5cGUudmFsdWVPZikpO1xuICAgICAgICBlY21hXzEuRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5oYXNPd25Qcm9wZXJ0eSwgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KGhhc093blByb3BlcnR5LCAxLCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KSk7XG4gICAgICAgIGVjbWFfMS5EZWZpbmVURlQodGhpcywgY29uc3RhbnRzLmlzUHJvdG90eXBlT2YsIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdChpc1Byb3RvdHlwZU9mLCAxLCBPYmplY3QucHJvdG90eXBlLmlzUHJvdG90eXBlT2YpKTtcbiAgICAgICAgZWNtYV8xLkRlZmluZVRGVCh0aGlzLCBjb25zdGFudHMucHJvcGVydHlJc0VudW1lcmFibGUsIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdChwcm9wZXJ0eUlzRW51bWVyYWJsZSwgMSwgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIE9iamVjdFByb3RvdHlwZTtcbn0oZWNtYV8xLkVjbWEpKTtcbmV4cG9ydHMuT2JqZWN0UHJvdG90eXBlID0gT2JqZWN0UHJvdG90eXBlO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKCksIDE1LjIuNC4yXG5mdW5jdGlvbiB0b1N0cmluZyh0aGlzQXJnLCBhcmdzKSB7XG4gICAgaWYgKHRoaXNBcmcudmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZSgnW29iamVjdCBVbmRlZmluZWRdJywgdGhpc0FyZy5sYWJlbCk7XG4gICAgaWYgKHRoaXNBcmcudmFsdWUgPT09IG51bGwpXG4gICAgICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUoJ1tvYmplY3QgTnVsbF0nLCB0aGlzQXJnLmxhYmVsKTtcbiAgICB2YXIgTyA9IFRvT2JqZWN0XzEuVG9PYmplY3QodGhpc0FyZyk7XG4gICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZSgnW29iamVjdCAnICsgTy52YWx1ZS5DbGFzcyArICddJywgdGhpc0FyZy5sYWJlbCk7XG59XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIDE1LjIuNC4zXG5mdW5jdGlvbiB0b0xvY2FsZVN0cmluZyh0aGlzQXJnLCBhcmdzKSB7XG4gICAgdmFyIE8gPSBUb09iamVjdF8xLlRvT2JqZWN0KHRoaXNBcmcpO1xuICAgIHZhciB0b1N0cmluZyA9IE8uR2V0KGNvbnN0YW50cy50b1N0cmluZyk7XG4gICAgdmFyIGIgPSBJc0NhbGxhYmxlXzEuSXNDYWxsYWJsZSh0b1N0cmluZyk7XG4gICAgdmFyIHJlc3VsdDtcbiAgICBtb25pdG9yLmNvbnRleHQucHVzaFBDKGIubGFiZWwpO1xuICAgIGlmIChiLnZhbHVlKSB7XG4gICAgICAgIHJlc3VsdCA9IHRvU3RyaW5nLkNhbGwoTyk7XG4gICAgICAgIHJlc3VsdC5yYWlzZShiLmxhYmVsKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG1vbml0b3IuVGhyb3cobW9uaXRvci5tb2R1bGVzLmVycm9yLlR5cGVFcnJvciwgXCJwcm9wZXJ0eSAndG9TdHJpbmcnIG9mIG9iamVjdCBcIiArIE8gKyBcIiBpcyBub3QgYSBmdW5jdGlvbiBcIiwgbGFiZWxfMS5ib3QpO1xuICAgIH1cbiAgICBtb25pdG9yLmNvbnRleHQucG9wUEMoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAxNS4yLjQuNFxuZnVuY3Rpb24gdmFsdWVPZih0aGlzQXJnKSB7XG4gICAgdmFyIG8gPSBUb09iamVjdF8xLlRvT2JqZWN0KHRoaXNBcmcpO1xuICAgIHJldHVybiBvO1xufVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAxNS4yLjQuNVxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkodGhpc0FyZywgYXJncykge1xuICAgIHZhciBWID0gYXJnc1swXSB8fCBuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCBsYWJlbF8xLmJvdCk7XG4gICAgdmFyIFAgPSBUb1N0cmluZ18xLlRvU3RyaW5nKFYpO1xuICAgIHZhciBPID0gVG9PYmplY3RfMS5Ub09iamVjdCh0aGlzQXJnKTtcbiAgICB2YXIgZGVzYyA9IE8uR2V0T3duUHJvcGVydHkoUCk7XG4gICAgdmFyIHJlc3VsdCA9IGRlc2MudmFsdWUgIT09IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gbmV3IHZhbHVlc18xLlZhbHVlKHJlc3VsdCwgZGVzYy5sYWJlbCk7XG59XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIDE1LjIuNC42XG5mdW5jdGlvbiBpc1Byb3RvdHlwZU9mKHRoaXNBcmcsIGFyZ3MpIHtcbiAgICB2YXIgYyA9IG1vbml0b3IuY29udGV4dDtcbiAgICB2YXIgViA9IGFyZ3NbMF0gfHwgbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgbGFiZWxfMS5ib3QpO1xuICAgIGlmIChWLnZhbHVlID09PSBudWxsIHx8IHR5cGVvZiBWLnZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IHZhbHVlc18xLlZhbHVlKGZhbHNlLCBWLmxhYmVsKTtcbiAgICB9XG4gICAgYy5wdXNoUEMoVi5sYWJlbCk7XG4gICAgdmFyIE8gPSBUb09iamVjdF8xLlRvT2JqZWN0KHRoaXNBcmcpO1xuICAgIGMucG9wUEMoKTtcbiAgICB2YXIgbGJsID0gbmV3IGxhYmVsXzEuTGFiZWwoKTtcbiAgICBsYmwubHViKFYubGFiZWwpO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIFYgPSBWLnZhbHVlLlByb3RvdHlwZTtcbiAgICAgICAgbGJsLmx1YihWLmxhYmVsKTtcbiAgICAgICAgaWYgKFYudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUoZmFsc2UsIGxibCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE8udmFsdWUgPT09IFYudmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUodHJ1ZSwgbGJsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoViA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09iamVjdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZjogb2JqZWN0IHdpdGggdW5kZWZpbmVkIHByb3RvdHlwZScpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAxNS4yLjQuN1xuZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUodGhpc0FyZywgYXJncykge1xuICAgIHZhciBWID0gYXJnc1swXSB8fCBuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCBsYWJlbF8xLmJvdCk7XG4gICAgdmFyIFAgPSBUb1N0cmluZ18xLlRvU3RyaW5nKFYpO1xuICAgIHZhciBPID0gVG9PYmplY3RfMS5Ub09iamVjdCh0aGlzQXJnKTtcbiAgICB2YXIgZGVzYyA9IE8uR2V0T3duUHJvcGVydHkoUCk7XG4gICAgaWYgKGRlc2MudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbmV3IHZhbHVlc18xLlZhbHVlKGZhbHNlLCBkZXNjLmxhYmVsKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZShkZXNjLnZhbHVlLnZhbHVlLCBsYWJlbF8xLmx1YihkZXNjLmxhYmVsLCBkZXNjLnZhbHVlLmxhYmVsKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1PYmplY3RQcm90b3R5cGUuanMubWFwIiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gQ2hlY2tPYmplY3RDb2VyY2libGUsIDkuMTBcbmZ1bmN0aW9uIENoZWNrT2JqZWN0Q29lcmNpYmxlKHgpIHtcbiAgICBpZiAoeC52YWx1ZSA9PT0gbnVsbCB8fCB4LnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbW9uaXRvci5jb250ZXh0LnJhaXNlUEMoeC5sYWJlbCk7XG4gICAgICAgIG1vbml0b3IuVGhyb3cobW9uaXRvci5tb2R1bGVzLmVycm9yLlR5cGVFcnJvck9iamVjdCwgU3RyaW5nKHgudmFsdWUpICsgJyBpcyBub3QgY29lcmNpYmxlJywgeC5sYWJlbCk7XG4gICAgfVxufVxuZXhwb3J0cy5DaGVja09iamVjdENvZXJjaWJsZSA9IENoZWNrT2JqZWN0Q29lcmNpYmxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2hlY2tPYmplY3RDb2VyY2libGUuanMubWFwIiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZhbHVlc18xID0gcmVxdWlyZShcIi4uL3ZhbHVlc1wiKTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIElzQ2FsbGFibGUsIDkuMTFcbmZ1bmN0aW9uIElzQ2FsbGFibGUoeCkge1xuICAgIHZhciBiID0gZmFsc2U7XG4gICAgaWYgKHgudmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHgudmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGIgPSB4LnZhbHVlLkNhbGwgIT09IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZShiLCB4LmxhYmVsKTtcbn1cbmV4cG9ydHMuSXNDYWxsYWJsZSA9IElzQ2FsbGFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Jc0NhbGxhYmxlLmpzLm1hcCIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBsYWJlbF8xID0gcmVxdWlyZShcIi4vbGFiZWxcIik7XG52YXIgdmFsdWVzXzEgPSByZXF1aXJlKFwiLi92YWx1ZXNcIik7XG5leHBvcnRzLmluZGV4ID0gbmV3IHZhbHVlc18xLlZhbHVlKCdpbmRleCcsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMuaW5wdXQgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ2lucHV0JywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy52YWx1ZSA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgndmFsdWUnLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLndyaXRhYmxlID0gbmV3IHZhbHVlc18xLlZhbHVlKCd3cml0YWJsZScsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMuZW51bWVyYWJsZSA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgnZW51bWVyYWJsZScsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMuY29uZmlndXJhYmxlID0gbmV3IHZhbHVlc18xLlZhbHVlKCdjb25maWd1cmFibGUnLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLmdldCA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgnZ2V0JywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5zZXQgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ3NldCcsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMucHJpbnQgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ3ByaW50JywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5jb25zb2xlID0gbmV3IHZhbHVlc18xLlZhbHVlKCdjb25zb2xlJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5hbGVydCA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgnYWxlcnQnLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLmxvZyA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgnbG9nJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5wcm90b3R5cGUgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ3Byb3RvdHlwZScsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMuY29uc3RydWN0b3IgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ2NvbnN0cnVjdG9yJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5sZW5ndGggPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ2xlbmd0aCcsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMuYXJndW1lbnRzID0gbmV3IHZhbHVlc18xLlZhbHVlKCdhcmd1bWVudHMnLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLnVwZyA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgndXBnJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy51cGd2ID0gbmV3IHZhbHVlc18xLlZhbHVlKCd1cGd2JywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy51cGdmID0gbmV3IHZhbHVlc18xLlZhbHVlKCd1cGdmJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy51cGdzID0gbmV3IHZhbHVlc18xLlZhbHVlKCd1cGdzJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5nZXRQcm90b3R5cGVPZiA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgnZ2V0UHJvdG90eXBlT2YnLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLmdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgnZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5nZXRPd25Qcm9wZXJ0eU5hbWVzID0gbmV3IHZhbHVlc18xLlZhbHVlKCdnZXRPd25Qcm9wZXJ0eU5hbWVzJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5jcmVhdGUgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ2NyZWF0ZScsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMucmVxdWlyZSA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgncmVxdWlyZScsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMuZGVmaW5lUHJvcGVydHkgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ2RlZmluZVByb3BlcnR5JywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5kZWZpbmVQcm9wZXJ0aWVzID0gbmV3IHZhbHVlc18xLlZhbHVlKCdkZWZpbmVQcm9wZXJ0aWVzJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5zZWFsID0gbmV3IHZhbHVlc18xLlZhbHVlKCdzZWFsJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5mcmVlemUgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ2ZyZWV6ZScsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMucHJldmVudEV4dGVuc2lvbnMgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ3ByZXZlbnRFeHRlbnNpb25zJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5pc1NlYWxlZCA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgnaXNTZWFsZWQnLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLmlzRnJvemVuID0gbmV3IHZhbHVlc18xLlZhbHVlKCdpc0Zyb3plbicsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMuaXNFeHRlbnNpYmxlID0gbmV3IHZhbHVlc18xLlZhbHVlKCdpc0V4dGVuc2libGUnLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLmtleXMgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ2tleXMnLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLnRvU3RyaW5nID0gbmV3IHZhbHVlc18xLlZhbHVlKCd0b1N0cmluZycsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMudG9Mb2NhbGVTdHJpbmcgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ3RvTG9jYWxlU3RyaW5nJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy52YWx1ZU9mID0gbmV3IHZhbHVlc18xLlZhbHVlKCd2YWx1ZU9mJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eSA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgnaGFzT3duUHJvcGVydHknLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLmlzUHJvdG90eXBlT2YgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ2lzUHJvdG90eXBlT2YnLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLnByb3BlcnR5SXNFbnVtZXJhYmxlID0gbmV3IHZhbHVlc18xLlZhbHVlKCdwcm9wZXJ0eUlzRW51bWVyYWJsZScsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMuYXBwbHkgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ2FwcGx5JywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5jYWxsID0gbmV3IHZhbHVlc18xLlZhbHVlKCdjYWxsJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5jYWxsZXIgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ2NhbGxlcicsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMuYmluZCA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgnYmluZCcsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMuTmFOID0gbmV3IHZhbHVlc18xLlZhbHVlKCdOYU4nLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLkluZmluaXR5ID0gbmV3IHZhbHVlc18xLlZhbHVlKCdJbmZpbml0eScsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMudW5kZWZpbmVkID0gbmV3IHZhbHVlc18xLlZhbHVlKCd1bmRlZmluZWQnLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLmV2YWwgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ2V2YWwnLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLnBhcnNlSW50ID0gbmV3IHZhbHVlc18xLlZhbHVlKCdwYXJzZUludCcsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMucGFyc2VGbG9hdCA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgncGFyc2VGbG9hdCcsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMuaXNOYU4gPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ2lzTmFOJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5pc0Zpbml0ZSA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgnaXNGaW5pdGUnLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLmRlY29kZVVSSSA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgnZGVjb2RlVVJJJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5kZWNvZGVVUklDb21wb25lbnQgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ2RlY29kZVVSSUNvbXBvbmVudCcsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMuZW5jb2RlVVJJID0gbmV3IHZhbHVlc18xLlZhbHVlKCdlbmNvZGVVUkknLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLmVuY29kZVVSSUNvbXBvbmVudCA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgnZW5jb2RlVVJJQ29tcG9uZW50JywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5PYmplY3QgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ09iamVjdCcsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMuRnVuY3Rpb24gPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ0Z1bmN0aW9uJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5BcnJheSA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgnQXJyYXknLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLlN0cmluZyA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgnU3RyaW5nJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5Cb29sZWFuID0gbmV3IHZhbHVlc18xLlZhbHVlKCdCb29sZWFuJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5OdW1iZXIgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ051bWJlcicsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMuRGF0ZSA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgnRGF0ZScsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMuUmVnRXhwID0gbmV3IHZhbHVlc18xLlZhbHVlKCdSZWdFeHAnLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLkVycm9yID0gbmV3IHZhbHVlc18xLlZhbHVlKCdFcnJvcicsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMuRXZhbEVycm9yID0gbmV3IHZhbHVlc18xLlZhbHVlKCdFdmFsRXJyb3InLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLlJhbmdlRXJyb3IgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ1JhbmdlRXJyb3InLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLlJlZmVyZW5jZUVycm9yID0gbmV3IHZhbHVlc18xLlZhbHVlKCdSZWZlcmVuY2VFcnJvcicsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMuU3ludGF4RXJyb3IgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ1N5bnRheEVycm9yJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5UeXBlRXJyb3IgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ1R5cGVFcnJvcicsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMuVVJJRXJyb3IgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ1VSSUVycm9yJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5NYXRoID0gbmV3IHZhbHVlc18xLlZhbHVlKCdNYXRoJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5KU09OID0gbmV3IHZhbHVlc18xLlZhbHVlKCdKU09OJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5wYXJzZSA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgncGFyc2UnLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLnN0cmluZ2lmeSA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgnc3RyaW5naWZ5JywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5uYW1lID0gbmV3IHZhbHVlc18xLlZhbHVlKCduYW1lJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5tZXNzYWdlID0gbmV3IHZhbHVlc18xLlZhbHVlKCdtZXNzYWdlJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5pc0FycmF5ID0gbmV3IHZhbHVlc18xLlZhbHVlKCdpc0FycmF5JywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5jb25jYXQgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ2NvbmNhdCcsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMuam9pbiA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgnam9pbicsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMucG9wID0gbmV3IHZhbHVlc18xLlZhbHVlKCdwb3AnLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLnB1c2ggPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ3B1c2gnLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLnJldmVyc2UgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ3JldmVyc2UnLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLnNoaWZ0ID0gbmV3IHZhbHVlc18xLlZhbHVlKCdzaGlmdCcsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMuc2xpY2UgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ3NsaWNlJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5zb3J0ID0gbmV3IHZhbHVlc18xLlZhbHVlKCdzb3J0JywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5zcGxpY2UgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ3NwbGljZScsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMudW5zaGlmdCA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgndW5zaGlmdCcsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMuaW5kZXhPZiA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgnaW5kZXhPZicsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMubGFzdEluZGV4T2YgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ2xhc3RJbmRleE9mJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5ldmVyeSA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgnZXZlcnknLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLnNvbWUgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ3NvbWUnLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLmZvckVhY2ggPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ2ZvckVhY2gnLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLm1hcCA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgnbWFwJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5maWx0ZXIgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ2ZpbHRlcicsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMucmVkdWNlID0gbmV3IHZhbHVlc18xLlZhbHVlKCdyZWR1Y2UnLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLnJlZHVjZVJpZ2h0ID0gbmV3IHZhbHVlc18xLlZhbHVlKCdyZWR1Y2VSaWdodCcsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMuZnJvbUNoYXJDb2RlID0gbmV3IHZhbHVlc18xLlZhbHVlKCdmcm9tQ2hhckNvZGUnLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLmNoYXJBdCA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgnY2hhckF0JywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5jaGFyQ29kZUF0ID0gbmV3IHZhbHVlc18xLlZhbHVlKCdjaGFyQ29kZUF0JywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5sb2NhbGVDb21wYXJlID0gbmV3IHZhbHVlc18xLlZhbHVlKCdsb2NhbGVDb21wYXJlJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5tYXRjaCA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgnbWF0Y2gnLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLnJlcGxhY2UgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ3JlcGxhY2UnLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLnNlYXJjaCA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgnc2VhcmNoJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5zcGxpdCA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgnc3BsaXQnLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLnN1YnN0cmluZyA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgnc3Vic3RyaW5nJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5zdWJzdHIgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ3N1YnN0cicsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMudG9Mb3dlckNhc2UgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ3RvTG93ZXJDYXNlJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy50b0xvY2FsZUxvd2VyQ2FzZSA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgndG9Mb2NhbGVMb3dlckNhc2UnLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLnRvVXBwZXJDYXNlID0gbmV3IHZhbHVlc18xLlZhbHVlKCd0b1VwcGVyQ2FzZScsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMudG9Mb2NhbGVVcHBlckNhc2UgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ3RvTG9jYWxlVXBwZXJDYXNlJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy50cmltID0gbmV3IHZhbHVlc18xLlZhbHVlKCd0cmltJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5NQVhfVkFMVUUgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ01BWF9WQUxVRScsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMuTUlOX1ZBTFVFID0gbmV3IHZhbHVlc18xLlZhbHVlKCdNSU5fVkFMVUUnLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLk5FR0FUSVZFX0lORklOSVRZID0gbmV3IHZhbHVlc18xLlZhbHVlKCdORUdBVElWRV9JTkZJTklUWScsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMuUE9TSVRJVkVfSU5GSU5JVFkgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ1BPU0lUSVZFX0lORklOSVRZJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy50b0ZpeGVkID0gbmV3IHZhbHVlc18xLlZhbHVlKCd0b0ZpeGVkJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy50b0V4cG9uZW50aWFsID0gbmV3IHZhbHVlc18xLlZhbHVlKCd0b0V4cG9uZW50aWFsJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy50b1ByZWNpc2lvbiA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgndG9QcmVjaXNpb24nLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLkUgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ0UnLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLkxOMTAgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ0xOMTAnLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLkxOMiA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgnTE4yJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5MT0cyRSA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgnTE9HMkUnLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLkxPRzEwRSA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgnTE9HMTBFJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5QSSA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgnUEknLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLlNRUlQxXzIgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ1NRUlQxXzInLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLlNRUlQyID0gbmV3IHZhbHVlc18xLlZhbHVlKCdTUVJUMicsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMuYWJzID0gbmV3IHZhbHVlc18xLlZhbHVlKCdhYnMnLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLmFjb3MgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ2Fjb3MnLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLmFzaW4gPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ2FzaW4nLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLmF0YW4gPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ2F0YW4nLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLmF0YW4yID0gbmV3IHZhbHVlc18xLlZhbHVlKCdhdGFuMicsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMuY2VpbCA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgnY2VpbCcsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMuY29zID0gbmV3IHZhbHVlc18xLlZhbHVlKCdjb3MnLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLmV4cCA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgnZXhwJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5mbG9vciA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgnZmxvb3InLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLmxvZyA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgnbG9nJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5tYXggPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ21heCcsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMubWluID0gbmV3IHZhbHVlc18xLlZhbHVlKCdtaW4nLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLnBvdyA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgncG93JywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5yYW5kb20gPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ3JhbmRvbScsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMucm91bmQgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ3JvdW5kJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5zaW4gPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ3NpbicsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMuc3FydCA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgnc3FydCcsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMudGFuID0gbmV3IHZhbHVlc18xLlZhbHVlKCd0YW4nLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLnRvRGF0ZVN0cmluZyA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgndG9EYXRlU3RyaW5nJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy50b1RpbWVTdHJpbmcgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ3RvVGltZVN0cmluZycsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMudG9Mb2NhbGVEYXRlU3RyaW5nID0gbmV3IHZhbHVlc18xLlZhbHVlKCd0b0xvY2FsZURhdGVTdHJpbmcnLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLnRvTG9jYWxlVGltZVN0cmluZyA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgndG9Mb2NhbGVUaW1lU3RyaW5nJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5nZXRUaW1lID0gbmV3IHZhbHVlc18xLlZhbHVlKCdnZXRUaW1lJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5nZXRGdWxsWWVhciA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgnZ2V0RnVsbFllYXInLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLmdldFVUQ0Z1bGxZZWFyID0gbmV3IHZhbHVlc18xLlZhbHVlKCdnZXRVVENGdWxsWWVhcicsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMuZ2V0TW9udGggPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ2dldE1vbnRoJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5nZXRVVENNb250aCA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgnZ2V0VVRDTW9udGgnLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLmdldERhdGUgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ2dldERhdGUnLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLmdldFVUQ0RhdGUgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ2dldFVUQ0RhdGUnLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLmdldERheSA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgnZ2V0RGF5JywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5nZXRVVENEYXkgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ2dldFVUQ0RheScsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMuZ2V0SG91cnMgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ2dldEhvdXJzJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5nZXRVVENIb3VycyA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgnZ2V0VVRDSG91cnMnLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLmdldE1pbnV0ZXMgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ2dldE1pbnV0ZXMnLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLmdldFVUQ01pbnV0ZXMgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ2dldFVUQ01pbnV0ZXMnLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLmdldFNlY29uZHMgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ2dldFNlY29uZHMnLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLmdldFVUQ1NlY29uZHMgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ2dldFVUQ1NlY29uZHMnLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLmdldE1pbGxpc2Vjb25kcyA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgnZ2V0TWlsbGlzZWNvbmRzJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5nZXRVVENNaWxsaXNlY29uZHMgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ2dldFVUQ01pbGxpc2Vjb25kcycsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMuZ2V0VGltZXpvbmVPZmZzZXQgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ2dldFRpbWV6b25lT2Zmc2V0JywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5zZXRUaW1lID0gbmV3IHZhbHVlc18xLlZhbHVlKCdzZXRUaW1lJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5zZXRNaWxsaXNlY29uZHMgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ3NldE1pbGxpc2Vjb25kcycsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMuc2V0VVRDTWlsbGlzZWNvbmRzID0gbmV3IHZhbHVlc18xLlZhbHVlKCdzZXRVVENNaWxsaXNlY29uZHMnLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLnNldFNlY29uZHMgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ3NldFNlY29uZHMnLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLnNldFVUQ1NlY29uZHMgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ3NldFVUQ1NlY29uZHMnLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLnNldE1pbnV0ZXMgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ3NldE1pbnV0ZXMnLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLnNldFVUQ01pbnV0ZXMgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ3NldFVUQ01pbnV0ZXMnLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLnNldEhvdXJzID0gbmV3IHZhbHVlc18xLlZhbHVlKCdzZXRIb3VycycsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMuc2V0VVRDSG91cnMgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ3NldFVUQ0hvdXJzJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5zZXREYXRlID0gbmV3IHZhbHVlc18xLlZhbHVlKCdzZXREYXRlJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5zZXRVVENEYXRlID0gbmV3IHZhbHVlc18xLlZhbHVlKCdzZXRVVENEYXRlJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5zZXRNb250aCA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgnc2V0TW9udGgnLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLnNldFVUQ01vbnRoID0gbmV3IHZhbHVlc18xLlZhbHVlKCdzZXRVVENNb250aCcsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMuc2V0RnVsbFllYXIgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ3NldEZ1bGxZZWFyJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5zZXRVVENGdWxsWWVhciA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgnc2V0VVRDRnVsbFllYXInLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLnRvVVRDU3RyaW5nID0gbmV3IHZhbHVlc18xLlZhbHVlKCd0b1VUQ1N0cmluZycsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMudG9JU09TdHJpbmcgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ3RvSVNPU3RyaW5nJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy50b0pTT04gPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ3RvSlNPTicsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMucGFyc2UgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ3BhcnNlJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5VVEMgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ1VUQycsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMubm93ID0gbmV3IHZhbHVlc18xLlZhbHVlKCdub3cnLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLmV4ZWMgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ2V4ZWMnLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLnRlc3QgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ3Rlc3QnLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLnNvdXJjZSA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgnc291cmNlJywgbGFiZWxfMS5ib3QpO1xuZXhwb3J0cy5nbG9iYWwgPSBuZXcgdmFsdWVzXzEuVmFsdWUoJ2dsb2JhbCcsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMuaWdub3JlQ2FzZSA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgnaWdub3JlQ2FzZScsIGxhYmVsXzEuYm90KTtcbmV4cG9ydHMubXVsdGlsaW5lID0gbmV3IHZhbHVlc18xLlZhbHVlKCdtdWx0aWxpbmUnLCBsYWJlbF8xLmJvdCk7XG5leHBvcnRzLmxhc3RJbmRleCA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgnbGFzdEluZGV4JywgbGFiZWxfMS5ib3QpO1xuLypcbnZhciBzdHJpbmdzID0gW1xuICAnaW5kZXgnLFxuICAnaW5wdXQnLFxuICAndmFsdWUnLFxuICAnd3JpdGFibGUnLFxuICAnZW51bWVyYWJsZScsXG4gICdjb25maWd1cmFibGUnLFxuICAnZ2V0JyxcbiAgJ3NldCcsXG4gICdwcmludCcsXG4gICdjb25zb2xlJyxcbiAgJ2FsZXJ0JyxcbiAgJ2xvZycsXG4gICdwcm90b3R5cGUnLFxuICAnY29uc3RydWN0b3InLFxuICAnbGVuZ3RoJyxcbiAgJ2FyZ3VtZW50cycsXG4gICd1cGcnLFxuICAndXBndicsXG4gICd1cGdmJyxcbiAgJ3VwZ3MnLFxuICAnZ2V0UHJvdG90eXBlT2YnLFxuICAnZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJyxcbiAgJ2dldE93blByb3BlcnR5TmFtZXMnLFxuICAnY3JlYXRlJyxcbiAgJ3JlcXVpcmUnLFxuICAnZGVmaW5lUHJvcGVydHknLFxuICAnZGVmaW5lUHJvcGVydGllcycsXG4gICdzZWFsJyxcbiAgJ2ZyZWV6ZScsXG4gICdwcmV2ZW50RXh0ZW5zaW9ucycsXG4gICdpc1NlYWxlZCcsXG4gICdpc0Zyb3plbicsXG4gICdpc0V4dGVuc2libGUnLFxuICAna2V5cycsXG4gICd0b1N0cmluZycsXG4gICd0b0xvY2FsZVN0cmluZycsXG4gICd2YWx1ZU9mJyxcbiAgJ2hhc093blByb3BlcnR5JyxcbiAgJ2lzUHJvdG90eXBlT2YnLFxuICAncHJvcGVydHlJc0VudW1lcmFibGUnLFxuICAnYXBwbHknLFxuICAnY2FsbCcsXG4gICdjYWxsZXInLFxuICAnYmluZCcsXG4gICdOYU4nLFxuICAnSW5maW5pdHknLFxuICAndW5kZWZpbmVkJyxcbiAgJ2V2YWwnLFxuICAncGFyc2VJbnQnLFxuICAncGFyc2VGbG9hdCcsXG4gICdpc05hTicsXG4gICdpc0Zpbml0ZScsXG4gICdkZWNvZGVVUkknLFxuICAnZGVjb2RlVVJJQ29tcG9uZW50JyxcbiAgJ2VuY29kZVVSSScsXG4gICdlbmNvZGVVUklDb21wb25lbnQnLFxuICAnT2JqZWN0JyxcbiAgJ0Z1bmN0aW9uJyxcbiAgJ0FycmF5JyxcbiAgJ1N0cmluZycsXG4gICdCb29sZWFuJyxcbiAgJ051bWJlcicsXG4gICdEYXRlJyxcbiAgJ1JlZ0V4cCcsXG4gICdFcnJvcicsXG4gICdFdmFsRXJyb3InLFxuICAnUmFuZ2VFcnJvcicsXG4gICdSZWZlcmVuY2VFcnJvcicsXG4gICdTeW50YXhFcnJvcicsXG4gICdUeXBlRXJyb3InLFxuICAnVVJJRXJyb3InLFxuICAnTWF0aCcsXG4gICdKU09OJyxcbiAgJ3BhcnNlJyxcbiAgJ3N0cmluZ2lmeScsXG4gICduYW1lJyxcbiAgJ21lc3NhZ2UnLFxuICAnaXNBcnJheScsXG4gICdjb25jYXQnLFxuICAnam9pbicsXG4gICdwb3AnLFxuICAncHVzaCcsXG4gICdyZXZlcnNlJyxcbiAgJ3NoaWZ0JyxcbiAgJ3NsaWNlJyxcbiAgJ3NvcnQnLFxuICAnc3BsaWNlJyxcbiAgJ3Vuc2hpZnQnLFxuICAnaW5kZXhPZicsXG4gICdsYXN0SW5kZXhPZicsXG4gICdldmVyeScsXG4gICdzb21lJyxcbiAgJ2ZvckVhY2gnLFxuICAnbWFwJyxcbiAgJ2ZpbHRlcicsXG4gICdyZWR1Y2UnLFxuICAncmVkdWNlUmlnaHQnLFxuICAnZnJvbUNoYXJDb2RlJyxcbiAgJ2NoYXJBdCcsXG4gICdjaGFyQ29kZUF0JyxcbiAgJ2xvY2FsZUNvbXBhcmUnLFxuICAnbWF0Y2gnLFxuICAncmVwbGFjZScsXG4gICdzZWFyY2gnLFxuICAnc3BsaXQnLFxuICAnc3Vic3RyaW5nJyxcbiAgJ3N1YnN0cicsXG4gICd0b0xvd2VyQ2FzZScsXG4gICd0b0xvY2FsZUxvd2VyQ2FzZScsXG4gICd0b1VwcGVyQ2FzZScsXG4gICd0b0xvY2FsZVVwcGVyQ2FzZScsXG4gICd0cmltJyxcbiAgJ01BWF9WQUxVRScsXG4gICdNSU5fVkFMVUUnLFxuICAnTkVHQVRJVkVfSU5GSU5JVFknLFxuICAnUE9TSVRJVkVfSU5GSU5JVFknLFxuICAndG9GaXhlZCcsXG4gICd0b0V4cG9uZW50aWFsJyxcbiAgJ3RvUHJlY2lzaW9uJyxcbiAgJ0UnLFxuICAnTE4xMCcsXG4gICdMTjInLFxuICAnTE9HMkUnLFxuICAnTE9HMTBFJyxcbiAgJ1BJJyxcbiAgJ1NRUlQxXzInLFxuICAnU1FSVDInLFxuICAnYWJzJyxcbiAgJ2Fjb3MnLFxuICAnYXNpbicsXG4gICdhdGFuJyxcbiAgJ2F0YW4yJyxcbiAgJ2NlaWwnLFxuICAnY29zJyxcbiAgJ2V4cCcsXG4gICdmbG9vcicsXG4gICdsb2cnLFxuICAnbWF4JyxcbiAgJ21pbicsXG4gICdwb3cnLFxuICAncmFuZG9tJyxcbiAgJ3JvdW5kJyxcbiAgJ3NpbicsXG4gICdzcXJ0JyxcbiAgJ3RhbicsXG4gICd0b0RhdGVTdHJpbmcnLFxuICAndG9UaW1lU3RyaW5nJyxcbiAgJ3RvTG9jYWxlRGF0ZVN0cmluZycsXG4gICd0b0xvY2FsZVRpbWVTdHJpbmcnLFxuICAnZ2V0VGltZScsXG4gICdnZXRGdWxsWWVhcicsXG4gICdnZXRVVENGdWxsWWVhcicsXG4gICdnZXRNb250aCcsXG4gICdnZXRVVENNb250aCcsXG4gICdnZXREYXRlJyxcbiAgJ2dldFVUQ0RhdGUnLFxuICAnZ2V0RGF5JyxcbiAgJ2dldFVUQ0RheScsXG4gICdnZXRIb3VycycsXG4gICdnZXRVVENIb3VycycsXG4gICdnZXRNaW51dGVzJyxcbiAgJ2dldFVUQ01pbnV0ZXMnLFxuICAnZ2V0U2Vjb25kcycsXG4gICdnZXRVVENTZWNvbmRzJyxcbiAgJ2dldE1pbGxpc2Vjb25kcycsXG4gICdnZXRVVENNaWxsaXNlY29uZHMnLFxuICAnZ2V0VGltZXpvbmVPZmZzZXQnLFxuICAnc2V0VGltZScsXG4gICdzZXRNaWxsaXNlY29uZHMnLFxuICAnc2V0VVRDTWlsbGlzZWNvbmRzJyxcbiAgJ3NldFNlY29uZHMnLFxuICAnc2V0VVRDU2Vjb25kcycsXG4gICdzZXRNaW51dGVzJyxcbiAgJ3NldFVUQ01pbnV0ZXMnLFxuICAnc2V0SG91cnMnLFxuICAnc2V0VVRDSG91cnMnLFxuICAnc2V0RGF0ZScsXG4gICdzZXRVVENEYXRlJyxcbiAgJ3NldE1vbnRoJyxcbiAgJ3NldFVUQ01vbnRoJyxcbiAgJ3NldEZ1bGxZZWFyJyxcbiAgJ3NldFVUQ0Z1bGxZZWFyJyxcbiAgJ3RvVVRDU3RyaW5nJyxcbiAgJ3RvSVNPU3RyaW5nJyxcbiAgJ3RvSlNPTicsXG4gICdwYXJzZScsXG4gICdVVEMnLFxuICAnbm93JyxcbiAgJ2V4ZWMnLFxuICAndGVzdCcsXG4gICdzb3VyY2UnLFxuICAnZ2xvYmFsJyxcbiAgJ2lnbm9yZUNhc2UnLFxuICAnbXVsdGlsaW5lJyxcbiAgJ2xhc3RJbmRleCdcbl07XG5cbmV4cG9ydCB2YXIgY29uc3RhbnRzID0ge307XG5mb3IgKHZhciBpID0gMCwgbGVuID0gc3RyaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICB2YXIgc3RyID0gc3RyaW5nc1tpXTtcbiAgY29uc29sZS5sb2coYGV4cG9ydCB2YXIgJHtzdHJ9ID0gbmV3IFZhbHVlKCcke3N0cn0nLCBib3QpO2ApXG4gIGNvbnN0YW50c1tzdHJdID0gbmV3IFZhbHVlKHN0ciwgTGFiZWwuYm90KTtcbn1cbiovXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuanMubWFwIiwiLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBsYWJlbF8xID0gcmVxdWlyZShcIi4vbGFiZWxcIik7XG52YXIgc3RhY2tfMSA9IHJlcXVpcmUoXCIuL3N0YWNrXCIpO1xudmFyIHBwXzEgPSByZXF1aXJlKFwiLi9wcFwiKTtcbi8vIC0tLSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIEJ1Y2tldCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCdWNrZXQoZWxlbWVudCwgcHJldiwgbmV4dCkge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLm5leHQgPSBuZXh0IHx8IG51bGw7XG4gICAgICAgIHRoaXMucHJldiA9IHByZXYgfHwgbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIEJ1Y2tldDtcbn0oKSk7XG52YXIgV29ya0xpc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gV29ya0xpc3QoKSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgICAgICAgdGhpcy50aGVubG9jID0gbnVsbDtcbiAgICB9XG4gICAgLy8gLS0tXG4gICAgV29ya0xpc3QucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcG9zID0gdGhpcy5oZWFkO1xuICAgICAgICB2YXIgc3RyID0gJ3dvcmtsaXN0Oic7XG4gICAgICAgIHZhciBjbnQgPSAxO1xuICAgICAgICB3aGlsZSAocG9zKSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IHBvcy5lbGVtZW50O1xuICAgICAgICAgICAgdmFyIGxpbmU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBsaW5lID0gY250ICsgJzogJyArIFN0cmluZyhlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCdmdW5jJyBpbiBlbGVtZW50ICYmICdkYXRhJyBpbiBlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgbGluZSA9IGNudCArICc6ICcgKyBTdHJpbmcoZWxlbWVudC5mdW5jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxpbmUgPSBjbnQgKyAnOiAnICsgZWxlbWVudC50eXBlICsgJyAnICsgcHBfMS5wcmV0dHkoZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaXggPSBsaW5lLmluZGV4T2YoJ1xcbicpO1xuICAgICAgICAgICAgaWYgKGl4ID4gMCkge1xuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnNsaWNlKDAsIGl4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0ciA9IHN0ciArICdcXG4nICsgbGluZTtcbiAgICAgICAgICAgIHBvcyA9IHBvcy5uZXh0O1xuICAgICAgICAgICAgY250Kys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9O1xuICAgIC8vIC0tLVxuICAgIFdvcmtMaXN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5oZWFkID0gbmV3IEJ1Y2tldChlbGVtZW50LCBudWxsLCB0aGlzLmhlYWQpO1xuICAgICAgICBpZiAodGhpcy5oZWFkLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZC5uZXh0LnByZXYgPSB0aGlzLmhlYWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICB9O1xuICAgIC8vIC0tLVxuICAgIFdvcmtMaXN0LnByb3RvdHlwZS5wcmVwZW5kID0gZnVuY3Rpb24gKGVsZW1lbnRzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBlbGVtZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdGhpcy5wdXNoKGVsZW1lbnRzW2ldKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gLS0tXG4gICAgV29ya0xpc3QucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmhlYWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBtb25pdG9yLmZhdGFsKFwiV29ya0xpc3QucGVlaygpIGVtcHR5IHdvcmsgbGlzdFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5oZWFkLmVsZW1lbnQ7XG4gICAgfTtcbiAgICAvLyAtLS1cbiAgICBXb3JrTGlzdC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5oZWFkID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9uaXRvci5mYXRhbChcIldvcmtMaXN0LnBvcCgpIGVtcHR5IHdvcmsgbGlzdFwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuaGVhZC5lbGVtZW50O1xuICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDtcbiAgICAgICAgdGhpcy5sZW5ndGgtLTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfTtcbiAgICAvLyAtLS1cbiAgICBXb3JrTGlzdC5wcm90b3R5cGUuZW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5oZWFkID09PSBudWxsKTtcbiAgICB9O1xuICAgIC8vIC0tLVxuICAgIFdvcmtMaXN0LnByb3RvdHlwZS50b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgV29ya0xpc3RQdHIodGhpcywgbnVsbCk7XG4gICAgfTtcbiAgICAvLyAtLS1cbiAgICBXb3JrTGlzdC5wcm90b3R5cGUuZmlyc3QgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy50aGVubG9jID0gdGhpcy5oZWFkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgbm8gZWxlbWVudCBnaXZlbiwgcmVzZXQgdGhlbmxvYyB0byBmb3JjZSBuZXh0IGNhbGxlZCAndGhlbidcbiAgICAgICAgICAgIC8vIHRvIGJlIGEgJ2ZpcnN0J1xuICAgICAgICAgICAgdGhpcy50aGVubG9jID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gLS0tXG4gICAgV29ya0xpc3QucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICBpZiAoIXRoaXMudGhlbmxvYykge1xuICAgICAgICAgICAgdGhpcy5maXJzdChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBiZWZvcmUgPSB0aGlzLnRoZW5sb2M7XG4gICAgICAgICAgICB2YXIgYWZ0ZXIgPSB0aGlzLnRoZW5sb2MubmV4dDtcbiAgICAgICAgICAgIHZhciBidWNrZXQgPSBuZXcgQnVja2V0KGVsZW1lbnQsIGJlZm9yZSwgYWZ0ZXIpO1xuICAgICAgICAgICAgYmVmb3JlLm5leHQgPSBidWNrZXQ7XG4gICAgICAgICAgICB0aGlzLnRoZW5sb2MgPSBiZWZvcmUubmV4dDtcbiAgICAgICAgICAgIGlmIChhZnRlcikge1xuICAgICAgICAgICAgICAgIGFmdGVyLnByZXYgPSBiZWZvcmUubmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBXb3JrTGlzdDtcbn0oKSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgV29ya0xpc3RQdHIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gV29ya0xpc3RQdHIod29ya2xpc3QsIHBvcykge1xuICAgICAgICB0aGlzLndvcmtsaXN0ID0gd29ya2xpc3Q7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgIH1cbiAgICBXb3JrTGlzdFB0ci5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIChlbGVtZW50LCBkYXRhKSB7XG4gICAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGhpbmcgPSBlbGVtZW50O1xuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgdGhpbmcgPSB7IGZ1bmM6IGVsZW1lbnQsIGRhdGE6IGRhdGEgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wb3MpIHtcbiAgICAgICAgICAgIHZhciBiZWZvcmUgPSB0aGlzLnBvcztcbiAgICAgICAgICAgIHZhciBhZnRlciA9IHRoaXMucG9zLm5leHQ7XG4gICAgICAgICAgICB2YXIgYnVja2V0ID0gbmV3IEJ1Y2tldCh0aGluZywgYmVmb3JlLCBhZnRlcik7XG4gICAgICAgICAgICBiZWZvcmUubmV4dCA9IGJ1Y2tldDtcbiAgICAgICAgICAgIHRoaXMucG9zID0gYmVmb3JlLm5leHQ7XG4gICAgICAgICAgICBpZiAoYWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICBhZnRlci5wcmV2ID0gYmVmb3JlLm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLndvcmtsaXN0Lmxlbmd0aCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy53b3JrbGlzdC5wdXNoKHRoaW5nKTtcbiAgICAgICAgICAgIHRoaXMucG9zID0gdGhpcy53b3JrbGlzdC5oZWFkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIFdvcmtMaXN0UHRyO1xufSgpKTtcbnZhciBSZXN1bHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVzdWx0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMudHlwZSA9ICdub3JtYWwnO1xuICAgICAgICB0aGlzLnRhcmdldCA9IG51bGw7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZSB8fCBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gUmVzdWx0O1xufSgpKTtcbmV4cG9ydHMuUmVzdWx0ID0gUmVzdWx0O1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVGhlIEV4ZWN1dGlvbiBDb250ZXh0XG52YXIgQ29udGV4dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb250ZXh0KHRoaXNWYWx1ZSwgdmFyaWFibGVFbnYsIGxleGljYWxFbnYpIHtcbiAgICAgICAgdGhpcy5sYWJlbHMgPSBuZXcgLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gY2xhc3NfMShvdXRlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuZXhjTGJsID0gbGFiZWxfMS5ib3Q7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXRMYmwgPSBsYWJlbF8xLmJvdDtcbiAgICAgICAgICAgICAgICB0aGlzLmxhYmVsbWFwID0ge307XG4gICAgICAgICAgICAgICAgdGhpcy5vdXRlciA9IG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsYXNzXzEucHJvdG90eXBlLCBcImV4Y1wiLCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb25pdG9yLm9wdGlvbnMuZ2V0KCdtb25pdG9yLnRhaW50TW9kZScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGFiZWxfMS5ib3Q7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhjTGJsO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAobCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV4Y0xibCA9IGw7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xhc3NfMS5wcm90b3R5cGUsIFwicmV0XCIsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vbml0b3Iub3B0aW9ucy5nZXQoJ21vbml0b3IudGFpbnRNb2RlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsYWJlbF8xLmJvdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXRMYmw7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmV0TGJsID0gbDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbGFzc18xLnByb3RvdHlwZSwgXCJwY1wiLCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb25pdG9yLm9wdGlvbnMuZ2V0KCdtb25pdG9yLnRhaW50TW9kZScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGFiZWxfMS5ib3Q7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3V0ZXIucGNTdGFjay5wZWVrKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3V0ZXIucGNTdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRlci5wY1N0YWNrLnB1c2gobCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gY2xhc3NfMTtcbiAgICAgICAgfSgpKSh0aGlzKTtcbiAgICAgICAgdGhpcy50aGlzVmFsdWUgPSB0aGlzVmFsdWU7XG4gICAgICAgIHRoaXMudmFyaWFibGVFbnYgPSB2YXJpYWJsZUVudjtcbiAgICAgICAgdGhpcy5sZXhpY2FsRW52ID0gbGV4aWNhbEVudjtcbiAgICAgICAgdGhpcy5wY1N0YWNrID0gbmV3IHN0YWNrXzEuU3RhY2soKTtcbiAgICAgICAgdGhpcy5wY1N0YWNrLnB1c2gobGFiZWxfMS5MYWJlbC5ib3QpO1xuICAgICAgICB0aGlzLndvcmtMaXN0ID0gbmV3IFdvcmtMaXN0KCk7XG4gICAgICAgIHRoaXMucmVzdWx0ID0gbmV3IFJlc3VsdCgpO1xuICAgICAgICB0aGlzLnZhbHVlU3RhY2sgPSBuZXcgc3RhY2tfMS5TdGFjaygpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29udGV4dC5wcm90b3R5cGUsIFwiZWZmZWN0aXZlUENcIiwge1xuICAgICAgICAvLyAtLS1cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobW9uaXRvci5vcHRpb25zLmdldCgnbW9uaXRvci50YWludE1vZGUnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsYWJlbF8xLmJvdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsYWJlbF8xLmx1Yih0aGlzLmxhYmVscy5wYywgdGhpcy5sYWJlbHMuZXhjLCB0aGlzLmxhYmVscy5yZXQpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvLyAtLS1cbiAgICBDb250ZXh0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICh0aGlzVmFsdWUsIHZhcmlhYmxlRW52LCBsZXhpY2FsRW52KSB7XG4gICAgICAgIHZhciB0ViA9IHRoaXNWYWx1ZSB8fCB0aGlzLnRoaXNWYWx1ZTtcbiAgICAgICAgdmFyIGxFID0gbGV4aWNhbEVudiB8fCB0aGlzLmxleGljYWxFbnY7XG4gICAgICAgIHZhciB2RSA9IHZhcmlhYmxlRW52IHx8IHRoaXMudmFyaWFibGVFbnY7XG4gICAgICAgIHZhciBuZXdDdHggPSBuZXcgQ29udGV4dCh0ViwgdkUsIGxFKTtcbiAgICAgICAgbmV3Q3R4LmxhYmVscy5wYyA9IHRoaXMuZWZmZWN0aXZlUEM7XG4gICAgICAgIG5ld0N0eC5sYWJlbHMuZXhjID0gdGhpcy5sYWJlbHMuZXhjO1xuICAgICAgICBuZXdDdHgubGFiZWxzLnJldCA9IHRoaXMubGFiZWxzLnJldDtcbiAgICAgICAgcmV0dXJuIG5ld0N0eDtcbiAgICB9O1xuICAgIC8vIC0tLVxuICAgIENvbnRleHQucHJvdG90eXBlLnB1c2hQQyA9IGZ1bmN0aW9uIChsKSB7XG4gICAgICAgIHRoaXMucGNTdGFjay5wdXNoKGxhYmVsXzEubHViKGwsIHRoaXMubGFiZWxzLnBjKSk7XG4gICAgfTtcbiAgICAvLyAtLS1cbiAgICBDb250ZXh0LnByb3RvdHlwZS5yYWlzZVBDID0gZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgdGhpcy5sYWJlbHMucGMgPSBsYWJlbF8xLmx1Yih0aGlzLmxhYmVscy5wYywgbCk7XG4gICAgfTtcbiAgICAvLyAtLS1cbiAgICBDb250ZXh0LnByb3RvdHlwZS5wb3BQQyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGNTdGFjay5wb3AoKTtcbiAgICB9O1xuICAgIHJldHVybiBDb250ZXh0O1xufSgpKTtcbmV4cG9ydHMuQ29udGV4dCA9IENvbnRleHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250ZXh0LmpzLm1hcCIsIi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uICovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBsYWJlbCA9IHJlcXVpcmUoXCIuL2xhYmVsXCIpO1xudmFyIHZhbHVlc18xID0gcmVxdWlyZShcIi4vdmFsdWVzXCIpO1xudmFyIGVjbWEgPSByZXF1aXJlKFwiLi9lY21hXCIpO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbnZhciBmdW5jdGlvbl8xID0gcmVxdWlyZShcIi4vZnVuY3Rpb25cIik7XG52YXIgSGFzSW5zdGFuY2VfMSA9IHJlcXVpcmUoXCIuL0hhc0luc3RhbmNlXCIpO1xudmFyIFRvUHJpbWl0aXZlXzEgPSByZXF1aXJlKFwiLi9Db252ZXJzaW9uL1RvUHJpbWl0aXZlXCIpO1xudmFyIFRvTnVtYmVyXzEgPSByZXF1aXJlKFwiLi9Db252ZXJzaW9uL1RvTnVtYmVyXCIpO1xudmFyIFRvU3RyaW5nXzEgPSByZXF1aXJlKFwiLi9Db252ZXJzaW9uL1RvU3RyaW5nXCIpO1xuZXhwb3J0cy5mdW5jdG9yID0gZnVuY3Rpb24gKG1vbml0b3IpIHtcbiAgICB2YXIgZXJyb3IgPSBtb25pdG9yLnJlcXVpcmUoJ2Vycm9yJyk7XG4gICAgdmFyIEVjbWEgPSBlY21hLkVjbWE7XG4gICAgdmFyIExhYmVsID0gbGFiZWwuTGFiZWw7XG4gICAgdmFyIGx1YiA9IGxhYmVsLmx1YjtcbiAgICB2YXIgbGUgPSBsYWJlbC5sZTtcbiAgICB2YXIgYm90ID0gTGFiZWwuYm90O1xuICAgIHZhciB0b3AgPSBMYWJlbC50b3A7XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gYWxsb2NhdGUoaG9zdCkge1xuICAgICAgICB2YXIgZGF0ZUNvbnN0cnVjdG9yID0gbmV3IERhdGVDb25zdHJ1Y3Rvcihob3N0LkRhdGUpO1xuICAgICAgICB2YXIgZGF0ZVByb3RvdHlwZSA9IGRhdGVDb25zdHJ1Y3Rvci5fcHJvdG87XG4gICAgICAgIHJldHVybiB7IERhdGVDb25zdHJ1Y3RvcjogZGF0ZUNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgRGF0ZVByb3RvdHlwZTogZGF0ZVByb3RvdHlwZVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBUaGUgRGF0ZSBDb25zdHJ1Y3RvciwgMTUuOS4zXG4gICAgdmFyIERhdGVDb25zdHJ1Y3RvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKERhdGVDb25zdHJ1Y3RvciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gRGF0ZUNvbnN0cnVjdG9yKGhvc3QpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy5Qcm90b3R5cGUgPSBuZXcgdmFsdWVzXzEuVmFsdWUobW9uaXRvci5pbnN0YW5jZXMuRnVuY3Rpb25Qcm90b3R5cGUsIGJvdCk7XG4gICAgICAgICAgICBfdGhpcy5DbGFzcyA9ICdGdW5jdGlvbic7XG4gICAgICAgICAgICBfdGhpcy5FeHRlbnNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIF90aGlzLl9wcm90byA9IG5ldyBEYXRlUHJvdG90eXBlKF90aGlzLCBob3N0KTtcbiAgICAgICAgICAgIF90aGlzLmhvc3QgPSBob3N0O1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVGRkYoX3RoaXMsIGNvbnN0YW50cy5sZW5ndGgsIDcpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVGRkYoX3RoaXMsIGNvbnN0YW50cy5wcm90b3R5cGUsIF90aGlzLl9wcm90byk7XG4gICAgICAgICAgICBlY21hLkRlZmluZVRGVChfdGhpcywgY29uc3RhbnRzLnBhcnNlLCBuZXcgZnVuY3Rpb25fMS5CdWlsdGluRnVuY3Rpb25PYmplY3QocGFyc2UsIDAsIERhdGUucGFyc2UpKTtcbiAgICAgICAgICAgIGVjbWEuRGVmaW5lVEZUKF90aGlzLCBjb25zdGFudHMuVVRDLCBuZXcgZnVuY3Rpb25fMS5CdWlsdGluRnVuY3Rpb25PYmplY3QoVVRDLCAwLCBEYXRlLlVUQykpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXMsIGNvbnN0YW50cy5ub3csIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdChub3csIDAsIERhdGUubm93KSk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERhdGVDb25zdHJ1Y3RvcjtcbiAgICB9KEVjbWEpKTtcbiAgICBEYXRlQ29uc3RydWN0b3IucHJvdG90eXBlLkhhc0luc3RhbmNlID0gSGFzSW5zdGFuY2VfMS5IYXNJbnN0YW5jZTtcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyAxNS45LjEuMVxuICAgIERhdGVDb25zdHJ1Y3Rvci5wcm90b3R5cGUuQ2FsbCA9IGZ1bmN0aW9uICh0aGlzQXJnLCBhcmdzKSB7XG4gICAgICAgIHZhciBzdHIgPSBtb25pdG9yLmluc3RhbmNlcy5EYXRlQ29uc3RydWN0b3IuaG9zdCgpO1xuICAgICAgICByZXR1cm4gbmV3IHZhbHVlc18xLlZhbHVlKHN0ciwgYm90KTtcbiAgICB9O1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIDE1LjkuMy4xXG4gICAgRGF0ZUNvbnN0cnVjdG9yLnByb3RvdHlwZS5Db25zdHJ1Y3QgPSBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICB2YXIgX2FyZ3MgPSBbXTtcbiAgICAgICAgdmFyIGxhYmVsID0gbmV3IExhYmVsKCk7XG4gICAgICAgIHZhciBvYmo7XG4gICAgICAgIHZhciBfRGF0ZSA9IG1vbml0b3IuaW5zdGFuY2VzLkRhdGVDb25zdHJ1Y3Rvci5ob3N0O1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgb2JqID0gbmV3IERhdGVPYmplY3QobmV3IF9EYXRlKCksIG5ldyBMYWJlbCgnRGF0ZScpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICB2YXIgdiA9IFRvUHJpbWl0aXZlXzEuVG9QcmltaXRpdmUoYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2LnZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB2ID0gVG9OdW1iZXJfMS5Ub051bWJlcih2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2JqID0gbmV3IERhdGVPYmplY3QobmV3IF9EYXRlKHYudmFsdWUpLCB2LmxhYmVsKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IFRvTnVtYmVyXzEuVG9OdW1iZXIoYXJnc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIF9hcmdzW2ldID0gdmFsLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBsYWJlbC5sdWIodmFsLmxhYmVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIF9hcmdzWzJdID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgX2FyZ3NbaV0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZGF0ZSA9IG5ldyBfRGF0ZShfYXJnc1swXSwgX2FyZ3NbMV0sIF9hcmdzWzJdLCBfYXJnc1szXSwgX2FyZ3NbNF0sIF9hcmdzWzVdLCBfYXJnc1s2XSk7XG4gICAgICAgICAgICAgICAgb2JqID0gbmV3IERhdGVPYmplY3QoZGF0ZSwgbGFiZWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUob2JqLCBib3QpO1xuICAgIH07XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gcGFyc2UsIDE1LjkuNC4yXG4gICAgZnVuY3Rpb24gcGFyc2UodGhpc0FyZywgYXJncykge1xuICAgICAgICB2YXIgc3RyaW5nID0gYXJnc1swXSB8fCBuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgICAgICBzdHJpbmcgPSBUb1N0cmluZ18xLlRvU3RyaW5nKHN0cmluZyk7XG4gICAgICAgIHZhciBudW1iZXIgPSBtb25pdG9yLmluc3RhbmNlcy5EYXRlQ29uc3RydWN0b3IuaG9zdC5wYXJzZShzdHJpbmcudmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IHZhbHVlc18xLlZhbHVlKG51bWJlciwgc3RyaW5nLmxhYmVsKTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gVVRDLCAxNS45LjQuM1xuICAgIGZ1bmN0aW9uIFVUQyh0aGlzQXJnLCBhcmdzKSB7XG4gICAgICAgIHZhciBfYXJncyA9IFtdO1xuICAgICAgICB2YXIgbGFiZWwgPSBuZXcgTGFiZWwoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSBUb051bWJlcl8xLlRvTnVtYmVyKGFyZ3NbaV0pO1xuICAgICAgICAgICAgX2FyZ3NbaV0gPSB2YWwudmFsdWU7XG4gICAgICAgICAgICBsYWJlbC5sdWIodmFsLmxhYmVsKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbnVtYmVyID0gbW9uaXRvci5pbnN0YW5jZXMuRGF0ZUNvbnN0cnVjdG9yLmhvc3QuVVRDLmFwcGx5KG51bGwsIF9hcmdzKTtcbiAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZShudW1iZXIsIGxhYmVsKTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gbm93LCAxNS45LjQuNFxuICAgIGZ1bmN0aW9uIG5vdyh0aGlzQXJnLCBhcmdzKSB7XG4gICAgICAgIHZhciBudW1iZXIgPSBtb25pdG9yLmluc3RhbmNlcy5EYXRlQ29uc3RydWN0b3IuaG9zdC5ub3coKTtcbiAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZShudW1iZXIsIGJvdCAvKnRvcCovKTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gVGhlIERhdGUgUHJvdG90eXBlLCAxNS45LjVcbiAgICB2YXIgRGF0ZVByb3RvdHlwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKERhdGVQcm90b3R5cGUsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIERhdGVQcm90b3R5cGUoY29uc3RydWN0b3IsIF9EYXRlKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMuQ2xhc3MgPSAnRGF0ZSc7XG4gICAgICAgICAgICBfdGhpcy5QcmltaXRpdmVWYWx1ZSA9IG5ldyB2YWx1ZXNfMS5WYWx1ZShOYU4sIGJvdCk7XG4gICAgICAgICAgICBfdGhpcy5Qcm90b3R5cGUgPSBuZXcgdmFsdWVzXzEuVmFsdWUobW9uaXRvci5pbnN0YW5jZXMuT2JqZWN0UHJvdG90eXBlLCBib3QpO1xuICAgICAgICAgICAgX3RoaXMuaG9zdCA9IF9EYXRlLnByb3RvdHlwZTtcbiAgICAgICAgICAgIGVjbWEuRGVmaW5lRkZGKF90aGlzLCBjb25zdGFudHMubGVuZ3RoLCAwKTtcbiAgICAgICAgICAgIGVjbWEuRGVmaW5lVEZUKF90aGlzLCBjb25zdGFudHMuY29uc3RydWN0b3IsIGNvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgIGVjbWEuRGVmaW5lVEZUKF90aGlzLCBjb25zdGFudHMudG9TdHJpbmcsIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdCh0b1N0cmluZywgMCwgX0RhdGUucHJvdG90eXBlLnRvU3RyaW5nKSk7XG4gICAgICAgICAgICBlY21hLkRlZmluZVRGVChfdGhpcywgY29uc3RhbnRzLnRvRGF0ZVN0cmluZywgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHRvRGF0ZVN0cmluZywgMCwgX0RhdGUucHJvdG90eXBlLnRvRGF0ZVN0cmluZykpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXMsIGNvbnN0YW50cy50b1RpbWVTdHJpbmcsIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdCh0b1RpbWVTdHJpbmcsIDAsIF9EYXRlLnByb3RvdHlwZS50b1RpbWVTdHJpbmcpKTtcbiAgICAgICAgICAgIGVjbWEuRGVmaW5lVEZUKF90aGlzLCBjb25zdGFudHMudG9Mb2NhbGVTdHJpbmcsIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdCh0b0xvY2FsZVN0cmluZywgMCwgX0RhdGUucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nKSk7XG4gICAgICAgICAgICBlY21hLkRlZmluZVRGVChfdGhpcywgY29uc3RhbnRzLnRvTG9jYWxlRGF0ZVN0cmluZywgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHRvTG9jYWxlRGF0ZVN0cmluZywgMCwgX0RhdGUucHJvdG90eXBlLnRvTG9jYWxlRGF0ZVN0cmluZykpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXMsIGNvbnN0YW50cy50b0xvY2FsZVRpbWVTdHJpbmcsIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdCh0b0xvY2FsZVRpbWVTdHJpbmcsIDAsIF9EYXRlLnByb3RvdHlwZS50b0xvY2FsZVRpbWVTdHJpbmcpKTtcbiAgICAgICAgICAgIGVjbWEuRGVmaW5lVEZUKF90aGlzLCBuZXcgdmFsdWVzXzEuVmFsdWUoJ3ZhbHVlT2YnLCBib3QpLCBuZXcgZnVuY3Rpb25fMS5CdWlsdGluRnVuY3Rpb25PYmplY3QodmFsdWVPZiwgMCwgX0RhdGUucHJvdG90eXBlLnZhbHVlT2YpKTtcbiAgICAgICAgICAgIGVjbWEuRGVmaW5lVEZUKF90aGlzLCBjb25zdGFudHMuZ2V0VGltZSwgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KGdldFRpbWUsIDAsIF9EYXRlLnByb3RvdHlwZS5nZXRUaW1lKSk7XG4gICAgICAgICAgICBlY21hLkRlZmluZVRGVChfdGhpcywgY29uc3RhbnRzLmdldEZ1bGxZZWFyLCBuZXcgZnVuY3Rpb25fMS5CdWlsdGluRnVuY3Rpb25PYmplY3QoZ2V0RnVsbFllYXIsIDAsIF9EYXRlLnByb3RvdHlwZS5nZXRGdWxsWWVhcikpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXMsIGNvbnN0YW50cy5nZXRVVENGdWxsWWVhciwgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KGdldFVUQ0Z1bGxZZWFyLCAwLCBfRGF0ZS5wcm90b3R5cGUuZ2V0VVRDRnVsbFllYXIpKTtcbiAgICAgICAgICAgIGVjbWEuRGVmaW5lVEZUKF90aGlzLCBjb25zdGFudHMuZ2V0TW9udGgsIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdChnZXRNb250aCwgMCwgX0RhdGUucHJvdG90eXBlLmdldE1vbnRoKSk7XG4gICAgICAgICAgICBlY21hLkRlZmluZVRGVChfdGhpcywgY29uc3RhbnRzLmdldFVUQ01vbnRoLCBuZXcgZnVuY3Rpb25fMS5CdWlsdGluRnVuY3Rpb25PYmplY3QoZ2V0VVRDTW9udGgsIDAsIF9EYXRlLnByb3RvdHlwZS5nZXRVVENNb250aCkpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXMsIGNvbnN0YW50cy5nZXREYXRlLCBuZXcgZnVuY3Rpb25fMS5CdWlsdGluRnVuY3Rpb25PYmplY3QoZ2V0RGF0ZSwgMCwgX0RhdGUucHJvdG90eXBlLmdldERhdGUpKTtcbiAgICAgICAgICAgIGVjbWEuRGVmaW5lVEZUKF90aGlzLCBjb25zdGFudHMuZ2V0VVRDRGF0ZSwgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KGdldFVUQ0RhdGUsIDAsIF9EYXRlLnByb3RvdHlwZS5nZXRVVENEYXRlKSk7XG4gICAgICAgICAgICBlY21hLkRlZmluZVRGVChfdGhpcywgY29uc3RhbnRzLmdldERheSwgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KGdldERheSwgMCwgX0RhdGUucHJvdG90eXBlLmdldERheSkpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXMsIGNvbnN0YW50cy5nZXRVVENEYXksIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdChnZXRVVENEYXksIDAsIF9EYXRlLnByb3RvdHlwZS5nZXRVVENEYXkpKTtcbiAgICAgICAgICAgIGVjbWEuRGVmaW5lVEZUKF90aGlzLCBjb25zdGFudHMuZ2V0SG91cnMsIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdChnZXRIb3VycywgMCwgX0RhdGUucHJvdG90eXBlLmdldEhvdXJzKSk7XG4gICAgICAgICAgICBlY21hLkRlZmluZVRGVChfdGhpcywgY29uc3RhbnRzLmdldFVUQ0hvdXJzLCBuZXcgZnVuY3Rpb25fMS5CdWlsdGluRnVuY3Rpb25PYmplY3QoZ2V0VVRDSG91cnMsIDAsIF9EYXRlLnByb3RvdHlwZS5nZXRVVENIb3VycykpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXMsIGNvbnN0YW50cy5nZXRNaW51dGVzLCBuZXcgZnVuY3Rpb25fMS5CdWlsdGluRnVuY3Rpb25PYmplY3QoZ2V0TWludXRlcywgMCwgX0RhdGUucHJvdG90eXBlLmdldE1pbnV0ZXMpKTtcbiAgICAgICAgICAgIGVjbWEuRGVmaW5lVEZUKF90aGlzLCBjb25zdGFudHMuZ2V0VVRDTWludXRlcywgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KGdldFVUQ01pbnV0ZXMsIDAsIF9EYXRlLnByb3RvdHlwZS5nZXRVVENNaW51dGVzKSk7XG4gICAgICAgICAgICBlY21hLkRlZmluZVRGVChfdGhpcywgY29uc3RhbnRzLmdldFNlY29uZHMsIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdChnZXRTZWNvbmRzLCAwLCBfRGF0ZS5wcm90b3R5cGUuZ2V0U2Vjb25kcykpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXMsIGNvbnN0YW50cy5nZXRVVENTZWNvbmRzLCBuZXcgZnVuY3Rpb25fMS5CdWlsdGluRnVuY3Rpb25PYmplY3QoZ2V0VVRDU2Vjb25kcywgMCwgX0RhdGUucHJvdG90eXBlLmdldFVUQ1NlY29uZHMpKTtcbiAgICAgICAgICAgIGVjbWEuRGVmaW5lVEZUKF90aGlzLCBjb25zdGFudHMuZ2V0TWlsbGlzZWNvbmRzLCBuZXcgZnVuY3Rpb25fMS5CdWlsdGluRnVuY3Rpb25PYmplY3QoZ2V0TWlsbGlzZWNvbmRzLCAwLCBfRGF0ZS5wcm90b3R5cGUuZ2V0TWlsbGlzZWNvbmRzKSk7XG4gICAgICAgICAgICBlY21hLkRlZmluZVRGVChfdGhpcywgY29uc3RhbnRzLmdldFVUQ01pbGxpc2Vjb25kcywgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KGdldFVUQ01pbGxpc2Vjb25kcywgMCwgX0RhdGUucHJvdG90eXBlLmdldFVUQ01pbGxpc2Vjb25kcykpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXMsIGNvbnN0YW50cy5nZXRUaW1lem9uZU9mZnNldCwgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KGdldFRpbWV6b25lT2Zmc2V0LCAwLCBfRGF0ZS5wcm90b3R5cGUuZ2V0VGltZXpvbmVPZmZzZXQpKTtcbiAgICAgICAgICAgIGVjbWEuRGVmaW5lVEZUKF90aGlzLCBjb25zdGFudHMuc2V0VGltZSwgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHNldFRpbWUsIDEsIF9EYXRlLnByb3RvdHlwZS5zZXRUaW1lKSk7XG4gICAgICAgICAgICBlY21hLkRlZmluZVRGVChfdGhpcywgY29uc3RhbnRzLnNldE1pbGxpc2Vjb25kcywgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHNldE1pbGxpc2Vjb25kcywgMCwgX0RhdGUucHJvdG90eXBlLnNldE1pbGxpc2Vjb25kcykpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXMsIGNvbnN0YW50cy5zZXRVVENNaWxsaXNlY29uZHMsIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdChzZXRVVENNaWxsaXNlY29uZHMsIDAsIF9EYXRlLnByb3RvdHlwZS5zZXRVVENNaWxsaXNlY29uZHMpKTtcbiAgICAgICAgICAgIGVjbWEuRGVmaW5lVEZUKF90aGlzLCBjb25zdGFudHMuc2V0U2Vjb25kcywgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHNldFNlY29uZHMsIDAsIF9EYXRlLnByb3RvdHlwZS5zZXRTZWNvbmRzKSk7XG4gICAgICAgICAgICBlY21hLkRlZmluZVRGVChfdGhpcywgY29uc3RhbnRzLnNldFVUQ1NlY29uZHMsIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdChzZXRVVENTZWNvbmRzLCAwLCBfRGF0ZS5wcm90b3R5cGUuc2V0VVRDU2Vjb25kcykpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXMsIGNvbnN0YW50cy5zZXRNaW51dGVzLCBuZXcgZnVuY3Rpb25fMS5CdWlsdGluRnVuY3Rpb25PYmplY3Qoc2V0TWludXRlcywgMCwgX0RhdGUucHJvdG90eXBlLnNldE1pbnV0ZXMpKTtcbiAgICAgICAgICAgIGVjbWEuRGVmaW5lVEZUKF90aGlzLCBjb25zdGFudHMuc2V0VVRDTWludXRlcywgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHNldFVUQ01pbnV0ZXMsIDAsIF9EYXRlLnByb3RvdHlwZS5zZXRVVENNaW51dGVzKSk7XG4gICAgICAgICAgICBlY21hLkRlZmluZVRGVChfdGhpcywgY29uc3RhbnRzLnNldEhvdXJzLCBuZXcgZnVuY3Rpb25fMS5CdWlsdGluRnVuY3Rpb25PYmplY3Qoc2V0SG91cnMsIDAsIF9EYXRlLnByb3RvdHlwZS5zZXRIb3VycykpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXMsIGNvbnN0YW50cy5zZXRVVENIb3VycywgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHNldFVUQ0hvdXJzLCAwLCBfRGF0ZS5wcm90b3R5cGUuc2V0VVRDSG91cnMpKTtcbiAgICAgICAgICAgIGVjbWEuRGVmaW5lVEZUKF90aGlzLCBjb25zdGFudHMuc2V0RGF0ZSwgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHNldERhdGUsIDAsIF9EYXRlLnByb3RvdHlwZS5zZXREYXRlKSk7XG4gICAgICAgICAgICBlY21hLkRlZmluZVRGVChfdGhpcywgY29uc3RhbnRzLnNldFVUQ0RhdGUsIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdChzZXRVVENEYXRlLCAwLCBfRGF0ZS5wcm90b3R5cGUuc2V0VVRDRGF0ZSkpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXMsIGNvbnN0YW50cy5zZXRNb250aCwgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHNldE1vbnRoLCAyLCBfRGF0ZS5wcm90b3R5cGUuc2V0TW9udGgpKTtcbiAgICAgICAgICAgIGVjbWEuRGVmaW5lVEZUKF90aGlzLCBjb25zdGFudHMuc2V0VVRDTW9udGgsIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdChzZXRVVENNb250aCwgMCwgX0RhdGUucHJvdG90eXBlLnNldFVUQ01vbnRoKSk7XG4gICAgICAgICAgICBlY21hLkRlZmluZVRGVChfdGhpcywgY29uc3RhbnRzLnNldEZ1bGxZZWFyLCBuZXcgZnVuY3Rpb25fMS5CdWlsdGluRnVuY3Rpb25PYmplY3Qoc2V0RnVsbFllYXIsIDAsIF9EYXRlLnByb3RvdHlwZS5zZXRGdWxsWWVhcikpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXMsIGNvbnN0YW50cy5zZXRVVENGdWxsWWVhciwgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHNldFVUQ0Z1bGxZZWFyLCAwLCBfRGF0ZS5wcm90b3R5cGUuc2V0VVRDRnVsbFllYXIpKTtcbiAgICAgICAgICAgIGVjbWEuRGVmaW5lVEZUKF90aGlzLCBjb25zdGFudHMudG9VVENTdHJpbmcsIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdCh0b1VUQ1N0cmluZywgMCwgX0RhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nKSk7XG4gICAgICAgICAgICBlY21hLkRlZmluZVRGVChfdGhpcywgY29uc3RhbnRzLnRvSVNPU3RyaW5nLCBuZXcgZnVuY3Rpb25fMS5CdWlsdGluRnVuY3Rpb25PYmplY3QodG9JU09TdHJpbmcsIDAsIF9EYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZykpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXMsIGNvbnN0YW50cy50b0pTT04sIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdCh0b0pTT04sIDAsIF9EYXRlLnByb3RvdHlwZS50b0pTT04pKTtcbiAgICAgICAgICAgIC8vIEIuMi42IC0gdXNlZCBieSBnb29nbGUgYW5hbHl0aWNzXG4gICAgICAgICAgICBlY21hLkRlZmluZVRGVChfdGhpcywgbmV3IHZhbHVlc18xLlZhbHVlKCd0b0dNVFN0cmluZycsIGJvdCksIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdCh0b1VUQ1N0cmluZywgMCwgX0RhdGUucHJvdG90eXBlLnRvR1RNU3RyaW5nKSk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERhdGVQcm90b3R5cGU7XG4gICAgfShFY21hKSk7XG4gICAgZnVuY3Rpb24gYXNzZXJ0RGF0ZSh2LCBjYWxsZXIpIHtcbiAgICAgICAgaWYgKHYudmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHYudmFsdWUgIT09ICdvYmplY3QnIHx8IHYudmFsdWUuQ2xhc3MgIT09ICdEYXRlJykge1xuICAgICAgICAgICAgbW9uaXRvci5jb250ZXh0LnB1c2hQQyh2LmxhYmVsKTtcbiAgICAgICAgICAgIG1vbml0b3IuVGhyb3cobW9uaXRvci5tb2R1bGVzLmVycm9yLlR5cGVFcnJvck9iamVjdCwgY2FsbGVyICsgJyBpcyBub3QgZ2VuZXJpYycsIGJvdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gbWtHZW5lcmljR2V0KGZuYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodGhpc0FyZywgYXJncykge1xuICAgICAgICAgICAgYXNzZXJ0RGF0ZSh0aGlzQXJnLCBmbmFtZSk7XG4gICAgICAgICAgICB2YXIgbGFiZWwgPSBsdWIodGhpc0FyZy5sYWJlbCwgdGhpc0FyZy52YWx1ZS5QcmltaXRpdmVMYWJlbCk7XG4gICAgICAgICAgICB2YXIgZGF0ZSA9IHRoaXNBcmcudmFsdWUuUHJpbWl0aXZlVmFsdWU7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBkYXRlW2ZuYW1lXS5jYWxsKGRhdGUpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZSh2YWx1ZSwgbGFiZWwpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBta0dlbmVyaWNTZXQoZm5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0aGlzQXJnLCBhcmdzKSB7XG4gICAgICAgICAgICBhc3NlcnREYXRlKHRoaXNBcmcsIGZuYW1lKTtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gbHViKHRoaXNBcmcubGFiZWwsIG1vbml0b3IuY29udGV4dC5lZmZlY3RpdmVQQyk7XG4gICAgICAgICAgICBtb25pdG9yLmFzc2VydChsZShjb250ZXh0LCB0aGlzQXJnLnZhbHVlLlByaW1pdGl2ZUxhYmVsKSwgZm5hbWUgKyAnOiBjb250ZXh0ICcgKyBjb250ZXh0ICsgJyBub3QgYmVsb3cgc3RhdGUgbGFiZWwgb2YgRGF0ZSBvYmplY3QgJyArIHRoaXNBcmcudmFsdWUuUHJpbWl0aXZlTGFiZWwpO1xuICAgICAgICAgICAgdmFyIF9hcmdzID0gW107XG4gICAgICAgICAgICB2YXIgbGFiZWwgPSBuZXcgTGFiZWwoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHggPSBUb051bWJlcl8xLlRvTnVtYmVyKGFyZ3NbaV0pO1xuICAgICAgICAgICAgICAgIGxhYmVsLmx1Yih4LmxhYmVsKTtcbiAgICAgICAgICAgICAgICBfYXJnc1tpXSA9IHgudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzQXJnLnZhbHVlLlByaW1pdGl2ZUxhYmVsID0gbHViKHRoaXNBcmcudmFsdWUuUHJpbWl0aXZlTGFiZWwsIGxhYmVsKTtcbiAgICAgICAgICAgIGxhYmVsID0gbHViKHRoaXNBcmcubGFiZWwsIHRoaXNBcmcudmFsdWUuUHJpbWl0aXZlTGFiZWwpO1xuICAgICAgICAgICAgdmFyIGRhdGUgPSB0aGlzQXJnLnZhbHVlLlByaW1pdGl2ZVZhbHVlO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gZGF0ZVtmbmFtZV0uYXBwbHkoZGF0ZSwgX2FyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZSh2YWx1ZSwgbGFiZWwpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyB0b0lTT1N0cmluZywgMTUuOS41LjQzXG4gICAgdmFyIHRvSVNPU3RyaW5nID0gbWtHZW5lcmljR2V0KCd0b0lTT1N0cmluZycpO1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIHRvU3RyaW5nLCAxNS45LjUuMlxuICAgIHZhciB0b1N0cmluZyA9IG1rR2VuZXJpY0dldCgndG9TdHJpbmcnKTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyB0b0RhdGVTdHJpbmcsIDE1LjkuNS4/XG4gICAgdmFyIHRvRGF0ZVN0cmluZyA9IG1rR2VuZXJpY0dldCgndG9EYXRlU3RyaW5nJyk7XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gdG9UaW1lU3RyaW5nLCAxNS45LjUuP1xuICAgIHZhciB0b1RpbWVTdHJpbmcgPSBta0dlbmVyaWNHZXQoJ3RvVGltZVN0cmluZycpO1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIHRvTG9jYWxlU3RyaW5nLCAxNS45LjUuP1xuICAgIHZhciB0b0xvY2FsZVN0cmluZyA9IG1rR2VuZXJpY0dldCgndG9Mb2NhbGVTdHJpbmcnKTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyB0b0xvY2FsZURhdGVTdHJpbmcsIDE1LjkuNS4/XG4gICAgdmFyIHRvTG9jYWxlRGF0ZVN0cmluZyA9IG1rR2VuZXJpY0dldCgndG9Mb2NhbGVEYXRlU3RyaW5nJyk7XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gdG9Mb2NhbGVUaW1lU3RyaW5nLCAxNS45LjUuP1xuICAgIHZhciB0b0xvY2FsZVRpbWVTdHJpbmcgPSBta0dlbmVyaWNHZXQoJ3RvTG9jYWxlVGltZVN0cmluZycpO1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIHZhbHVlT2YsIDE1LjkuNS4/XG4gICAgZnVuY3Rpb24gdmFsdWVPZih0aGlzQXJnLCBhcmdzKSB7XG4gICAgICAgIGFzc2VydERhdGUodGhpc0FyZywgJ3ZhbHVlT2YnKTtcbiAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZSh0aGlzQXJnLnZhbHVlLlByaW1pdGl2ZVZhbHVlLnZhbHVlT2YoKSwgdGhpc0FyZy5sYWJlbCk7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIGdldFRpbWUsIDE1LjkuNS45XG4gICAgdmFyIGdldFRpbWUgPSBta0dlbmVyaWNHZXQoJ2dldFRpbWUnKTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBnZXRGdWxsWWVhciwgMTUuOS41Lj9cbiAgICB2YXIgZ2V0RnVsbFllYXIgPSBta0dlbmVyaWNHZXQoJ2dldEZ1bGxZZWFyJyk7XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gZ2V0VVRDRnVsbFllYXIsIDE1LjkuNS4/XG4gICAgdmFyIGdldFVUQ0Z1bGxZZWFyID0gbWtHZW5lcmljR2V0KCdnZXRVVENGdWxsWWVhcicpO1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIGdldE1vbnRoLCAxNS45LjUuP1xuICAgIHZhciBnZXRNb250aCA9IG1rR2VuZXJpY0dldCgnZ2V0TW9udGgnKTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBnZXRVVENNb250aCwgMTUuOS41Lj9cbiAgICB2YXIgZ2V0VVRDTW9udGggPSBta0dlbmVyaWNHZXQoJ2dldFVUQ01vbnRoJyk7XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gZ2V0RGF0ZSwgMTUuOS41Lj9cbiAgICB2YXIgZ2V0RGF0ZSA9IG1rR2VuZXJpY0dldCgnZ2V0RGF0ZScpO1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIGdldFVUQ0RhdGUsIDE1LjkuNS4/XG4gICAgdmFyIGdldFVUQ0RhdGUgPSBta0dlbmVyaWNHZXQoJ2dldFVUQ0RhdGUnKTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBnZXREYXksIDE1LjkuNS4/XG4gICAgdmFyIGdldERheSA9IG1rR2VuZXJpY0dldCgnZ2V0RGF5Jyk7XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gZ2V0VVRDRGF5LCAxNS45LjUuP1xuICAgIHZhciBnZXRVVENEYXkgPSBta0dlbmVyaWNHZXQoJ2dldFVUQ0RheScpO1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIGdldEhvdXJzLCAxNS45LjUuP1xuICAgIHZhciBnZXRIb3VycyA9IG1rR2VuZXJpY0dldCgnZ2V0SG91cnMnKTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBnZXRVVENIb3VycywgMTUuOS41Lj9cbiAgICB2YXIgZ2V0VVRDSG91cnMgPSBta0dlbmVyaWNHZXQoJ2dldFVUQ0hvdXJzJyk7XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gZ2V0TWludXRlcywgMTUuOS41Lj9cbiAgICB2YXIgZ2V0TWludXRlcyA9IG1rR2VuZXJpY0dldCgnZ2V0TWludXRlcycpO1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIGdldFVUQ01pbnV0ZXMsIDE1LjkuNS4/XG4gICAgdmFyIGdldFVUQ01pbnV0ZXMgPSBta0dlbmVyaWNHZXQoJ2dldFVUQ01pbnV0ZXMnKTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBnZXRTZWNvbmRzLCAxNS45LjUuP1xuICAgIHZhciBnZXRTZWNvbmRzID0gbWtHZW5lcmljR2V0KCdnZXRTZWNvbmRzJyk7XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gZ2V0VVRDU2Vjb25kcywgMTUuOS41Lj9cbiAgICB2YXIgZ2V0VVRDU2Vjb25kcyA9IG1rR2VuZXJpY0dldCgnZ2V0VVRDU2Vjb25kcycpO1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIGdldE1pbGxpc2Vjb25kcywgMTUuOS41Lj9cbiAgICB2YXIgZ2V0TWlsbGlzZWNvbmRzID0gbWtHZW5lcmljR2V0KCdnZXRNaWxsaXNlY29uZHMnKTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBnZXRVVENNaWxsaXNlY29uZHMsIDE1LjkuNS4/XG4gICAgdmFyIGdldFVUQ01pbGxpc2Vjb25kcyA9IG1rR2VuZXJpY0dldCgnZ2V0VVRDTWlsbGlzZWNvbmRzJyk7XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gZ2V0VGltZXpvbmVPZmZzZXQsIDE1LjkuNS4/XG4gICAgdmFyIGdldFRpbWV6b25lT2Zmc2V0ID0gbWtHZW5lcmljR2V0KCdnZXRUaW1lem9uZU9mZnNldCcpO1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIHNldFRpbWUsIDE1LjkuNS4/XG4gICAgdmFyIHNldFRpbWUgPSBta0dlbmVyaWNTZXQoJ3NldFRpbWUnKTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBzZXRNaWxsaXNlY29uZHMsIDE1LjkuNS4/XG4gICAgdmFyIHNldE1pbGxpc2Vjb25kcyA9IG1rR2VuZXJpY1NldCgnc2V0TWlsbGlzZWNvbmRzJyk7XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gc2V0VVRDTWlsbGlzZWNvbmRzLCAxNS45LjUuP1xuICAgIHZhciBzZXRVVENNaWxsaXNlY29uZHMgPSBta0dlbmVyaWNTZXQoJ3NldFVUQ01pbGxpc2Vjb25kcycpO1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIHNldFNlY29uZHMsIDE1LjkuNS4/XG4gICAgdmFyIHNldFNlY29uZHMgPSBta0dlbmVyaWNTZXQoJ3NldFNlY29uZHMnKTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBzZXRVVENTZWNvbmRzLCAxNS45LjUuP1xuICAgIHZhciBzZXRVVENTZWNvbmRzID0gbWtHZW5lcmljU2V0KCdzZXRVVENTZWNvbmRzJyk7XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gc2V0TWludXRlcywgMTUuOS41Lj9cbiAgICB2YXIgc2V0TWludXRlcyA9IG1rR2VuZXJpY1NldCgnc2V0TWludXRlcycpO1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIHNldFVUQ01pbnV0ZXMsIDE1LjkuNS4/XG4gICAgdmFyIHNldFVUQ01pbnV0ZXMgPSBta0dlbmVyaWNTZXQoJ3NldFVUQ01pbnV0ZXMnKTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBzZXRIb3VycywgMTUuOS41Lj9cbiAgICB2YXIgc2V0SG91cnMgPSBta0dlbmVyaWNTZXQoJ3NldEhvdXJzJyk7XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gc2V0VVRDSG91cnMsIDE1LjkuNS4/XG4gICAgdmFyIHNldFVUQ0hvdXJzID0gbWtHZW5lcmljU2V0KCdzZXRVVENIb3VycycpO1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIHNldERhdGUsIDE1LjkuNS4/XG4gICAgdmFyIHNldERhdGUgPSBta0dlbmVyaWNTZXQoJ3NldERhdGUnKTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBzZXRVVENEYXRlLCAxNS45LjUuP1xuICAgIHZhciBzZXRVVENEYXRlID0gbWtHZW5lcmljU2V0KCdzZXRVVENEYXRlJyk7XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gc2V0TW9udGgsIDE1LjkuNS4/XG4gICAgdmFyIHNldE1vbnRoID0gbWtHZW5lcmljU2V0KCdzZXRNb250aCcpO1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIHNldFVUQ01vbnRoLCAxNS45LjUuP1xuICAgIHZhciBzZXRVVENNb250aCA9IG1rR2VuZXJpY1NldCgnc2V0VVRDTW9udGgnKTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBzZXRGdWxsWWVhciwgMTUuOS41Lj9cbiAgICB2YXIgc2V0RnVsbFllYXIgPSBta0dlbmVyaWNTZXQoJ3NldEZ1bGxZZWFyJyk7XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gc2V0VVRDRnVsbFllYXIsIDE1LjkuNS4/XG4gICAgdmFyIHNldFVUQ0Z1bGxZZWFyID0gbWtHZW5lcmljU2V0KCdzZXRVVENGdWxsWWVhcicpO1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIHRvVVRDU3RyaW5nLCAxNS45LjUuP1xuICAgIHZhciB0b1VUQ1N0cmluZyA9IG1rR2VuZXJpY0dldCgndG9VVENTdHJpbmcnKTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyB0b0pTT04sIDE1LjkuNS4/XG4gICAgdmFyIHRvSlNPTiA9IG1rR2VuZXJpY0dldCgndG9KU09OJyk7XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gRGF0ZSBPYmplY3QsIDE1LjkuNVxuICAgIHZhciBEYXRlT2JqZWN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoRGF0ZU9iamVjdCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gRGF0ZU9iamVjdChkYXRlLCBsYWJlbCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLkNsYXNzID0gJ0RhdGUnO1xuICAgICAgICAgICAgX3RoaXMuUHJpbWl0aXZlVmFsdWUgPSBkYXRlO1xuICAgICAgICAgICAgX3RoaXMuUHJpbWl0aXZlTGFiZWwgPSBsYWJlbDtcbiAgICAgICAgICAgIF90aGlzLkV4dGVuc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgX3RoaXMuUHJvdG90eXBlID0gbmV3IHZhbHVlc18xLlZhbHVlKG1vbml0b3IuaW5zdGFuY2VzLkRhdGVQcm90b3R5cGUsIGJvdCk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERhdGVPYmplY3Q7XG4gICAgfShFY21hKSk7XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgdmFyIG1vZHVsZSA9IHt9O1xuICAgIG1vZHVsZS5EYXRlT2JqZWN0ID0gRGF0ZU9iamVjdDtcbiAgICBtb2R1bGUuYWxsb2NhdGUgPSBhbGxvY2F0ZTtcbiAgICByZXR1cm4gbW9kdWxlO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGUuanMubWFwIiwiLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBsYWJlbF8xID0gcmVxdWlyZShcIi4vbGFiZWxcIik7XG52YXIgdmFsdWVzXzEgPSByZXF1aXJlKFwiLi92YWx1ZXNcIik7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xudmFyIF8gPSByZXF1aXJlKFwidW5kZXJzY29yZVwiKTtcbnZhciBJc0NhbGxhYmxlXzEgPSByZXF1aXJlKFwiLi9VdGlsaXR5L0lzQ2FsbGFibGVcIik7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFByb3BlcnR5IGRlc2NyaXB0b3JzLCA4LjEwXG5mdW5jdGlvbiBJc0FjY2Vzc29yRGVzY3JpcHRvcihwZCkge1xuICAgIGlmIChwZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAoJ2dldCcgaW4gcGQgfHwgJ3B1dCcgaW4gcGQpO1xuICAgIH1cbn1cbmV4cG9ydHMuSXNBY2Nlc3NvckRlc2NyaXB0b3IgPSBJc0FjY2Vzc29yRGVzY3JpcHRvcjtcbmZ1bmN0aW9uIElzRGF0YURlc2NyaXB0b3IocGQpIHtcbiAgICBpZiAocGQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gKCd2YWx1ZScgaW4gcGQgfHwgJ3dyaXRhYmxlJyBpbiBwZCk7XG4gICAgfVxufVxuZXhwb3J0cy5Jc0RhdGFEZXNjcmlwdG9yID0gSXNEYXRhRGVzY3JpcHRvcjtcbnZhciBFY21hID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVjbWEoa2xhc3MpIHtcbiAgICAgICAgdGhpcy5Qcm90b3R5cGUgPSBuZXcgdmFsdWVzXzEuVmFsdWUobnVsbCwgbGFiZWxfMS5ib3QpO1xuICAgICAgICB0aGlzLkV4dGVuc2libGUgPSB0cnVlO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgdGhpcy5sYWJlbHMgPSB7fTtcbiAgICAgICAgdGhpcy5DbGFzcyA9IGtsYXNzO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgdGhpcy5sYWJlbHMgPSB7fTtcbiAgICAgICAgdGhpcy5zdHJ1Y3QgPSBtb25pdG9yLmNvbnRleHQuZWZmZWN0aXZlUEM7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbWFwJywge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTb21ldGhpbmcgdG91Y2hlZCBFY21hLm1hcCcpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gLS0tXG4gICAgRWNtYS5wcm90b3R5cGUuZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIChsYWJlbCkge1xuICAgICAgICB2YXIgbmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzLnByb3BlcnRpZXMpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBuYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgICAgICAgIHJlc3VsdFtpXSA9IG5ldyB2YWx1ZXNfMS5WYWx1ZShuYW1lLCBsYWJlbF8xLmx1YihsYWJlbCwgdGhpcy5sYWJlbHNbbmFtZV0uZXhpc3RlbmNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8vIC0tLVxuICAgIEVjbWEucHJvdG90eXBlLmdldE93bkVudW1lcmFibGVQcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gKGxhYmVsKSB7XG4gICAgICAgIHZhciBuYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMucHJvcGVydGllcyk7XG4gICAgICAgIHZhciBlbnVtZXJhYmxlID0gW107XG4gICAgICAgIHZhciBqID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IG5hbWVzW2ldO1xuICAgICAgICAgICAgLy8gZnJvbSBnZXRPd25Qcm9wZXJ0eU5hbWVzOyBndWFyYW50ZWVkIHRvIGJlIGZvdW5kXG4gICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGhpcy5wcm9wZXJ0aWVzLCBuYW1lKTtcbiAgICAgICAgICAgIGlmIChkZXNjLmVudW1lcmFibGUpIHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlW2orK10gPSBuZXcgdmFsdWVzXzEuVmFsdWUobmFtZSwgbGFiZWxfMS5sdWIobGFiZWwsIHRoaXMubGFiZWxzW25hbWVdLmV4aXN0ZW5jZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnVtZXJhYmxlO1xuICAgIH07XG4gICAgLy8gLS0tXG4gICAgRWNtYS5wcm90b3R5cGUuZ2V0RW51bWVyYWJsZVByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiAoaW5pdGlhbExhYmVsKSB7XG4gICAgICAgIHZhciBkZWZpbmVkID0ge307XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdmFyIGogPSAwO1xuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXM7XG4gICAgICAgIHZhciBsYmwgPSBpbml0aWFsTGFiZWwgfHwgbGFiZWxfMS5ib3Q7XG4gICAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgICAgICB2YXIgZW51bWVyYWJsZSA9IGN1cnJlbnQuZ2V0T3duRW51bWVyYWJsZVByb3BlcnR5TmFtZXMobGJsKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlbnVtZXJhYmxlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBlbnVtZXJhYmxlW2ldO1xuICAgICAgICAgICAgICAgIGlmICghZGVmaW5lZC5oYXNPd25Qcm9wZXJ0eShuYW1lLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBkZWZpbmVkW25hbWUudmFsdWVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2orK10gPSBuYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuZXh0ID0gY3VycmVudC5Qcm90b3R5cGU7XG4gICAgICAgICAgICBjdXJyZW50ID0gbmV4dC52YWx1ZTtcbiAgICAgICAgICAgIGxibCA9IGxhYmVsXzEubHViKGxibCwgbmV4dC5sYWJlbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8vIEdldE93blByb3BlcnR5LCA4LjEyLjEgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBFY21hLnByb3RvdHlwZS5HZXRPd25Qcm9wZXJ0eSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHZhciBwcm9wTmFtZSA9IHMudmFsdWU7XG4gICAgICAgIHZhciBwcm9wTmFtZUxhYmVsID0gcy5sYWJlbDtcbiAgICAgICAgdmFyIGpzZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGhpcy5wcm9wZXJ0aWVzLCBwcm9wTmFtZSk7XG4gICAgICAgIGlmIChqc2Rlc2MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIGxhYmVsXzEubHViKHRoaXMuc3RydWN0LCBwcm9wTmFtZUxhYmVsKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb3BMYWJlbCA9IHRoaXMubGFiZWxzW3Byb3BOYW1lXTtcbiAgICAgICAgLy8gVE9ETzogYWRkIHByb3BlciBjbG9uaW5nP1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGpzZGVzYy5sYWJlbCA9IHByb3BMYWJlbC52YWx1ZTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyB2YWx1ZXNfMS5WYWx1ZShqc2Rlc2MsIGxhYmVsXzEubHViKHByb3BOYW1lTGFiZWwsIHByb3BMYWJlbC5leGlzdGVuY2UpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8vIEdldFByb3BlcnR5LCA4LjEyLjIgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBFY21hLnByb3RvdHlwZS5HZXRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHZhciBwcm9wID0gdGhpcy5HZXRPd25Qcm9wZXJ0eShzKTtcbiAgICAgICAgaWYgKHByb3AudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb3A7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb3RvID0gdGhpcy5Qcm90b3R5cGU7XG4gICAgICAgIHZhciBsYmwgPSBsYWJlbF8xLmx1Yihwcm9wLmxhYmVsLCBwcm90by5sYWJlbCk7XG4gICAgICAgIGlmIChwcm90by52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIGxibCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gREVCVUc6IHJlbW92ZVxuICAgICAgICBpZiAocHJvdG8udmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbW9uaXRvci5mYXRhbCgnRUNNQSBPYmplY3Qgd2l0aCB1bmRlZmluZWQgUHJvdG90eXBlJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcyA9IHByb3RvLkdldFByb3BlcnR5KHMpO1xuICAgICAgICByZXMubGFiZWwgPSBsYmwubHViKHJlcy5sYWJlbCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICAvLyBHZXQsIDguMTIuMyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgRWNtYS5wcm90b3R5cGUuR2V0ID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgdmFyIGxhYmVsZWREZXNjID0gdGhpcy5HZXRQcm9wZXJ0eShzKTtcbiAgICAgICAgLy8gVE9ETzogaXMgdGhpcyByZWFsbHkgY29ycmVjdD9cbiAgICAgICAgaWYgKGxhYmVsZWREZXNjLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBsYWJlbGVkRGVzYztcbiAgICAgICAgfVxuICAgICAgICB2YXIgdjtcbiAgICAgICAgdmFyIGRlc2MgPSBsYWJlbGVkRGVzYy52YWx1ZTtcbiAgICAgICAgbW9uaXRvci5jb250ZXh0LnB1c2hQQyhsYWJlbGVkRGVzYy5sYWJlbCk7XG4gICAgICAgIGlmICgndmFsdWUnIGluIGRlc2MpIHtcbiAgICAgICAgICAgIHYgPSBuZXcgdmFsdWVzXzEuVmFsdWUoZGVzYy52YWx1ZSwgZGVzYy5sYWJlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgICAgIHYgPSBkZXNjLmdldC5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdiA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIGxhYmVsZWREZXNjLmxhYmVsKTtcbiAgICAgICAgfVxuICAgICAgICBtb25pdG9yLmNvbnRleHQucG9wUEMoKTtcbiAgICAgICAgdi5yYWlzZShsYWJlbGVkRGVzYy5sYWJlbCk7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH07XG4gICAgLy8gQ2FuUHV0LCA4LjEyLjQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIEVjbWEucHJvdG90eXBlLkNhblB1dCA9IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciBsYWJlbGVkRGVzYyA9IHRoaXMuR2V0T3duUHJvcGVydHkocCk7XG4gICAgICAgIHZhciBsYWJlbCA9IGxhYmVsZWREZXNjLmxhYmVsO1xuICAgICAgICBpZiAobGFiZWxlZERlc2MudmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBkZXNjID0gbGFiZWxlZERlc2MudmFsdWU7XG4gICAgICAgICAgICBsYWJlbCA9IGxhYmVsXzEubHViKGxhYmVsLCBkZXNjLmxhYmVsKTtcbiAgICAgICAgICAgIGlmIChJc0FjY2Vzc29yRGVzY3JpcHRvcihkZXNjKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUoZGVzYy5zZXQgIT09IHVuZGVmaW5lZCwgbGFiZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZSghIWRlc2Mud3JpdGFibGUsIGxhYmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvdG8gPSB0aGlzLlByb3RvdHlwZTtcbiAgICAgICAgaWYgKHByb3RvLnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHZhbHVlc18xLlZhbHVlKHRoaXMuRXh0ZW5zaWJsZSwgbGFiZWwpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsYWJsZWxlZFByb3RvdHlwZURlc2MgPSBwcm90by5HZXRQcm9wZXJ0eShwKTtcbiAgICAgICAgbGFiZWwgPSBsYWJlbF8xLmx1YihsYWJlbCwgbGFibGVsZWRQcm90b3R5cGVEZXNjLmxhYmVsKTtcbiAgICAgICAgaWYgKGxhYmxlbGVkUHJvdG90eXBlRGVzYy52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHZhbHVlc18xLlZhbHVlKHRoaXMuRXh0ZW5zaWJsZSwgbGFiZWwpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcm90b3R5cGVEZXNjID0gbGFibGVsZWRQcm90b3R5cGVEZXNjLnZhbHVlO1xuICAgICAgICBsYWJlbC5sdWIocHJvdG90eXBlRGVzYy5sYWJlbCk7XG4gICAgICAgIGlmIChJc0FjY2Vzc29yRGVzY3JpcHRvcihwcm90b3R5cGVEZXNjKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZShwcm90b3R5cGVEZXNjLnNldCAhPT0gdW5kZWZpbmVkLCBsYWJlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuRXh0ZW5zaWJsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUoZmFsc2UsIGxhYmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUoISFwcm90b3R5cGVEZXNjLndyaXRhYmxlLCBsYWJlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIFB1dCwgOC4xMi41IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBFY21hLnByb3RvdHlwZS5QdXQgPSBmdW5jdGlvbiAocywgdiwgVGhyb3cpIHtcbiAgICAgICAgdmFyIGMgPSBtb25pdG9yLmNvbnRleHQ7XG4gICAgICAgIHZhciBjYW5QdXQgPSB0aGlzLkNhblB1dChzKTtcbiAgICAgICAgaWYgKCFjYW5QdXQudmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChUaHJvdykge1xuICAgICAgICAgICAgICAgIGMucHVzaFBDKGNhblB1dC5sYWJlbCk7XG4gICAgICAgICAgICAgICAgbW9uaXRvci5UaHJvdyhtb25pdG9yLm1vZHVsZXMuZXJyb3IuVHlwZUVycm9yT2JqZWN0LCAnaWxsZWdhbCBhY2Nlc3MnLCBsYWJlbF8xLmJvdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYy5wdXNoUEMobmV3IGxhYmVsXzEuTGFiZWwoKSk7XG4gICAgICAgIHZhciBvd25EZXNjID0gdGhpcy5HZXRPd25Qcm9wZXJ0eShzKTtcbiAgICAgICAgaWYgKG93bkRlc2MudmFsdWUgJiYgSXNEYXRhRGVzY3JpcHRvcihvd25EZXNjLnZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5EZWZpbmVPd25Qcm9wZXJ0eShzLCB7IHZhbHVlOiB2LnZhbHVlLCBsYWJlbDogdi5sYWJlbCB9LCBUaHJvdyk7XG4gICAgICAgICAgICBjLnBvcFBDKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlc2MgPSB0aGlzLkdldFByb3BlcnR5KHMpO1xuICAgICAgICBpZiAoZGVzYy52YWx1ZSAmJiBJc0FjY2Vzc29yRGVzY3JpcHRvcihkZXNjLnZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5zdHJ1Y3QubHViKHMubGFiZWwpO1xuICAgICAgICAgICAgaWYgKGRlc2MudmFsdWUuc2V0KSB7XG4gICAgICAgICAgICAgICAgYy5sYWJlbHMucGMubHViKGRlc2MubGFiZWwpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2MudmFsdWUuc2V0LmNhbGwodGhpcywgdik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vbml0b3IudHJ5UmV0aHJvdyhlLCBUaHJvdyk7XG4gICAgICAgICAgICAgICAgICAgIG1vbml0b3IuZmF0YWwoJ3VuYWJsZSB0byBsaWZ0JywgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYy5wb3BQQygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGMubGFiZWxzLnBjLmx1YihkZXNjLmxhYmVsKTtcbiAgICAgICAgdGhpcy5EZWZpbmVPd25Qcm9wZXJ0eShzLCB7XG4gICAgICAgICAgICB2YWx1ZTogdi52YWx1ZSxcbiAgICAgICAgICAgIGxhYmVsOiB2LmxhYmVsLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0sIFRocm93KTtcbiAgICAgICAgYy5wb3BQQygpO1xuICAgICAgICByZXR1cm47XG4gICAgfTtcbiAgICAvLyBIYXNQcm9wZXJ0eSwgOC4xMi42IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgRWNtYS5wcm90b3R5cGUuSGFzUHJvcGVydHkgPSBmdW5jdGlvbiAocykge1xuICAgICAgICB2YXIgZGVzYyA9IHRoaXMuR2V0UHJvcGVydHkocyk7XG4gICAgICAgIHZhciB2YWwgPSBuZXcgdmFsdWVzXzEuVmFsdWUoZGVzYy52YWx1ZSAhPT0gdW5kZWZpbmVkLCBkZXNjLmxhYmVsKTtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9O1xuICAgIC8vIERlbGV0ZSwgOC4xMi43IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBFY21hLnByb3RvdHlwZS5EZWxldGUgPSBmdW5jdGlvbiAocywgVGhyb3cpIHtcbiAgICAgICAgdmFyIGMgPSBtb25pdG9yLmNvbnRleHQ7XG4gICAgICAgIHZhciBwcm9wZXJ0eU5hbWUgPSBzLnZhbHVlO1xuICAgICAgICB2YXIgZGVzYyA9IHRoaXMuR2V0T3duUHJvcGVydHkocyk7XG4gICAgICAgIGlmIChkZXNjLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUodHJ1ZSwgZGVzYy5sYWJlbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsYWJlbF8xLmxlKGMuZWZmZWN0aXZlUEMsIHRoaXMuc3RydWN0KSkge1xuICAgICAgICAgICAgdmFyIG1zZyA9IF8udGVtcGxhdGUoJ0VjbWEucHJvdG90eXBlLkRlbGV0ZTogc2VjdXJpdHkgY29udGV4dCA8JT1lbCU+IG5vdCBiZWxvdyBzdHJ1Y3R1cmUgPCU9c2wlPicpO1xuICAgICAgICAgICAgbW9uaXRvci5zZWN1cml0eUVycm9yKG1zZyh7IGVsOiBjLmVmZmVjdGl2ZVBDLCBzbDogdGhpcy5zdHJ1Y3QgfSkpO1xuICAgICAgICAgICAgLy8gRm9yIG9ic2VydmFibGUgZmxvd3NcbiAgICAgICAgICAgIHRoaXMuc3RydWN0Lmx1YihjLmVmZmVjdGl2ZVBDKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGJsID0gbGFiZWxfMS5sdWIoYy5lZmZlY3RpdmVQQywgZGVzYy5sYWJlbCk7XG4gICAgICAgIHZhciBleGlzdGVuY2UgPSB0aGlzLmxhYmVsc1twcm9wZXJ0eU5hbWVdLmV4aXN0ZW5jZTtcbiAgICAgICAgaWYgKCFsYWJlbF8xLmxlKGxibCwgZXhpc3RlbmNlKSkge1xuICAgICAgICAgICAgdmFyIG1zZyA9IF8udGVtcGxhdGUoJ0VjbWEucHJvdG90eXBlLkRlbGV0ZTogc2VjdXJpdHkgY29udGV4dCA8JT1lbCU+IG5vdCBiZWxvdyBleHN0ZW5jZSBsYWJlbCA8JT1zbCU+Jyk7XG4gICAgICAgICAgICBtb25pdG9yLnNlY3VyaXR5RXJyb3IobXNnKHsgZWw6IGxibCwgc2w6IGV4aXN0ZW5jZSB9KSk7XG4gICAgICAgICAgICAvLyBGb3Igb2JzZXJ2YWJsZSBmbG93c1xuICAgICAgICAgICAgZXhpc3RlbmNlLmx1YihsYmwpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXMgPSBkZWxldGUgdGhpcy5wcm9wZXJ0aWVzW3Byb3BlcnR5TmFtZV07XG4gICAgICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMubGFiZWxzW3Byb3BlcnR5TmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIG1vbml0b3IudHJ5UmV0aHJvdyhlLCBUaHJvdyk7XG4gICAgICAgICAgICBtb25pdG9yLmZhdGFsKCd1bmFibGUgdG8gbGlmdCcsIGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUocmVzLCBsYWJlbF8xLmx1YihkZXNjLmxhYmVsLCBleGlzdGVuY2UpKTtcbiAgICB9O1xuICAgIC8vIERlZmF1bHRWYWx1ZSwgOC4xMi44IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBFY21hLnByb3RvdHlwZS5EZWZhdWx0VmFsdWUgPSBmdW5jdGlvbiAoaGludCkge1xuICAgICAgICBpZiAoaGludCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5DbGFzcyA9PT0gJ0RhdGUnKVxuICAgICAgICAgICAgICAgIGhpbnQgPSAnc3RyaW5nJztcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBoaW50ID0gJ251bWJlcic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhpbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YXIgdG9TdHJpbmcgPSB0aGlzLkdldChjb25zdGFudHMudG9TdHJpbmcpO1xuICAgICAgICAgICAgaWYgKElzQ2FsbGFibGVfMS5Jc0NhbGxhYmxlKHRvU3RyaW5nKS52YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBzdHIgPSB0b1N0cmluZy5DYWxsKG5ldyB2YWx1ZXNfMS5WYWx1ZSh0aGlzLCBsYWJlbF8xLmJvdCksIFtdKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVzXzEuaXNEZWZpbmVkUHJpbWl0aXZlVmFsdWUoc3RyKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1vbml0b3IuY29udGV4dC5wdXNoUEModG9TdHJpbmcubGFiZWwpO1xuICAgICAgICAgICAgdmFyIHZhbHVlT2YgPSB0aGlzLkdldChjb25zdGFudHMudmFsdWVPZik7XG4gICAgICAgICAgICBpZiAoSXNDYWxsYWJsZV8xLklzQ2FsbGFibGUodmFsdWVPZikudmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RyID0gdmFsdWVPZi5DYWxsKG5ldyB2YWx1ZXNfMS5WYWx1ZSh0aGlzLCBsYWJlbF8xLmJvdCksIFtdKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVzXzEuaXNEZWZpbmVkUHJpbWl0aXZlVmFsdWUoc3RyKSkge1xuICAgICAgICAgICAgICAgICAgICBzdHIucmFpc2UodG9TdHJpbmcubGFiZWwpO1xuICAgICAgICAgICAgICAgICAgICBtb25pdG9yLmNvbnRleHQucG9wUEMoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZXR1cm4gbmV3IFZhbHVlKCdEZWZhdWx0VmFsdWU6IHVuYWJsZSB0byBjb252ZXJ0JywgYm90KTtcbiAgICAgICAgICAgIG1vbml0b3IuVGhyb3cobW9uaXRvci5tb2R1bGVzLmVycm9yLlR5cGVFcnJvck9iamVjdCwgJ2RlZmF1bHQgdmFsdWUsIHVuYWJsZSB0byBjb252ZXJ0JywgbGFiZWxfMS5sdWIodG9TdHJpbmcubGFiZWwsIHZhbHVlT2YubGFiZWwpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBoaW50IG11c3QgYmUgJ251bWJlcidcbiAgICAgICAgdmFyIHZhbHVlT2YgPSB0aGlzLkdldChjb25zdGFudHMudmFsdWVPZik7XG4gICAgICAgIGlmIChJc0NhbGxhYmxlXzEuSXNDYWxsYWJsZSh2YWx1ZU9mKS52YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHN0ciA9IHZhbHVlT2YuQ2FsbChuZXcgdmFsdWVzXzEuVmFsdWUodGhpcywgbGFiZWxfMS5ib3QpLCBbXSk7XG4gICAgICAgICAgICBpZiAodmFsdWVzXzEuaXNEZWZpbmVkUHJpbWl0aXZlVmFsdWUoc3RyKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICB9XG4gICAgICAgIG1vbml0b3IuY29udGV4dC5wdXNoUEModmFsdWVPZi5sYWJlbCk7XG4gICAgICAgIHZhciB0b1N0cmluZyA9IHRoaXMuR2V0KGNvbnN0YW50cy50b1N0cmluZyk7XG4gICAgICAgIGlmIChJc0NhbGxhYmxlXzEuSXNDYWxsYWJsZSh0b1N0cmluZykudmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBzdHIgPSB0b1N0cmluZy5DYWxsKG5ldyB2YWx1ZXNfMS5WYWx1ZSh0aGlzLCBsYWJlbF8xLmJvdCksIFtdKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZXNfMS5pc0RlZmluZWRQcmltaXRpdmVWYWx1ZShzdHIpKSB7XG4gICAgICAgICAgICAgICAgc3RyLnJhaXNlKHZhbHVlT2YubGFiZWwpO1xuICAgICAgICAgICAgICAgIG1vbml0b3IuY29udGV4dC5wb3BQQygpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vbml0b3IuVGhyb3cobW9uaXRvci5tb2R1bGVzLmVycm9yLlR5cGVFcnJvck9iamVjdCwgJ2RlZmF1bHQgdmFsdWUsIHVuYWJsZSB0byBjb252ZXJ0JywgbGFiZWxfMS5sdWIodG9TdHJpbmcubGFiZWwsIHZhbHVlT2YubGFiZWwpKTtcbiAgICB9O1xuICAgIC8vIERlZmluZU93blByb3BlcnR5LCA4LjEyLjkgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBFY21hLnByb3RvdHlwZS5EZWZpbmVPd25Qcm9wZXJ0eSA9IGZ1bmN0aW9uIChzLCBkZXNjLCBUaHJvdykge1xuICAgICAgICB2YXIgYyA9IG1vbml0b3IuY29udGV4dDtcbiAgICAgICAgdmFyIHByb3BOYW1lID0gcy52YWx1ZTtcbiAgICAgICAgdmFyIHByb3BOYW1lTGFiZWwgPSBzLmxhYmVsO1xuICAgICAgICB0aGlzLnN0cnVjdCA9IGxhYmVsXzEubHViKHRoaXMuc3RydWN0LCBwcm9wTmFtZUxhYmVsKTtcbiAgICAgICAgdmFyIGNvbnRleHRMYWJlbCA9IGxhYmVsXzEubHViKGMuZWZmZWN0aXZlUEMsIHByb3BOYW1lTGFiZWwpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMucHJvcGVydGllcywgcHJvcE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlTGFiZWwgPSB0aGlzLmxhYmVsc1twcm9wTmFtZV0udmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKCFsYWJlbF8xLmxlKGNvbnRleHRMYWJlbCwgdmFsdWVMYWJlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1zZyA9IF8udGVtcGxhdGUoJ0VjbWEucHJvdG90eXBlLkRlZmluZU93blByb3BlcnR5OiBzZWN1cml0eSBjb250ZXh0IDwlPWVsJT4gbm90IGJlbG93IGV4aXN0aW5nIHZhbHVlIGxhYmVsIDwlPXZsJT4gZm9yIHByb3BlcnR5IDwlPXBuJT4nKTtcbiAgICAgICAgICAgICAgICAgICAgbW9uaXRvci5zZWN1cml0eUVycm9yKG1zZyh7IGVsOiBjb250ZXh0TGFiZWwsIHZsOiB2YWx1ZUxhYmVsLCBwbjogcHJvcE5hbWUgfSkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBGb3Igb2JzZXJ2YWJsZSBmbG93c1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZUxhYmVsLmx1Yihjb250ZXh0TGFiZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghbGFiZWxfMS5sZShjLmVmZmVjdGl2ZVBDLCB0aGlzLnN0cnVjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1zZyA9IF8udGVtcGxhdGUoJ0VjbWEucHJvdG90eXBlLkRlZmluZU93blByb3BlcnR5OiBzZWN1cml0eSBjb250ZXh0IDwlPWVsJT4gbm90IGJlbG93IHN0cnVjdHVyZSA8JT1zbCU+Jyk7XG4gICAgICAgICAgICAgICAgICAgIG1vbml0b3Iuc2VjdXJpdHlFcnJvcihtc2coeyBlbDogYy5lZmZlY3RpdmVQQywgc2w6IHRoaXMuc3RydWN0IH0pKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIG9ic2VydmFibGUgZmxvd3NcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHJ1Y3QubHViKGMuZWZmZWN0aXZlUEMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZXNjLmdldCkge1xuICAgICAgICAgICAgICAgIHZhciBnZXQgPSBkZXNjLmdldDtcbiAgICAgICAgICAgICAgICBkZXNjLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdldC5DYWxsKG5ldyB2YWx1ZXNfMS5WYWx1ZSh0aGlzLCBsYWJlbF8xLmJvdCksIFtdKTsgfTtcbiAgICAgICAgICAgICAgICBkZXNjLmdldC5hY3R1YWxGdW5jdGlvbiA9IGdldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgICAgICAgICAgIHZhciBzZXQgPSBkZXNjLnNldDtcbiAgICAgICAgICAgICAgICBkZXNjLnNldCA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBzZXQuQ2FsbChuZXcgdmFsdWVzXzEuVmFsdWUodGhpcywgbGFiZWxfMS5ib3QpLCBbdl0pOyB9O1xuICAgICAgICAgICAgICAgIGRlc2Muc2V0LmFjdHVhbEZ1bmN0aW9uID0gc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMucHJvcGVydGllcywgcHJvcE5hbWUsIGRlc2MpO1xuICAgICAgICAgICAgdGhpcy5sYWJlbHNbcHJvcE5hbWVdID0geyB2YWx1ZTogbGFiZWxfMS5sdWIoZGVzYy5sYWJlbCwgY29udGV4dExhYmVsKSwgZXhpc3RlbmNlOiBjb250ZXh0TGFiZWwgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbW9uaXRvci50cnlSZXRocm93KGUsIFRocm93KTtcbiAgICAgICAgICAgIG1vbml0b3IuZmF0YWwoJ3VuYWJsZSB0byBsaWZ0JywgZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZSh0cnVlLCBsYWJlbF8xLmJvdCk7XG4gICAgfTtcbiAgICByZXR1cm4gRWNtYTtcbn0oKSk7XG5leHBvcnRzLkVjbWEgPSBFY21hO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBEZWZpbmUoX3RoaXMsIG5hbWUsIHYsIG9wdHMpIHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICBuYW1lID0gbmFtZS52YWx1ZSB8fCBuYW1lO1xuICAgIHZhciBwZCA9IHsgdmFsdWU6IHYgfTtcbiAgICBwZC53cml0YWJsZSA9IEJvb2xlYW4ob3B0cy53cml0YWJsZSk7XG4gICAgcGQuZW51bWVyYWJsZSA9IEJvb2xlYW4ob3B0cy5lbnVtZXJhYmxlKTtcbiAgICBwZC5jb25maWd1cmFibGUgPSBCb29sZWFuKG9wdHMuY29uZmlndXJhYmxlKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMucHJvcGVydGllcywgbmFtZSwgcGQpO1xuICAgIF90aGlzLmxhYmVsc1tuYW1lXSA9IHsgdmFsdWU6IG9wdHMubGFiZWwgfHwgbGFiZWxfMS5ib3QsIGV4aXN0ZW5jZTogb3B0cy5leGlzdGVuY2UgfHwgbGFiZWxfMS5ib3QgfTtcbn1cbmV4cG9ydHMuRGVmaW5lID0gRGVmaW5lO1xuZnVuY3Rpb24gRGVmaW5lRkZUKF90aGlzLCBuYW1lLCB2LCBvcHRzKSB7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgbmFtZSA9IG5hbWUudmFsdWUgfHwgbmFtZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMucHJvcGVydGllcywgbmFtZSwge1xuICAgICAgICB2YWx1ZTogdixcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgX3RoaXMubGFiZWxzW25hbWVdID0geyB2YWx1ZTogb3B0cy5sYWJlbCB8fCBsYWJlbF8xLmJvdCwgZXhpc3RlbmNlOiBvcHRzLmV4aXN0ZW5jZSB8fCBsYWJlbF8xLmJvdCB9O1xufVxuZXhwb3J0cy5EZWZpbmVGRlQgPSBEZWZpbmVGRlQ7XG5mdW5jdGlvbiBEZWZpbmVGRkYoX3RoaXMsIG5hbWUsIHYsIG9wdHMpIHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICBuYW1lID0gbmFtZS52YWx1ZSB8fCBuYW1lO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcy5wcm9wZXJ0aWVzLCBuYW1lLCB7IHZhbHVlOiB2IH0pO1xuICAgIF90aGlzLmxhYmVsc1tuYW1lXSA9IHsgdmFsdWU6IG9wdHMubGFiZWwgfHwgbGFiZWxfMS5ib3QsIGV4aXN0ZW5jZTogb3B0cy5leGlzdGVuY2UgfHwgbGFiZWxfMS5ib3QgfTtcbn1cbmV4cG9ydHMuRGVmaW5lRkZGID0gRGVmaW5lRkZGO1xuZnVuY3Rpb24gRGVmaW5lVEZGKF90aGlzLCBuYW1lLCB2LCBvcHRzKSB7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgbmFtZSA9IG5hbWUudmFsdWUgfHwgbmFtZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMucHJvcGVydGllcywgbmFtZSwge1xuICAgICAgICB2YWx1ZTogdixcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgICBfdGhpcy5sYWJlbHNbbmFtZV0gPSB7IHZhbHVlOiBvcHRzLmxhYmVsIHx8IGxhYmVsXzEuYm90LCBleGlzdGVuY2U6IG9wdHMuZXhpc3RlbmNlIHx8IGxhYmVsXzEuYm90IH07XG59XG5leHBvcnRzLkRlZmluZVRGRiA9IERlZmluZVRGRjtcbmZ1bmN0aW9uIERlZmluZVRGVChfdGhpcywgbmFtZSwgdiwgb3B0cykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIG5hbWUgPSBuYW1lLnZhbHVlIHx8IG5hbWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLnByb3BlcnRpZXMsIG5hbWUsIHtcbiAgICAgICAgdmFsdWU6IHYsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBfdGhpcy5sYWJlbHNbbmFtZV0gPSB7IHZhbHVlOiBvcHRzLmxhYmVsIHx8IGxhYmVsXzEuYm90LCBleGlzdGVuY2U6IG9wdHMuZXhpc3RlbmNlIHx8IGxhYmVsXzEuYm90IH07XG59XG5leHBvcnRzLkRlZmluZVRGVCA9IERlZmluZVRGVDtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZWNtYS5qcy5tYXAiLCIvKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLiAqL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbGFiZWxfMSA9IHJlcXVpcmUoXCIuL2xhYmVsXCIpO1xudmFyIHZhbHVlc18xID0gcmVxdWlyZShcIi4vdmFsdWVzXCIpO1xudmFyIGVjbWFfMSA9IHJlcXVpcmUoXCIuL2VjbWFcIik7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIDEwLjJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gMTAuMi4yLjJcbmZ1bmN0aW9uIE5ld0RlY2xhcmF0aXZlRW52aXJvbm1lbnQoZSkge1xuICAgIHZhciBlbnZSZWMgPSBuZXcgRGVjbGFyYXRpdmVFbnZpcm9ubWVudFJlY29yZCgpO1xuICAgIHZhciBlbnYgPSBuZXcgTGV4aWNhbEVudmlyb25tZW50KGVudlJlYywgZSk7XG4gICAgcmV0dXJuIGVudjtcbn1cbmV4cG9ydHMuTmV3RGVjbGFyYXRpdmVFbnZpcm9ubWVudCA9IE5ld0RlY2xhcmF0aXZlRW52aXJvbm1lbnQ7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIDEwLjIuMi4zXG5mdW5jdGlvbiBOZXdPYmplY3RFbnZpcm9ubWVudChvLCBlKSB7XG4gICAgdmFyIGVudlJlYyA9IG5ldyBPYmplY3RFbnZpcm9ubWVudFJlY29yZChvKTtcbiAgICB2YXIgZW52ID0gbmV3IExleGljYWxFbnZpcm9ubWVudChlbnZSZWMsIGUpO1xuICAgIHJldHVybiBlbnY7XG59XG5leHBvcnRzLk5ld09iamVjdEVudmlyb25tZW50ID0gTmV3T2JqZWN0RW52aXJvbm1lbnQ7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEVudmlyb25tZW50IHJlY29yZHMsIDEwLjIuMS4yXG52YXIgT2JqZWN0RW52aXJvbm1lbnRSZWNvcmQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE9iamVjdEVudmlyb25tZW50UmVjb3JkLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE9iamVjdEVudmlyb25tZW50UmVjb3JkKHApIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucHJvdmlkZVRoaXMgPSBmYWxzZTtcbiAgICAgICAgaWYgKHAudmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIG1vbml0b3IuZmF0YWwoJ09iamVjdEVudmlyb25tZW50UmVjb3JkLCB1bmRlZmluZWQgYmluZGluZyBvYmplY3QnKTtcbiAgICAgICAgX3RoaXMuYmluZGluZ09iamVjdCA9IHA7IC8vIFZhbHVlXG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLy8gLS0tXG4gICAgT2JqZWN0RW52aXJvbm1lbnRSZWNvcmQucHJvdG90eXBlLnJhaXNlID0gZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgdGhpcy5iaW5kaW5nT2JqZWN0LnJhaXNlKGwpO1xuICAgIH07XG4gICAgLy8gLS0tXG4gICAgLy8gSGFzQmluZGluZywgMTAuMi4xLjIuMVxuICAgIE9iamVjdEVudmlyb25tZW50UmVjb3JkLnByb3RvdHlwZS5IYXNCaW5kaW5nID0gZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmluZGluZ09iamVjdC5IYXNQcm9wZXJ0eShwKTtcbiAgICB9O1xuICAgIC8vIC0tLVxuICAgIC8vIENyZWF0ZU11dGFibGVCaW5kaW5nLCAxMC4yLjEuMi4yXG4gICAgT2JqZWN0RW52aXJvbm1lbnRSZWNvcmQucHJvdG90eXBlLkNyZWF0ZU11dGFibGVCaW5kaW5nID0gZnVuY3Rpb24gKHAsIGQpIHtcbiAgICAgICAgdmFyIGRlc2MgPSB7XG4gICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbGFiZWw6IG1vbml0b3IuY29udGV4dC5lZmZlY3RpdmVQQyxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmJpbmRpbmdPYmplY3QuRGVmaW5lT3duUHJvcGVydHkocCwgZGVzYywgdHJ1ZSk7XG4gICAgfTtcbiAgICAvLyAtLS1cbiAgICAvLyBHZXRCaW5kaW5nVmFsdWUsIDEwLjIuMS4yLjRcbiAgICBPYmplY3RFbnZpcm9ubWVudFJlY29yZC5wcm90b3R5cGUuR2V0QmluZGluZ1ZhbHVlID0gZnVuY3Rpb24gKHAsIHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmluZGluZ09iamVjdC5HZXQocCk7XG4gICAgfTtcbiAgICAvLyBTZXRNdXRhYmxlQmluZGluZywgMTAuMi4xLjIuM1xuICAgIE9iamVjdEVudmlyb25tZW50UmVjb3JkLnByb3RvdHlwZS5TZXRNdXRhYmxlQmluZGluZyA9IGZ1bmN0aW9uIChwLCB2LCBzKSB7XG4gICAgICAgIHRoaXMuYmluZGluZ09iamVjdC5QdXQocCwgdiwgcyk7XG4gICAgfTtcbiAgICAvLyBEZWxldGVCaW5kaW5nLCAxMC4yLjEuMi41XG4gICAgT2JqZWN0RW52aXJvbm1lbnRSZWNvcmQucHJvdG90eXBlLkRlbGV0ZUJpbmRpbmcgPSBmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iaW5kaW5nT2JqZWN0LkRlbGV0ZShwKTtcbiAgICB9O1xuICAgIC8vIEltcGxpY2l0VGhpc1ZhbHVlLCAxMC4yLjEuMi42XG4gICAgT2JqZWN0RW52aXJvbm1lbnRSZWNvcmQucHJvdG90eXBlLkltcGxpY2l0VGhpc1ZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5wcm92aWRlVGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmluZGluZ09iamVjdC5jbG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIGxhYmVsXzEuYm90KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE9iamVjdEVudmlyb25tZW50UmVjb3JkO1xufShlY21hXzEuRWNtYSkpO1xuZXhwb3J0cy5PYmplY3RFbnZpcm9ubWVudFJlY29yZCA9IE9iamVjdEVudmlyb25tZW50UmVjb3JkO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBEZWNsYXJhdGl2ZSBFbnZpcm9ubWVudCBSZWNvcmQsIDEwLjIuMS4xXG52YXIgRGVjbGFyYXRpdmVFbnZpcm9ubWVudFJlY29yZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGVjbGFyYXRpdmVFbnZpcm9ubWVudFJlY29yZCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEZWNsYXJhdGl2ZUVudmlyb25tZW50UmVjb3JkKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICB9XG4gICAgLy8gSGFzQmluZGluZywgMTAuMi4xLjEuMVxuICAgIERlY2xhcmF0aXZlRW52aXJvbm1lbnRSZWNvcmQucHJvdG90eXBlLkhhc0JpbmRpbmcgPSBmdW5jdGlvbiAocykge1xuICAgICAgICByZXR1cm4gdGhpcy5IYXNQcm9wZXJ0eShzKTtcbiAgICB9O1xuICAgIC8vIENyZWF0ZU11dGFibGVCaW5kaW5nLCAxMC4yLjEuMS4yXG4gICAgRGVjbGFyYXRpdmVFbnZpcm9ubWVudFJlY29yZC5wcm90b3R5cGUuQ3JlYXRlTXV0YWJsZUJpbmRpbmcgPSBmdW5jdGlvbiAocCwgZCkge1xuICAgICAgICB2YXIgZGVzYyA9IHtcbiAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBsYWJlbDogbW9uaXRvci5jb250ZXh0LmVmZmVjdGl2ZVBDLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiBkXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuRGVmaW5lT3duUHJvcGVydHkocCwgZGVzYywgdHJ1ZSk7XG4gICAgfTtcbiAgICAvLyBHZXRCaW5kaW5nVmFsdWUgMTAuMi4xLjEuNFxuICAgIERlY2xhcmF0aXZlRW52aXJvbm1lbnRSZWNvcmQucHJvdG90eXBlLkdldEJpbmRpbmdWYWx1ZSA9IGZ1bmN0aW9uIChwLCBzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLkdldChwKTtcbiAgICB9O1xuICAgIC8vIFNldE11dGFibGVCaW5kaW5nLCAxMC4yLjEuMS4zXG4gICAgRGVjbGFyYXRpdmVFbnZpcm9ubWVudFJlY29yZC5wcm90b3R5cGUuU2V0TXV0YWJsZUJpbmRpbmcgPSBmdW5jdGlvbiAocCwgdiwgcykge1xuICAgICAgICB0aGlzLlB1dChwLCB2LCBzKTtcbiAgICB9O1xuICAgIC8vIERlbGV0ZUJpbmRpbmcsIDEwLjIuMS4xLjVcbiAgICBEZWNsYXJhdGl2ZUVudmlyb25tZW50UmVjb3JkLnByb3RvdHlwZS5EZWxldGVCaW5kaW5nID0gZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuRGVsZXRlKHApO1xuICAgIH07XG4gICAgLy8gSW1wbGljaXRUaGlzVmFsaWUuIDEwLjIuMS4xLjZcbiAgICBEZWNsYXJhdGl2ZUVudmlyb25tZW50UmVjb3JkLnByb3RvdHlwZS5JbXBsaWNpdFRoaXNWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIGxhYmVsXzEuYm90KTtcbiAgICB9O1xuICAgIC8vIENyZWF0ZUltbXV0YWJsZUJpbmRpbmcsIDEwLjIuMS4xLjdcbiAgICBEZWNsYXJhdGl2ZUVudmlyb25tZW50UmVjb3JkLnByb3RvdHlwZS5DcmVhdGVJbW11dGFibGVCaW5kaW5nID0gZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIGRlc2MgPSB7XG4gICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbGFiZWw6IGxhYmVsXzEuYm90LFxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLkRlZmluZU93blByb3BlcnR5KHAsIGRlc2MsIGZhbHNlKTtcbiAgICB9O1xuICAgIC8vIEluaXRpYWxpemVJbW11dGFibGVCaW5kaW5nLCAxMC4yLjEuMS44XG4gICAgRGVjbGFyYXRpdmVFbnZpcm9ubWVudFJlY29yZC5wcm90b3R5cGUuSW5pdGlhbGl6ZUltbXV0YWJsZUJpbmRpbmcgPSBmdW5jdGlvbiAocCwgdikge1xuICAgICAgICB2YXIgZGVzYyA9IHRoaXMuR2V0T3duUHJvcGVydHkocCkudmFsdWU7XG4gICAgICAgIGRlc2MudmFsdWUgPSB2LnZhbHVlO1xuICAgICAgICBkZXNjLmxhYmVsID0gdi5sYWJlbDtcbiAgICAgICAgdGhpcy5EZWZpbmVPd25Qcm9wZXJ0eShwLCBkZXNjLCBmYWxzZSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGVjbGFyYXRpdmVFbnZpcm9ubWVudFJlY29yZDtcbn0oZWNtYV8xLkVjbWEpKTtcbmV4cG9ydHMuRGVjbGFyYXRpdmVFbnZpcm9ubWVudFJlY29yZCA9IERlY2xhcmF0aXZlRW52aXJvbm1lbnRSZWNvcmQ7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIElzRW52aXJvbm1lbnRSZWNvcmQocCkge1xuICAgIHJldHVybiAoJ0hhc0JpbmRpbmcnIGluIHAudmFsdWUpO1xufVxuZXhwb3J0cy5Jc0Vudmlyb25tZW50UmVjb3JkID0gSXNFbnZpcm9ubWVudFJlY29yZDtcbjtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIExleGljYWxFbnZpcm9ubWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMZXhpY2FsRW52aXJvbm1lbnQoZXIsIGxlKSB7XG4gICAgICAgIHRoaXMuRW52aXJvbm1lbnRSZWNvcmQgPSBlcjsgLy8gTm90IFZhbHVlXG4gICAgICAgIHRoaXMuT3V0ZXJMZXhpY2FsRW52aXJvbm1lbnQgPSBsZTsgLy8gVmFsdWVcbiAgICB9XG4gICAgTGV4aWNhbEVudmlyb25tZW50LnByb3RvdHlwZS5wcm92aWRlVGhpcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5FbnZpcm9ubWVudFJlY29yZC5wcm92aWRlVGhpcyA9IHRydWU7XG4gICAgfTtcbiAgICBMZXhpY2FsRW52aXJvbm1lbnQucHJvdG90eXBlLkhhc0JpbmRpbmcgPSBmdW5jdGlvbiAocykge1xuICAgICAgICByZXR1cm4gdGhpcy5FbnZpcm9ubWVudFJlY29yZC5IYXNCaW5kaW5nKHMpO1xuICAgIH07XG4gICAgTGV4aWNhbEVudmlyb25tZW50LnByb3RvdHlwZS5DcmVhdGVNdXRhYmxlQmluZGluZyA9IGZ1bmN0aW9uIChzLCBkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLkVudmlyb25tZW50UmVjb3JkLkNyZWF0ZU11dGFibGVCaW5kaW5nKHMsIGQpO1xuICAgIH07XG4gICAgTGV4aWNhbEVudmlyb25tZW50LnByb3RvdHlwZS5TZXRNdXRhYmxlQmluZGluZyA9IGZ1bmN0aW9uIChzLCB2LCBkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLkVudmlyb25tZW50UmVjb3JkLlNldE11dGFibGVCaW5kaW5nKHMsIHYsIGQpO1xuICAgIH07XG4gICAgTGV4aWNhbEVudmlyb25tZW50LnByb3RvdHlwZS5HZXRCaW5kaW5nVmFsdWUgPSBmdW5jdGlvbiAocywgZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5FbnZpcm9ubWVudFJlY29yZC5HZXRCaW5kaW5nVmFsdWUocywgZCk7XG4gICAgfTtcbiAgICBMZXhpY2FsRW52aXJvbm1lbnQucHJvdG90eXBlLkRlbGV0ZUJpbmRpbmcgPSBmdW5jdGlvbiAocykge1xuICAgICAgICByZXR1cm4gdGhpcy5FbnZpcm9ubWVudFJlY29yZC5EZWxldGVCaW5kaW5nKHMpO1xuICAgIH07XG4gICAgTGV4aWNhbEVudmlyb25tZW50LnByb3RvdHlwZS5JbXBsaWNpdFRoaXNWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuRW52aXJvbm1lbnRSZWNvcmQuSW1wbGljaXRUaGlzVmFsdWUoKTtcbiAgICB9O1xuICAgIC8vIE9ubHkgbWVhbmluZ2Z1bCBpZiB0aGUgdW5kZXJseWluZyBlbnZpcm9ubWVudCByZWNvcmQgaXMgXG4gICAgLy8gIGEgZGVjbGFyYXRpdmUgZW52aXJvbm1lbnQgcmVjb3JkXG4gICAgTGV4aWNhbEVudmlyb25tZW50LnByb3RvdHlwZS5DcmVhdGVJbW11dGFibGVCaW5kaW5nID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuRW52aXJvbm1lbnRSZWNvcmQuQ3JlYXRlSW1tdXRhYmxlQmluZGluZyhzKTtcbiAgICB9O1xuICAgIExleGljYWxFbnZpcm9ubWVudC5wcm90b3R5cGUuSW5pdGlhbGl6ZUltbXV0YWJsZUJpbmRpbmcgPSBmdW5jdGlvbiAocywgdikge1xuICAgICAgICByZXR1cm4gdGhpcy5FbnZpcm9ubWVudFJlY29yZC5Jbml0aWFsaXplSW1tdXRhYmxlQmluZGluZyhzLCB2KTtcbiAgICB9O1xuICAgIHJldHVybiBMZXhpY2FsRW52aXJvbm1lbnQ7XG59KCkpO1xuZXhwb3J0cy5MZXhpY2FsRW52aXJvbm1lbnQgPSBMZXhpY2FsRW52aXJvbm1lbnQ7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEdldElkZW50aWZpZXJSZWZlcmVuY2UsIDEwLjIuMi4xXG5mdW5jdGlvbiBHZXRJZGVudGlmaWVyUmVmZXJlbmNlKHAsIHgpIHtcbiAgICBpZiAoIXApIHtcbiAgICAgICAgbW9uaXRvci5mYXRhbCgnR2V0SWRlbnRpZmllclJlZmVyZW5jZTogcCB1bmRlZmluZWQgb3IgbnVsbCBmb3IgJyArIHgpO1xuICAgIH1cbiAgICBpZiAocC52YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBuZXcgdmFsdWVzXzEuUmVmZXJlbmNlKG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIHAubGFiZWwpLCBuZXcgdmFsdWVzXzEuVmFsdWUoeCwgbGFiZWxfMS5ib3QpKTtcbiAgICB9XG4gICAgdmFyIGVycCA9IG5ldyB2YWx1ZXNfMS5WYWx1ZShwLnZhbHVlLkVudmlyb25tZW50UmVjb3JkLCBwLmxhYmVsKTtcbiAgICB2YXIgYiA9IGVycC5IYXNCaW5kaW5nKG5ldyB2YWx1ZXNfMS5WYWx1ZSh4LCBsYWJlbF8xLmJvdCkpO1xuICAgIGlmIChiLnZhbHVlKSB7XG4gICAgICAgIGVycC5sYWJlbCA9IGIubGFiZWw7XG4gICAgICAgIHJldHVybiBuZXcgdmFsdWVzXzEuUmVmZXJlbmNlKGVycCwgbmV3IHZhbHVlc18xLlZhbHVlKHgsIGxhYmVsXzEuYm90KSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgcmVzID0gR2V0SWRlbnRpZmllclJlZmVyZW5jZShwLnZhbHVlLk91dGVyTGV4aWNhbEVudmlyb25tZW50LCB4KTtcbiAgICAgICAgcmVzLmJhc2UucmFpc2UoYi5sYWJlbCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufVxuZXhwb3J0cy5HZXRJZGVudGlmaWVyUmVmZXJlbmNlID0gR2V0SWRlbnRpZmllclJlZmVyZW5jZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVudi5qcy5tYXAiLCIvKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLiAqL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbGFiZWwgPSByZXF1aXJlKFwiLi9sYWJlbFwiKTtcbnZhciB2YWx1ZXNfMSA9IHJlcXVpcmUoXCIuL3ZhbHVlc1wiKTtcbnZhciBlY21hID0gcmVxdWlyZShcIi4vZWNtYVwiKTtcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG52YXIgZnVuY3Rpb25fMSA9IHJlcXVpcmUoXCIuL2Z1bmN0aW9uXCIpO1xudmFyIEhhc0luc3RhbmNlXzEgPSByZXF1aXJlKFwiLi9IYXNJbnN0YW5jZVwiKTtcbnZhciBUb1N0cmluZ18xID0gcmVxdWlyZShcIi4vQ29udmVyc2lvbi9Ub1N0cmluZ1wiKTtcbmV4cG9ydHMuZnVuY3RvciA9IGZ1bmN0aW9uIChtb25pdG9yKSB7XG4gICAgdmFyIEVjbWEgPSBlY21hLkVjbWE7XG4gICAgdmFyIExhYmVsID0gbGFiZWwuTGFiZWw7XG4gICAgdmFyIGx1YiA9IGxhYmVsLmx1YjtcbiAgICB2YXIgbGUgPSBsYWJlbC5sZTtcbiAgICB2YXIgYm90ID0gTGFiZWwuYm90O1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIGFsbG9jYXRlKGdsb2JhbCkge1xuICAgICAgICB2YXIgZXJyb3JDb25zdHJ1Y3RvciA9IG5ldyBFcnJvckNvbnN0cnVjdG9yKCk7XG4gICAgICAgIHZhciBlcnJvclByb3RvdHlwZSA9IGVycm9yQ29uc3RydWN0b3IuX3Byb3RvO1xuICAgICAgICAvLyAxNS4xMS41XG4gICAgICAgIHZhciBldmFsRXJyb3JDb25zdHJ1Y3RvciA9IG5ldyBOYXRpdmVFcnJvckNvbnN0cnVjdG9yKGdsb2JhbCwgJ0V2YWxFcnJvcicpO1xuICAgICAgICB2YXIgcmFuZ2VFcnJvckNvbnN0cnVjdG9yID0gbmV3IE5hdGl2ZUVycm9yQ29uc3RydWN0b3IoZ2xvYmFsLCAnUmFuZ2VFcnJvcicpO1xuICAgICAgICB2YXIgcmVmZXJlbmNlRXJyb3JDb25zdHJ1Y3RvciA9IG5ldyBOYXRpdmVFcnJvckNvbnN0cnVjdG9yKGdsb2JhbCwgJ1JlZmVyZW5jZUVycm9yJyk7XG4gICAgICAgIHZhciBzeW50YXhFcnJvckNvbnN0cnVjdG9yID0gbmV3IE5hdGl2ZUVycm9yQ29uc3RydWN0b3IoZ2xvYmFsLCAnU3ludGF4RXJyb3InKTtcbiAgICAgICAgdmFyIHR5cGVFcnJvckNvbnN0cnVjdG9yID0gbmV3IE5hdGl2ZUVycm9yQ29uc3RydWN0b3IoZ2xvYmFsLCAnVHlwZUVycm9yJyk7XG4gICAgICAgIHZhciBVUklFcnJvckNvbnN0cnVjdG9yID0gbmV3IE5hdGl2ZUVycm9yQ29uc3RydWN0b3IoZ2xvYmFsLCAnVVJJRXJyb3InKTtcbiAgICAgICAgdmFyIGV2YWxFcnJvclByb3RvdHlwZSA9IGV2YWxFcnJvckNvbnN0cnVjdG9yLl9wcm90bztcbiAgICAgICAgdmFyIHJhbmdlRXJyb3JQcm90b3R5cGUgPSByYW5nZUVycm9yQ29uc3RydWN0b3IuX3Byb3RvO1xuICAgICAgICB2YXIgcmVmZXJlbmNlRXJyb3JQcm90b3R5cGUgPSByZWZlcmVuY2VFcnJvckNvbnN0cnVjdG9yLl9wcm90bztcbiAgICAgICAgdmFyIHN5bnRheEVycm9yUHJvdG90eXBlID0gc3ludGF4RXJyb3JDb25zdHJ1Y3Rvci5fcHJvdG87XG4gICAgICAgIHZhciB0eXBlRXJyb3JQcm90b3R5cGUgPSB0eXBlRXJyb3JDb25zdHJ1Y3Rvci5fcHJvdG87XG4gICAgICAgIHZhciB1cmlFcnJvclByb3RvdHlwZSA9IFVSSUVycm9yQ29uc3RydWN0b3IuX3Byb3RvO1xuICAgICAgICByZXR1cm4geyBFcnJvckNvbnN0cnVjdG9yOiBlcnJvckNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgRXJyb3JQcm90b3R5cGU6IGVycm9yUHJvdG90eXBlLFxuICAgICAgICAgICAgRXZhbEVycm9yQ29uc3RydWN0b3I6IGV2YWxFcnJvckNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgRXZhbEVycm9yUHJvdG90eXBlOiBldmFsRXJyb3JQcm90b3R5cGUsXG4gICAgICAgICAgICBSYW5nZUVycm9yQ29uc3RydWN0b3I6IHJhbmdlRXJyb3JDb25zdHJ1Y3RvcixcbiAgICAgICAgICAgIFJhbmdlRXJyb3JQcm90b3R5cGU6IHJhbmdlRXJyb3JQcm90b3R5cGUsXG4gICAgICAgICAgICBSZWZlcmVuY2VFcnJvckNvbnN0cnVjdG9yOiByZWZlcmVuY2VFcnJvckNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgUmVmZXJlbmNlRXJyb3JQcm90b3R5cGU6IHJlZmVyZW5jZUVycm9yUHJvdG90eXBlLFxuICAgICAgICAgICAgU3ludGF4RXJyb3JDb25zdHJ1Y3Rvcjogc3ludGF4RXJyb3JDb25zdHJ1Y3RvcixcbiAgICAgICAgICAgIFN5bnRheEVycm9yUHJvdG90eXBlOiBzeW50YXhFcnJvclByb3RvdHlwZSxcbiAgICAgICAgICAgIFR5cGVFcnJvckNvbnN0cnVjdG9yOiB0eXBlRXJyb3JDb25zdHJ1Y3RvcixcbiAgICAgICAgICAgIFR5cGVFcnJvclByb3RvdHlwZTogdHlwZUVycm9yUHJvdG90eXBlLFxuICAgICAgICAgICAgVVJJRXJyb3JDb25zdHJ1Y3RvcjogVVJJRXJyb3JDb25zdHJ1Y3RvcixcbiAgICAgICAgICAgIFVSSUVycm9yUHJvdG90eXBlOiB1cmlFcnJvclByb3RvdHlwZVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyAxNS4xMSAtIFRoZSBFcnJvciBDb25zdHJ1Y3RvclxuICAgIHZhciBFcnJvckNvbnN0cnVjdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoRXJyb3JDb25zdHJ1Y3RvciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gRXJyb3JDb25zdHJ1Y3Rvcihob3N0KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMuQ2xhc3MgPSAnRnVuY3Rpb24nO1xuICAgICAgICAgICAgX3RoaXMuaG9zdCA9IGhvc3Q7XG4gICAgICAgICAgICBfdGhpcy5Qcm90b3R5cGUgPSBuZXcgdmFsdWVzXzEuVmFsdWUobW9uaXRvci5pbnN0YW5jZXMuRnVuY3Rpb25Qcm90b3R5cGUsIGJvdCk7XG4gICAgICAgICAgICBfdGhpcy5FeHRlbnNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIF90aGlzLm5hbWUgPSAnRXJyb3InO1xuICAgICAgICAgICAgX3RoaXMuX3Byb3RvID0gbmV3IEVycm9yUHJvdG90eXBlKF90aGlzKTtcbiAgICAgICAgICAgIGVjbWEuRGVmaW5lRkZGKF90aGlzLCBjb25zdGFudHMubGVuZ3RoLCAxKTtcbiAgICAgICAgICAgIGVjbWEuRGVmaW5lRkZGKF90aGlzLCBjb25zdGFudHMucHJvdG90eXBlLCBfdGhpcy5fcHJvdG8pO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBFcnJvckNvbnN0cnVjdG9yO1xuICAgIH0oRWNtYSkpO1xuICAgIEVycm9yQ29uc3RydWN0b3IucHJvdG90eXBlLkhhc0luc3RhbmNlID0gSGFzSW5zdGFuY2VfMS5IYXNJbnN0YW5jZTtcbiAgICAvLyAxNS4xMS4yXG4gICAgRXJyb3JDb25zdHJ1Y3Rvci5wcm90b3R5cGUuQ2FsbCA9IGZ1bmN0aW9uICh0aGlzQXJnLCBhcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNvbnN0cnVjdChhcmdzKTtcbiAgICB9O1xuICAgIC8vIDE1LjExLjIuMVxuICAgIEVycm9yQ29uc3RydWN0b3IucHJvdG90eXBlLkNvbnN0cnVjdCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgIHZhciBhcmcwID0gYXJnc1swXSA/IGFyZ3NbMF0gOiBuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgICAgICB2YXIgbyA9IG5ldyBFcnJvck9iamVjdChhcmcwKTtcbiAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZShvLCBib3QpO1xuICAgIH07XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gMTUuMTEuNCBUaGUgRXJyb3IgUHJvdG90eXBlXG4gICAgdmFyIEVycm9yUHJvdG90eXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoRXJyb3JQcm90b3R5cGUsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEVycm9yUHJvdG90eXBlKGNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMuQ2xhc3MgPSAnRXJyb3InO1xuICAgICAgICAgICAgX3RoaXMuUHJvdG90eXBlID0gbmV3IHZhbHVlc18xLlZhbHVlKG1vbml0b3IuaW5zdGFuY2VzLk9iamVjdFByb3RvdHlwZSwgYm90KTtcbiAgICAgICAgICAgIF90aGlzLmhvc3QgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRXJyb3IpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXMsIGNvbnN0YW50cy5jb25zdHJ1Y3RvciwgY29uc3RydWN0b3IpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXMsIGNvbnN0YW50cy5uYW1lLCAnRXJyb3InKTtcbiAgICAgICAgICAgIGVjbWEuRGVmaW5lVEZUKF90aGlzLCBjb25zdGFudHMubWVzc2FnZSwgJycpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXMsIGNvbnN0YW50cy50b1N0cmluZywgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHRvc3RyaW5nLCAwLCB1bmRlZmluZWQpKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRXJyb3JQcm90b3R5cGU7XG4gICAgfShFY21hKSk7XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gdG9zdHJpbmcodGhpc0FyZywgYXJncykge1xuICAgICAgICB2YXIgYyA9IG1vbml0b3IuY29udGV4dDtcbiAgICAgICAgaWYgKHRoaXNBcmcudmFsdWUgPT09IG51bGxcbiAgICAgICAgICAgIHx8IHR5cGVvZiB0aGlzQXJnLnZhbHVlICE9PSAnb2JqZWN0J1xuICAgICAgICAgICAgfHwgdGhpc0FyZy52YWx1ZS5DbGFzcyAhPT0gJ0Vycm9yJykge1xuICAgICAgICAgICAgYy5wdXNoUEModGhpc0FyZy5sYWJlbCk7XG4gICAgICAgICAgICBtb25pdG9yLlRocm93KFR5cGVFcnJvck9iamVjdCwgJ0Vycm9yIG9iamVjdCBleHBlY3RlZCcsIGJvdCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5hbWUgPSB0aGlzQXJnLkdldChjb25zdGFudHMubmFtZSk7XG4gICAgICAgIGlmIChuYW1lLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5hbWUudmFsdWUgPSAnRXJyb3InO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYy5wdXNoUEMobmFtZS5sYWJlbCk7XG4gICAgICAgICAgICBuYW1lID0gVG9TdHJpbmdfMS5Ub1N0cmluZyhuYW1lKTtcbiAgICAgICAgICAgIGMucG9wUEMoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbXNnID0gdGhpc0FyZy5HZXQoY29uc3RhbnRzLm1lc3NhZ2UpO1xuICAgICAgICBpZiAobXNnLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG1zZy52YWx1ZSA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYy5wdXNoUEMobXNnLmxhYmVsKTtcbiAgICAgICAgICAgIG1zZyA9IFRvU3RyaW5nXzEuVG9TdHJpbmcobXNnKTtcbiAgICAgICAgICAgIGMucG9wUEMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZS52YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgIG1zZy5yYWlzZShuYW1lLmxhYmVsKTtcbiAgICAgICAgICAgIHJldHVybiBtc2c7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1zZy52YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgIG5hbWUucmFpc2UobXNnLmxhYmVsKTtcbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIG5hbWUudmFsdWUgKz0gJzogJyArIG1zZy52YWx1ZTtcbiAgICAgICAgbmFtZS5yYWlzZShtc2cubGFiZWwpO1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgdmFyIEVycm9yT2JqZWN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoRXJyb3JPYmplY3QsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEVycm9yT2JqZWN0KHYpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy5Qcm90b3R5cGUgPSBuZXcgdmFsdWVzXzEuVmFsdWUobW9uaXRvci5pbnN0YW5jZXMuRXJyb3JQcm90b3R5cGUsIGJvdCk7XG4gICAgICAgICAgICBfdGhpcy5DbGFzcyA9ICdFcnJvcic7XG4gICAgICAgICAgICBfdGhpcy5FeHRlbnNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh2LnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2ID0gVG9TdHJpbmdfMS5Ub1N0cmluZyh2KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5EZWZpbmVPd25Qcm9wZXJ0eShjb25zdGFudHMubWVzc2FnZSwgeyB2YWx1ZTogdi52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IHYubGFiZWwsXG4gICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEVycm9yT2JqZWN0O1xuICAgIH0oRWNtYSkpO1xuICAgIEVycm9yT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0ciA9IFRvU3RyaW5nXzEuVG9TdHJpbmcobmV3IHZhbHVlc18xLlZhbHVlKHRoaXMsIGJvdCkpO1xuICAgICAgICByZXR1cm4gc3RyLnZhbHVlO1xuICAgIH07XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gMTUuMTEuNyBUaGUgTmF0aXZlRXJyb3IgQ29uc3RydWN0b3JcbiAgICB2YXIgTmF0aXZlRXJyb3JDb25zdHJ1Y3RvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKE5hdGl2ZUVycm9yQ29uc3RydWN0b3IsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIE5hdGl2ZUVycm9yQ29uc3RydWN0b3IoZ2xvYmFsLCBuYW1lKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMuQ2xhc3MgPSAnRnVuY3Rpb24nO1xuICAgICAgICAgICAgX3RoaXMuUHJvdG90eXBlID0gbmV3IHZhbHVlc18xLlZhbHVlKG1vbml0b3IuaW5zdGFuY2VzLkZ1bmN0aW9uUHJvdG90eXBlLCBib3QpO1xuICAgICAgICAgICAgX3RoaXMuRXh0ZW5zaWJsZSA9IHRydWU7XG4gICAgICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgIF90aGlzLmhvc3QgPSBnbG9iYWxbbmFtZV07XG4gICAgICAgICAgICBfdGhpcy5fcHJvdG8gPSBuZXcgTmF0aXZlRXJyb3JQcm90b3R5cGUoX3RoaXMsIG5hbWUpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVGRkYoX3RoaXMsIGNvbnN0YW50cy5sZW5ndGgsIDEpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVGRkYoX3RoaXMsIGNvbnN0YW50cy5wcm90b3R5cGUsIF90aGlzLl9wcm90byk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE5hdGl2ZUVycm9yQ29uc3RydWN0b3I7XG4gICAgfShFY21hKSk7XG4gICAgTmF0aXZlRXJyb3JDb25zdHJ1Y3Rvci5wcm90b3R5cGUuSGFzSW5zdGFuY2UgPSBIYXNJbnN0YW5jZV8xLkhhc0luc3RhbmNlO1xuICAgIC8vIDE1LjExLjcuMlxuICAgIE5hdGl2ZUVycm9yQ29uc3RydWN0b3IucHJvdG90eXBlLkNhbGwgPSBmdW5jdGlvbiAodGhpc0FyZywgYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5Db25zdHJ1Y3QoYXJncyk7XG4gICAgfTtcbiAgICAvLyAxNS4xMS43LjRcbiAgICBOYXRpdmVFcnJvckNvbnN0cnVjdG9yLnByb3RvdHlwZS5Db25zdHJ1Y3QgPSBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IGFyZ3NbMF0gfHwgbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgYm90KTtcbiAgICAgICAgdmFyIG8gPSBuZXcgTmF0aXZlRXJyb3JPYmplY3QodGhpcy5fcHJvdG8sIG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gbmV3IHZhbHVlc18xLlZhbHVlKG8sIGJvdCk7XG4gICAgfTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyAxNS4xMS43LjYgVGhlIE5hdGl2ZUVycm9yIFByb3RvdHlwZVxuICAgIHZhciBOYXRpdmVFcnJvclByb3RvdHlwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKE5hdGl2ZUVycm9yUHJvdG90eXBlLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBOYXRpdmVFcnJvclByb3RvdHlwZShjb25zdHJ1Y3RvciwgbmFtZSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLkNsYXNzID0gJ0Vycm9yJztcbiAgICAgICAgICAgIF90aGlzLlByb3RvdHlwZSA9IG5ldyB2YWx1ZXNfMS5WYWx1ZShtb25pdG9yLmluc3RhbmNlcy5PYmplY3RQcm90b3R5cGUsIGJvdCk7XG4gICAgICAgICAgICBlY21hLkRlZmluZVRGVChfdGhpcywgY29uc3RhbnRzLmNvbnN0cnVjdG9yLCBjb25zdHJ1Y3Rvcik7XG4gICAgICAgICAgICBlY21hLkRlZmluZVRGVChfdGhpcywgY29uc3RhbnRzLm5hbWUsIG5hbWUpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXMsIGNvbnN0YW50cy5tZXNzYWdlLCAnJyk7XG4gICAgICAgICAgICBlY21hLkRlZmluZVRGVChfdGhpcywgY29uc3RhbnRzLnRvU3RyaW5nLCBuZXcgZnVuY3Rpb25fMS5CdWlsdGluRnVuY3Rpb25PYmplY3QodG9zdHJpbmcsIDAsIHVuZGVmaW5lZCkpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOYXRpdmVFcnJvclByb3RvdHlwZTtcbiAgICB9KEVjbWEpKTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICB2YXIgTmF0aXZlRXJyb3JPYmplY3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhOYXRpdmVFcnJvck9iamVjdCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gTmF0aXZlRXJyb3JPYmplY3QocHJvdG8sIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy5Qcm90b3R5cGUgPSBuZXcgdmFsdWVzXzEuVmFsdWUocHJvdG8sIGJvdCk7XG4gICAgICAgICAgICBfdGhpcy5DbGFzcyA9ICdFcnJvcic7XG4gICAgICAgICAgICBfdGhpcy5FeHRlbnNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIF90aGlzLnN0YWNrID0gbW9uaXRvci5zdGFja1RyYWNlKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFRvU3RyaW5nXzEuVG9TdHJpbmcobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuRGVmaW5lT3duUHJvcGVydHkoY29uc3RhbnRzLm1lc3NhZ2UsIHsgdmFsdWU6IG1lc3NhZ2UudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiBtZXNzYWdlLmxhYmVsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE5hdGl2ZUVycm9yT2JqZWN0O1xuICAgIH0oRWNtYSkpO1xuICAgIE5hdGl2ZUVycm9yT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0ciA9IFRvU3RyaW5nXzEuVG9TdHJpbmcobmV3IHZhbHVlc18xLlZhbHVlKHRoaXMsIGJvdCkpO1xuICAgICAgICByZXR1cm4gc3RyLnZhbHVlO1xuICAgIH07XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gXG4gICAgdmFyIEV2YWxFcnJvck9iamVjdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKEV2YWxFcnJvck9iamVjdCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gRXZhbEVycm9yT2JqZWN0KHYpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1vbml0b3IuaW5zdGFuY2VzLkV2YWxFcnJvclByb3RvdHlwZSwgdikgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLlR5cGUgPSAnRXZhbEVycm9yJztcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRXZhbEVycm9yT2JqZWN0O1xuICAgIH0oTmF0aXZlRXJyb3JPYmplY3QpKTtcbiAgICB2YXIgUmFuZ2VFcnJvck9iamVjdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKFJhbmdlRXJyb3JPYmplY3QsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFJhbmdlRXJyb3JPYmplY3Qodikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbW9uaXRvci5pbnN0YW5jZXMuUmFuZ2VFcnJvclByb3RvdHlwZSwgdikgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLlR5cGUgPSAnUmFuZ2VFcnJvcic7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJhbmdlRXJyb3JPYmplY3Q7XG4gICAgfShOYXRpdmVFcnJvck9iamVjdCkpO1xuICAgIHZhciBSZWZlcmVuY2VFcnJvck9iamVjdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKFJlZmVyZW5jZUVycm9yT2JqZWN0LCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBSZWZlcmVuY2VFcnJvck9iamVjdCh2KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtb25pdG9yLmluc3RhbmNlcy5SZWZlcmVuY2VFcnJvclByb3RvdHlwZSwgdikgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLlR5cGUgPSAnUmVmZXJlbmNlRXJyb3InO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSZWZlcmVuY2VFcnJvck9iamVjdDtcbiAgICB9KE5hdGl2ZUVycm9yT2JqZWN0KSk7XG4gICAgdmFyIFN5bnRheEVycm9yT2JqZWN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoU3ludGF4RXJyb3JPYmplY3QsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFN5bnRheEVycm9yT2JqZWN0KHYpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1vbml0b3IuaW5zdGFuY2VzLlN5bnRheEVycm9yUHJvdG90eXBlLCB2KSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMuVHlwZSA9ICdTeW50YXhFcnJvcic7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN5bnRheEVycm9yT2JqZWN0O1xuICAgIH0oTmF0aXZlRXJyb3JPYmplY3QpKTtcbiAgICB2YXIgVHlwZUVycm9yT2JqZWN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoVHlwZUVycm9yT2JqZWN0LCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBUeXBlRXJyb3JPYmplY3Qodikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbW9uaXRvci5pbnN0YW5jZXMuVHlwZUVycm9yUHJvdG90eXBlLCB2KSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMuVHlwZSA9ICdUeXBlRXJyb3InO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBUeXBlRXJyb3JPYmplY3Q7XG4gICAgfShOYXRpdmVFcnJvck9iamVjdCkpO1xuICAgIHZhciBVUklFcnJvck9iamVjdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKFVSSUVycm9yT2JqZWN0LCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBVUklFcnJvck9iamVjdCh2KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtb25pdG9yLmluc3RhbmNlcy5VcmlFcnJvclByb3RvdHlwZSwgdikgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLlR5cGUgPSAnVVJJRXJyb3InO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBVUklFcnJvck9iamVjdDtcbiAgICB9KE5hdGl2ZUVycm9yT2JqZWN0KSk7XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgdmFyIG1vZHVsZSA9IHt9O1xuICAgIG1vZHVsZS5FdmFsRXJyb3JPYmplY3QgPSBFdmFsRXJyb3JPYmplY3Q7XG4gICAgbW9kdWxlLlJhbmdlRXJyb3JPYmplY3QgPSBSYW5nZUVycm9yT2JqZWN0O1xuICAgIG1vZHVsZS5SZWZlcmVuY2VFcnJvck9iamVjdCA9IFJlZmVyZW5jZUVycm9yT2JqZWN0O1xuICAgIG1vZHVsZS5TeW50YXhFcnJvck9iamVjdCA9IFN5bnRheEVycm9yT2JqZWN0O1xuICAgIG1vZHVsZS5UeXBlRXJyb3JPYmplY3QgPSBUeXBlRXJyb3JPYmplY3Q7XG4gICAgbW9kdWxlLlVSSUVycm9yT2JqZWN0ID0gVVJJRXJyb3JPYmplY3Q7XG4gICAgbW9kdWxlLkVycm9yT2JqZWN0ID0gRXJyb3JPYmplY3Q7XG4gICAgbW9kdWxlLmFsbG9jYXRlID0gYWxsb2NhdGU7XG4gICAgbW9kdWxlLm5hdGl2ZVRhYmxlID0ge1xuICAgICAgICAnRXJyb3InOiBFcnJvck9iamVjdCxcbiAgICAgICAgJ0V2YWxFcnJvcic6IEV2YWxFcnJvck9iamVjdCxcbiAgICAgICAgJ1JhbmdlRXJyb3InOiBSYW5nZUVycm9yT2JqZWN0LFxuICAgICAgICAnUmVmZXJlbmNlRXJyb3InOiBSZWZlcmVuY2VFcnJvck9iamVjdCxcbiAgICAgICAgJ1N5bnRheEVycm9yJzogU3ludGF4RXJyb3JPYmplY3QsXG4gICAgICAgICdUeXBlRXJyb3InOiBUeXBlRXJyb3JPYmplY3QsXG4gICAgICAgICdVUklFcnJvcic6IFVSSUVycm9yT2JqZWN0XG4gICAgfTtcbiAgICByZXR1cm4gbW9kdWxlO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9yLmpzLm1hcCIsIi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbGFiZWwgPSByZXF1aXJlKFwiLi9sYWJlbFwiKTtcbnZhciBwcCA9IHJlcXVpcmUoXCIuL3BwXCIpO1xudmFyIHZhbHVlc18xID0gcmVxdWlyZShcIi4vdmFsdWVzXCIpO1xudmFyIGNvbnRleHRfMSA9IHJlcXVpcmUoXCIuL2NvbnRleHRcIik7XG52YXIgZW52ID0gcmVxdWlyZShcIi4vZW52XCIpO1xudmFyIGVjbWEgPSByZXF1aXJlKFwiLi9lY21hXCIpO1xudmFyIHNldF8xID0gcmVxdWlyZShcIi4vc2V0XCIpO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbnZhciBlc3ByaW1hID0gcmVxdWlyZShcImVzcHJpbWFcIik7XG52YXIgZnVuY3Rpb25fMSA9IHJlcXVpcmUoXCIuL2Z1bmN0aW9uXCIpO1xudmFyIEZ1bmN0aW9uT2JqZWN0XzEgPSByZXF1aXJlKFwiLi9PYmplY3RzL0Z1bmN0aW9uT2JqZWN0XCIpO1xudmFyIE9iamVjdE9iamVjdF8xID0gcmVxdWlyZShcIi4vT2JqZWN0cy9PYmplY3RPYmplY3RcIik7XG52YXIgQXJyYXlPYmplY3RfMSA9IHJlcXVpcmUoXCIuL09iamVjdHMvQXJyYXlPYmplY3RcIik7XG52YXIgVG9Cb29sZWFuXzEgPSByZXF1aXJlKFwiLi9Db252ZXJzaW9uL1RvQm9vbGVhblwiKTtcbnZhciBUb1ByaW1pdGl2ZV8xID0gcmVxdWlyZShcIi4vQ29udmVyc2lvbi9Ub1ByaW1pdGl2ZVwiKTtcbnZhciBUb051bWJlcl8xID0gcmVxdWlyZShcIi4vQ29udmVyc2lvbi9Ub051bWJlclwiKTtcbnZhciBUb0ludDMyXzEgPSByZXF1aXJlKFwiLi9Db252ZXJzaW9uL1RvSW50MzJcIik7XG52YXIgVG9VSW50MzJfMSA9IHJlcXVpcmUoXCIuL0NvbnZlcnNpb24vVG9VSW50MzJcIik7XG52YXIgVG9TdHJpbmdfMSA9IHJlcXVpcmUoXCIuL0NvbnZlcnNpb24vVG9TdHJpbmdcIik7XG52YXIgVG9PYmplY3RfMSA9IHJlcXVpcmUoXCIuL0NvbnZlcnNpb24vVG9PYmplY3RcIik7XG52YXIgQ2hlY2tPYmplY3RDb2VyY2libGVfMSA9IHJlcXVpcmUoXCIuL1V0aWxpdHkvQ2hlY2tPYmplY3RDb2VyY2libGVcIik7XG52YXIgSXNDYWxsYWJsZV8xID0gcmVxdWlyZShcIi4vVXRpbGl0eS9Jc0NhbGxhYmxlXCIpO1xuZXhwb3J0cy5mdW5jdG9yID0gZnVuY3Rpb24gKG1vbml0b3IpIHtcbiAgICB2YXIgZXJyb3IgPSBtb25pdG9yLnJlcXVpcmUoJ2Vycm9yJyk7XG4gICAgdmFyIHJlZ2V4cCA9IG1vbml0b3IucmVxdWlyZSgncmVnZXhwJyk7XG4gICAgdmFyIFJlZ0V4cE9iamVjdCA9IHJlZ2V4cC5SZWdFeHBPYmplY3Q7XG4gICAgdmFyIExhYmVsID0gbGFiZWwuTGFiZWw7XG4gICAgdmFyIGx1YiA9IGxhYmVsLmx1YjtcbiAgICB2YXIgbGUgPSBsYWJlbC5sZTtcbiAgICB2YXIgYm90ID0gTGFiZWwuYm90O1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHZhciBydW5mb3JfYWxsID0geyAndGhyb3cnOiB0cnVlLCAnY29udGludWUnOiB0cnVlLCAnYnJlYWsnOiB0cnVlIH07XG4gICAgdmFyIHJ1bmZvcl90aHJvdyA9IHsgJ3Rocm93JzogdHJ1ZSB9O1xuICAgIHZhciBydW5mb3JfY29udGludWUgPSB7ICdjb250aW51ZSc6IHRydWUgfTtcbiAgICB2YXIgcnVuZm9yX2JyZWFrID0geyAnYnJlYWsnOiB0cnVlIH07XG4gICAgdmFyIHJ1bmZvcl9jb250aW51ZV9icmVhayA9IHsgJ2JyZWFrJzogdHJ1ZSwgJ2NvbnRpbnVlJzogdHJ1ZSB9O1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gICAgICAgIHZhciBnbG9iYWwgPSBtb25pdG9yLmluc3RhbmNlcy5nbG9iYWxPYmplY3Q7XG4gICAgICAgIHZhciBnbG9iYWxFbnYgPSBlbnYuTmV3T2JqZWN0RW52aXJvbm1lbnQobmV3IHZhbHVlc18xLlZhbHVlKGdsb2JhbCwgYm90KSwgbmV3IHZhbHVlc18xLlZhbHVlKG51bGwsIGJvdCkpO1xuICAgICAgICBtb25pdG9yLmluc3RhbmNlcy5nbG9iYWxFbnZpcm9ubWVudCA9IGdsb2JhbEVudjtcbiAgICAgICAgbW9uaXRvci5jb250ZXh0LnRoaXNWYWx1ZSA9IG5ldyB2YWx1ZXNfMS5WYWx1ZShnbG9iYWwsIGJvdCk7XG4gICAgICAgIG1vbml0b3IuY29udGV4dC52YXJpYWJsZUVudiA9IG5ldyB2YWx1ZXNfMS5WYWx1ZShnbG9iYWxFbnYsIGJvdCk7XG4gICAgICAgIG1vbml0b3IuY29udGV4dC5sZXhpY2FsRW52ID0gbmV3IHZhbHVlc18xLlZhbHVlKGdsb2JhbEVudiwgYm90KTtcbiAgICAgICAgLy8gc2V0IFRocm93VHlwZUVycm9yIG9iamVjdCBpbiBmdW5jdGlvbiwgYXMgd2Ugbm93IGhhdmUgZ2xvYmFsIGVudmlyb25tZW50XG4gICAgICAgIG1vbml0b3IuaW5zdGFuY2VzLlRocm93VHlwZUVycm9yID0gbmV3IGZ1bmN0aW9uXzEuVGhyb3dUeXBlRXJyb3IoKTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gcnVubmluZygpIHtcbiAgICAgICAgcmV0dXJuICFtb25pdG9yLmNvbnRleHQud29ya0xpc3QuZW1wdHkoKTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gZXhlY3V0ZShhc3QsIGRlYnVnRW5hYmxlZCkge1xuICAgICAgICBtb25pdG9yLmNvbnRleHQud29ya0xpc3QucHVzaChhc3QpO1xuICAgICAgICBtb25pdG9yLmNvbnRleHQucmVzdWx0ID0gbmV3IGNvbnRleHRfMS5SZXN1bHQoKTtcbiAgICAgICAgaWYgKGRlYnVnRW5hYmxlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkZWJ1Z0VuYWJsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGVwQ291bnQgPSAwO1xuICAgICAgICB2YXIgY29udCA9IHRydWU7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChkZWJ1Z0VuYWJsZWQgJiYgbW9uaXRvci5kZWJ1Zy5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9uaXRvci5jb250ZXh0LnJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnQgPSBzdGVwKCk7XG4gICAgICAgICAgICBzdGVwQ291bnQrKztcbiAgICAgICAgICAgIGlmIChzdGVwQ291bnQgJSAxMDAwMDAwID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbW9uaXRvci5sb2coJ0V4ZWN1dGluZyAnLCBzdGVwQ291bnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChjb250KTtcbiAgICAgICAgbW9uaXRvci5sb2coJ0ZpbmFsIG51bWJlciBvZiBleGVjdXRpb24gc3RlcHM6ICcsIHN0ZXBDb3VudCk7XG4gICAgICAgIHJldHVybiBtb25pdG9yLmNvbnRleHQucmVzdWx0O1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiByZXN1bWUoKSB7XG4gICAgICAgIHZhciBjb250ID0gdHJ1ZTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgY29udCA9IHN0ZXAoKTtcbiAgICAgICAgICAgIGlmIChtb25pdG9yLmRlYnVnLmFjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb25pdG9yLmNvbnRleHQucmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChjb250KTtcbiAgICAgICAgcmV0dXJuIG1vbml0b3IuY29udGV4dC5yZXN1bHQ7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIGV4ZWN1dGVHbG9iYWxDb2RlKGNvZGUsIGZpbGVuYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtb25pdG9yLmNvZGUgPSBjb2RlO1xuICAgICAgICAgICAgbW9uaXRvci5hc3QgPSBlc3ByaW1hLnBhcnNlKGNvZGUsIHsgbG9jOiB0cnVlLCByYW5nZTogdHJ1ZSwgdG9sZXJhbnQ6IHRydWUsIHNvdXJjZTogZmlsZW5hbWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHZhciBtc2cgPSBlLmRlc2NyaXB0aW9uICsgJyBpbiAnICsgZmlsZW5hbWUgKyAnOicgKyBlLmxpbmVOdW1iZXIgKyAnOicgKyBlLmNvbHVtbjtcbiAgICAgICAgICAgIG1zZyA9IG5ldyB2YWx1ZXNfMS5WYWx1ZShtc2csIGJvdCk7XG4gICAgICAgICAgICB2YXIgb2JqID0gbmV3IGVycm9yLlN5bnRheEVycm9yT2JqZWN0KG1zZywgYm90KTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgY29udGV4dF8xLlJlc3VsdCgpO1xuICAgICAgICAgICAgcmVzdWx0LnR5cGUgPSAndGhyb3cnO1xuICAgICAgICAgICAgcmVzdWx0LnZhbHVlID0gbmV3IHZhbHVlc18xLlZhbHVlKG9iaiwgYm90KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlYnVnRW5hYmxlZCA9IHRydWU7XG4gICAgICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLmRlYnVnRW5hYmxlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGRlYnVnRW5hYmxlZCA9IG9wdGlvbnMuZGVidWdFbmFibGVkO1xuICAgICAgICB9XG4gICAgICAgIGVudGVyR2xvYmFsQ29kZShtb25pdG9yLmFzdCk7XG4gICAgICAgIHJldHVybiBleGVjdXRlKG1vbml0b3IuYXN0LCBkZWJ1Z0VuYWJsZWQpO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyAgIGNvbnRhaW5zIHRoZSBkZWNsYXJhdGlvbiBiaW5kaW5nICgxMC41KSBvZiBnbG9iYWwgY29kZVxuICAgIGZ1bmN0aW9uIGVudGVyR2xvYmFsQ29kZShhc3QsIGZpbGVuYW1lKSB7XG4gICAgICAgIHZhciBjID0gbW9uaXRvci5jb250ZXh0O1xuICAgICAgICAvLyAxMC41IC0gaG9pc3RpbmdcbiAgICAgICAgZnVuY3Rpb25fMS5Ib2lzdEZ1bmN0aW9ucyhjLnZhcmlhYmxlRW52LCBhc3QsIGZhbHNlLCBib3QpO1xuICAgICAgICBmdW5jdGlvbl8xLkhvaXN0VmFyaWFibGVzKGMudmFyaWFibGVFbnYsIGFzdCwgZmFsc2UsIGJvdCk7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEdldFZhbHVlLCA4LjcuMVxuICAgIGZ1bmN0aW9uIEdldFZhbHVlKHYpIHtcbiAgICAgICAgaWYgKCF2IHx8ICEodiBpbnN0YW5jZW9mIHZhbHVlc18xLlJlZmVyZW5jZSkpXG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgaWYgKHYuYmFzZS5sYWJlbCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgbW9uaXRvci5mYXRhbCgnR2V0VmFsdWUsIGJhc2UubGFiZWwgdW5kZWZpbmVkJyk7XG4gICAgICAgIGlmICh2LklzVW5yZXNvbHZhYmxlUmVmZXJlbmNlKCkpIHtcbiAgICAgICAgICAgIG1vbml0b3IuVGhyb3coZXJyb3IuUmVmZXJlbmNlRXJyb3JPYmplY3QsIHYucHJvcGVydHlOYW1lLnZhbHVlICsgJyBub3QgZGVmaW5lZCcsIHYuYmFzZS5sYWJlbCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHAgPSB2LmJhc2U7XG4gICAgICAgIHZhciBzID0gdi5wcm9wZXJ0eU5hbWU7XG4gICAgICAgIGlmICh2LklzUHJvcGVydHlSZWZlcmVuY2UoKSkge1xuICAgICAgICAgICAgaWYgKCF2Lkhhc1ByaW1pdGl2ZUJhc2UoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwLkdldChzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBvID0gVG9PYmplY3RfMS5Ub09iamVjdChwKTtcbiAgICAgICAgICAgICAgICB2YXIgZGVzYyA9IG8uR2V0UHJvcGVydHkocyk7XG4gICAgICAgICAgICAgICAgaWYgKGRlc2MudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVzYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGxibCA9IG5ldyBMYWJlbCgpO1xuICAgICAgICAgICAgICAgIGxibC5sdWIoZGVzYy5sYWJlbCwgZGVzYy52YWx1ZS5sYWJlbCk7XG4gICAgICAgICAgICAgICAgZGVzYyA9IGRlc2MudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGVjbWEuSXNEYXRhRGVzY3JpcHRvcihkZXNjKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHZhbHVlc18xLlZhbHVlKGRlc2MudmFsdWUsIGxibCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBnZXQgPSBkZXNjLmdldDtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgbGJsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbW9uaXRvci5jb250ZXh0LnB1c2hQQyhsYmwpO1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSBnZXQuQ2FsbChnZXQsIHYuYmFzZSk7XG4gICAgICAgICAgICAgICAgbW9uaXRvci5jb250ZXh0LnBvcFBDKCk7XG4gICAgICAgICAgICAgICAgcmVzLnJhaXNlKGxibCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcC5HZXRCaW5kaW5nVmFsdWUocyk7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFB1dFZhbHVlXG4gICAgZnVuY3Rpb24gUHV0VmFsdWUociwgdikge1xuICAgICAgICB2YXIgY3R4ID0gbW9uaXRvci5jb250ZXh0O1xuICAgICAgICBpZiAoIShyIGluc3RhbmNlb2YgdmFsdWVzXzEuUmVmZXJlbmNlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgICAgICBtb25pdG9yLlRocm93KGVycm9yLlJlZmVyZW5jZUVycm9yT2JqZWN0LCAnUHV0VmFsdWU6IHRhcmdldCBpcyBub3QgYSByZWZlcmVuY2UnLCByLmxhYmVsKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcCA9IHIuYmFzZTtcbiAgICAgICAgdmFyIHMgPSByLnByb3BlcnR5TmFtZTtcbiAgICAgICAgaWYgKHIuSXNVbnJlc29sdmFibGVSZWZlcmVuY2UoKSkge1xuICAgICAgICAgICAgcC52YWx1ZSA9IG1vbml0b3IuaW5zdGFuY2VzLmdsb2JhbE9iamVjdDtcbiAgICAgICAgICAgIHAuUHV0KHMsIHYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHIuSXNQcm9wZXJ0eVJlZmVyZW5jZSgpKSB7XG4gICAgICAgICAgICBpZiAoci5IYXNQcmltaXRpdmVCYXNlKCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbyA9IFRvT2JqZWN0XzEuVG9PYmplY3QocCk7XG4gICAgICAgICAgICAgICAgaWYgKCFvLkNhblB1dChzKS52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBvd25EZXNjID0gby5HZXRPd25Qcm9wZXJ0eShzKTtcbiAgICAgICAgICAgICAgICBpZiAob3duRGVzYy52YWx1ZSAmJiBlY21hLklzRGF0YURlc2NyaXB0b3Iob3duRGVzYy52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZGVzYyA9IG8uR2V0UHJvcGVydHkocyk7XG4gICAgICAgICAgICAgICAgaWYgKGRlc2MudmFsdWUgJiYgZWNtYS5Jc0FjY2Vzc29yRGVzY3JpcHRvcihkZXNjLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBtb25pdG9yLmNvbnRleHQucHVzaFBDKGx1Yihvd25EZXNjLmxhYmVsLCBkZXNjLmxhYmVsKSk7IC8vIGNvbnRhaW5zIG8ubGFiZWxcbiAgICAgICAgICAgICAgICAgICAgZGVzYy52YWx1ZS5TZXQuQ2FsbChwLCBbdl0pO1xuICAgICAgICAgICAgICAgICAgICBtb25pdG9yLmNvbnRleHQucG9wUEMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwLlB1dChzLCB2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHAuU2V0TXV0YWJsZUJpbmRpbmcocywgdik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFVuYXJ5IG9wZXJhdG9yc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBVbmFyeSAtLCAxMS40LjdcbiAgICBmdW5jdGlvbiB1bmFyeU1pbnVzKHdsLCB2cykge1xuICAgICAgICB2YXIgcmVmID0gdnMucG9wKCk7XG4gICAgICAgIHZhciBuID0gVG9OdW1iZXJfMS5Ub051bWJlcihHZXRWYWx1ZShyZWYpKTtcbiAgICAgICAgbi52YWx1ZSA9IC1uLnZhbHVlO1xuICAgICAgICB2cy5wdXNoKG4pO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gVW5hcnkgKywgMTEuNC42XG4gICAgZnVuY3Rpb24gdW5hcnlQbHVzKHdsLCB2cykge1xuICAgICAgICB2YXIgcmVmID0gdnMucG9wKCk7XG4gICAgICAgIHZhciBuID0gVG9OdW1iZXJfMS5Ub051bWJlcihHZXRWYWx1ZShyZWYpKTtcbiAgICAgICAgdnMucHVzaChuKTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIExvZ2ljYWwgTk9ULCAxMS40LjlcbiAgICBmdW5jdGlvbiB1bmFyeUxvZ2ljYWxOb3Qod2wsIHZzKSB7XG4gICAgICAgIHZhciByZWYgPSB2cy5wb3AoKTtcbiAgICAgICAgdmFyIGIgPSBUb0Jvb2xlYW5fMS5Ub0Jvb2xlYW4oR2V0VmFsdWUocmVmKSk7XG4gICAgICAgIGIudmFsdWUgPSAhYi52YWx1ZTtcbiAgICAgICAgdnMucHVzaChiKTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEJpdHdpc2UgTk9ULCAxMS40LjhcbiAgICBmdW5jdGlvbiB1bmFyeUJpdHdpc2VOb3Qod2wsIHZzKSB7XG4gICAgICAgIHZhciByZWYgPSB2cy5wb3AoKTtcbiAgICAgICAgdmFyIG4gPSBUb0ludDMyXzEuVG9JbnQzMihHZXRWYWx1ZShyZWYpKTtcbiAgICAgICAgbi52YWx1ZSA9IH5uLnZhbHVlO1xuICAgICAgICB2cy5wdXNoKG4pO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gVGhlIHR5cGVvZiBPcGVyYXRvciwgMTEuNC4zXG4gICAgZnVuY3Rpb24gdW5hcnlUeXBlb2Yod2wsIHZzKSB7XG4gICAgICAgIHZhciByZWYgPSB2cy5wb3AoKTtcbiAgICAgICAgdmFyIGlzUmVmID0gKHJlZiBpbnN0YW5jZW9mIHZhbHVlc18xLlJlZmVyZW5jZSk7XG4gICAgICAgIGlmIChpc1JlZiAmJiByZWYuSXNVbnJlc29sdmFibGVSZWZlcmVuY2UoKSkge1xuICAgICAgICAgICAgdnMucHVzaChuZXcgdmFsdWVzXzEuVmFsdWUoJ3VuZGVmaW5lZCcsIHJlZi5iYXNlLmxhYmVsKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgdmFsO1xuICAgICAgICAgICAgaWYgKGlzUmVmKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gR2V0VmFsdWUocmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbCA9IHJlZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWwudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2cy5wdXNoKG5ldyB2YWx1ZXNfMS5WYWx1ZSgnb2JqZWN0JywgdmFsLmxhYmVsKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwudmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCdDYWxsJyBpbiB2YWwudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdnMucHVzaChuZXcgdmFsdWVzXzEuVmFsdWUoJ2Z1bmN0aW9uJywgdmFsLmxhYmVsKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2cy5wdXNoKG5ldyB2YWx1ZXNfMS5WYWx1ZSgnb2JqZWN0JywgdmFsLmxhYmVsKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdnMucHVzaChuZXcgdmFsdWVzXzEuVmFsdWUodHlwZW9mIHZhbC52YWx1ZSwgdmFsLmxhYmVsKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFRoZSB2b2lkIE9wZXJhdG9yLCAxMS40LjJcbiAgICBmdW5jdGlvbiB1bmFyeVZvaWQod2wsIHZzKSB7XG4gICAgICAgIHZhciByZWYgPSB2cy5wb3AoKTtcbiAgICAgICAgdmFyIF9pZ25vcmUgPSBHZXRWYWx1ZShyZWYpO1xuICAgICAgICB2cy5wdXNoKG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIGJvdCkpO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gVGhlIGRlbGV0ZSBPcGVyYXRvciwgMTEuNC4xXG4gICAgZnVuY3Rpb24gdW5hcnlEZWxldGUod2wsIHZzKSB7XG4gICAgICAgIHZhciByZWYgPSB2cy5wb3AoKTtcbiAgICAgICAgaWYgKHJlZiBpbnN0YW5jZW9mIHZhbHVlc18xLlJlZmVyZW5jZSkge1xuICAgICAgICAgICAgaWYgKHJlZi5Jc1VucmVzb2x2YWJsZVJlZmVyZW5jZSgpKSB7XG4gICAgICAgICAgICAgICAgdnMucHVzaChuZXcgdmFsdWVzXzEuVmFsdWUodHJ1ZSwgcmVmLmJhc2UubGFiZWwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChyZWYuSXNQcm9wZXJ0eVJlZmVyZW5jZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvYmplY3QgPSBUb09iamVjdF8xLlRvT2JqZWN0KHJlZi5iYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgdnMucHVzaChvYmplY3QuRGVsZXRlKHJlZi5wcm9wZXJ0eU5hbWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZzLnB1c2gocmVmLmJhc2UuRGVsZXRlQmluZGluZyhyZWYucHJvcGVydHlOYW1lKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdnMucHVzaChuZXcgdmFsdWVzXzEuVmFsdWUodHJ1ZSwgcmVmLmxhYmVsKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHZhciB1bmFyeXRibCA9IHtcbiAgICAgICAgJy0nOiB1bmFyeU1pbnVzLFxuICAgICAgICAnKyc6IHVuYXJ5UGx1cyxcbiAgICAgICAgJyEnOiB1bmFyeUxvZ2ljYWxOb3QsXG4gICAgICAgICd+JzogdW5hcnlCaXR3aXNlTm90LFxuICAgICAgICAndHlwZW9mJzogdW5hcnlUeXBlb2YsXG4gICAgICAgICd2b2lkJzogdW5hcnlWb2lkLFxuICAgICAgICAnZGVsZXRlJzogdW5hcnlEZWxldGVcbiAgICB9O1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBFcXVhbGl0eSBPcGVyYXRvcnMsIDExLjlcbiAgICBmdW5jdGlvbiBiaW5hcnlFcXMob3AsIHdsLCB2cykge1xuICAgICAgICB2YXIgcnZhbCA9IHZzLnBvcCgpO1xuICAgICAgICB2YXIgbHZhbCA9IHZzLnBvcCgpO1xuICAgICAgICB2YXIgcmVzO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgdmFyIGx0ID0gdHlwZW9mIGx2YWwudmFsdWU7XG4gICAgICAgICAgICB2YXIgcnQgPSB0eXBlb2YgcnZhbC52YWx1ZTtcbiAgICAgICAgICAgIGx0ID0gbHZhbC52YWx1ZSA9PT0gdW5kZWZpbmVkID8gJ3VuZGVmaW5lZCcgOiBsdDtcbiAgICAgICAgICAgIHJ0ID0gcnZhbC52YWx1ZSA9PT0gdW5kZWZpbmVkID8gJ3VuZGVmaW5lZCcgOiBydDtcbiAgICAgICAgICAgIGx0ID0gbHZhbC52YWx1ZSA9PT0gbnVsbCA/ICdudWxsJyA6IGx0O1xuICAgICAgICAgICAgcnQgPSBydmFsLnZhbHVlID09PSBudWxsID8gJ251bGwnIDogcnQ7XG4gICAgICAgICAgICAvLyBtdXN0IHVzZSBzdHJpY3QgaW4gb3JkZXIgbm90IHRvIHRyaWdnZXIgY29udmVyc2lvblxuICAgICAgICAgICAgLy8gICBidXQgdGhlbiBudWxsIGFuZCB1bmRlZmluZWQgbXVzdCBiZSBoYW5kbGVkIHNlcGFyYXRlbHlcbiAgICAgICAgICAgIGlmIChsdCA9PT0gcnQpIHtcbiAgICAgICAgICAgICAgICByZXMgPSBuZXcgdmFsdWVzXzEuVmFsdWUobHZhbC52YWx1ZSA9PT0gcnZhbC52YWx1ZSwgbHViKGx2YWwubGFiZWwsIHJ2YWwubGFiZWwpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgobHZhbC52YWx1ZSA9PT0gbnVsbCAmJiBydmFsLnZhbHVlID09PSB1bmRlZmluZWQpIHx8XG4gICAgICAgICAgICAgICAgKGx2YWwudmFsdWUgPT09IHVuZGVmaW5lZCAmJiBydmFsLnZhbHVlID09PSBudWxsKSkge1xuICAgICAgICAgICAgICAgIHJlcyA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSh0cnVlLCBsdWIobHZhbC5sYWJlbCwgcnZhbC5sYWJlbCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGx0ID09PSAnbnVtYmVyJyAmJiBydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBydmFsID0gVG9OdW1iZXJfMS5Ub051bWJlcihydmFsKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsdCA9PT0gJ3N0cmluZycgJiYgcnQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgbHZhbCA9IFRvTnVtYmVyXzEuVG9OdW1iZXIobHZhbCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobHQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGx2YWwgPSBUb051bWJlcl8xLlRvTnVtYmVyKGx2YWwpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJ0ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBydmFsID0gVG9OdW1iZXJfMS5Ub051bWJlcihydmFsKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgobHQgPT09ICdzdHJpbmcnIHx8IGx0ID09PSAnbnVtYmVyJykgJiZcbiAgICAgICAgICAgICAgICBydCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBydmFsID0gVG9QcmltaXRpdmVfMS5Ub1ByaW1pdGl2ZShydmFsKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICAocnQgPT09ICdzdHJpbmcnIHx8IHJ0ID09PSAnbnVtYmVyJykpIHtcbiAgICAgICAgICAgICAgICBsdmFsID0gVG9QcmltaXRpdmVfMS5Ub1ByaW1pdGl2ZShsdmFsKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcyA9IG5ldyB2YWx1ZXNfMS5WYWx1ZShmYWxzZSwgbHViKGx2YWwubGFiZWwsIHJ2YWwubGFiZWwpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcCA9PT0gJyE9Jykge1xuICAgICAgICAgICAgcmVzLnZhbHVlID0gIXJlcy52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB2cy5wdXNoKHJlcyk7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBTdHJpY3QgRXF1YWxpdHkgT3BlcmF0b3JzLCAxMS45LjQsIDExLjkuNVxuICAgIGZ1bmN0aW9uIGJpbmFyeVN0cmljdEVxcyhvcCwgd2wsIHZzKSB7XG4gICAgICAgIHZhciBydmFsID0gdnMucG9wKCk7XG4gICAgICAgIHZhciBsdmFsID0gdnMucG9wKCk7XG4gICAgICAgIHZhciByZXMgPSBuZXcgdmFsdWVzXzEuVmFsdWUobHZhbC52YWx1ZSA9PT0gcnZhbC52YWx1ZSwgbHViKGx2YWwubGFiZWwsIHJ2YWwubGFiZWwpKTtcbiAgICAgICAgaWYgKG9wID09PSAnIT09Jykge1xuICAgICAgICAgICAgcmVzLnZhbHVlID0gIXJlcy52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB2cy5wdXNoKHJlcyk7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBSZWxhdGlvbmFsIE9wZXJhdG9ycywgMTEuOFxuICAgIC8vICBUaGUgZXZhbHVhdGlvbiBvcmRlciBpcyBpbXBvcnRhbnQsIDExLjguNVxuICAgIGZ1bmN0aW9uIGJpbmFyeU9yZHMob3AsIHdsLCB2cykge1xuICAgICAgICB2YXIgcnZhbCA9IHZzLnBvcCgpO1xuICAgICAgICB2YXIgbHZhbCA9IHZzLnBvcCgpO1xuICAgICAgICB2YXIgbHByaW0gPSBUb1ByaW1pdGl2ZV8xLlRvUHJpbWl0aXZlKGx2YWwpO1xuICAgICAgICB2YXIgcnByaW0gPSBUb1ByaW1pdGl2ZV8xLlRvUHJpbWl0aXZlKHJ2YWwpO1xuICAgICAgICB2YXIgcmVzO1xuICAgICAgICBpZiAodHlwZW9mIGxwcmltLnZhbHVlICE9PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgdHlwZW9mIHJwcmltLnZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFyIGxudW0gPSBUb051bWJlcl8xLlRvTnVtYmVyKGxwcmltKTtcbiAgICAgICAgICAgIHZhciBybnVtID0gVG9OdW1iZXJfMS5Ub051bWJlcihycHJpbSk7XG4gICAgICAgICAgICB2YXIgdmFsID0gZXZhbCgnbG51bS52YWx1ZSAnICsgb3AgKyAnIHJudW0udmFsdWUnKTtcbiAgICAgICAgICAgIHJlcyA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSh2YWwsIGx1YihsbnVtLmxhYmVsLCBybnVtLmxhYmVsKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gZXZhbCgnbHByaW0udmFsdWUgJyArIG9wICsgJyBycHJpbS52YWx1ZScpO1xuICAgICAgICAgICAgcmVzID0gbmV3IHZhbHVlc18xLlZhbHVlKHZhbCwgbHViKGxwcmltLmxhYmVsLCBycHJpbS5sYWJlbCkpO1xuICAgICAgICB9XG4gICAgICAgIHZzLnB1c2gocmVzKTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEJpdHdpc2UgU2hpZnQgT3BlcmF0b3JzLCAxMS43XG4gICAgZnVuY3Rpb24gYmluYXJ5U2hpZnRzKG9wLCB3bCwgdnMpIHtcbiAgICAgICAgdmFyIHJ2YWwgPSB2cy5wb3AoKTtcbiAgICAgICAgdmFyIGx2YWwgPSB2cy5wb3AoKTtcbiAgICAgICAgdmFyIGxudW0gPSAob3AgPT09ICc+Pj4nKSA/IFRvVUludDMyXzEuVG9VSW50MzIobHZhbCkgOiBUb0ludDMyXzEuVG9JbnQzMihsdmFsKTtcbiAgICAgICAgdmFyIHJudW0gPSBUb1VJbnQzMl8xLlRvVUludDMyKHJ2YWwpO1xuICAgICAgICB2YXIgdmFsID0gZXZhbCgnbG51bS52YWx1ZSAnICsgb3AgKyAnIHJudW0udmFsdWUnKTtcbiAgICAgICAgdnMucHVzaChuZXcgdmFsdWVzXzEuVmFsdWUodmFsLCBsdWIobG51bS5sYWJlbCwgcm51bS5sYWJlbCkpKTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEJpbmFyeSBCaXR3aXNlIE9wZXJhdG9ycywgMTEuMTBcbiAgICBmdW5jdGlvbiBiaW5hcnlCaXR3aXNlT3BzKG9wLCB3bCwgdnMpIHtcbiAgICAgICAgdmFyIHJ2YWwgPSB2cy5wb3AoKTtcbiAgICAgICAgdmFyIGx2YWwgPSB2cy5wb3AoKTtcbiAgICAgICAgdmFyIGxudW0gPSBUb0ludDMyXzEuVG9JbnQzMihsdmFsKTtcbiAgICAgICAgdmFyIHJudW0gPSBUb0ludDMyXzEuVG9JbnQzMihydmFsKTtcbiAgICAgICAgdmFyIHZhbCA9IGV2YWwoJ2xudW0udmFsdWUgJyArIG9wICsgJyBybnVtLnZhbHVlJyk7XG4gICAgICAgIHZzLnB1c2gobmV3IHZhbHVlc18xLlZhbHVlKHZhbCwgbHViKGxudW0ubGFiZWwsIHJudW0ubGFiZWwpKSk7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBQbHVzLCAxMS42XG4gICAgZnVuY3Rpb24gYmluYXJ5UGx1cyh3bCwgdnMpIHtcbiAgICAgICAgdmFyIHJ2YWwgPSB2cy5wb3AoKTtcbiAgICAgICAgdmFyIGx2YWwgPSB2cy5wb3AoKTtcbiAgICAgICAgdmFyIGxwcmltID0gVG9QcmltaXRpdmVfMS5Ub1ByaW1pdGl2ZShsdmFsKTtcbiAgICAgICAgdmFyIHJwcmltID0gVG9QcmltaXRpdmVfMS5Ub1ByaW1pdGl2ZShydmFsKTtcbiAgICAgICAgdmFyIHJlcztcbiAgICAgICAgaWYgKCh0eXBlb2YgbHByaW0udmFsdWUpID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgKHR5cGVvZiBycHJpbS52YWx1ZSkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YXIgbHN0ciA9IFRvU3RyaW5nXzEuVG9TdHJpbmcobHByaW0pO1xuICAgICAgICAgICAgdmFyIHJzdHIgPSBUb1N0cmluZ18xLlRvU3RyaW5nKHJwcmltKTtcbiAgICAgICAgICAgIHJlcyA9IG5ldyB2YWx1ZXNfMS5WYWx1ZShsc3RyLnZhbHVlICsgcnN0ci52YWx1ZSwgbHViKGxwcmltLmxhYmVsLCBycHJpbS5sYWJlbCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGxudW0gPSBUb051bWJlcl8xLlRvTnVtYmVyKGxwcmltKTtcbiAgICAgICAgICAgIHZhciBybnVtID0gVG9OdW1iZXJfMS5Ub051bWJlcihycHJpbSk7XG4gICAgICAgICAgICByZXMgPSBuZXcgdmFsdWVzXzEuVmFsdWUobG51bS52YWx1ZSArIHJudW0udmFsdWUsIGx1YihsbnVtLmxhYmVsLCBybnVtLmxhYmVsKSk7XG4gICAgICAgIH1cbiAgICAgICAgdnMucHVzaChyZXMpO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gTXVsdGlwbGljYXRpdmUgb3BlcmF0b3JzLCAxMS41LCBhbmQgbWludXMsIDExLjZcbiAgICBmdW5jdGlvbiBiaW5hcnlBcml0aG1ldGljT3BzKG9wLCB3bCwgdnMpIHtcbiAgICAgICAgdmFyIHJ2YWwgPSB2cy5wb3AoKTtcbiAgICAgICAgdmFyIGx2YWwgPSB2cy5wb3AoKTtcbiAgICAgICAgdmFyIGxlZnROdW0gPSBUb051bWJlcl8xLlRvTnVtYmVyKGx2YWwpO1xuICAgICAgICB2YXIgcmlnaHROdW0gPSBUb051bWJlcl8xLlRvTnVtYmVyKHJ2YWwpO1xuICAgICAgICB2YXIgdmFsID0gZXZhbCgnbGVmdE51bS52YWx1ZSAnICsgb3AgKyAnIHJpZ2h0TnVtLnZhbHVlJyk7XG4gICAgICAgIHZzLnB1c2gobmV3IHZhbHVlc18xLlZhbHVlKHZhbCwgbHViKGxlZnROdW0ubGFiZWwsIHJpZ2h0TnVtLmxhYmVsKSkpO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gVGhlIGluIG9wZXJhdG9yLCAxMS44LjdcbiAgICBmdW5jdGlvbiBiaW5hcnlJbih3bCwgdnMpIHtcbiAgICAgICAgdmFyIHJ2YWwgPSB2cy5wb3AoKTtcbiAgICAgICAgdmFyIGx2YWwgPSB2cy5wb3AoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBydmFsLnZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaWYgKGZhbHNlKSB7IC8vIFNJTEVOVCBFUlJPUlxuICAgICAgICAgICAgICAgIHZzLnB1c2gobmV3IHZhbHVlc18xLlZhbHVlKGZhbHNlLCBsdWIobHZhbC5sYWJlbCwgcnZhbC5sYWJlbCkpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtb25pdG9yLlRocm93KGVycm9yLlR5cGVFcnJvck9iamVjdCwgXCJpbnZhbGlkICdpbicgcGFyYW1ldGVyXCIsIHJ2YWwubGFiZWwpO1xuICAgICAgICB9XG4gICAgICAgIHZzLnB1c2gocnZhbC5IYXNQcm9wZXJ0eShUb1N0cmluZ18xLlRvU3RyaW5nKGx2YWwpKSk7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBUaGUgaW5zdGFuY2VvZiBvcGVyYXRvciwgMTEuOC42XG4gICAgZnVuY3Rpb24gYmluYXJ5SW5zdGFuY2VvZih3bCwgdnMpIHtcbiAgICAgICAgdmFyIHJ2YWwgPSB2cy5wb3AoKTtcbiAgICAgICAgdmFyIGx2YWwgPSB2cy5wb3AoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBydmFsLnZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaWYgKGZhbHNlKSB7IC8vIFNJTEVOVCBFUlJPUlxuICAgICAgICAgICAgICAgIHZzLnB1c2gobmV3IHZhbHVlc18xLlZhbHVlKGZhbHNlLCBsdWIobHZhbC5sYWJlbCwgcnZhbC5sYWJlbCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1vbml0b3IuVGhyb3coZXJyb3IuVHlwZUVycm9yT2JqZWN0LCBcImludmFsaWQgJ2luc3RhbmNlb2YnIHBhcmFtZXRlclwiLCBydmFsLmxhYmVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISgnSGFzSW5zdGFuY2UnIGluIHJ2YWwudmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoZmFsc2UpIHsgLy8gU0lMRU5UIEVSUk9SXG4gICAgICAgICAgICAgICAgdnMucHVzaChuZXcgdmFsdWVzXzEuVmFsdWUoZmFsc2UsIGx1YihsdmFsLmxhYmVsLCBydmFsLmxhYmVsKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbW9uaXRvci5UaHJvdyhlcnJvci5UeXBlRXJyb3JPYmplY3QsIFwiaW52YWxpZCAnaW5zdGFuY2VvZicgcGFyYW1ldGVyXCIsIHJ2YWwubGFiZWwpO1xuICAgICAgICB9XG4gICAgICAgIHZzLnB1c2gocnZhbC5IYXNJbnN0YW5jZShsdmFsKSk7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICB2YXIgYmluYXJ5dGJsID0ge1xuICAgICAgICAnPT0nOiBiaW5hcnlFcXMuYmluZChudWxsLCAnPT0nKSxcbiAgICAgICAgJyE9JzogYmluYXJ5RXFzLmJpbmQobnVsbCwgJyE9JyksXG4gICAgICAgICc9PT0nOiBiaW5hcnlTdHJpY3RFcXMuYmluZChudWxsLCAnPT09JyksXG4gICAgICAgICchPT0nOiBiaW5hcnlTdHJpY3RFcXMuYmluZChudWxsLCAnIT09JyksXG4gICAgICAgICc8JzogYmluYXJ5T3Jkcy5iaW5kKG51bGwsICc8JyksXG4gICAgICAgICc8PSc6IGJpbmFyeU9yZHMuYmluZChudWxsLCAnPD0nKSxcbiAgICAgICAgJz4nOiBiaW5hcnlPcmRzLmJpbmQobnVsbCwgJz4nKSxcbiAgICAgICAgJz49JzogYmluYXJ5T3Jkcy5iaW5kKG51bGwsICc+PScpLFxuICAgICAgICAnPDwnOiBiaW5hcnlTaGlmdHMuYmluZChudWxsLCAnPDwnKSxcbiAgICAgICAgJz4+JzogYmluYXJ5U2hpZnRzLmJpbmQobnVsbCwgJz4+JyksXG4gICAgICAgICc+Pj4nOiBiaW5hcnlTaGlmdHMuYmluZChudWxsLCAnPj4+JyksXG4gICAgICAgICcrJzogYmluYXJ5UGx1cyxcbiAgICAgICAgJy0nOiBiaW5hcnlBcml0aG1ldGljT3BzLmJpbmQobnVsbCwgJy0nKSxcbiAgICAgICAgJyonOiBiaW5hcnlBcml0aG1ldGljT3BzLmJpbmQobnVsbCwgJyonKSxcbiAgICAgICAgJy8nOiBiaW5hcnlBcml0aG1ldGljT3BzLmJpbmQobnVsbCwgJy8nKSxcbiAgICAgICAgJyUnOiBiaW5hcnlBcml0aG1ldGljT3BzLmJpbmQobnVsbCwgJyUnKSxcbiAgICAgICAgJ3wnOiBiaW5hcnlCaXR3aXNlT3BzLmJpbmQobnVsbCwgJ3wnKSxcbiAgICAgICAgJyYnOiBiaW5hcnlCaXR3aXNlT3BzLmJpbmQobnVsbCwgJyYnKSxcbiAgICAgICAgJ14nOiBiaW5hcnlCaXR3aXNlT3BzLmJpbmQobnVsbCwgJ14nKSxcbiAgICAgICAgJ2luJzogYmluYXJ5SW4sXG4gICAgICAgICdpbnN0YW5jZW9mJzogYmluYXJ5SW5zdGFuY2VvZlxuICAgIH07XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBcbiAgICAvLyBQcmVmaXgsIGFuZCBQb3N0Zml4IEV4cHJlc3Npb25zLCAxMS4zLCAxMS40LjQsIDExLjQuNVxuICAgIGZ1bmN0aW9uIHByZWZpeE9wcyhvcCwgd2wsIHZzKSB7XG4gICAgICAgIHZhciByZWYgPSB2cy5wb3AoKTtcbiAgICAgICAgdmFyIG9sZFZhbHVlID0gVG9OdW1iZXJfMS5Ub051bWJlcihHZXRWYWx1ZShyZWYpKTtcbiAgICAgICAgdmFyIHZhbCA9IG9wID09PSAnKysnID8gb2xkVmFsdWUudmFsdWUgKyAxIDogb2xkVmFsdWUudmFsdWUgLSAxO1xuICAgICAgICB2YXIgbmV3VmFsdWUgPSBuZXcgdmFsdWVzXzEuVmFsdWUodmFsLCBvbGRWYWx1ZS5sYWJlbCk7XG4gICAgICAgIFB1dFZhbHVlKHJlZiwgbmV3VmFsdWUpO1xuICAgICAgICB2cy5wdXNoKG5ld1ZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9zdGZpeE9wcyhvcCwgd2wsIHZzKSB7XG4gICAgICAgIHZhciByZWYgPSB2cy5wb3AoKTtcbiAgICAgICAgdmFyIG9sZFZhbHVlID0gVG9OdW1iZXJfMS5Ub051bWJlcihHZXRWYWx1ZShyZWYpKTtcbiAgICAgICAgdmFyIHZhbCA9IG9wID09PSAnKysnID8gb2xkVmFsdWUudmFsdWUgKyAxIDogb2xkVmFsdWUudmFsdWUgLSAxO1xuICAgICAgICB2YXIgbmV3VmFsdWUgPSBuZXcgdmFsdWVzXzEuVmFsdWUodmFsLCBvbGRWYWx1ZS5sYWJlbCk7XG4gICAgICAgIFB1dFZhbHVlKHJlZiwgbmV3VmFsdWUpO1xuICAgICAgICB2cy5wdXNoKG9sZFZhbHVlKTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHZhciBwcmVmaXh0YmwgPSB7XG4gICAgICAgICcrKyc6IHByZWZpeE9wcy5iaW5kKG51bGwsICcrKycpLFxuICAgICAgICAnLS0nOiBwcmVmaXhPcHMuYmluZChudWxsLCAnLS0nKVxuICAgIH07XG4gICAgdmFyIHBvc3RmaXh0YmwgPSB7XG4gICAgICAgICcrKyc6IHBvc3RmaXhPcHMuYmluZChudWxsLCAnKysnKSxcbiAgICAgICAgJy0tJzogcG9zdGZpeE9wcy5iaW5kKG51bGwsICctLScpXG4gICAgfTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gQmluYXJ5IExvZ2ljYWwgfHwsIDExLjExXG4gICAgZnVuY3Rpb24gYmluYXJ5TG9naWNhbE9yKHdsLCB2cykge1xuICAgICAgICB2YXIgbHZhbCA9IEdldFZhbHVlKHZzLnBvcCgpKTtcbiAgICAgICAgdnMucHVzaChsdmFsKTtcbiAgICAgICAgdmFyIGxiID0gVG9Cb29sZWFuXzEuVG9Cb29sZWFuKGx2YWwpO1xuICAgICAgICB2YXIgcmlnaHQgPSB3bC5wb3AoKTtcbiAgICAgICAgaWYgKGxiLnZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbW9uaXRvci5jb250ZXh0LnB1c2hQQyhsYi5sYWJlbCk7XG4gICAgICAgIHZhciBpcCA9IHdsLnRvcCgpO1xuICAgICAgICBpcC50aGVuKHJpZ2h0KTtcbiAgICAgICAgaXAudGhlbihiaW5hcnlMb2dpY2FsT3JfZW5kKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmluYXJ5TG9naWNhbE9yX2VuZCh3bCwgdnMpIHtcbiAgICAgICAgdmFyIHJ2YWwgPSBHZXRWYWx1ZSh2cy5wb3AoKSk7XG4gICAgICAgIHZhciBsdmFsID0gdnMucG9wKCk7XG4gICAgICAgIG1vbml0b3IuY29udGV4dC5wb3BQQygpO1xuICAgICAgICB2cy5wdXNoKG5ldyB2YWx1ZXNfMS5WYWx1ZShydmFsLnZhbHVlLCBsdWIocnZhbC5sYWJlbCwgbHZhbC5sYWJlbCkpKTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEJpbmFyeSBMb2dpY2FsICYmLCAxMS4xMVxuICAgIGZ1bmN0aW9uIGJpbmFyeUxvZ2ljYWxBbmQod2wsIHZzKSB7XG4gICAgICAgIHZhciBsdmFsID0gR2V0VmFsdWUodnMucG9wKCkpO1xuICAgICAgICB2cy5wdXNoKGx2YWwpO1xuICAgICAgICB2YXIgbGIgPSBUb0Jvb2xlYW5fMS5Ub0Jvb2xlYW4obHZhbCk7XG4gICAgICAgIHZhciByaWdodCA9IHdsLnBvcCgpO1xuICAgICAgICBpZiAoIWxiLnZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbW9uaXRvci5jb250ZXh0LnB1c2hQQyhsYi5sYWJlbCk7XG4gICAgICAgIHZhciBpcCA9IHdsLnRvcCgpO1xuICAgICAgICBpcC50aGVuKHJpZ2h0KTtcbiAgICAgICAgaXAudGhlbihiaW5hcnlMb2dpY2FsQW5kX2VuZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJpbmFyeUxvZ2ljYWxBbmRfZW5kKHdsLCB2cykge1xuICAgICAgICB2YXIgcnZhbCA9IEdldFZhbHVlKHZzLnBvcCgpKTtcbiAgICAgICAgdmFyIGx2YWwgPSB2cy5wb3AoKTtcbiAgICAgICAgbW9uaXRvci5jb250ZXh0LnBvcFBDKCk7XG4gICAgICAgIHZzLnB1c2gobmV3IHZhbHVlc18xLlZhbHVlKHJ2YWwudmFsdWUsIGx1YihydmFsLmxhYmVsLCBsdmFsLmxhYmVsKSkpO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgdmFyIGxvZ2ljYWx0YmwgPSB7XG4gICAgICAgICd8fCc6IGJpbmFyeUxvZ2ljYWxPcixcbiAgICAgICAgJyYmJzogYmluYXJ5TG9naWNhbEFuZFxuICAgIH07XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIGFzc2lnbm1lbnRPcHMob3AsIHdsLCB2cykge1xuICAgICAgICB2YXIgcnZhbCA9IEdldFZhbHVlKHZzLnBvcCgpKTtcbiAgICAgICAgdmFyIGxyZWYgPSB2cy5wb3AoKTtcbiAgICAgICAgaWYgKG9wKSB7XG4gICAgICAgICAgICB2cy5wdXNoKGxyZWYpO1xuICAgICAgICAgICAgdnMucHVzaChHZXRWYWx1ZShscmVmKSk7XG4gICAgICAgICAgICB2cy5wdXNoKHJ2YWwpO1xuICAgICAgICAgICAgYmluYXJ5dGJsW29wXSh3bCwgdnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdnMucHVzaChscmVmKTtcbiAgICAgICAgICAgIHZzLnB1c2gocnZhbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGFzc2lnbm1lbnR0YmwgPSB7XG4gICAgICAgICc9JzogYXNzaWdubWVudE9wcy5iaW5kKG51bGwsIG51bGwpLFxuICAgICAgICAnKz0nOiBhc3NpZ25tZW50T3BzLmJpbmQobnVsbCwgJysnKSxcbiAgICAgICAgJy09JzogYXNzaWdubWVudE9wcy5iaW5kKG51bGwsICctJyksXG4gICAgICAgICcqPSc6IGFzc2lnbm1lbnRPcHMuYmluZChudWxsLCAnKicpLFxuICAgICAgICAnLz0nOiBhc3NpZ25tZW50T3BzLmJpbmQobnVsbCwgJy8nKSxcbiAgICAgICAgJyU9JzogYXNzaWdubWVudE9wcy5iaW5kKG51bGwsICclJyksXG4gICAgICAgICc+Pj0nOiBhc3NpZ25tZW50T3BzLmJpbmQobnVsbCwgJz4+JyksXG4gICAgICAgICc8PD0nOiBhc3NpZ25tZW50T3BzLmJpbmQobnVsbCwgJzw8JyksXG4gICAgICAgICc+Pj49JzogYXNzaWdubWVudE9wcy5iaW5kKG51bGwsICc+Pj4nKSxcbiAgICAgICAgJ3w9JzogYXNzaWdubWVudE9wcy5iaW5kKG51bGwsICd8JyksXG4gICAgICAgICcmPSc6IGFzc2lnbm1lbnRPcHMuYmluZChudWxsLCAnJicpLFxuICAgICAgICAnXj0nOiBhc3NpZ25tZW50T3BzLmJpbmQobnVsbCwgJ14nKVxuICAgIH07XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIF9HZXRWYWx1ZSgpIHtcbiAgICAgICAgdmFyIHZzID0gbW9uaXRvci5jb250ZXh0LnZhbHVlU3RhY2s7XG4gICAgICAgIHZzLnB1c2goR2V0VmFsdWUodnMucG9wKCkpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX3BvcFBDKCkge1xuICAgICAgICBtb25pdG9yLmNvbnRleHQucG9wUEMoKTtcbiAgICB9XG4gICAgX3BvcFBDLnJ1bmZvciA9IHJ1bmZvcl9jb250aW51ZV9icmVhaztcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gZXhwcmVzc2lvbiBoYW5kbGVyIGZ1bmN0aW9ucyBcbiAgICB2YXIgZXhwcmVzc2lvbnRibCA9IHtcbiAgICAgICAgJ1RoaXNFeHByZXNzaW9uJzogdGhpc0V4cHJlc3Npb24sXG4gICAgICAgICdBcnJheUV4cHJlc3Npb24nOiBhcnJheUV4cHJlc3Npb24sXG4gICAgICAgICdPYmplY3RFeHByZXNzaW9uJzogb2JqZWN0RXhwcmVzc2lvbixcbiAgICAgICAgJ0Z1bmN0aW9uRXhwcmVzc2lvbic6IGZ1bmN0aW9uRXhwcmVzc2lvbixcbiAgICAgICAgJ1NlcXVlbmNlRXhwcmVzc2lvbic6IHNlcXVlbmNlRXhwcmVzc2lvbixcbiAgICAgICAgJ1VuYXJ5RXhwcmVzc2lvbic6IHVuYXJ5RXhwcmVzc2lvbixcbiAgICAgICAgJ0JpbmFyeUV4cHJlc3Npb24nOiBiaW5hcnlFeHByZXNzaW9uLFxuICAgICAgICAnVXBkYXRlRXhwcmVzc2lvbic6IHVwZGF0ZUV4cHJlc3Npb24sXG4gICAgICAgICdMb2dpY2FsRXhwcmVzc2lvbic6IGxvZ2ljYWxFeHByZXNzaW9uLFxuICAgICAgICAnQXNzaWdubWVudEV4cHJlc3Npb24nOiBhc3NpZ25tZW50RXhwcmVzc2lvbixcbiAgICAgICAgJ0NvbmRpdGlvbmFsRXhwcmVzc2lvbic6IGNvbmRpdGlvbmFsRXhwcmVzc2lvbixcbiAgICAgICAgJ05ld0V4cHJlc3Npb24nOiBuZXdFeHByZXNzaW9uLFxuICAgICAgICAnQ2FsbEV4cHJlc3Npb24nOiBjYWxsRXhwcmVzc2lvbixcbiAgICAgICAgJ01lbWJlckV4cHJlc3Npb24nOiBtZW1iZXJFeHByZXNzaW9uLFxuICAgICAgICAnSWRlbnRpZmllcic6IGlkZW50aWZpZXJFeHByZXNzaW9uLFxuICAgICAgICAnTGl0ZXJhbCc6IGxpdGVyYWxFeHByZXNzaW9uXG4gICAgfTtcbiAgICAvLyBUaGlzLCAxMS4xLjEgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gXG4gICAgZnVuY3Rpb24gdGhpc0V4cHJlc3Npb24obm9kZSwgd2wsIHZzKSB7XG4gICAgICAgIHZhciBjID0gbW9uaXRvci5jb250ZXh0O1xuICAgICAgICB2cy5wdXNoKGMudGhpc1ZhbHVlLmNsb25lKCkpO1xuICAgIH1cbiAgICAvLyBBcnJheSBJbml0aWFsaXplciwgMTEuMS40IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBhcnJheUV4cHJlc3Npb24obm9kZSwgd2wsIHZzKSB7XG4gICAgICAgIHZhciBpcCA9IHdsLnRvcCgpO1xuICAgICAgICB2YXIgYXJyID0gbmV3IHZhbHVlc18xLlZhbHVlKG5ldyBBcnJheU9iamVjdF8xLkFycmF5T2JqZWN0KCksIGJvdCk7XG4gICAgICAgIHZhciBlcyA9IG5vZGUuZWxlbWVudHM7XG4gICAgICAgIHZhciBsZW4gPSBlcy5sZW5ndGg7XG4gICAgICAgIGFyci5QdXQoY29uc3RhbnRzLmxlbmd0aCwgbmV3IHZhbHVlc18xLlZhbHVlKGxlbiwgYm90KSk7XG4gICAgICAgIHZzLnB1c2goYXJyKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKGVzW2ldKSB7XG4gICAgICAgICAgICAgICAgaXAudGhlbihlc1tpXSk7XG4gICAgICAgICAgICAgICAgaXAudGhlbihhcnJheUV4cHJlc3Npb25VcGRhdGUsIHsgYXJyYXk6IGFyciwgaW5kZXg6IGkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYXJyYXlFeHByZXNzaW9uVXBkYXRlXG4gICAgZnVuY3Rpb24gYXJyYXlFeHByZXNzaW9uVXBkYXRlKHdsLCB2cykge1xuICAgICAgICB2YXIgaW5pdFZhbHVlID0gR2V0VmFsdWUodnMucG9wKCkpO1xuICAgICAgICB0aGlzLmFycmF5LlB1dChuZXcgdmFsdWVzXzEuVmFsdWUodGhpcy5pbmRleCwgYm90KSwgaW5pdFZhbHVlKTtcbiAgICB9XG4gICAgLy8gT2JqZWN0IEluaXRpYWxpemVyLCAxMS4xLjUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gb2JqZWN0RXhwcmVzc2lvbihub2RlLCB3bCwgdnMpIHtcbiAgICAgICAgdmFyIGlwID0gd2wudG9wKCk7XG4gICAgICAgIHZhciBvYmogPSBuZXcgdmFsdWVzXzEuVmFsdWUobmV3IE9iamVjdE9iamVjdF8xLk9iamVjdE9iamVjdCgpLCBib3QpO1xuICAgICAgICB2cy5wdXNoKG9iaik7XG4gICAgICAgIHZhciBwcyA9IG5vZGUucHJvcGVydGllcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpcC50aGVuKHBzW2ldLnZhbHVlKTtcbiAgICAgICAgICAgIGlwLnRoZW4ob2JqZWN0RXhwcmVzc2lvblVwZGF0ZSwgeyBwcm9wZXJ0aWVzOiBwcywgb2JqZWN0OiBvYmosIGluZGV4OiBpIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIG9iamVjdEV4cHJlc3Npb25VcGRhdGVcbiAgICBmdW5jdGlvbiBvYmplY3RFeHByZXNzaW9uVXBkYXRlKHdsLCB2cykge1xuICAgICAgICB2YXIgcHJvcCA9IHRoaXMucHJvcGVydGllc1t0aGlzLmluZGV4XTtcbiAgICAgICAgdmFyIHByb3BOYW1lID0gbmV3IHZhbHVlc18xLlZhbHVlKG51bGwsIGJvdCk7XG4gICAgICAgIHN3aXRjaCAocHJvcC5rZXkudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnSWRlbnRpZmllcic6XG4gICAgICAgICAgICAgICAgcHJvcE5hbWUudmFsdWUgPSBwcm9wLmtleS5uYW1lO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnTGl0ZXJhbCc6XG4gICAgICAgICAgICAgICAgLy8gY2FuIG9ubHkgYmUgc3RyaW5nIG9yIG51bWJlcjsgY29udmVyc2lvbiB3aWxsIG9jY3VyIG9uY2UgYXNzaWduZWQgdG8gdGhlIG9iamVjdFxuICAgICAgICAgICAgICAgIHByb3BOYW1lLnZhbHVlID0gcHJvcC5rZXkudmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IEdldFZhbHVlKHZzLnBvcCgpKTtcbiAgICAgICAgdmFyIHByb3BEZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfTtcbiAgICAgICAgc3dpdGNoIChwcm9wLmtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgJ2luaXQnOlxuICAgICAgICAgICAgICAgIHByb3BEZXNjLnZhbHVlID0gcHJvcFZhbHVlLnZhbHVlO1xuICAgICAgICAgICAgICAgIHByb3BEZXNjLmxhYmVsID0gcHJvcFZhbHVlLmxhYmVsO1xuICAgICAgICAgICAgICAgIHByb3BEZXNjLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2dldCc6XG4gICAgICAgICAgICAgICAgcHJvcERlc2MuZ2V0ID0gcHJvcFZhbHVlLnZhbHVlO1xuICAgICAgICAgICAgICAgIHByb3BEZXNjLmxhYmVsID0gcHJvcFZhbHVlLmxhYmVsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2V0JzpcbiAgICAgICAgICAgICAgICBwcm9wRGVzYy5zZXQgPSBwcm9wVmFsdWUudmFsdWU7XG4gICAgICAgICAgICAgICAgcHJvcERlc2MubGFiZWwgPSBwcm9wVmFsdWUubGFiZWw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXZpb3VzID0gdGhpcy5vYmplY3QuR2V0T3duUHJvcGVydHkocHJvcE5hbWUpO1xuICAgICAgICBtb25pdG9yLmNvbnRleHQucHVzaFBDKHByZXZpb3VzLmxhYmVsKTtcbiAgICAgICAgaWYgKHByZXZpb3VzLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICgoZWNtYS5Jc0RhdGFEZXNjcmlwdG9yKHByZXZpb3VzKSAmJiBlY21hLklzQWNjZXNzb3JEZXNjcmlwdG9yKHByb3BEZXNjKSkgfHxcbiAgICAgICAgICAgICAgICAoZWNtYS5Jc0FjY2Vzc29yRGVzY3JpcHRvcihwcmV2aW91cykgJiYgZWNtYS5Jc0RhdGFEZXNjcmlwdG9yKHByb3BEZXNjKSkgfHxcbiAgICAgICAgICAgICAgICAoZWNtYS5Jc0FjY2Vzc29yRGVzY3JpcHRvcihwcmV2aW91cykgJiYgZWNtYS5Jc0FjY2Vzc29yRGVzY3JpcHRvcihwcm9wRGVzYykgJiZcbiAgICAgICAgICAgICAgICAgICAgKChwcmV2aW91cy5nZXQgJiYgcHJvcERlc2MuZ2V0KSB8fCAocHJldmlvdXMuc2V0ICYmIHByb3BEZXNjLnNldCkpKSkge1xuICAgICAgICAgICAgICAgIG1vbml0b3IuVGhyb3coZXJyb3IuU3ludGF4RXJyb3JPYmplY3QsICdPYmplY3QgaW5pdGlhbGl6ZXI6IGlsbGVnYWwgcmVkZWZpbmUgb2YgcHJvcGVydHknLCBib3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1vbml0b3IuY29udGV4dC5wb3BQQygpO1xuICAgICAgICB0aGlzLm9iamVjdC5EZWZpbmVPd25Qcm9wZXJ0eShwcm9wTmFtZSwgcHJvcERlc2MpO1xuICAgIH1cbiAgICAvLyBGdW5jdGlvbiBEZWZpbml0aW9uLCAxMyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25FeHByZXNzaW9uKG5vZGUsIHdsLCB2cykge1xuICAgICAgICB2YXIgZnVuO1xuICAgICAgICBpZiAobm9kZS5pZCkge1xuICAgICAgICAgICAgdmFyIGZ1bmNFbnYgPSBlbnYuTmV3RGVjbGFyYXRpdmVFbnZpcm9ubWVudChtb25pdG9yLmNvbnRleHQubGV4aWNhbEVudik7XG4gICAgICAgICAgICB2YXIgaWRlbnRpZmllciA9IG5ldyB2YWx1ZXNfMS5WYWx1ZShub2RlLmlkLm5hbWUsIGJvdCk7XG4gICAgICAgICAgICBmdW5jRW52LkNyZWF0ZUltbXV0YWJsZUJpbmRpbmcoaWRlbnRpZmllcik7XG4gICAgICAgICAgICBmdW4gPSBuZXcgRnVuY3Rpb25PYmplY3RfMS5GdW5jdGlvbk9iamVjdChub2RlLnBhcmFtcywgbm9kZS5ib2R5LCBuZXcgdmFsdWVzXzEuVmFsdWUoZnVuY0VudiwgYm90KSk7XG4gICAgICAgICAgICBmdW4uTmFtZSA9IG5vZGUuaWQubmFtZTtcbiAgICAgICAgICAgIGZ1bi5Tb3VyY2UgPSBub2RlO1xuICAgICAgICAgICAgZnVuY0Vudi5Jbml0aWFsaXplSW1tdXRhYmxlQmluZGluZyhpZGVudGlmaWVyLCBuZXcgdmFsdWVzXzEuVmFsdWUoZnVuLCBib3QpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZ1biA9IG5ldyBGdW5jdGlvbk9iamVjdF8xLkZ1bmN0aW9uT2JqZWN0KG5vZGUucGFyYW1zLCBub2RlLmJvZHksIG1vbml0b3IuY29udGV4dC5sZXhpY2FsRW52KTtcbiAgICAgICAgICAgIGZ1bi5Tb3VyY2UgPSBub2RlO1xuICAgICAgICB9XG4gICAgICAgIHZzLnB1c2gobmV3IHZhbHVlc18xLlZhbHVlKGZ1biwgYm90KSk7XG4gICAgfVxuICAgIC8vIENvbW1hIE9wZXJhdG9yLCAxMS4xNCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBzZXF1ZW5jZUV4cHJlc3Npb24obm9kZSwgd2wsIHZzKSB7XG4gICAgICAgIHZhciBpcCA9IHdsLnRvcCgpO1xuICAgICAgICB2YXIgZXMgPSBub2RlLmV4cHJlc3Npb25zO1xuICAgICAgICB2YXIgbGVuID0gZXMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbiAtIDE7IGkrKykge1xuICAgICAgICAgICAgaXAudGhlbihlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPCBsZW4pIHtcbiAgICAgICAgICAgIGlwLnRoZW4oZXNbaV0pO1xuICAgICAgICAgICAgaXAudGhlbihzZXF1ZW5jZUV4cHJlc3Npb25FbmQsIHsgbGVuZ3RoOiBsZW4gfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2VxdWVuY2VFeHByZXNzaW9uRW5kKHdsLCB2cykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdnMucG9wKCk7XG4gICAgICAgIC8vIFBvcCBhbGwgYnV0IGxhc3QgYW5kIGV4ZWN1dGUgR2V0VmFsdWUgb24gcmVzdWx0IGZvciBldmVudHVhbCBzaWRlIGVmZmVjdHMuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIEdldFZhbHVlKHZzLnBvcCgpKTtcbiAgICAgICAgfVxuICAgICAgICB2cy5wdXNoKHJlc3VsdCk7XG4gICAgfVxuICAgIC8vIFVuYXJ5IE9wZXJhdG9ycywgMTEuNCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiB1bmFyeUV4cHJlc3Npb24obm9kZSwgd2wsIHZzKSB7XG4gICAgICAgIHZhciBpcCA9IHdsLnRvcCgpO1xuICAgICAgICBpcC50aGVuKG5vZGUuYXJndW1lbnQpO1xuICAgICAgICBpcC50aGVuKHVuYXJ5dGJsW25vZGUub3BlcmF0b3JdKTtcbiAgICB9XG4gICAgLy8gQmluYXJ5IE9wZXJhdG9ycywgMTEuNS0xMS45IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gYmluYXJ5RXhwcmVzc2lvbihub2RlLCB3bCwgdnMpIHtcbiAgICAgICAgdmFyIGlwID0gd2wudG9wKCk7XG4gICAgICAgIGlwLnRoZW4obm9kZS5sZWZ0KTtcbiAgICAgICAgaXAudGhlbihfR2V0VmFsdWUpO1xuICAgICAgICBpcC50aGVuKG5vZGUucmlnaHQpO1xuICAgICAgICBpcC50aGVuKF9HZXRWYWx1ZSk7XG4gICAgICAgIGlwLnRoZW4oYmluYXJ5dGJsW25vZGUub3BlcmF0b3JdKTtcbiAgICB9XG4gICAgLy8gUHJlZml4LCBhbmQgUG9zdGZpeCBFeHByZXNzaW9ucywgMTEuMywgMTEuNC40LCAxMS40LjUgLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiB1cGRhdGVFeHByZXNzaW9uKG5vZGUsIHdsLCB2cykge1xuICAgICAgICB2YXIgaXAgPSB3bC50b3AoKTtcbiAgICAgICAgaXAudGhlbihub2RlLmFyZ3VtZW50KTtcbiAgICAgICAgaWYgKG5vZGUucHJlZml4KSB7XG4gICAgICAgICAgICBpcC50aGVuKHByZWZpeHRibFtub2RlLm9wZXJhdG9yXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpcC50aGVuKHBvc3RmaXh0Ymxbbm9kZS5vcGVyYXRvcl0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEJpbmFyeSBPcGVyYXRvcnMsIDExLjUtMTEuOSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIGxvZ2ljYWxFeHByZXNzaW9uKG5vZGUsIHdsLCB2cykge1xuICAgICAgICB2YXIgaXAgPSB3bC50b3AoKTtcbiAgICAgICAgaXAudGhlbihub2RlLmxlZnQpO1xuICAgICAgICBpcC50aGVuKGxvZ2ljYWx0Ymxbbm9kZS5vcGVyYXRvcl0pO1xuICAgICAgICBpcC50aGVuKG5vZGUucmlnaHQpO1xuICAgIH1cbiAgICAvLyBBc3NpZ25tZW50LCAxMS4xMyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIGFzc2lnbm1lbnRFeHByZXNzaW9uKG5vZGUsIHdsLCB2cykge1xuICAgICAgICB2YXIgaXAgPSB3bC50b3AoKTtcbiAgICAgICAgaXAudGhlbihub2RlLmxlZnQpO1xuICAgICAgICBpcC50aGVuKG5vZGUucmlnaHQpO1xuICAgICAgICBpcC50aGVuKGFzc2lnbm1lbnR0Ymxbbm9kZS5vcGVyYXRvcl0pO1xuICAgICAgICBpcC50aGVuKGFzc2lnbm1lbnRFeHByZXNzaW9uRW5kKTtcbiAgICB9XG4gICAgLy8gYXNzaWdubWVudEV4cHJlc3Npb25FbmRcbiAgICBmdW5jdGlvbiBhc3NpZ25tZW50RXhwcmVzc2lvbkVuZCh3bCwgdnMpIHtcbiAgICAgICAgdmFyIHJ2YWwgPSB2cy5wb3AoKTtcbiAgICAgICAgdmFyIGxyZWYgPSB2cy5wb3AoKTtcbiAgICAgICAgUHV0VmFsdWUobHJlZiwgcnZhbCk7XG4gICAgICAgIHZzLnB1c2gocnZhbCk7XG4gICAgfVxuICAgIC8vIENvbmRpdGlvbmFsIE9wZXJhdG9yLCAxMS4xMiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBjb25kaXRpb25hbEV4cHJlc3Npb24obm9kZSwgd2wsIHZzKSB7XG4gICAgICAgIHZhciBpcCA9IHdsLnRvcCgpO1xuICAgICAgICBpcC50aGVuKG5vZGUudGVzdCk7XG4gICAgICAgIGlwLnRoZW4oY29uZGl0aW9uYWxFeHByZXNzaW9uQ2hvb3NlLCB7IG5vZGU6IG5vZGUgfSk7XG4gICAgfVxuICAgIC8vIGNvbmRpdGlvbmFsRXhwcmVzc2lvbkNob29zZVxuICAgIGZ1bmN0aW9uIGNvbmRpdGlvbmFsRXhwcmVzc2lvbkNob29zZSh3bCwgdnMpIHtcbiAgICAgICAgdmFyIGlwID0gd2wudG9wKCk7XG4gICAgICAgIHZhciBsdmFsID0gR2V0VmFsdWUodnMucG9wKCkpO1xuICAgICAgICB2YXIgbGIgPSBUb0Jvb2xlYW5fMS5Ub0Jvb2xlYW4obHZhbCk7XG4gICAgICAgIHZhciB2YWw7XG4gICAgICAgIG1vbml0b3IuY29udGV4dC5wdXNoUEMobGIubGFiZWwpO1xuICAgICAgICBpZiAobGIudmFsdWUpIHtcbiAgICAgICAgICAgIGlwLnRoZW4odGhpcy5ub2RlLmNvbnNlcXVlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaXAudGhlbih0aGlzLm5vZGUuYWx0ZXJuYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpcC50aGVuKGNvbmRpdGlvbmFsRXhwcmVzc2lvbkVuZCwgeyB0ZXN0OiBsdmFsIH0pO1xuICAgIH1cbiAgICAvLyBjb25kaXRpb25hbEV4cHJlc3Npb25FbmRcbiAgICBmdW5jdGlvbiBjb25kaXRpb25hbEV4cHJlc3Npb25FbmQod2wsIHZzKSB7XG4gICAgICAgIHZhciB2YWwgPSBHZXRWYWx1ZSh2cy5wb3AoKSk7XG4gICAgICAgIG1vbml0b3IuY29udGV4dC5wb3BQQygpO1xuICAgICAgICB2cy5wdXNoKG5ldyB2YWx1ZXNfMS5WYWx1ZSh2YWwudmFsdWUsIGx1Yih2YWwubGFiZWwsIHRoaXMudGVzdC5sYWJlbCkpKTtcbiAgICB9XG4gICAgLy8gVGhlIG5ldyBPcGVyYXRvciwgMTEuMi4yIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIG5ld0V4cHJlc3Npb24obm9kZSwgd2wsIHZzKSB7XG4gICAgICAgIHZhciBpcCA9IHdsLnRvcCgpO1xuICAgICAgICBpcC50aGVuKG5vZGUuY2FsbGVlKTtcbiAgICAgICAgdmFyIGFzID0gbm9kZS5hcmd1bWVudHM7XG4gICAgICAgIHZhciBsZW4gPSBhcy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlwLnRoZW4oYXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGlwLnRoZW4obmV3RXhwcmVzc2lvbkV4ZWN1dGUsIHsgbGVuZ3RoOiBsZW4gfSk7XG4gICAgfVxuICAgIC8vIG5ld0V4cHJlc3Npb25cbiAgICBmdW5jdGlvbiBuZXdFeHByZXNzaW9uRXhlY3V0ZSh3bCwgdnMpIHtcbiAgICAgICAgdmFyIGMgPSBtb25pdG9yLmNvbnRleHQ7XG4gICAgICAgIHZhciBpcCA9IHdsLnRvcCgpO1xuICAgICAgICB2YXIgYXJnTGlzdCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgYXJnTGlzdFtpXSA9IEdldFZhbHVlKHZzLnBvcCgpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29uc3RydWN0b3IgPSBHZXRWYWx1ZSh2cy5wb3AoKSk7XG4gICAgICAgIGlmICh0eXBlb2YgY29uc3RydWN0b3IudmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAoZmFsc2UpIHsgLy8gU0lMRU5UIEVSUk9SXG4gICAgICAgICAgICAgICAgdiA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIGNvbnN0cnVjdG9yLmxhYmVsKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtb25pdG9yLlRocm93KGVycm9yLlR5cGVFcnJvck9iamVjdCwgXCJpbnZhbGlkICduZXcnIHBhcmFtZXRlclwiLCBjb25zdHJ1Y3Rvci5sYWJlbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoJ0NvbnN0cnVjdCcgaW4gY29uc3RydWN0b3IudmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoZmFsc2UpIHsgLy8gU0lMRU5UIEVSUk9SXG4gICAgICAgICAgICAgICAgdiA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIGNvbnN0cnVjdG9yLmxhYmVsKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtb25pdG9yLlRocm93KGVycm9yLlR5cGVFcnJvck9iamVjdCwgXCJpbnZhbGlkICduZXcnIHBhcmFtZXRlclwiLCBjb25zdHJ1Y3Rvci5sYWJlbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnN0cnVjdG9yLnZhbHVlLkFzeW5jQ29uc3RydWN0KSB7XG4gICAgICAgICAgICBjLnB1c2hQQyhjb25zdHJ1Y3Rvci5sYWJlbCk7XG4gICAgICAgICAgICBpcCA9IGNvbnN0cnVjdG9yLnZhbHVlLkFzeW5jQ29uc3RydWN0KGFyZ0xpc3QpO1xuICAgICAgICAgICAgaXAudGhlbihjYWxsRXhwcmVzc2lvbkVuZCwgeyBsYWJlbDogY29uc3RydWN0b3IubGFiZWwgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciByZXR2YWwgPSBjb25zdHJ1Y3Rvci5Db25zdHJ1Y3QoYXJnTGlzdCk7XG4gICAgICAgICAgICAgICAgcmV0dmFsLnJhaXNlKGNvbnN0cnVjdG9yLmxhYmVsKTtcbiAgICAgICAgICAgICAgICB2cy5wdXNoKHJldHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmICghKGUgaW5zdGFuY2VvZiB2YWx1ZXNfMS5WYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGMucmVzdWx0O1xuICAgICAgICAgICAgICAgIC8vIFZlcmZpeSB0aGF0IHRoZSBleGNlcHRpb24gaXMgYWxsb3dlZCBcbiAgICAgICAgICAgICAgICBtb25pdG9yLmFzc2VydChsZShjLmVmZmVjdGl2ZVBDLCBjLmxhYmVscy5leGMpLCBcImV4Y2VwdGlvbiBpbiBcIiArIGMuZWZmZWN0aXZlUEMgKyBcIiBub3QgYWxsb3dlZCB3aXRoIGV4Y2VwdGlvbiBsYWJlbCBcIiArIGMubGFiZWxzLmV4Yyk7XG4gICAgICAgICAgICAgICAgLy8gRm9yIG9ic2VydmFibGUgZmxvd3NcbiAgICAgICAgICAgICAgICBjLmxhYmVscy5leGMubHViKGMuZWZmZWN0aXZlUEMpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC50eXBlID0gJ3Rocm93JztcbiAgICAgICAgICAgICAgICByZXN1bHQudmFsdWUgPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEZ1bmN0aW9uIENhbGxzLCAxMS4yLjMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBjYWxsRXhwcmVzc2lvbihub2RlLCB3bCwgdnMpIHtcbiAgICAgICAgdmFyIGlwID0gd2wudG9wKCk7XG4gICAgICAgIHZhciBhcyA9IG5vZGUuYXJndW1lbnRzO1xuICAgICAgICB2YXIgbGVuID0gYXMubGVuZ3RoO1xuICAgICAgICBpcC50aGVuKG5vZGUuY2FsbGVlKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaXAudGhlbihhc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgaXAudGhlbihjYWxsRXhwcmVzc2lvbkV4ZWN1dGUsIHsgbGVuZ3RoOiBsZW4sIG5vZGU6IG5vZGUgfSk7XG4gICAgfVxuICAgIC8vIGNhbGxFeHByZXNzaW9uRXhlY3V0ZVxuICAgIGZ1bmN0aW9uIGNhbGxFeHByZXNzaW9uRXhlY3V0ZSh3bCwgdnMpIHtcbiAgICAgICAgdmFyIGMgPSBtb25pdG9yLmNvbnRleHQ7XG4gICAgICAgIHZhciBpcCA9IHdsLnRvcCgpO1xuICAgICAgICB2YXIgYXJnTGlzdCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgYXJnTGlzdFtpXSA9IEdldFZhbHVlKHZzLnBvcCgpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVmID0gdnMucG9wKCk7XG4gICAgICAgIHZhciBmdW5jID0gR2V0VmFsdWUocmVmKTtcbiAgICAgICAgLy8gdXNlZCB0byBkZWNpZGUgaWYgZXZhbCBpcyBhIGRpcmVjdCBjYWxsIGluIGZ1bmN0aW9uLmVudGVyRXZhbENvZGVcbiAgICAgICAgYy5jdXJyZW50Q2FsbCA9IHsgcmVmZXJlbmNlOiByZWYsIHRhcmdldDogZnVuYy52YWx1ZSwgc291cmNlOiB0aGlzLm5vZGUgfTtcbiAgICAgICAgLy8gZm9yIGV2YWxcbiAgICAgICAgYy5jYWxsID0ge307XG4gICAgICAgIGMuY2FsbC5yZWYgPSByZWY7XG4gICAgICAgIGMuY2FsbC5mdW5jID0gZnVuYztcbiAgICAgICAgaWYgKCFJc0NhbGxhYmxlXzEuSXNDYWxsYWJsZShmdW5jKS52YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGZhbHNlKSB7IC8vIFNJTEVOVCBFUlJPUlNcbiAgICAgICAgICAgICAgICB2ID0gbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgZnVuYy5sYWJlbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbW9uaXRvci5UaHJvdyhlcnJvci5UeXBlRXJyb3JPYmplY3QsICdJbnZhbGlkIGNhbGwgdGFyZ2V0OyAnICsgcHAucHJldHR5KHRoaXMubm9kZS5jYWxsZWUpICsgJyBldmFsdWF0ZXMgdG8gJyArIGZ1bmMudmFsdWUgKyAnIGluICcgKyBwcC5wcmV0dHkodGhpcy5ub2RlKSwgZnVuYy5sYWJlbCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRoaXNWYWx1ZTtcbiAgICAgICAgaWYgKHJlZiBpbnN0YW5jZW9mIHZhbHVlc18xLlJlZmVyZW5jZSkge1xuICAgICAgICAgICAgaWYgKHJlZi5Jc1Byb3BlcnR5UmVmZXJlbmNlKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzVmFsdWUgPSByZWYuYmFzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXNWYWx1ZSA9IHJlZi5iYXNlLkltcGxpY2l0VGhpc1ZhbHVlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzVmFsdWUgPSBuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCByZWYubGFiZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmdW5jLnZhbHVlLkFzeW5jQ2FsbCkge1xuICAgICAgICAgICAgbW9uaXRvci5jb250ZXh0LnB1c2hQQyhmdW5jLmxhYmVsKTtcbiAgICAgICAgICAgIGZ1bmMudmFsdWUuQXN5bmNDYWxsKHRoaXNWYWx1ZSwgYXJnTGlzdCk7XG4gICAgICAgICAgICBpcC50aGVuKGNhbGxFeHByZXNzaW9uRW5kLCB7IGxhYmVsOiBmdW5jLmxhYmVsIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgcmV0dmFsID0gZnVuYy5DYWxsKHRoaXNWYWx1ZSwgYXJnTGlzdCk7XG4gICAgICAgICAgICAgICAgcmV0dmFsLnJhaXNlKGZ1bmMubGFiZWwpO1xuICAgICAgICAgICAgICAgIHZzLnB1c2gocmV0dmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIHZhbHVlc18xLlZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gYy5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgLy8gVmVyZml5IHRoYXQgdGhlIGV4Y2VwdGlvbiBpcyBhbGxvd2VkIFxuICAgICAgICAgICAgICAgIG1vbml0b3IuYXNzZXJ0KGxlKGMuZWZmZWN0aXZlUEMsIGMubGFiZWxzLmV4YyksIFwiZXhjZXB0aW9uIGluIFwiICsgYy5lZmZlY3RpdmVQQyArIFwiIG5vdCBhbGxvd2VkIHdpdGggZXhjZXB0aW9uIGxhYmVsIFwiICsgYy5sYWJlbHMuZXhjKTtcbiAgICAgICAgICAgICAgICAvLyBGb3Igb2JzZXJ2YWJsZSBmbG93c1xuICAgICAgICAgICAgICAgIGMubGFiZWxzLmV4Yy5sdWIoYy5lZmZlY3RpdmVQQyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnR5cGUgPSAndGhyb3cnO1xuICAgICAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gY2FsbEV4cHJlc3Npb25FbmQgXG4gICAgZnVuY3Rpb24gY2FsbEV4cHJlc3Npb25FbmQod2wsIHZzKSB7XG4gICAgICAgIHZhciBjYWxsUmVzdWx0ID0gdnMucG9wKCk7XG4gICAgICAgIHZhciBjID0gbW9uaXRvci5jb250ZXh0O1xuICAgICAgICB2YXIgcmVzdWx0ID0gYy5yZXN1bHQ7XG4gICAgICAgIGNhbGxSZXN1bHQudmFsdWUucmFpc2UodGhpcy5sYWJlbCk7XG4gICAgICAgIGlmIChjYWxsUmVzdWx0LnR5cGUgPT09ICd0aHJvdycpIHtcbiAgICAgICAgICAgIHJlc3VsdC50eXBlID0gJ3Rocm93JztcbiAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IGNhbGxSZXN1bHQudmFsdWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYy5wb3BQQygpO1xuICAgICAgICB2cy5wdXNoKGNhbGxSZXN1bHQudmFsdWUpO1xuICAgIH1cbiAgICAvLyBQcm9wZXJ0eSBBY2Nlc3NvcnMsIDExLjIuMSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gbWVtYmVyRXhwcmVzc2lvbihub2RlLCB3bCwgdnMpIHtcbiAgICAgICAgdmFyIGlwID0gd2wudG9wKCk7XG4gICAgICAgIGlwLnRoZW4obm9kZS5vYmplY3QpO1xuICAgICAgICBpcC50aGVuKF9HZXRWYWx1ZSk7XG4gICAgICAgIGlmIChub2RlLmNvbXB1dGVkKSB7XG4gICAgICAgICAgICBpcC50aGVuKG5vZGUucHJvcGVydHkpO1xuICAgICAgICAgICAgaXAudGhlbihfR2V0VmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlwLnRoZW4obWVtYmVyRXhwcmVzc2lvbkV4ZWN1dGUsIHsgbm9kZTogbm9kZSB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWVtYmVyRXhwcmVzc2lvbkV4ZWN1dGUod2wsIHZzKSB7XG4gICAgICAgIHZhciBwcm9wZXJ0eU5hbWVWYWx1ZTtcbiAgICAgICAgaWYgKHRoaXMubm9kZS5jb21wdXRlZCkge1xuICAgICAgICAgICAgcHJvcGVydHlOYW1lVmFsdWUgPSB2cy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByb3BlcnR5TmFtZVZhbHVlID0gbmV3IHZhbHVlc18xLlZhbHVlKHRoaXMubm9kZS5wcm9wZXJ0eS5uYW1lLCBib3QpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiYXNlVmFsdWUgPSB2cy5wb3AoKTtcbiAgICAgICAgaWYgKGJhc2VWYWx1ZS52YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IGJhc2VWYWx1ZS52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgbW9uaXRvci5sb2cocHAucHJldHR5KHRoaXMubm9kZS5vYmplY3QpICsgJyBldmFsdWF0ZXMgdG8gJyArIFN0cmluZyhiYXNlVmFsdWUudmFsdWUpICsgJyBpbiAnICsgcHAucHJldHR5KHRoaXMubm9kZSkpO1xuICAgICAgICB9XG4gICAgICAgIENoZWNrT2JqZWN0Q29lcmNpYmxlXzEuQ2hlY2tPYmplY3RDb2VyY2libGUoYmFzZVZhbHVlKTtcbiAgICAgICAgdnMucHVzaChuZXcgdmFsdWVzXzEuUmVmZXJlbmNlKGJhc2VWYWx1ZSwgVG9TdHJpbmdfMS5Ub1N0cmluZyhwcm9wZXJ0eU5hbWVWYWx1ZSkpKTtcbiAgICB9XG4gICAgLy8gSWRlbnRpZmllciwgMTEuMS4yIC0+IDEwLjMuMSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIGlkZW50aWZpZXJFeHByZXNzaW9uKG5vZGUsIHdsLCB2cykge1xuICAgICAgICB2cy5wdXNoKGVudi5HZXRJZGVudGlmaWVyUmVmZXJlbmNlKG1vbml0b3IuY29udGV4dC5sZXhpY2FsRW52LCBub2RlLm5hbWUpKTtcbiAgICB9XG4gICAgLy8gTGl0ZXJhbHMsIDExLjEuMyAtPiA3LjggLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIGxpdGVyYWxFeHByZXNzaW9uKG5vZGUsIHdsLCB2cykge1xuICAgICAgICB2YXIgcmVzID0gbmV3IHZhbHVlc18xLlZhbHVlKG5vZGUudmFsdWUsIGJvdCk7XG4gICAgICAgIGlmIChub2RlLnZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICByZXMudmFsdWUgPSBuZXcgUmVnRXhwT2JqZWN0KG5vZGUudmFsdWUsIGJvdCk7XG4gICAgICAgIH1cbiAgICAgICAgdnMucHVzaChyZXMpO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBzdGF0ZW1lbnQgaGFuZGxlciBmdW5jdGlvbnNcbiAgICB2YXIgc3RhdGVtZW50dGJsID0ge1xuICAgICAgICAnUHJvZ3JhbSc6IGJsb2NrU3RhdGVtZW50LFxuICAgICAgICAnQmxvY2tTdGF0ZW1lbnQnOiBibG9ja1N0YXRlbWVudCxcbiAgICAgICAgJ0VtcHR5U3RhdGVtZW50JzogZW1wdHlTdGF0ZW1lbnQsXG4gICAgICAgICdFeHByZXNzaW9uU3RhdGVtZW50JzogZXhwcmVzc2lvblN0YXRlbWVudCxcbiAgICAgICAgJ0lmU3RhdGVtZW50JzogaWZTdGF0ZW1lbnQsXG4gICAgICAgICdTd2l0Y2hTdGF0ZW1lbnQnOiBzd2l0Y2hTdGF0ZW1lbnQsXG4gICAgICAgICdMYWJlbGVkU3RhdGVtZW50JzogbGFiZWxlZFN0YXRlbWVudCxcbiAgICAgICAgJ0JyZWFrU3RhdGVtZW50JzogYnJlYWtTdGF0ZW1lbnQsXG4gICAgICAgICdDb250aW51ZVN0YXRlbWVudCc6IGNvbnRpbnVlU3RhdGVtZW50LFxuICAgICAgICAnV2l0aFN0YXRlbWVudCc6IHdpdGhTdGF0ZW1lbnQsXG4gICAgICAgICdSZXR1cm5TdGF0ZW1lbnQnOiByZXR1cm5TdGF0ZW1lbnQsXG4gICAgICAgICdUaHJvd1N0YXRlbWVudCc6IHRocm93U3RhdGVtZW50LFxuICAgICAgICAnVHJ5U3RhdGVtZW50JzogdHJ5U3RhdGVtZW50LFxuICAgICAgICAnV2hpbGVTdGF0ZW1lbnQnOiB3aGlsZVN0YXRlbWVudCxcbiAgICAgICAgJ0RvV2hpbGVTdGF0ZW1lbnQnOiBkb1doaWxlU3RhdGVtZW50LFxuICAgICAgICAnRm9yU3RhdGVtZW50JzogZm9yU3RhdGVtZW50LFxuICAgICAgICAnRm9ySW5TdGF0ZW1lbnQnOiBmb3JJblN0YXRlbWVudCxcbiAgICAgICAgJ1ZhcmlhYmxlRGVjbGFyYXRpb24nOiB2YXJpYWJsZURlY2xhcmF0aW9uLFxuICAgICAgICAnRnVuY3Rpb25EZWNsYXJhdGlvbic6IGVtcHR5U3RhdGVtZW50LFxuICAgICAgICAnRGVidWdnZXJTdGF0ZW1lbnQnOiBkZWJ1Z2dlclN0YXRlbWVudFxuICAgIH07XG4gICAgdmFyIGVtcHR5TGFiZWwgPSAnZGVmYXVsdCc7IC8vIGRlZmF1bHQgaXMgYSByZXNlcnZlZCB3b3JkIHNvIG5vIGFjdHVhbCBsYWJlbCBjYW4gYmUgbmFtZWQgZGVmYXVsdCBcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBibG9ja1N0YXRlbWVudChub2RlLCB3bCkge1xuICAgICAgICB3bC5wcmVwZW5kKG5vZGUuYm9keSk7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIGVtcHR5U3RhdGVtZW50KCkge1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBleHByZXNzaW9uU3RhdGVtZW50KG5vZGUsIHdsKSB7XG4gICAgICAgIHZhciBpcCA9IHdsLnRvcCgpO1xuICAgICAgICBpcC50aGVuKG5vZGUuZXhwcmVzc2lvbik7XG4gICAgICAgIGlwLnRoZW4oZXhwcmVzc2lvblN0YXRlbWVudEVuZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGV4cHJlc3Npb25TdGF0ZW1lbnRFbmQoKSB7XG4gICAgICAgIHZhciBjID0gbW9uaXRvci5jb250ZXh0O1xuICAgICAgICB2YXIgdnMgPSBjLnZhbHVlU3RhY2s7XG4gICAgICAgIGMucmVzdWx0LnZhbHVlID0gR2V0VmFsdWUodnMucG9wKCkpO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBpZlN0YXRlbWVudChub2RlLCB3bCkge1xuICAgICAgICB2YXIgaXAgPSB3bC50b3AoKTtcbiAgICAgICAgaXAudGhlbihub2RlLnRlc3QpO1xuICAgICAgICBpcC50aGVuKGlmU3RhdGVtZW50Q2hvb3NlLCB7IG5vZGU6IG5vZGUgfSk7XG4gICAgfVxuICAgIC8vIGlmU3RhdGVtZW50Q2hvb3NlXG4gICAgZnVuY3Rpb24gaWZTdGF0ZW1lbnRDaG9vc2Uod2wsIHZzKSB7XG4gICAgICAgIHZhciBpcCA9IHdsLnRvcCgpO1xuICAgICAgICB2YXIgY29uZCA9IEdldFZhbHVlKHZzLnBvcCgpKTtcbiAgICAgICAgY29uZCA9IFRvQm9vbGVhbl8xLlRvQm9vbGVhbihjb25kKTtcbiAgICAgICAgbW9uaXRvci5jb250ZXh0LnB1c2hQQyhjb25kLmxhYmVsKTtcbiAgICAgICAgaWYgKGNvbmQubGFiZWwgPiBtb25pdG9yLmNvbnRleHQucGMgJiYgaHlicmlkKSB7XG4gICAgICAgICAgICBoeWJyaWQodGhpcy5ub2RlLmNvbnNlcXVlbnQpO1xuICAgICAgICAgICAgaHlicmlkKHRoaXMubm9kZS5hbHRlcm5hdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25kLnZhbHVlKSB7XG4gICAgICAgICAgICBpcC50aGVuKHRoaXMubm9kZS5jb25zZXF1ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubm9kZS5hbHRlcm5hdGUgJiYgaXAudGhlbih0aGlzLm5vZGUuYWx0ZXJuYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpcC50aGVuKGlmU3RhdGVtZW50RW5kLCB7IGxhYmVsOiBjb25kLmxhYmVsIH0pO1xuICAgIH1cbiAgICAvLyBpZlN0YXRlbWVudEVuZFxuICAgIGZ1bmN0aW9uIGlmU3RhdGVtZW50RW5kKHdsLCB2cykge1xuICAgICAgICB2YXIgYyA9IG1vbml0b3IuY29udGV4dDtcbiAgICAgICAgYy5wb3BQQygpO1xuICAgICAgICBpZiAoYy5yZXN1bHQudmFsdWUpIHtcbiAgICAgICAgICAgIGMucmVzdWx0LnZhbHVlLnJhaXNlKHRoaXMubGFiZWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmU3RhdGVtZW50RW5kLnJ1bmZvciA9IHJ1bmZvcl9jb250aW51ZV9icmVhaztcbiAgICAvLyAxMi4xMSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBzd2l0Y2hTdGF0ZW1lbnQobm9kZSwgd2wpIHtcbiAgICAgICAgdmFyIGMgPSBtb25pdG9yLmNvbnRleHQ7XG4gICAgICAgIHZhciBsbWFwID0gbW9uaXRvci5jb250ZXh0LmxhYmVscy5sYWJlbG1hcDtcbiAgICAgICAgaWYgKCFub2RlLmxhYmVsc2V0KSB7XG4gICAgICAgICAgICBub2RlLmxhYmVsc2V0ID0gbmV3IHNldF8xLlNldChbXSk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5sYWJlbHNldC5hZGQoZW1wdHlMYWJlbCk7XG4gICAgICAgIHZhciBvdXRlckVtcHR5TGFiZWxEYXRhID0gbG1hcFtlbXB0eUxhYmVsXTtcbiAgICAgICAgbG1hcFtlbXB0eUxhYmVsXSA9IHsgbGFiZWw6IGMuZWZmZWN0aXZlUEMsXG4gICAgICAgICAgICBwY21hcmtlcjogYy5wY1N0YWNrLm1hcmtlcigpIH07XG4gICAgICAgIHZhciBjb250ZXh0TGFiZWwgPSBsbWFwW2VtcHR5TGFiZWxdLmxhYmVsO1xuICAgICAgICBjLnB1c2hQQyhjb250ZXh0TGFiZWwpO1xuICAgICAgICB2YXIgc3dpdGNoU3RhdGUgPSB7XG4gICAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgICAgb3V0ZXJFbXB0eUxhYmVsRGF0YTogbGFiZWwsXG4gICAgICAgICAgICBkZWZhdWx0Q2FzZUluZGV4OiBudWxsLFxuICAgICAgICAgICAgbmV4dENhc2U6IDBcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG5vZGUuY2FzZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jYXNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmNhc2VzW2ldLnRlc3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoU3RhdGUuZGVmYXVsdENhc2VJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgaXAgPSB3bC50b3AoKTtcbiAgICAgICAgLy8gU3RvcmUgdGhlIGRpc2NyaW1pbmFudCB2YWx1ZSBvbiB0aGUgdmFsdWUgc3RhY2suXG4gICAgICAgIC8vIEl0IGlzIGxhdGVyIHBvcHBlZCBieSBzd2l0Y2hTdGF0ZW1lbnRFbmQuXG4gICAgICAgIGlwLnRoZW4obm9kZS5kaXNjcmltaW5hbnQpO1xuICAgICAgICBpcC50aGVuKF9HZXRWYWx1ZSk7XG4gICAgICAgIC8vIFNldCB1cCBzdGF0ZW1lbnQgbGFiZWxzXG4gICAgICAgIGlwLnRoZW4oc3dpdGNoU3RhdGVtZW50VXBncmFkZUxhYmVscywgc3dpdGNoU3RhdGUpO1xuICAgICAgICAvLyBLaWNrIG9mZiB0aGUgZmlyc3QgY2FzZVxuICAgICAgICBpcC50aGVuKHN3aXRjaFN0YXRlbWVudENhc2UsIHN3aXRjaFN0YXRlKTtcbiAgICAgICAgLy8gQ2xlYW4gdXAgYW5kIGhhbmRsZSBicmVha3NcbiAgICAgICAgaXAudGhlbihzd2l0Y2hTdGF0ZW1lbnRFbmQsIHN3aXRjaFN0YXRlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3dpdGNoU3RhdGVtZW50VXBncmFkZUxhYmVscyh3bCwgdnMpIHtcbiAgICAgICAgdmFyIGMgPSBtb25pdG9yLmNvbnRleHQ7XG4gICAgICAgIHZhciBkaXNjcmltaW5hbnRMYWJlbCA9IHZzLnBlZWsoKS5sYWJlbDtcbiAgICAgICAgdmFyIGxibG1hcCA9IGMubGFiZWxzLmxhYmVsbWFwO1xuICAgICAgICBjLmxhYmVscy5wYyA9IGx1YihjLmxhYmVscy5wYywgZGlzY3JpbWluYW50TGFiZWwpO1xuICAgICAgICB0aGlzLm5vZGUubGFiZWxzZXQuaXRlcihmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgbGJsbWFwW25hbWVdLmxhYmVsID0gbHViKGxibG1hcFtuYW1lXS5sYWJlbCwgZGlzY3JpbWluYW50TGFiZWwpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3dpdGNoU3RhdGVtZW50Q2FzZSh3bCwgdnMpIHtcbiAgICAgICAgdmFyIGlwID0gd2wudG9wKCk7XG4gICAgICAgIHZhciBpZHggPSB0aGlzLm5leHRDYXNlO1xuICAgICAgICBpZiAodGhpcy5ub2RlLmNhc2VzID09PSB1bmRlZmluZWQgfHwgaWR4ID49IHRoaXMubm9kZS5jYXNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIE5vIG1vcmUgY2FzZXMgdG8gdHJ5LCBzY2hlZHVsZSB0aGUgZGVmYXVsdCBcbiAgICAgICAgICAgIC8vIGNhc2UgaWYgdGhlcmUgaXMgb25lXG4gICAgICAgICAgICBpZiAodGhpcy5kZWZhdWx0Q2FzZUluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuZGVmYXVsdENhc2VJbmRleDsgaSA8IHRoaXMubm9kZS5jYXNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMubm9kZS5jYXNlc1tpXS5jb25zZXF1ZW50Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpcC50aGVuKHRoaXMubm9kZS5jYXNlc1tpXS5jb25zZXF1ZW50W2pdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaWR4ID09PSB0aGlzLmRlZmF1bHRDYXNlSW5kZXgpIHtcbiAgICAgICAgICAgIC8vIFNraXAgdGhlIGRlZmF1bHQgY2FzZSBkdXJpbmcgbWF0Y2hpbmdcbiAgICAgICAgICAgIHRoaXMubmV4dENhc2UgKz0gMTtcbiAgICAgICAgICAgIGlwLnRoZW4oc3dpdGNoU3RhdGVtZW50Q2FzZSwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdnMuZHVwKCk7IC8vIER1cGxpY2F0ZSB0aGUgZGlzY3JpbWluYW50IHZhbHVlXG4gICAgICAgIC8vIFB1c2ggdGhlIHRlc3QgdmFsdWVcbiAgICAgICAgaXAudGhlbih0aGlzLm5vZGUuY2FzZXNbaWR4XS50ZXN0KTtcbiAgICAgICAgaXAudGhlbihfR2V0VmFsdWUpO1xuICAgICAgICAvLyBUZXN0IGZvciBlcXVhbGl0eSBhbmQgZGVjaWRlIHdoYXQgdG8gZG8gbmV4dFxuICAgICAgICBpcC50aGVuKHN3aXRjaFN0YXRlbWVudFRlc3QsIHRoaXMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzd2l0Y2hTdGF0ZW1lbnRUZXN0KHdsLCB2cykge1xuICAgICAgICB2YXIgaXAgPSB3bC50b3AoKTtcbiAgICAgICAgYmluYXJ5U3RyaWN0RXFzKCc9PT0nLCB3bCwgdnMpO1xuICAgICAgICB2YXIgYnJlc3VsdCA9IHZzLnBvcCgpO1xuICAgICAgICBtb25pdG9yLmNvbnRleHQubGFiZWxzLnBjID0gbHViKG1vbml0b3IuY29udGV4dC5sYWJlbHMucGMsIGJyZXN1bHQubGFiZWwpO1xuICAgICAgICBpZiAoYnJlc3VsdC52YWx1ZSkge1xuICAgICAgICAgICAgLy8gRm91bmQgYSBtYXRjaCwgc2NoZWR1bGUgYWxsIHN0YXRlbWVudHMgZnJvbSBoZXJlIGRvd25cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLm5leHRDYXNlOyBpIDwgdGhpcy5ub2RlLmNhc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLm5vZGUuY2FzZXNbaV0uY29uc2VxdWVudC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpcC50aGVuKHRoaXMubm9kZS5jYXNlc1tpXS5jb25zZXF1ZW50W2pdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm5leHRDYXNlICs9IDE7XG4gICAgICAgICAgICBpcC50aGVuKHN3aXRjaFN0YXRlbWVudENhc2UsIHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN3aXRjaFN0YXRlbWVudEVuZCh3bCwgdnMpIHtcbiAgICAgICAgdmFyIGMgPSBtb25pdG9yLmNvbnRleHQ7XG4gICAgICAgIHZzLnBvcCgpOyAvLyBwb3AgdGhlIGRpc2NyaW1pbmFudCB2YWx1ZVxuICAgICAgICBjLnBvcFBDKCk7IC8vIHBvcCB0aGUgbGFiZWxDb250ZXh0XG4gICAgICAgIGlmIChjLnJlc3VsdC50eXBlID09PSAnYnJlYWsnICYmIHRoaXMubm9kZS5sYWJlbHNldC5jb250YWlucyhjLnJlc3VsdC50YXJnZXQpKSB7XG4gICAgICAgICAgICBjLnJlc3VsdC50eXBlID0gJ25vcm1hbCc7XG4gICAgICAgICAgICBjLnJlc3VsdC50YXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgYy5sYWJlbHMubGFiZWxtYXBbJ2VtcHR5J10gPSB0aGlzLm91dGVyRW1wdHlMYWJlbERhdGE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoU3RhdGVtZW50RW5kLnJ1bmZvciA9IHJ1bmZvcl9icmVhaztcbiAgICAvLyAxMi4xMiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBsYWJlbGVkU3RhdGVtZW50KG5vZGUsIHdsKSB7XG4gICAgICAgIHZhciBpcCA9IHdsLnRvcCgpO1xuICAgICAgICB2YXIgYyA9IG1vbml0b3IuY29udGV4dDtcbiAgICAgICAgdmFyIHBjbWFya2VyID0gYy5wY1N0YWNrLm1hcmtlcigpO1xuICAgICAgICB2YXIgdnNtYXJrZXIgPSBjLnZhbHVlU3RhY2subWFya2VyKCk7XG4gICAgICAgIGlmICghbm9kZS5ib2R5LmxhYmVsc2V0KSB7XG4gICAgICAgICAgICBub2RlLmJvZHkubGFiZWxzZXQgPSBuZXcgc2V0XzEuU2V0KFtub2RlLmxhYmVsLm5hbWVdKTtcbiAgICAgICAgICAgIGlmIChub2RlLmxhYmVsc2V0KSB7XG4gICAgICAgICAgICAgICAgbm9kZS5ib2R5LmxhYmVsc2V0LnVuaW9uKG5vZGUubGFiZWxzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBuYW1lID0gbm9kZS5sYWJlbC5uYW1lO1xuICAgICAgICB2YXIgb3V0ZXJsYWJlbCA9IHNldHVwU3RhdGVtZW50TGFiZWwobmFtZSk7XG4gICAgICAgIHZhciBsYWJlbGRhdGEgPSBjLmxhYmVscy5sYWJlbG1hcFtuYW1lXTtcbiAgICAgICAgbGFiZWxkYXRhLnBjbWFya2VyID0gYy5wY1N0YWNrLm1hcmtlcigpO1xuICAgICAgICBjLnB1c2hQQyhsYWJlbGRhdGEubGFiZWwpO1xuICAgICAgICBpcC50aGVuKG5vZGUuYm9keSk7XG4gICAgICAgIGlwLnRoZW4obGFiZWxlZFN0YXRlbWVudEVuZCwgeyBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgb3V0ZXJsYWJlbDogbGFiZWxkYXRhLmxhYmVsLFxuICAgICAgICAgICAgcGNtYXJrZXI6IHBjbWFya2VyLFxuICAgICAgICAgICAgdnNtYXJrZXI6IHZzbWFya2VyIH0pO1xuICAgIH1cbiAgICAvLyBsYWJlbGVkU3RhdGVtZW50RW5kXG4gICAgZnVuY3Rpb24gbGFiZWxlZFN0YXRlbWVudEVuZCh3bCwgdnMpIHtcbiAgICAgICAgdmFyIGMgPSBtb25pdG9yLmNvbnRleHQ7XG4gICAgICAgIHZhciByZXN1bHQgPSBjLnJlc3VsdDtcbiAgICAgICAgLy8gcmVzZXQgdGhlIG91dGVyIGxhYmVsIC0gbm8gbmVlZCB0byByZXNldCBwY21hcmtlciBzaW5jZVxuICAgICAgICAvLyBzdGF0ZW1lbnQgbGFiZWxzIHdpdGggdGhlIHNhbWUgbmFtZSBjYW5ub3QgYmUgbmVzdGVkXG4gICAgICAgIGMubGFiZWxzLmxhYmVsbWFwW3RoaXMubmFtZV0ubGFiZWwgPSB0aGlzLm91dGVybGFiZWw7XG4gICAgICAgIGMucGNTdGFjay5yZXNldCh0aGlzLnBjbWFya2VyKTtcbiAgICAgICAgYy52YWx1ZVN0YWNrLnJlc2V0KHRoaXMudnNtYXJrZXIpO1xuICAgICAgICBpZiAocmVzdWx0LnR5cGUgPT09ICdicmVhaycgJiYgcmVzdWx0LnRhcmdldCA9PT0gdGhpcy5uYW1lKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjLnJlc3VsdDtcbiAgICAgICAgICAgIHJlc3VsdC50eXBlID0gJ25vcm1hbCc7XG4gICAgICAgICAgICByZXN1bHQudGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsYWJlbGVkU3RhdGVtZW50RW5kLnJ1bmZvciA9IHJ1bmZvcl9jb250aW51ZV9icmVhaztcbiAgICAvLyAxMi44IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBicmVha1N0YXRlbWVudChub2RlLCB3bCkge1xuICAgICAgICB2YXIgYyA9IG1vbml0b3IuY29udGV4dDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG1vbml0b3IuY29udGV4dC5yZXN1bHQ7XG4gICAgICAgIHZhciBuYW1lID0gbm9kZS5sYWJlbCA/IG5vZGUubGFiZWwubmFtZSA6IGVtcHR5TGFiZWw7XG4gICAgICAgIHZhciBsYmxjb250ZXh0ID0gYy5sYWJlbHMubGFiZWxtYXBbbmFtZV0ubGFiZWw7XG4gICAgICAgIHZhciBkaXNwbGF5TmFtZSA9IG5vZGUubGFiZWwgPyAnKCcgKyBuYW1lICsgJyknIDogJyc7XG4gICAgICAgIG1vbml0b3IuYXNzZXJ0KGxlKGMuZWZmZWN0aXZlUEMsIGxibGNvbnRleHQpLCAnd3JpdGUgY29udGV4dCAnICsgYy5lZmZlY3RpdmVQQyArICcgbm90IGJlbG93ICcgK1xuICAgICAgICAgICAgJ2xhYmVsIGNvbnRleHQgJyArIGxibGNvbnRleHQgKyAnICcgKyBkaXNwbGF5TmFtZSk7XG4gICAgICAgIC8vIEZvciBvYnNlcnZhYmxlIGZsb3dzXG4gICAgICAgIGxibGNvbnRleHQubHViKGMuZWZmZWN0aXZlUEMpO1xuICAgICAgICByZXN1bHQudHlwZSA9ICdicmVhayc7XG4gICAgICAgIHJlc3VsdC50YXJnZXQgPSBuYW1lO1xuICAgIH1cbiAgICAvLyAxMi43IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBjb250aW51ZVN0YXRlbWVudChub2RlLCB3bCkge1xuICAgICAgICB2YXIgYyA9IG1vbml0b3IuY29udGV4dDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG1vbml0b3IuY29udGV4dC5yZXN1bHQ7XG4gICAgICAgIHZhciBuYW1lID0gbm9kZS5sYWJlbCA/IG5vZGUubGFiZWwubmFtZSA6IGVtcHR5TGFiZWw7XG4gICAgICAgIHZhciBsYmxjb250ZXh0ID0gYy5sYWJlbHMubGFiZWxtYXBbbmFtZV0ubGFiZWw7XG4gICAgICAgIHZhciBkaXNwbGF5TmFtZSA9IG5vZGUubGFiZWwgPyAnKCcgKyBuYW1lICsgJyknIDogJyc7XG4gICAgICAgIG1vbml0b3IuYXNzZXJ0KGxlKGMuZWZmZWN0aXZlUEMsIGxibGNvbnRleHQpLCAnd3JpdGUgY29udGV4dCAnICsgYy5lZmZlY3RpdmVQQyArICcgbm90IGJlbG93ICcgK1xuICAgICAgICAgICAgJ2xhYmVsIGNvbnRleHQgJyArIGxibGNvbnRleHQgKyBkaXNwbGF5TmFtZSk7XG4gICAgICAgIC8vIEZvciBvYnNlcnZhYmxlIGZsb3dzXG4gICAgICAgIGxibGNvbnRleHQubHViKGMuZWZmZWN0aXZlUEMpO1xuICAgICAgICByZXN1bHQudHlwZSA9ICdjb250aW51ZSc7XG4gICAgICAgIHJlc3VsdC50YXJnZXQgPSBuYW1lO1xuICAgIH1cbiAgICAvLyAxMi4xMCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiB3aXRoU3RhdGVtZW50KG5vZGUsIHdsKSB7XG4gICAgICAgIHZhciBpcCA9IHdsLnRvcCgpO1xuICAgICAgICBpcC50aGVuKG5vZGUub2JqZWN0KTtcbiAgICAgICAgaXAudGhlbih3aXRoU3RhdGVtZW50Qm9keSwgeyBub2RlOiBub2RlIH0pO1xuICAgIH1cbiAgICAvLyB3aXRoU3RhdGVtZW50Qm9keVxuICAgIGZ1bmN0aW9uIHdpdGhTdGF0ZW1lbnRCb2R5KHdsLCB2cykge1xuICAgICAgICB2YXIgaXAgPSB3bC50b3AoKTtcbiAgICAgICAgdmFyIGMgPSBtb25pdG9yLmNvbnRleHQ7XG4gICAgICAgIHZhciB2YWwgPSBHZXRWYWx1ZSh2cy5wb3AoKSk7XG4gICAgICAgIHZhciBvYmogPSBUb09iamVjdF8xLlRvT2JqZWN0KHZhbCk7XG4gICAgICAgIHZhciBvbGRFbnYgPSBjLmxleGljYWxFbnY7XG4gICAgICAgIHZhciBuZXdFbnYgPSBlbnYuTmV3T2JqZWN0RW52aXJvbm1lbnQob2JqLCBvbGRFbnYpO1xuICAgICAgICBuZXdFbnYucHJvdmlkZVRoaXMoKTtcbiAgICAgICAgYy5sZXhpY2FsRW52ID0gbmV3IHZhbHVlc18xLlZhbHVlKG5ld0Vudiwgb2JqLmxhYmVsKTtcbiAgICAgICAgaXAudGhlbih0aGlzLm5vZGUuYm9keSk7XG4gICAgICAgIGlwLnRoZW4od2l0aFN0YXRlbWVudEVuZCwgeyBsZXhpY2FsRW52OiBvbGRFbnYgfSk7XG4gICAgfVxuICAgIC8vIHdpdGhTdGF0ZW1lbnRFbmRcbiAgICBmdW5jdGlvbiB3aXRoU3RhdGVtZW50RW5kKHdsLCB2cykge1xuICAgICAgICBtb25pdG9yLmNvbnRleHQubGV4aWNhbEVudiA9IHRoaXMubGV4aWNhbEVudjtcbiAgICB9XG4gICAgd2l0aFN0YXRlbWVudEVuZC5ydW5mb3IgPSBydW5mb3JfY29udGludWVfYnJlYWs7XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFxuICAgIGZ1bmN0aW9uIHJldHVyblN0YXRlbWVudChub2RlLCB3bCkge1xuICAgICAgICB2YXIgYyA9IG1vbml0b3IuY29udGV4dDtcbiAgICAgICAgdmFyIGlwID0gd2wudG9wKCk7XG4gICAgICAgIG1vbml0b3IuYXNzZXJ0KGxlKGMuZWZmZWN0aXZlUEMsIGMubGFiZWxzLnJldCksICd3cml0ZSBjb250ZXh0ICcgKyBjLmVmZmVjdGl2ZVBDICsgJyBub3QgYmVsb3cgJyArXG4gICAgICAgICAgICAncmV0dXJuIGNvbnRleHQgJyArIGMubGFiZWxzLnJldCk7XG4gICAgICAgIC8vIFRoaXMgaXMgZm9yIHRoZSBuZXcgbW9kZSBvZiBvcGVyYXRpb24sIGZvciBvYnNlcnZhYmxlIGZsb3dzXG4gICAgICAgIGMubGFiZWxzLnJldC5sdWIoYy5lZmZlY3RpdmVQQyk7XG4gICAgICAgIGlmIChub2RlLmFyZ3VtZW50KSB7XG4gICAgICAgICAgICBpcC50aGVuKG5vZGUuYXJndW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYy52YWx1ZVN0YWNrLnB1c2gobmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgYm90KSk7XG4gICAgICAgIH1cbiAgICAgICAgaXAudGhlbihyZXR1cm5TdGF0ZW1lbnRFbmQpO1xuICAgIH1cbiAgICAvLyByZXR1cm5TdGF0ZW1lbnRFbmRcbiAgICBmdW5jdGlvbiByZXR1cm5TdGF0ZW1lbnRFbmQod2wsIHZzKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBtb25pdG9yLmNvbnRleHQucmVzdWx0O1xuICAgICAgICByZXN1bHQudHlwZSA9ICdyZXR1cm4nO1xuICAgICAgICByZXN1bHQudmFsdWUgPSBHZXRWYWx1ZSh2cy5wb3AoKSk7XG4gICAgICAgIHJlc3VsdC50YXJnZXQgPSBudWxsO1xuICAgIH1cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gXG4gICAgZnVuY3Rpb24gdGhyb3dTdGF0ZW1lbnQobm9kZSwgd2wpIHtcbiAgICAgICAgdmFyIGlwID0gd2wudG9wKCk7XG4gICAgICAgIGlwLnRoZW4obm9kZS5hcmd1bWVudCk7XG4gICAgICAgIGlwLnRoZW4odGhyb3dTdGF0ZW1lbnRFbmQpO1xuICAgIH1cbiAgICAvLyB0aHJvd1N0YXRlbWVudEVuZFxuICAgIGZ1bmN0aW9uIHRocm93U3RhdGVtZW50RW5kKHdsLCB2cykge1xuICAgICAgICB2YXIgYyA9IG1vbml0b3IuY29udGV4dDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGMucmVzdWx0O1xuICAgICAgICB2YXIgZXhwclJlZiA9IHZzLnBvcCgpO1xuICAgICAgICAvLyBWZXJmaXkgdGhhdCB0aGUgZXhjZXB0aW9uIGlzIGFsbG93ZWQgXG4gICAgICAgIG1vbml0b3IuYXNzZXJ0KGxlKGMuZWZmZWN0aXZlUEMsIGMubGFiZWxzLmV4YyksIFwiZXhjZXB0aW9uIGluIFwiICsgYy5lZmZlY3RpdmVQQyArIFwiIG5vdCBhbGxvd2VkIHdpdGggZXhjZXB0aW9uIGxhYmVsIFwiICsgYy5sYWJlbHMuZXhjKTtcbiAgICAgICAgLy8gRm9yIG9ic2VydmFibGUgZmxvd3NcbiAgICAgICAgYy5sYWJlbHMuZXhjLmx1YihjLmVmZmVjdGl2ZVBDKTtcbiAgICAgICAgcmVzdWx0LnR5cGUgPSAndGhyb3cnO1xuICAgICAgICByZXN1bHQudmFsdWUgPSBHZXRWYWx1ZShleHByUmVmKTtcbiAgICAgICAgbW9uaXRvci5vZmZlbmRpbmdUcmFjZSA9IG1vbml0b3Iuc3RhY2tUcmFjZSgpO1xuICAgIH1cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gXG4gICAgZnVuY3Rpb24gdHJ5U3RhdGVtZW50KG5vZGUsIHdsKSB7XG4gICAgICAgIHZhciBpcCA9IHdsLnRvcCgpO1xuICAgICAgICB2YXIgYyA9IG1vbml0b3IuY29udGV4dDtcbiAgICAgICAgaXAudGhlbihub2RlLmJsb2NrKTtcbiAgICAgICAgLy8gRXhwcmVzc2lvbiBldmFsdWF0aW9uIG1pZ2h0IGNhdXNlIGV4Y2VwdGlvbnM7IGlmIHNvIHRoZSBzdGF0ZSBvZlxuICAgICAgICAvLyB0aGUgY29udGV4dCBtaWdodCBuZWVkIHNvbWUgY2xlYW5pbmcgdXAuXG4gICAgICAgIC8vIFRoZSByZXN1bHQgc3RhY2sgYW5kIHRoZSB3b3JrbGlzdCBhcmUgbm90IGFmZmVjdGVkIGJ5IGV4cHJlc3Npb24gc28gdGhlaXJcbiAgICAgICAgLy8gc3RhdGVzIGFyZSBmaW5lLlxuICAgICAgICAvLyBUaGUgcmV0IGxhYmVsIGNhbm5vdCBiZSBhZmZlY3RlZCBieSBleGNlcHRpb25zLlxuICAgICAgICAvLyBUaGUgc3RhY2tzIG5lZWRzIHRvIGJlIHJlc2V0LiBcbiAgICAgICAgdmFyIHBjbWFya2VyID0gYy5wY1N0YWNrLm1hcmtlcigpO1xuICAgICAgICB2YXIgdnNtYXJrZXIgPSBjLnZhbHVlU3RhY2subWFya2VyKCk7XG4gICAgICAgIHZhciBleGMgPSBjLmxhYmVscy5leGM7XG4gICAgICAgIC8vIGVzcHJpbWEgc2VlbXMgdG8gZ2VuZXJhdGUgYSBsaXN0IG9mIGhhbmRsZXJzIC0tLSBzdGFuZGFyZCBvbmx5IHN1cHBvcnRzIG9uZVxuICAgICAgICBpcC50aGVuKHRyeVN0YXRlbWVudENhdGNoLCB7IGhhbmRsZXI6IG5vZGUuaGFuZGxlcnNbMF0sXG4gICAgICAgICAgICBwY21hcmtlcjogcGNtYXJrZXIsXG4gICAgICAgICAgICB2c21hcmtlcjogdnNtYXJrZXIsXG4gICAgICAgICAgICBleGM6IGV4YyB9KTtcbiAgICAgICAgLy8gVGhlIGZpbmFsaXplciBcbiAgICAgICAgdmFyIGxleGljYWxFbnYgPSBjLmxleGljYWxFbnY7XG4gICAgICAgIGlwLnRoZW4odHJ5U3RhdGVtZW50RmluYWxseSwgeyBib2R5OiBub2RlLmZpbmFsaXplcixcbiAgICAgICAgICAgIHBjbWFya2VyOiBwY21hcmtlcixcbiAgICAgICAgICAgIHZzbWFya2VyOiB2c21hcmtlcixcbiAgICAgICAgICAgIGxleGljYWxFbnY6IGxleGljYWxFbnYgfSk7XG4gICAgfVxuICAgIC8vIHRyeVN0YXRldGVtZW50Q2F0Y2hcbiAgICBmdW5jdGlvbiB0cnlTdGF0ZW1lbnRDYXRjaCh3bCwgdnMpIHtcbiAgICAgICAgdmFyIGMgPSBtb25pdG9yLmNvbnRleHQ7XG4gICAgICAgIHZhciByZXN1bHQgPSBjLnJlc3VsdDtcbiAgICAgICAgLy8gV2UgYXJlIGluIGNoYXJnZSBvZiByZXNldHRpbmcgdGhlIGV4YyBsYWJlbCwgdGhlIGZpbmFsbHkgZG9lcyB0aGUgcmVzdCBcbiAgICAgICAgLy8gb2YgdGhlIGNsZWFuaW5nLlxuICAgICAgICAvLyBUaGUgcGMgb2YgdGhlIGNhdGNoIGJsb2NrIGlzIHBjICsgZXhjIG9mIGJvZHlcbiAgICAgICAgdmFyIGhhbmRsZXJQQyA9IGx1YihjLmxhYmVscy5wYywgYy5sYWJlbHMuZXhjKTtcbiAgICAgICAgLy8gVGhlIGV4YyBvZiB0aGUgY2F0Y2ggYmxvY2sgaXMgdGhlIGV4YyBvZiBfY2F0Y2gsIHRoYXQgcmVzZXRzIHRoZSBleGNcbiAgICAgICAgYy5sYWJlbHMuZXhjID0gdGhpcy5leGM7XG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIGhhbmRsZXIgb3Igbm8gZXhjZXB0aW9uIHdhcyB0aHJvd24sIHRoZXJlJ3Mgbm90aGluZyBtb3JlIHRvIGRvXG4gICAgICAgIGlmICghdGhpcy5oYW5kbGVyIHx8IHJlc3VsdC50eXBlICE9PSAndGhyb3cnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYy5wY1N0YWNrLnJlc2V0KHRoaXMucGNtYXJrZXIpO1xuICAgICAgICBjLnZhbHVlU3RhY2sucmVzZXQodGhpcy52c21hcmtlcik7XG4gICAgICAgIGMucGNTdGFjay5wdXNoKGhhbmRsZXJQQyk7XG4gICAgICAgIHZhciBjYXRjaEVudiA9IGVudi5OZXdEZWNsYXJhdGl2ZUVudmlyb25tZW50KGMubGV4aWNhbEVudik7XG4gICAgICAgIC8vIEVDTUEtMjYyIGFsbG93cyBvbmx5IGlkZW5maWZpZXJzLCBidXQgdGhlIHBhcnNlciBhbGxvd3MgcGF0dGVybnM7XG4gICAgICAgIGlmICh0aGlzLmhhbmRsZXIucGFyYW0udHlwZSAhPT0gJ0lkZW50aWZpZXInKSB7XG4gICAgICAgICAgICBtb25pdG9yLmZhdGFsKCdQYXR0ZXJuIGluIGNhdGNoIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaWRlbnRpZmllciA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSh0aGlzLmhhbmRsZXIucGFyYW0ubmFtZSwgYm90KTtcbiAgICAgICAgY2F0Y2hFbnYuQ3JlYXRlTXV0YWJsZUJpbmRpbmcoaWRlbnRpZmllcik7XG4gICAgICAgIGNhdGNoRW52LlNldE11dGFibGVCaW5kaW5nKGlkZW50aWZpZXIsIHJlc3VsdC52YWx1ZSk7XG4gICAgICAgIGMubGV4aWNhbEVudiA9IG5ldyB2YWx1ZXNfMS5WYWx1ZShjYXRjaEVudiwgYy5lZmZlY3RpdmVQQyk7XG4gICAgICAgIHJlc3VsdC50eXBlID0gJ25vcm1hbCc7XG4gICAgICAgIHJlc3VsdC52YWx1ZSA9IG51bGw7XG4gICAgICAgIHdsLnB1c2godGhpcy5oYW5kbGVyLmJvZHkpO1xuICAgIH1cbiAgICB0cnlTdGF0ZW1lbnRDYXRjaC5ydW5mb3IgPSBydW5mb3JfdGhyb3c7XG4gICAgLy8gdHJ5U3RhdGVtZW50RmluYWxseVxuICAgIGZ1bmN0aW9uIHRyeVN0YXRlbWVudEZpbmFsbHkoKSB7XG4gICAgICAgIHZhciBjID0gbW9uaXRvci5jb250ZXh0O1xuICAgICAgICAvLyBUaGUgcGMgb2YgdGhlIGZpbmFsbHkgaXMgdGhlIHBjIG9mIHRoZSB0cnkuXG4gICAgICAgIC8vIFRoZSBleGMgb2YgdGhlIGZpbmFsbHkgaXMgdGhlIGV4YyBvZiB0aGUgX2NhdGNoLCB3aGljaCBpcyBlaXRoZXJcbiAgICAgICAgLy8gdGhlIGV4YyBvZiB0aGVlZSB0cnksIHVubGVzcyBpdCB3YXMgcmFpc2VkIGJ5IGEgaGFuZGxlciwgaW4gd2hpY2hcbiAgICAgICAgLy8gY2FzZSBpdCBlc2NhcGVzIHRoZSB0cnksIGFuZCBzaG91bGQgYWZmZWN0IHRoZSBmaW5hbGx5IHRvby5cbiAgICAgICAgLy8gV2UgYXJlIGluIGNoYXJnZSBvZiByZXNldHRpbmcgdGhlIHBjU3RhY2ssIGFuZCB0aGUgbGV4aWNhbEVudiBcbiAgICAgICAgYy5wY1N0YWNrLnJlc2V0KHRoaXMucGNtYXJrZXIpO1xuICAgICAgICBjLnZhbHVlU3RhY2sucmVzZXQodGhpcy52c21hcmtlcik7XG4gICAgICAgIGMubGV4aWNhbEVudiA9IHRoaXMubGV4aWNhbEVudjtcbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gZmluYWxseSBibG9jaywgd2UncmUgZG9uZVxuICAgICAgICBpZiAoIXRoaXMuYm9keSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFsbG9jYXRlIGEgbmV3IHJlc3VsdCAtLS0gX2ZpbmFsbHkgZW52IGNob3NlcyBiZXR3ZWVuIHRoZSByZXN1bHRcbiAgICAgICAgLy8gb2YgdGhlIGJvZHkvaGFuZGxlciwgYW5kIHRoZSByZXN1bHQgb2YgdGhlIGZpbmFsbHlcbiAgICAgICAgdmFyIHJlc3VsdCA9IGMucmVzdWx0O1xuICAgICAgICBjLnJlc3VsdCA9IG5ldyBjb250ZXh0XzEuUmVzdWx0KCk7XG4gICAgICAgIHZhciBpcCA9IGMud29ya0xpc3QudG9wKCk7XG4gICAgICAgIGlwLnRoZW4odGhpcy5ib2R5KTtcbiAgICAgICAgaXAudGhlbih0cnlTdGF0ZW1lbnRGaW5hbGx5RW5kLCB7IHJlc3VsdDogcmVzdWx0IH0pO1xuICAgIH1cbiAgICB0cnlTdGF0ZW1lbnRGaW5hbGx5LnJ1bmZvciA9IHJ1bmZvcl9hbGw7XG4gICAgLy8gdHJ5U3RhdGVtZW50RmluYWxseUVuZFxuICAgIGZ1bmN0aW9uIHRyeVN0YXRlbWVudEZpbmFsbHlFbmQod2wsIHZzKSB7XG4gICAgICAgIHZhciBjID0gbW9uaXRvci5jb250ZXh0O1xuICAgICAgICBpZiAoYy5yZXN1bHQudHlwZSA9PT0gJ25vcm1hbCcpIHtcbiAgICAgICAgICAgIGMucmVzdWx0ID0gdGhpcy5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdHJ5U3RhdGVtZW50RmluYWxseUVuZC5ydW5mb3IgPSBydW5mb3JfYWxsO1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIHdoaWxlU3RhdGVtZW50KG5vZGUsIHdsKSB7XG4gICAgICAgIHZhciBjID0gbW9uaXRvci5jb250ZXh0O1xuICAgICAgICB2YXIgaXAgPSB3bC50b3AoKTtcbiAgICAgICAgdmFyIGxtYXAgPSBjLmxhYmVscy5sYWJlbG1hcDtcbiAgICAgICAgaWYgKCFub2RlLmxhYmVsc2V0KSB7XG4gICAgICAgICAgICBub2RlLmxhYmVsc2V0ID0gbmV3IHNldF8xLlNldChbXSk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5sYWJlbHNldC5hZGQoZW1wdHlMYWJlbCk7XG4gICAgICAgIHZhciBvdXRlckVtcHR5TGFiZWxEYXRhID0gbG1hcFtlbXB0eUxhYmVsXTtcbiAgICAgICAgbG1hcFtlbXB0eUxhYmVsXSA9IHsgbGFiZWw6IGMuZWZmZWN0aXZlUEMsXG4gICAgICAgICAgICBwY21hcmtlcjogYy5wY1N0YWNrLm1hcmtlcigpIH07XG4gICAgICAgIHZhciBjb250ZXh0TGFiZWwgPSBsbWFwW2VtcHR5TGFiZWxdLmxhYmVsO1xuICAgICAgICBjLnB1c2hQQyhjb250ZXh0TGFiZWwpO1xuICAgICAgICBpcC50aGVuKHdoaWxlU3RhdGVtZW50U2hhcmVkLCB7IG5vZGU6IG5vZGUsIG91dGVyRW1wdHlMYWJlbERhdGE6IG91dGVyRW1wdHlMYWJlbERhdGEgfSk7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIGRvV2hpbGVTdGF0ZW1lbnQobm9kZSwgd2wpIHtcbiAgICAgICAgdmFyIGMgPSBtb25pdG9yLmNvbnRleHQ7XG4gICAgICAgIHZhciBpcCA9IHdsLnRvcCgpO1xuICAgICAgICB2YXIgbG1hcCA9IGMubGFiZWxzLmxhYmVsbWFwO1xuICAgICAgICBpZiAoIW5vZGUubGFiZWxzZXQpIHtcbiAgICAgICAgICAgIG5vZGUubGFiZWxzZXQgPSBuZXcgc2V0XzEuU2V0KFtdKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLmxhYmVsc2V0LmFkZChlbXB0eUxhYmVsKTtcbiAgICAgICAgdmFyIG91dGVyRW1wdHlMYWJlbERhdGEgPSBsbWFwW2VtcHR5TGFiZWxdO1xuICAgICAgICBsbWFwW2VtcHR5TGFiZWxdID0geyBsYWJlbDogYy5lZmZlY3RpdmVQQyxcbiAgICAgICAgICAgIHBjbWFya2VyOiBjLnBjU3RhY2subWFya2VyKCkgfTtcbiAgICAgICAgLy8gdXNlZCBmb3IgYm90aCBzdGF0ZW1lbnQgbGFiZWwgc2VjdXJpdHkgbGFiZWxzIGFuZCBjb250cm9sIHNlY3VyaXR5IGxhYmVsXG4gICAgICAgIHZhciBjb250ZXh0TGFiZWwgPSBsbWFwW2VtcHR5TGFiZWxdLmxhYmVsO1xuICAgICAgICBjLnB1c2hQQyhjb250ZXh0TGFiZWwpO1xuICAgICAgICBpcC50aGVuKG5vZGUuYm9keSk7XG4gICAgICAgIGlwLnRoZW4od2hpbGVTdGF0ZW1lbnRTaGFyZWQsIHsgbm9kZTogbm9kZSwgb3V0ZXJFbXB0eUxhYmVsRGF0YTogb3V0ZXJFbXB0eUxhYmVsRGF0YSB9KTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gd2hpbGVTdGF0ZW1lbnRTaGFyZWQod2wsIHZzKSB7XG4gICAgICAgIHZhciBpcCA9IHdsLnRvcCgpO1xuICAgICAgICB2YXIgYyA9IG1vbml0b3IuY29udGV4dDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGMucmVzdWx0O1xuICAgICAgICBpZiAocmVzdWx0LnR5cGUgPT09ICdicmVhaycgJiYgdGhpcy5ub2RlLmxhYmVsc2V0LmNvbnRhaW5zKHJlc3VsdC50YXJnZXQpKSB7XG4gICAgICAgICAgICByZXN1bHQudHlwZSA9ICdub3JtYWwnO1xuICAgICAgICAgICAgcmVzdWx0LnRhcmdldCA9IG51bGw7XG4gICAgICAgICAgICBjLmxhYmVscy5sYWJlbG1hcFtlbXB0eUxhYmVsXSA9IHRoaXMub3V0ZXJFbXB0eUxhYmVsRGF0YTtcbiAgICAgICAgICAgIGMucG9wUEMoKTsgLy8gY29udGV4dExhYmVsXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC50eXBlICE9PSAnY29udGludWUnIHx8ICF0aGlzLm5vZGUubGFiZWxzZXQuY29udGFpbnMocmVzdWx0LnRhcmdldCkpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQudHlwZSAhPT0gJ25vcm1hbCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29udGludWUgZ2V0cyB1cyBoZXJlXG4gICAgICAgIHJlc3VsdC50eXBlID0gJ25vcm1hbCc7XG4gICAgICAgIHJlc3VsdC50YXJnZXQgPSBudWxsO1xuICAgICAgICBpcC50aGVuKHRoaXMubm9kZS50ZXN0KTtcbiAgICAgICAgaXAudGhlbih3aGlsZVN0YXRlbWVudFNoYXJlZENob29zZSwgdGhpcyk7XG4gICAgfVxuICAgIHdoaWxlU3RhdGVtZW50U2hhcmVkLnJ1bmZvciA9IHJ1bmZvcl9jb250aW51ZV9icmVhaztcbiAgICAvLyB3aGlsZVN0YXRlbWVudFNoYXJlZENob29zZVxuICAgIGZ1bmN0aW9uIHdoaWxlU3RhdGVtZW50U2hhcmVkQ2hvb3NlKHdsLCB2cykge1xuICAgICAgICB2YXIgYyA9IG1vbml0b3IuY29udGV4dDtcbiAgICAgICAgdmFyIGNvbmQgPSBHZXRWYWx1ZSh2cy5wb3AoKSk7XG4gICAgICAgIHZhciBjb25kYiA9IFRvQm9vbGVhbl8xLlRvQm9vbGVhbihjb25kKTtcbiAgICAgICAgYy5sYWJlbHMucGMgPSBsdWIoYy5sYWJlbHMucGMsIGNvbmRiLmxhYmVsKTtcbiAgICAgICAgaWYgKGNvbmRiLnZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgaXAgPSB3bC50b3AoKTtcbiAgICAgICAgICAgIGlwLnRoZW4odGhpcy5ub2RlLmJvZHkpO1xuICAgICAgICAgICAgaXAudGhlbih3aGlsZVN0YXRlbWVudFNoYXJlZCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjLmxhYmVscy5sYWJlbG1hcFtlbXB0eUxhYmVsXSA9IHRoaXMub3V0ZXJFbXB0eUxhYmVsRGF0YTtcbiAgICAgICAgICAgIGMucG9wUEMoKTsgLy8gY29udGV4dExhYmVsXG4gICAgICAgIH1cbiAgICB9XG4gICAgd2hpbGVTdGF0ZW1lbnRTaGFyZWRDaG9vc2UucnVuZm9yID0gcnVuZm9yX2NvbnRpbnVlO1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIGZvclN0YXRlbWVudChub2RlLCB3bCkge1xuICAgICAgICB2YXIgYyA9IG1vbml0b3IuY29udGV4dDtcbiAgICAgICAgdmFyIGlwID0gd2wudG9wKCk7XG4gICAgICAgIHZhciBsbWFwID0gYy5sYWJlbHMubGFiZWxtYXA7XG4gICAgICAgIGlmIChub2RlLmluaXQpIHtcbiAgICAgICAgICAgIGlwLnRoZW4obm9kZS5pbml0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5vZGUubGFiZWxzZXQpIHtcbiAgICAgICAgICAgIG5vZGUubGFiZWxzZXQgPSBuZXcgc2V0XzEuU2V0KFtdKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLmxhYmVsc2V0LmFkZChlbXB0eUxhYmVsKTtcbiAgICAgICAgdmFyIG91dGVyRW1wdHlMYWJlbERhdGEgPSBsbWFwW2VtcHR5TGFiZWxdO1xuICAgICAgICBsbWFwW2VtcHR5TGFiZWxdID0geyBsYWJlbDogYy5lZmZlY3RpdmVQQyxcbiAgICAgICAgICAgIHBjbWFya2VyOiBjLnBjU3RhY2subWFya2VyKCkgfTtcbiAgICAgICAgdmFyIGNvbnRleHRMYWJlbCA9IGxtYXBbZW1wdHlMYWJlbF0ubGFiZWw7XG4gICAgICAgIGMucHVzaFBDKGNvbnRleHRMYWJlbCk7XG4gICAgICAgIGlwLnRoZW4oZm9yU3RhdGVtZW50TWFpbiwgeyBub2RlOiBub2RlIH0pO1xuICAgICAgICBpcC50aGVuKGZvclN0YXRlbWVudEVuZCwgeyBvdXRlckVtcHR5TGFiZWxEYXRhOiBvdXRlckVtcHR5TGFiZWxEYXRhIH0pO1xuICAgIH1cbiAgICAvLyBmb3JTdGF0ZW1lbnRNYWluXG4gICAgZnVuY3Rpb24gZm9yU3RhdGVtZW50TWFpbih3bCwgdnMpIHtcbiAgICAgICAgdmFyIGMgPSBtb25pdG9yLmNvbnRleHQ7XG4gICAgICAgIHZhciBpcCA9IHdsLnRvcCgpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gYy5yZXN1bHQ7XG4gICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gJ2JyZWFrJyAmJiB0aGlzLm5vZGUubGFiZWxzZXQuY29udGFpbnMocmVzdWx0LnRhcmdldCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC50eXBlID0gJ25vcm1hbCc7XG4gICAgICAgICAgICByZXN1bHQudGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0LnR5cGUgIT09ICdjb250aW51ZScgfHwgIXRoaXMubm9kZS5sYWJlbHNldC5jb250YWlucyhyZXN1bHQudGFyZ2V0KSkge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC50eXBlICE9PSAnbm9ybWFsJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHQudHlwZSA9ICdub3JtYWwnO1xuICAgICAgICByZXN1bHQudGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMubm9kZS50ZXN0KSB7XG4gICAgICAgICAgICBpcC50aGVuKHRoaXMubm9kZS50ZXN0KTtcbiAgICAgICAgICAgIGlwLnRoZW4oZm9yU3RhdGVtZW50Q2hvb3NlLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlwLnRoZW4oZm9yU3RhdGVtZW50RXhlY3V0ZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yU3RhdGVtZW50TWFpbi5ydW5mb3IgPSBydW5mb3JfY29udGludWVfYnJlYWs7XG4gICAgLy8gZm9yU3RhdGVtZW50Q2hvb3NlXG4gICAgZnVuY3Rpb24gZm9yU3RhdGVtZW50Q2hvb3NlKHdsLCB2cykge1xuICAgICAgICB2YXIgaXAgPSB3bC50b3AoKTtcbiAgICAgICAgdmFyIGMgPSBtb25pdG9yLmNvbnRleHQ7XG4gICAgICAgIHZhciByZXN1bHQgPSBjLnJlc3VsdDtcbiAgICAgICAgdmFyIGNvbmQgPSBHZXRWYWx1ZSh2cy5wb3AoKSk7XG4gICAgICAgIHZhciBjb25kYiA9IFRvQm9vbGVhbl8xLlRvQm9vbGVhbihjb25kKTtcbiAgICAgICAgYy5sYWJlbHMucGMgPSBsdWIoYy5sYWJlbHMucGMsIGNvbmRiLmxhYmVsKTtcbiAgICAgICAgaWYgKCFjb25kYi52YWx1ZSkge1xuICAgICAgICAgICAgcmVzdWx0LnR5cGUgPSAnbm9ybWFsJztcbiAgICAgICAgICAgIHJlc3VsdC50YXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlwLnRoZW4oZm9yU3RhdGVtZW50RXhlY3V0ZSwgdGhpcyk7XG4gICAgfVxuICAgIGZvclN0YXRlbWVudENob29zZS5ydW5mb3IgPSBydW5mb3JfY29udGludWU7XG4gICAgZnVuY3Rpb24gZm9yU3RhdGVtZW50RXhlY3V0ZSh3bCwgdnMpIHtcbiAgICAgICAgdmFyIGlwID0gd2wudG9wKCk7XG4gICAgICAgIGlwLnRoZW4odGhpcy5ub2RlLmJvZHkpO1xuICAgICAgICBpcC50aGVuKGZvclN0YXRlbWVudFVwZGF0ZSwgdGhpcyk7XG4gICAgICAgIGlwLnRoZW4oZm9yU3RhdGVtZW50TWFpbiwgdGhpcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZvclN0YXRlbWVudFVwZGF0ZSh3bCwgdnMpIHtcbiAgICAgICAgdmFyIGlwID0gd2wudG9wKCk7XG4gICAgICAgIHZhciBjID0gbW9uaXRvci5jb250ZXh0O1xuICAgICAgICB2YXIgcmVzdWx0ID0gYy5yZXN1bHQ7XG4gICAgICAgIGlmIChyZXN1bHQudHlwZSAhPT0gJ2NvbnRpbnVlJyB8fCAhdGhpcy5ub2RlLmxhYmVsc2V0LmNvbnRhaW5zKHJlc3VsdC50YXJnZXQpKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnR5cGUgIT09ICdub3JtYWwnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC50eXBlID0gJ25vcm1hbCc7XG4gICAgICAgIHJlc3VsdC50YXJnZXQgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5ub2RlLnVwZGF0ZSkge1xuICAgICAgICAgICAgaXAudGhlbih0aGlzLm5vZGUudXBkYXRlKTtcbiAgICAgICAgICAgIGlwLnRoZW4oX0dldFZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3JTdGF0ZW1lbnRVcGRhdGUucnVuZm9yID0gcnVuZm9yX2NvbnRpbnVlO1xuICAgIC8vIGZvclN0YXRlbWVudGVFbmRcbiAgICBmdW5jdGlvbiBmb3JTdGF0ZW1lbnRFbmQod2wsIHZzKSB7XG4gICAgICAgIHZhciBjID0gbW9uaXRvci5jb250ZXh0O1xuICAgICAgICBjLmxhYmVscy5sYWJlbG1hcFtlbXB0eUxhYmVsXSA9IHRoaXMub3V0ZXJFbXB0eUxhYmVsRGF0YTtcbiAgICAgICAgYy5wb3BQQygpO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBmb3JJblN0YXRlbWVudChub2RlLCB3bCkge1xuICAgICAgICB2YXIgaXAgPSB3bC50b3AoKTtcbiAgICAgICAgdmFyIGxlZnQ7XG4gICAgICAgIGlmIChub2RlLmxlZnQudHlwZSA9PT0gJ1ZhcmlhYmxlRGVjbGFyYXRpb24nKSB7XG4gICAgICAgICAgICBpcC50aGVuKG5vZGUubGVmdCk7XG4gICAgICAgICAgICAvLyB0aGUgc3RhbmRhcmQgb25seSBhbGxvd3MgZm9yIG9uZSBkZWNsYXJhdGlvbiwgZ2V0IHRoZSBuYW1lXG4gICAgICAgICAgICBsZWZ0ID0gbm9kZS5sZWZ0LmRlY2xhcmF0aW9uc1swXS5pZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxlZnQgPSBub2RlLmxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgaXAudGhlbihub2RlLnJpZ2h0KTtcbiAgICAgICAgaXAudGhlbihmb3JJblN0YXRlbWVudFNldHVwLCB7IG5vZGU6IG5vZGUsIGxlZnQ6IGxlZnQgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZvckluU3RhdGVtZW50U2V0dXAod2wsIHZzKSB7XG4gICAgICAgIHZhciBjID0gbW9uaXRvci5jb250ZXh0O1xuICAgICAgICB2YXIgaXAgPSB3bC50b3AoKTtcbiAgICAgICAgdmFyIGxtYXAgPSBjLmxhYmVscy5sYWJlbG1hcDtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGU7XG4gICAgICAgIGlmICghbm9kZS5sYWJlbHNldCkge1xuICAgICAgICAgICAgbm9kZS5sYWJlbHNldCA9IG5ldyBzZXRfMS5TZXQoW10pO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUubGFiZWxzZXQuYWRkKGVtcHR5TGFiZWwpO1xuICAgICAgICB2YXIgb3V0ZXJFbXB0eUxhYmVsRGF0YSA9IGxtYXBbZW1wdHlMYWJlbF07XG4gICAgICAgIGxtYXBbZW1wdHlMYWJlbF0gPSB7IGxhYmVsOiBjLmVmZmVjdGl2ZVBDLFxuICAgICAgICAgICAgcGNtYXJrZXI6IGMucGNTdGFjay5tYXJrZXIoKSB9O1xuICAgICAgICB2YXIgY29udGV4dExhYmVsID0gbG1hcFtlbXB0eUxhYmVsXS5sYWJlbDtcbiAgICAgICAgYy5wdXNoUEMoY29udGV4dExhYmVsKTtcbiAgICAgICAgdmFyIG9iaiA9IFRvT2JqZWN0XzEuVG9PYmplY3QoR2V0VmFsdWUodnMucG9wKCkpKTtcbiAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBvYmoudmFsdWUuZ2V0RW51bWVyYWJsZVByb3BlcnR5TmFtZXMob2JqLmxhYmVsKS5yZXZlcnNlKCk7XG4gICAgICAgIC8vIG1vbml0b3IuY29udGV4dC5wdXNoUEMob2JqLmxhYmVsKTtcbiAgICAgICAgaXAudGhlbihmb3JJbkV4ZWN1dGUsIHsgbm9kZTogdGhpcy5ub2RlLFxuICAgICAgICAgICAgbGVmdDogdGhpcy5sZWZ0LFxuICAgICAgICAgICAgcHJvcGVydGllczogcHJvcGVydGllcyxcbiAgICAgICAgICAgIG91dGVyRW1wdHlMYWJlbERhdGE6IG91dGVyRW1wdHlMYWJlbERhdGEgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZvckluRXhlY3V0ZSh3bCwgdnMpIHtcbiAgICAgICAgdmFyIGlwID0gd2wudG9wKCk7XG4gICAgICAgIHZhciBjID0gbW9uaXRvci5jb250ZXh0O1xuICAgICAgICB2YXIgcmVzdWx0ID0gYy5yZXN1bHQ7XG4gICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gJ2JyZWFrJyAmJiB0aGlzLm5vZGUubGFiZWxzZXQuY29udGFpbnMocmVzdWx0LnRhcmdldCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC50eXBlID0gJ25vcm1hbCc7XG4gICAgICAgICAgICByZXN1bHQudGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgIGMubGFiZWxzLmxhYmVsbWFwW2VtcHR5TGFiZWxdID0gdGhpcy5vdXRlckVtcHR5TGFiZWxEYXRhO1xuICAgICAgICAgICAgYy5wb3BQQygpOyAvLyBjb250ZXh0TGFiZWxcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0LnR5cGUgIT09ICdjb250aW51ZScgfHwgIXRoaXMubm9kZS5sYWJlbHNldC5jb250YWlucyhyZXN1bHQudGFyZ2V0KSkge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC50eXBlICE9PSAnbm9ybWFsJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBjb250aW51ZSBnZXRzIHVzIGhlcmVcbiAgICAgICAgcmVzdWx0LnR5cGUgPSAnbm9ybWFsJztcbiAgICAgICAgcmVzdWx0LnRhcmdldCA9IG51bGw7XG4gICAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuICAgICAgICB2YXIgcHJvcE5hbWU7XG4gICAgICAgIHZhciBQO1xuICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgYy5sYWJlbHMubGFiZWxtYXBbZW1wdHlMYWJlbF0gPSB0aGlzLm91dGVyRW1wdHlMYWJlbE1hcDtcbiAgICAgICAgICAgIGMucG9wUEMoKTsgLy8gY29udGV4dExhYmVsXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcHJvcE5hbWUgPSB0aGlzLnByb3BlcnRpZXMucG9wKCk7XG4gICAgICAgIHZzLnB1c2gocHJvcE5hbWUpO1xuICAgICAgICBpcC50aGVuKHRoaXMubGVmdCk7XG4gICAgICAgIGlwLnRoZW4oZm9ySW5VcGRhdGUsIHRoaXMpO1xuICAgIH1cbiAgICBmb3JJbkV4ZWN1dGUucnVuZm9yID0gcnVuZm9yX2NvbnRpbnVlX2JyZWFrO1xuICAgIGZ1bmN0aW9uIGZvckluVXBkYXRlKHdsLCB2cykge1xuICAgICAgICB2YXIgaXAgPSB3bC50b3AoKTtcbiAgICAgICAgdmFyIGxocyA9IHZzLnBvcCgpO1xuICAgICAgICB2YXIgcHJvcE5hbWUgPSB2cy5wb3AoKTtcbiAgICAgICAgUHV0VmFsdWUobGhzLCBwcm9wTmFtZSk7XG4gICAgICAgIG1vbml0b3IuY29udGV4dC5wdXNoUEMocHJvcE5hbWUubGFiZWwpO1xuICAgICAgICBpcC50aGVuKHRoaXMubm9kZS5ib2R5KTtcbiAgICAgICAgaXAudGhlbihmb3JJblNlY3VyaXR5Q29udGV4dEVuZCk7XG4gICAgICAgIGlwLnRoZW4oZm9ySW5FeGVjdXRlLCB0aGlzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZm9ySW5TZWN1cml0eUNvbnRleHRFbmQod2wsIHZzKSB7XG4gICAgICAgIG1vbml0b3IuY29udGV4dC5wb3BQQygpO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiB2YXJpYWJsZURlY2xhcmF0aW9uKG5vZGUsIHdsKSB7XG4gICAgICAgIHZhciBpcCA9IHdsLnRvcCgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbm9kZS5kZWNsYXJhdGlvbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB2ZCA9IG5vZGUuZGVjbGFyYXRpb25zW2ldO1xuICAgICAgICAgICAgaWYgKHZkLmluaXQpIHtcbiAgICAgICAgICAgICAgICBpZiAodmQuaWQudHlwZSAhPT0gJ0lkZW50aWZpZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vbml0b3IuZmF0YWwodmQuaWQudHlwZSArICcgbm90IHN1cHBvcnRlZCBpbiB2YXJpYWJsZSBkZWNsYXJhdGlvbnMnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGxocyA9IGVudi5HZXRJZGVudGlmaWVyUmVmZXJlbmNlKG1vbml0b3IuY29udGV4dC5sZXhpY2FsRW52LCB2ZC5pZC5uYW1lKTtcbiAgICAgICAgICAgICAgICBpcC50aGVuKHZkLmluaXQpO1xuICAgICAgICAgICAgICAgIGlwLnRoZW4odmFyaWFibGVEZWNsYXJhdGlvblVwZGF0ZSwgeyBsaHM6IGxocyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyB2YXJpYWJsZVVwZGF0ZVxuICAgIGZ1bmN0aW9uIHZhcmlhYmxlRGVjbGFyYXRpb25VcGRhdGUod2wsIHZzKSB7XG4gICAgICAgIHZhciByaHMgPSBHZXRWYWx1ZSh2cy5wb3AoKSk7XG4gICAgICAgIFB1dFZhbHVlKHRoaXMubGhzLCByaHMpO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBkZWJ1Z2dlclN0YXRlbWVudChub2RlLCB3bCkge1xuICAgICAgICBtb25pdG9yLmRlYnVnLmFjdGl2ZSA9IHRydWU7XG4gICAgfVxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvU3BpZGVyTW9ua2V5L1BhcnNlcl9BUElcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gc3RlcCgpIHtcbiAgICAgICAgdmFyIGMgPSBtb25pdG9yLmNvbnRleHQ7XG4gICAgICAgIHZhciB3bCA9IGMud29ya0xpc3Q7XG4gICAgICAgIHZhciB2cyA9IGMudmFsdWVTdGFjaztcbiAgICAgICAgdmFyIHJlc3VsdCA9IGMucmVzdWx0O1xuICAgICAgICBpZiAod2wuZW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0YXNrID0gd2wucG9wKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyB0aHJvdywgY29udGludWUsIG9yIGJyZWFrIHN0YXRlXG4gICAgICAgICAgICBpZiAocmVzdWx0LnR5cGUgIT09ICdub3JtYWwnKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhc2sucnVuZm9yICYmIHJlc3VsdC50eXBlIGluIHRhc2sucnVuZm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrKHdsLCB2cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGFzay5mdW5jICYmIHRhc2suZnVuYy5ydW5mb3IgJiYgcmVzdWx0LnR5cGUgaW4gdGFzay5mdW5jLnJ1bmZvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFzay5mdW5jLmNhbGwodGFzay5kYXRhLCB3bCwgdnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHdsLmVtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRhc2sgPSB3bC5wb3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZnVuY3Rpb24/XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRhc2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0YXNrKHdsLCB2cyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjbG9zdXJlP1xuICAgICAgICAgICAgaWYgKCdmdW5jJyBpbiB0YXNrICYmICdkYXRhJyBpbiB0YXNrKSB7XG4gICAgICAgICAgICAgICAgdGFzay5mdW5jLmNhbGwodGFzay5kYXRhLCB3bCwgdnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlLCBzeW50YXhcbiAgICAgICAgICAgIHZhciBub2RlID0gdGFzaztcbiAgICAgICAgICAgIC8vIGZvciBzdGFja1RyYWNlXG4gICAgICAgICAgICBjLmN1cnJlbnRTdGF0ZW1lbnQgPSBub2RlO1xuICAgICAgICAgICAgLy8gZXhwcmVzc2lvbnNcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUgaW4gZXhwcmVzc2lvbnRibCkge1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb250Ymxbbm9kZS50eXBlXShub2RlLCB3bCwgdnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc3RhdGVtZW50IFxuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSBpbiBzdGF0ZW1lbnR0YmwpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZW1lbnR0Ymxbbm9kZS50eXBlXShub2RlLCB3bCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtb25pdG9yLmZhdGFsKG5vZGUudHlwZSArICcgbm90IGltcGxlbWVudGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgdmFsdWVzXzEuVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBWZXJmaXkgdGhhdCB0aGUgZXhjZXB0aW9uIGlzIGFsbG93ZWQgXG4gICAgICAgICAgICAgICAgbW9uaXRvci5hc3NlcnQobGUoYy5lZmZlY3RpdmVQQywgYy5sYWJlbHMuZXhjKSwgXCJleGNlcHRpb24gaW4gXCIgKyBjLmVmZmVjdGl2ZVBDICsgXCIgbm90IGFsbG93ZWQgd2l0aCBleGNlcHRpb24gbGFiZWwgXCIgKyBjLmxhYmVscy5leGMpO1xuICAgICAgICAgICAgICAgIC8vIEZvciBvYnNlcnZhYmxlIGZsb3dzXG4gICAgICAgICAgICAgICAgYy5sYWJlbHMuZXhjLmx1YihjLmVmZmVjdGl2ZVBDKTtcbiAgICAgICAgICAgICAgICByZXN1bHQudHlwZSA9ICd0aHJvdyc7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnZhbHVlID0gZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFxuICAgIC8vIEluaXRpYWxpemVzIHRoZSBzdGF0ZW1lbnQgbGFiZWwgc2VjdXJpdHkgbGFiZWwuXG4gICAgZnVuY3Rpb24gc2V0dXBTdGF0ZW1lbnRMYWJlbChuYW1lKSB7XG4gICAgICAgIHZhciBjID0gbW9uaXRvci5jb250ZXh0O1xuICAgICAgICB2YXIgbG1hcCA9IGMubGFiZWxzLmxhYmVsbWFwO1xuICAgICAgICBpZiAoIWxtYXBbbmFtZV0pIHtcbiAgICAgICAgICAgIGxtYXBbbmFtZV0gPSB7IGxhYmVsOiBib3QsIHBjbWFya2VyOiB1bmRlZmluZWQgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGFiZWxkYXRhID0gbG1hcFtuYW1lXTtcbiAgICAgICAgdmFyIG91dGVybGFiZWwgPSBsYWJlbGRhdGEubGFiZWw7XG4gICAgICAgIC8vIHJhaXNlIHRvIGVmZmVjdGl2ZSBwY1xuICAgICAgICBsYWJlbGRhdGEubGFiZWwgPSBsdWIobGFiZWxkYXRhLmxhYmVsLCBjLmVmZmVjdGl2ZVBDKTtcbiAgICAgICAgcmV0dXJuIG91dGVybGFiZWw7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHZhciBtb2R1bGUgPSB7fTtcbiAgICBtb2R1bGUuaW5pdGlhbGl6ZSA9IGluaXRpYWxpemU7XG4gICAgbW9kdWxlLmV4ZWN1dGUgPSBleGVjdXRlO1xuICAgIG1vZHVsZS5leGVjdXRlR2xvYmFsQ29kZSA9IGV4ZWN1dGVHbG9iYWxDb2RlO1xuICAgIG1vZHVsZS5yZXN1bWUgPSByZXN1bWU7XG4gICAgbW9kdWxlLnJ1bm5pbmcgPSBydW5uaW5nO1xuICAgIHJldHVybiBtb2R1bGU7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXhlYy5qcy5tYXAiLCIvKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLiAqL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbGFiZWxfMSA9IHJlcXVpcmUoXCIuL2xhYmVsXCIpO1xudmFyIHZhbHVlc18xID0gcmVxdWlyZShcIi4vdmFsdWVzXCIpO1xudmFyIGVjbWFfMSA9IHJlcXVpcmUoXCIuL2VjbWFcIik7XG52YXIgZW52ID0gcmVxdWlyZShcIi4vZW52XCIpO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbnZhciBlc3ByaW1hID0gcmVxdWlyZShcImVzcHJpbWFcIik7XG52YXIgZXN0cmF2ZXJzZSA9IHJlcXVpcmUoXCJlc3RyYXZlcnNlXCIpO1xudmFyIEZ1bmN0aW9uT2JqZWN0XzEgPSByZXF1aXJlKFwiLi9PYmplY3RzL0Z1bmN0aW9uT2JqZWN0XCIpO1xudmFyIFRvT2JqZWN0XzEgPSByZXF1aXJlKFwiLi9Db252ZXJzaW9uL1RvT2JqZWN0XCIpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgTmV3QmlGTyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTmV3QmlGTywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOZXdCaUZPKHNlbGYsIGYsIG4sIGhvc3QpIHtcbiAgICAgICAgdmFyIF90aGlzXzEgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpc18xLmhvc3QgPSBob3N0O1xuICAgICAgICBfdGhpc18xLmFjdHVhbEZ1bmN0aW9uID0gZjtcbiAgICAgICAgX3RoaXNfMS5zZWxmID0gc2VsZjtcbiAgICAgICAgX3RoaXNfMS5DbGFzcyA9ICdGdW5jdGlvbic7XG4gICAgICAgIF90aGlzXzEuUHJvdG90eXBlID0gbmV3IHZhbHVlc18xLlZhbHVlKG1vbml0b3IuaW5zdGFuY2VzLkZ1bmN0aW9uUHJvdG90eXBlLCBsYWJlbF8xLmJvdCk7XG4gICAgICAgIF90aGlzXzEuRXh0ZW5zaWJsZSA9IHRydWU7XG4gICAgICAgIGVjbWFfMS5EZWZpbmVGRkYoX3RoaXNfMSwgY29uc3RhbnRzLmxlbmd0aCwgbik7XG4gICAgICAgIHJldHVybiBfdGhpc18xO1xuICAgIH1cbiAgICBOZXdCaUZPLnByb3RvdHlwZS5DYWxsID0gZnVuY3Rpb24gKHRoaXNBcmcsIGFyZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFjdHVhbEZ1bmN0aW9uLmNhbGwodGhpcy5zZWxmLCB0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbW9uaXRvci50cnlSZXRocm93KGUsIHRydWUpO1xuICAgICAgICAgICAgbW9uaXRvci5mYXRhbCgndW5hYmxlIHRvIGxpZnQnLCBlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTmV3QmlGTy5wcm90b3R5cGUuQ29uc3RydWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBtb25pdG9yLlRocm93KG1vbml0b3IubW9kdWxlcy5lcnJvci5UeXBlRXJyb3JPYmplY3QsICdjYW5ub3QgYmUgdXNlZCBhcyBhIGNvbnN0cnVjdG9yJywgbGFiZWxfMS5ib3QpO1xuICAgIH07XG4gICAgTmV3QmlGTy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmhvc3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhvc3QudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAnTk8gSE9TVCBHSVZFTiEgOiAnICsgdGhpcy5uYXRpdmVGdW5jdGlvbjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE5ld0JpRk87XG59KGVjbWFfMS5FY21hKSk7XG5leHBvcnRzLk5ld0JpRk8gPSBOZXdCaUZPO1xuLy8gLS0tXG4vLyBwcm90byBhbGxvd3MgRnVuY3Rpb25Qcm90b3R5cGUgdG8gdXNlIEJpRk8gYmVmb3JlIG1vbml0b3IuaW5zdGFuY2VzLkZ1bmN0aW9uUHJvdG90eXBlIGlzIHNldFxudmFyIEJ1aWx0aW5GdW5jdGlvbk9iamVjdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQnVpbHRpbkZ1bmN0aW9uT2JqZWN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJ1aWx0aW5GdW5jdGlvbk9iamVjdChmLCBuLCBob3N0KSB7XG4gICAgICAgIHZhciBfdGhpc18xID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXNfMS5ob3N0ID0gaG9zdDtcbiAgICAgICAgX3RoaXNfMS5hY3R1YWxGdW5jdGlvbiA9IGY7XG4gICAgICAgIF90aGlzXzEuQ2xhc3MgPSAnRnVuY3Rpb24nO1xuICAgICAgICBfdGhpc18xLlByb3RvdHlwZSA9IG5ldyB2YWx1ZXNfMS5WYWx1ZShtb25pdG9yLmluc3RhbmNlcy5GdW5jdGlvblByb3RvdHlwZSwgbGFiZWxfMS5ib3QpO1xuICAgICAgICBfdGhpc18xLkV4dGVuc2libGUgPSB0cnVlO1xuICAgICAgICB2YXIgX3RoaXMgPSBfdGhpc18xO1xuICAgICAgICBfdGhpc18xLkNhbGwgPVxuICAgICAgICAgICAgZnVuY3Rpb24gKHRoaXNBcmcsIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZi5jYWxsKF90aGlzLCB0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9uaXRvci50cnlSZXRocm93KGUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBtb25pdG9yLmZhdGFsKCd1bmFibGUgdG8gbGlmdCcsIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIF90aGlzXzEubmF0aXZlRnVuY3Rpb24gPSBmO1xuICAgICAgICBlY21hXzEuRGVmaW5lRkZGKF90aGlzXzEsIGNvbnN0YW50cy5sZW5ndGgsIG4pO1xuICAgICAgICByZXR1cm4gX3RoaXNfMTtcbiAgICB9XG4gICAgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0LnByb3RvdHlwZS5Db25zdHJ1Y3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG1vbml0b3IuVGhyb3cobW9uaXRvci5tb2R1bGVzLmVycm9yLlR5cGVFcnJvck9iamVjdCwgJ2Nhbm5vdCBiZSB1c2VkIGFzIGEgY29uc3RydWN0b3InLCBsYWJlbF8xLmJvdCk7XG4gICAgfTtcbiAgICBCdWlsdGluRnVuY3Rpb25PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5ob3N0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ob3N0LnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJ05PIEhPU1QgR0lWRU4hIDogJyArIHRoaXMubmF0aXZlRnVuY3Rpb247XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBCdWlsdGluRnVuY3Rpb25PYmplY3Q7XG59KGVjbWFfMS5FY21hKSk7XG5leHBvcnRzLkJ1aWx0aW5GdW5jdGlvbk9iamVjdCA9IEJ1aWx0aW5GdW5jdGlvbk9iamVjdDtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gMTAuNC4zXG5mdW5jdGlvbiBlbnRlckZ1bmN0aW9uQ29kZShGLCB0aGlzQXJnLCBhcmdzKSB7XG4gICAgdmFyIGMgPSBtb25pdG9yLmNvbnRleHQ7XG4gICAgaWYgKHRoaXNBcmcudmFsdWUgPT0gbnVsbCkge1xuICAgICAgICB0aGlzQXJnID0gbmV3IHZhbHVlc18xLlZhbHVlKG1vbml0b3IuaW5zdGFuY2VzLmdsb2JhbE9iamVjdCwgdGhpc0FyZy5sYWJlbCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB0aGlzQXJnLnZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aGlzQXJnID0gVG9PYmplY3RfMS5Ub09iamVjdCh0aGlzQXJnKTtcbiAgICB9XG4gICAgdmFyIGxvY2FsRW52ID0gbmV3IHZhbHVlc18xLlZhbHVlKGVudi5OZXdEZWNsYXJhdGl2ZUVudmlyb25tZW50KEYuU2NvcGUpLCBjLmVmZmVjdGl2ZVBDKTtcbiAgICB2YXIgbmV3Q29udGV4dCA9IGMuY2xvbmUodGhpc0FyZywgbG9jYWxFbnYsIGxvY2FsRW52KTtcbiAgICBuZXdDb250ZXh0LmxhYmVscy5yZXQgPSBsYWJlbF8xLmx1YihuZXdDb250ZXh0LmxhYmVscy5yZXQsIG5ld0NvbnRleHQubGFiZWxzLnBjKTtcbiAgICBEZWNsYXJhdGlvbkJpbmRpbmdJbnN0YW50aWF0aW9uKG5ld0NvbnRleHQsIEYsIGFyZ3MpO1xuICAgIHJldHVybiBuZXdDb250ZXh0O1xufVxuZXhwb3J0cy5lbnRlckZ1bmN0aW9uQ29kZSA9IGVudGVyRnVuY3Rpb25Db2RlO1xuZnVuY3Rpb24gZW50ZXJFdmFsQ29kZShjb2RlLCBfZXZhbCkge1xuICAgIHZhciBjID0gbW9uaXRvci5jb250ZXh0O1xuICAgIC8vIDE1LjEuMi4xLjEsIGlzIGRpcmVjdCBjYWxsXG4gICAgdmFyIGlzRGlyZWN0O1xuICAgIGlzRGlyZWN0ID0gYy5jdXJyZW50Q2FsbC5yZWZlcmVuY2UuYmFzZS52YWx1ZSBpbnN0YW5jZW9mIGVudi5PYmplY3RFbnZpcm9ubWVudFJlY29yZCB8fFxuICAgICAgICBjLmN1cnJlbnRDYWxsLnJlZmVyZW5jZS5iYXNlLnZhbHVlIGluc3RhbmNlb2YgZW52LkRlY2xhcmF0aXZlRW52aXJvbm1lbnRSZWNvcmQ7XG4gICAgaXNEaXJlY3QgPSBpc0RpcmVjdCAmJiBjLmN1cnJlbnRDYWxsLnJlZmVyZW5jZS5wcm9wZXJ0eU5hbWUudmFsdWUgPT09ICdldmFsJztcbiAgICBpc0RpcmVjdCA9IGlzRGlyZWN0ICYmIGMuY3VycmVudENhbGwudGFyZ2V0LmFjdHVhbEZ1bmN0aW9uID09PSBfZXZhbDtcbiAgICB2YXIgY29udGV4dCA9IGMuY2xvbmUoKTtcbiAgICAvLyAxMC40LjIgLSBubyBjYWxsaW5nIGNvbnRleHQgb3Igbm90IGRpcmVjdCBjYWxsXG4gICAgaWYgKCFpc0RpcmVjdCkge1xuICAgICAgICB2YXIgZ2xvYmFsID0gbW9uaXRvci5pbnN0YW5jZXMuZ2xvYmFsT2JqZWN0O1xuICAgICAgICB2YXIgZ2xvYmFsRW52ID0gbW9uaXRvci5pbnN0YW5jZXMuZ2xvYmFsRW52aXJvbm1lbnQ7XG4gICAgICAgIGNvbnRleHQudGhpc1ZhbHVlID0gbmV3IHZhbHVlc18xLlZhbHVlKGdsb2JhbCwgbGFiZWxfMS5ib3QpO1xuICAgICAgICBjb250ZXh0LmxleGljYWxFbnYgPSBuZXcgdmFsdWVzXzEuVmFsdWUoZ2xvYmFsRW52LCBsYWJlbF8xLmJvdCk7XG4gICAgICAgIGNvbnRleHQudmFyaWFibGVFbnYgPSBuZXcgdmFsdWVzXzEuVmFsdWUoZ2xvYmFsRW52LCBsYWJlbF8xLmJvdCk7XG4gICAgfVxuICAgIERlY2xhcmF0aW9uQmluZGluZ0luc3RhbnRpYXRpb24oY29udGV4dCwgY29kZSk7XG4gICAgLy8gZm9yIHN0YWNrIHRyYWNlIFxuICAgIGNvbnRleHQub3duZXIgPSAnZXZhbCc7XG4gICAgcmV0dXJuIGNvbnRleHQ7XG59XG5leHBvcnRzLmVudGVyRXZhbENvZGUgPSBlbnRlckV2YWxDb2RlO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAxMC41IC0gc3RyaWN0IGlnbm9yZWRcbmZ1bmN0aW9uIERlY2xhcmF0aW9uQmluZGluZ0luc3RhbnRpYXRpb24oY29udGV4dCwgRiwgYXJncykge1xuICAgIHZhciBpc0Z1bmN0aW9uQ29kZSwgaXNFdmFsQ29kZSwgY29kZTtcbiAgICBpZiAoRiBpbnN0YW5jZW9mIEZ1bmN0aW9uT2JqZWN0XzEuRnVuY3Rpb25PYmplY3QpIHtcbiAgICAgICAgaXNGdW5jdGlvbkNvZGUgPSB0cnVlO1xuICAgICAgICBpc0V2YWxDb2RlID0gZmFsc2U7XG4gICAgICAgIGNvZGUgPSBGLkNvZGU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpc0Z1bmN0aW9uQ29kZSA9IGZhbHNlO1xuICAgICAgICBpc0V2YWxDb2RlID0gdHJ1ZTtcbiAgICAgICAgY29kZSA9IEY7XG4gICAgfVxuICAgIHZhciBlbnYgPSBjb250ZXh0LnZhcmlhYmxlRW52O1xuICAgIHZhciBjb25maWd1cmFibGVCaW5kaW5ncyA9IGlzRXZhbENvZGU7XG4gICAgaWYgKGlzRnVuY3Rpb25Db2RlKSB7XG4gICAgICAgIEJpbmRBcmd1bWVudHMoZW52LCBGLkZvcm1hbFBhcmFtZXRlcnMsIGFyZ3MpO1xuICAgIH1cbiAgICB2YXIgcGMgPSBjb250ZXh0LmVmZmVjdGl2ZVBDO1xuICAgIEhvaXN0RnVuY3Rpb25zKGVudiwgY29kZSwgY29uZmlndXJhYmxlQmluZGluZ3MsIHBjKTtcbiAgICB2YXIgYXJndW1lbnRzQWxyZWFkeURlY2xhcmVkID0gZW52Lkhhc0JpbmRpbmcoY29uc3RhbnRzWydhcmd1bWVudHMnXSk7XG4gICAgaWYgKGlzRnVuY3Rpb25Db2RlICYmICFhcmd1bWVudHNBbHJlYWR5RGVjbGFyZWQudmFsdWUpIHtcbiAgICAgICAgLy8gbWFrZSBzdXJlIGl0IHJldHVybnMgYSBWYWx1ZVxuICAgICAgICB2YXIgYXJnc09iaiA9IENyZWF0ZUFyZ3VtZW50c09iamVjdChlbnYsIEYsIGFyZ3MpO1xuICAgICAgICBGLkRlZmluZU93blByb3BlcnR5KGNvbnN0YW50c1snYXJndW1lbnRzJ10sIGFyZ3NPYmosIGZhbHNlKTtcbiAgICAgICAgZW52LkNyZWF0ZU11dGFibGVCaW5kaW5nKGNvbnN0YW50c1snYXJndW1lbnRzJ10pO1xuICAgICAgICBlbnYuU2V0TXV0YWJsZUJpbmRpbmcoY29uc3RhbnRzWydhcmd1bWVudHMnXSwgYXJnc09iaiwgZmFsc2UpO1xuICAgIH1cbiAgICBIb2lzdFZhcmlhYmxlcyhlbnYsIGNvZGUsIGNvbmZpZ3VyYWJsZUJpbmRpbmdzLCBwYyk7XG59XG5leHBvcnRzLkRlY2xhcmF0aW9uQmluZGluZ0luc3RhbnRpYXRpb24gPSBEZWNsYXJhdGlvbkJpbmRpbmdJbnN0YW50aWF0aW9uO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBGdW5jdGlvbiBob2lzdGluZywgcGFydCBvZiAxMC41XG5mdW5jdGlvbiBIb2lzdEZ1bmN0aW9ucyhlbnYsIHNjcmlwdCwgY29uZmlndXJhYmxlQmluZGluZywgcGMpIHtcbiAgICBpZiAoIXNjcmlwdC5mdW5jdGlvbkRlY2xhcmF0aW9ucykge1xuICAgICAgICAvLyBcbiAgICAgICAgc2NyaXB0LmZ1bmN0aW9uRGVjbGFyYXRpb25zID0gW107XG4gICAgICAgIHZhciB2aXNpdG9yID0ge307XG4gICAgICAgIHZpc2l0b3IubGVhdmUgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIHZpc2l0b3IuZW50ZXIgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ0Z1bmN0aW9uRGVjbGFyYXRpb24nKSB7XG4gICAgICAgICAgICAgICAgc2NyaXB0LmZ1bmN0aW9uRGVjbGFyYXRpb25zLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEbyBub3QgaG9pc3QgaW5zaWRlIGZ1bmN0aW9uc1xuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ0Z1bmN0aW9uRGVjbGFyYXRpb24nIHx8XG4gICAgICAgICAgICAgICAgbm9kZS50eXBlID09PSAnRnVuY3Rpb25FeHByZXNzaW9uJykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2tpcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBlc3RyYXZlcnNlLnRyYXZlcnNlKHNjcmlwdCwgdmlzaXRvcik7XG4gICAgfVxuICAgIHZhciBkcyA9IHNjcmlwdC5mdW5jdGlvbkRlY2xhcmF0aW9ucztcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gZHMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgZm4gPSBuZXcgdmFsdWVzXzEuVmFsdWUoZHNbaV0uaWQubmFtZSwgbGFiZWxfMS5ib3QpO1xuICAgICAgICB2YXIgZm8gPSBuZXcgRnVuY3Rpb25PYmplY3RfMS5GdW5jdGlvbk9iamVjdChkc1tpXS5wYXJhbXMsIGRzW2ldLmJvZHksIGVudik7XG4gICAgICAgIGZvLk5hbWUgPSBkc1tpXS5pZC5uYW1lO1xuICAgICAgICBmby5Tb3VyY2UgPSBkc1tpXTtcbiAgICAgICAgdmFyIGZ1bmNBbHJlYWR5RGVjbGFyZWQgPSBlbnYuSGFzQmluZGluZyhmbik7XG4gICAgICAgIGlmICghZnVuY0FscmVhZHlEZWNsYXJlZC52YWx1ZSkge1xuICAgICAgICAgICAgZW52LkNyZWF0ZU11dGFibGVCaW5kaW5nKGZuLCBjb25maWd1cmFibGVCaW5kaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBlbnYuU2V0TXV0YWJsZUJpbmRpbmcoZm4sIG5ldyB2YWx1ZXNfMS5WYWx1ZShmbywgcGMpKTtcbiAgICB9XG59XG5leHBvcnRzLkhvaXN0RnVuY3Rpb25zID0gSG9pc3RGdW5jdGlvbnM7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFZhcmlhYmxlIGhvaXN0aW5nLCBwYXJ0IG9mIDEwLjVcbmZ1bmN0aW9uIEhvaXN0VmFyaWFibGVzKGVudiwgc2NyaXB0LCBjb25maWd1cmFibGVCaW5kaW5ncywgcGMpIHtcbiAgICBpZiAoIXNjcmlwdC52YXJpYWJsZURlY2xhcmF0aW9ucykge1xuICAgICAgICBzY3JpcHQudmFyaWFibGVEZWNsYXJhdGlvbnMgPSBbXTtcbiAgICAgICAgdmFyIHZpc2l0b3IgPSB7fTtcbiAgICAgICAgdmlzaXRvci5sZWF2ZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgdmlzaXRvci5lbnRlciA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAvLyBEbyBub3QgaG9pc3QgaW5zaWRlIGZ1bmN0aW9uc1xuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ0Z1bmN0aW9uRGVjbGFyYXRpb24nIHx8XG4gICAgICAgICAgICAgICAgbm9kZS50eXBlID09PSAnRnVuY3Rpb25FeHByZXNzaW9uJykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2tpcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ1ZhcmlhYmxlRGVjbGFyYXRpb24nKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG5vZGUuZGVjbGFyYXRpb25zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWNsYXJhdG9yID0gbm9kZS5kZWNsYXJhdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXR0ZXJuID0gZGVjbGFyYXRvci5pZDtcbiAgICAgICAgICAgICAgICAgICAgc2NyaXB0LnZhcmlhYmxlRGVjbGFyYXRpb25zLnB1c2gocGF0dGVybik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBlc3RyYXZlcnNlLnRyYXZlcnNlKHNjcmlwdCwgdmlzaXRvcik7XG4gICAgfVxuICAgIHZhciBkcyA9IHNjcmlwdC52YXJpYWJsZURlY2xhcmF0aW9ucztcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gZHMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoZHNbaV0udHlwZSAhPT0gJ0lkZW50aWZpZXInKSB7XG4gICAgICAgICAgICBtb25pdG9yLmZhdGFsKCdQYXR0ZXJzIGlzIHZhcmlhYmxlIGRlY2xhcmF0aW9ucyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVjbGFyYXRpb25zIGFyZSBpbmRlbnRpZmllcnMsIG5vdCBnZW5lcmFsIHBhdHRlcm5zXG4gICAgICAgIHZhciBkbiA9IG5ldyB2YWx1ZXNfMS5WYWx1ZShkc1tpXS5uYW1lLCBsYWJlbF8xLmJvdCk7XG4gICAgICAgIHZhciB2YXJBbHJlYWR5RGVjbGFyZWQgPSBlbnYuSGFzQmluZGluZyhkbik7XG4gICAgICAgIGlmICghdmFyQWxyZWFkeURlY2xhcmVkLnZhbHVlKSB7XG4gICAgICAgICAgICBlbnYuQ3JlYXRlTXV0YWJsZUJpbmRpbmcoZG4sIGNvbmZpZ3VyYWJsZUJpbmRpbmdzKTtcbiAgICAgICAgICAgIGVudi5TZXRNdXRhYmxlQmluZGluZyhkbiwgbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgcGMpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuSG9pc3RWYXJpYWJsZXMgPSBIb2lzdFZhcmlhYmxlcztcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gQ3JlYXRlIEFyZ3VtZW50cyBPYmplY3QsIDEwLjZcbmZ1bmN0aW9uIENyZWF0ZUFyZ3VtZW50c09iamVjdChlbnYsIEYsIGFyZ3MpIHtcbiAgICByZXR1cm4gbmV3IHZhbHVlc18xLlZhbHVlKG5ldyBBcmd1bWVudHNPYmplY3QoRiwgYXJncyksIGxhYmVsXzEuYm90KTtcbiAgICAvKlxuICAgIHZhciBvYmogPSBuZXcgRWNtYSgpO1xuICAgIG9iai5DbGFzcyA9ICdBcmd1bWVudHMnO1xuICBcbiAgICBvYmouUHJvdG90eXBlID0gbmV3IFZhbHVlKG1vbml0b3IuaW5zdGFuY2VzLk9iamVjdFByb3RvdHlwZSxib3QpO1xuICBcbiAgICBhcmdzID0gYXJncyB8fCBbXTtcbiAgXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG9iai5QdXQobmV3IFZhbHVlKGksIGJvdCksIGFyZ3NbaV0pO1xuICAgIH1cbiAgXG4gIFxuICAgIHZhciBhcmdOYW1lcyA9IEYuRm9ybWFsUGFyYW1ldGVycztcbiAgXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyZ05hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgaWQgPSBhcmdOYW1lc1tpXTtcbiAgXG4gICAgICBpZiAoaWQudHlwZSAhPT0gJ0lkZW50aWZpZXInKSB7XG4gICAgICAgIG1vbml0b3IuZmF0YWwoaWQudHlwZSArICcgaXMgbm90IHN1cHBvcnRlZCBpbiBDcmVhdGVBcmd1bWVudHNPYmplY3QnKTtcbiAgICAgIH1cbiAgXG4gICAgICBpZiAoYXJnc1tpXSkge1xuICAgICAgICBvYmouUHV0KG5ldyBWYWx1ZShpZC5uYW1lLCBib3QpLCBhcmdzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIFxuICAgIG9iai5QdXQobmV3IFZhbHVlKCdsZW5ndGgnLCBib3QpLCBuZXcgVmFsdWUoYXJncy5sZW5ndGgsIGJvdCkpO1xuICAgIG9iai5QdXQobmV3IFZhbHVlKCdjYWxsZWUnLCBib3QpLCBuZXcgVmFsdWUoRiwgYm90KSk7XG4gIFxuICAgIHJldHVybiBuZXcgVmFsdWUob2JqLCBib3QpO1xuICAgICovXG59XG5leHBvcnRzLkNyZWF0ZUFyZ3VtZW50c09iamVjdCA9IENyZWF0ZUFyZ3VtZW50c09iamVjdDtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gQmluZCBBcmd1bWVudHMsIFxuZnVuY3Rpb24gQmluZEFyZ3VtZW50cyhlbnYsIG5hbWVzLCBhcmdzKSB7XG4gICAgaWYgKGFyZ3MgPT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm47XG4gICAgdmFyIGFyZ0NvdW50ID0gYXJncy5sZW5ndGg7XG4gICAgdmFyIG5hbWVDb3VudCA9IG5hbWVzLmxlbmd0aDtcbiAgICBtb25pdG9yLmNvbnRleHQucHVzaFBDKGxhYmVsXzEuYm90KTtcbiAgICBmb3IgKHZhciBuID0gMDsgbiA8IG5hbWVDb3VudDsgbisrKSB7XG4gICAgICAgIHZhciB2O1xuICAgICAgICBpZiAobiA+PSBhcmdDb3VudClcbiAgICAgICAgICAgIHYgPSBuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCBsYWJlbF8xLmJvdCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHYgPSBhcmdzW25dO1xuICAgICAgICB2YXIgaWQgPSBuYW1lc1tuXTtcbiAgICAgICAgaWYgKGlkLnR5cGUgIT09ICdJZGVudGlmaWVyJykge1xuICAgICAgICAgICAgbW9uaXRvci5mYXRhbChpZC50eXBlICsgJyBpcyBub3Qgc3VwcG9ydGVkIGluIEJpbmRBcmd1bWVudHMnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXJnTmFtZSA9IG5ldyB2YWx1ZXNfMS5WYWx1ZShpZC5uYW1lLCBsYWJlbF8xLmJvdCk7XG4gICAgICAgIHZhciBhcmdBbHJlYWR5RGVjbGFyZWQgPSBlbnYuSGFzQmluZGluZyhhcmdOYW1lKTtcbiAgICAgICAgbW9uaXRvci5jb250ZXh0LnJhaXNlUEMoYXJnQWxyZWFkeURlY2xhcmVkLmxhYmVsKTtcbiAgICAgICAgaWYgKCFhcmdBbHJlYWR5RGVjbGFyZWQudmFsdWUpIHtcbiAgICAgICAgICAgIGVudi5DcmVhdGVNdXRhYmxlQmluZGluZyhhcmdOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbnYuU2V0TXV0YWJsZUJpbmRpbmcoYXJnTmFtZSwgdik7XG4gICAgfVxuICAgIG1vbml0b3IuY29udGV4dC5wb3BQQygpO1xufVxuZXhwb3J0cy5CaW5kQXJndW1lbnRzID0gQmluZEFyZ3VtZW50cztcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIEFyZ3VtZW50c09iamVjdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXJndW1lbnRzT2JqZWN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFyZ3VtZW50c09iamVjdChGLCBhcmdzKSB7XG4gICAgICAgIHZhciBfdGhpc18xID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXNfMS5Qcm90b3R5cGUgPSBuZXcgdmFsdWVzXzEuVmFsdWUobW9uaXRvci5pbnN0YW5jZXMuT2JqZWN0UHJvdG90eXBlLCBsYWJlbF8xLmJvdCk7XG4gICAgICAgIF90aGlzXzEuQ2xhc3MgPSAnQXJndW1lbnRzJztcbiAgICAgICAgX3RoaXNfMS5FeHRlbnNpYmxlID0gdHJ1ZTtcbiAgICAgICAgdmFyIGZvcm1hbFBhcmFtcyA9IEYuRm9ybWFsUGFyYW1ldGVycztcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmdzIHx8IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIF90aGlzXzEuUHV0KG5ldyB2YWx1ZXNfMS5WYWx1ZShpLCBsYWJlbF8xLmJvdCksIGFyZ3NbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9ybWFsUGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaWQgPSBmb3JtYWxQYXJhbXNbaV07XG4gICAgICAgICAgICBpZiAoaWQudHlwZSAhPT0gJ0lkZW50aWZpZXInKSB7XG4gICAgICAgICAgICAgICAgbW9uaXRvci5mYXRhbChpZC50eXBlICsgJyBpcyBub3Qgc3VwcG9ydGVkIGluIEFyZ3VtZW50c09iamVjdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFyZ3NbaV0pIHtcbiAgICAgICAgICAgICAgICBfdGhpc18xLlB1dChuZXcgdmFsdWVzXzEuVmFsdWUoaWQubmFtZSwgbGFiZWxfMS5ib3QpLCBhcmdzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBfdGhpc18xLlB1dChuZXcgdmFsdWVzXzEuVmFsdWUoJ2xlbmd0aCcsIGxhYmVsXzEuYm90KSwgbmV3IHZhbHVlc18xLlZhbHVlKGFyZ3MubGVuZ3RoLCBsYWJlbF8xLmJvdCkpO1xuICAgICAgICBfdGhpc18xLlB1dChuZXcgdmFsdWVzXzEuVmFsdWUoJ2NhbGxlZScsIGxhYmVsXzEuYm90KSwgbmV3IHZhbHVlc18xLlZhbHVlKEYsIGxhYmVsXzEuYm90KSk7XG4gICAgICAgIHJldHVybiBfdGhpc18xO1xuICAgIH1cbiAgICByZXR1cm4gQXJndW1lbnRzT2JqZWN0O1xufShlY21hXzEuRWNtYSkpO1xuZXhwb3J0cy5Bcmd1bWVudHNPYmplY3QgPSBBcmd1bWVudHNPYmplY3Q7XG4vLyAtLS1cbi8vIDEzLjIuM1xudmFyIFRocm93VHlwZUVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUaHJvd1R5cGVFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUaHJvd1R5cGVFcnJvcigpIHtcbiAgICAgICAgdmFyIF90aGlzXzEgPSBfc3VwZXIuY2FsbCh0aGlzLCBbXSwgZXNwcmltYS5wYXJzZShcIihmdW5jdGlvbigpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcigpOyB9KVwiKS5ib2R5WzBdLmV4cHJlc3Npb24sIG5ldyB2YWx1ZXNfMS5WYWx1ZShtb25pdG9yLmluc3RhbmNlcy5nbG9iYWxFbnZpcm9ubWVudCwgbGFiZWxfMS5ib3QpKSB8fCB0aGlzO1xuICAgICAgICBlY21hXzEuRGVmaW5lRkZGKF90aGlzXzEsIGNvbnN0YW50cy5sZW5ndGgsIDApO1xuICAgICAgICBfdGhpc18xLkV4dGVuc2libGUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIF90aGlzXzE7XG4gICAgfVxuICAgIHJldHVybiBUaHJvd1R5cGVFcnJvcjtcbn0oRnVuY3Rpb25PYmplY3RfMS5GdW5jdGlvbk9iamVjdCkpO1xuZXhwb3J0cy5UaHJvd1R5cGVFcnJvciA9IFRocm93VHlwZUVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnVuY3Rpb24uanMubWFwIiwiLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy4gKi9cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGxhYmVsID0gcmVxdWlyZShcIi4vbGFiZWxcIik7XG52YXIgdmFsdWVzXzEgPSByZXF1aXJlKFwiLi92YWx1ZXNcIik7XG52YXIgZWNtYSA9IHJlcXVpcmUoXCIuL2VjbWFcIik7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xudmFyIGVzcHJpbWEgPSByZXF1aXJlKFwiZXNwcmltYVwiKTtcbnZhciBmdW5jdGlvbl8xID0gcmVxdWlyZShcIi4vZnVuY3Rpb25cIik7XG52YXIgVG9OdW1iZXJfMSA9IHJlcXVpcmUoXCIuL0NvbnZlcnNpb24vVG9OdW1iZXJcIik7XG52YXIgVG9TdHJpbmdfMSA9IHJlcXVpcmUoXCIuL0NvbnZlcnNpb24vVG9TdHJpbmdcIik7XG5leHBvcnRzLmZ1bmN0b3IgPSBmdW5jdGlvbiAobW9uaXRvcikge1xuICAgIHZhciBlcnJvciA9IG1vbml0b3IucmVxdWlyZSgnZXJyb3InKTtcbiAgICB2YXIgTGFiZWwgPSBsYWJlbC5MYWJlbDtcbiAgICB2YXIgbHViID0gbGFiZWwubHViO1xuICAgIHZhciBsZSA9IGxhYmVsLmxlO1xuICAgIHZhciBib3QgPSBMYWJlbC5ib3Q7XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gYWxsb2NhdGUoaG9zdCkge1xuICAgICAgICB2YXIgZ28gPSBuZXcgR2xvYmFsT2JqZWN0KGhvc3QpO1xuICAgICAgICByZXR1cm4geyBnbG9iYWxPYmplY3Q6IGdvIH07XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHZhciBHbG9iYWxPYmplY3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhHbG9iYWxPYmplY3QsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEdsb2JhbE9iamVjdChob3N0KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMuQ2xhc3MgPSAnZ2xvYmFsJztcbiAgICAgICAgICAgIF90aGlzLkpTRkNsYXNzID0gJ0dsb2JhbE9iamVjdCc7XG4gICAgICAgICAgICBpZiAoX3RoaXMuUHJvdG90eXBlID09PSB1bmRlZmluZWQgfHwgX3RoaXMuUHJvdG90eXBlLnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuUHJvdG90eXBlID0gbmV3IHZhbHVlc18xLlZhbHVlKG1vbml0b3IuaW5zdGFuY2VzLk9iamVjdFByb3RvdHlwZSwgYm90KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmhvc3QgPSBob3N0O1xuICAgICAgICAgICAgLy8gMTUuMS4xXG4gICAgICAgICAgICBlY21hLkRlZmluZUZGRihfdGhpcywgY29uc3RhbnRzLk5hTiwgTmFOKTtcbiAgICAgICAgICAgIGVjbWEuRGVmaW5lRkZGKF90aGlzLCBjb25zdGFudHNbJ0luZmluaXR5J10sIEluZmluaXR5KTtcbiAgICAgICAgICAgIGVjbWEuRGVmaW5lRkZGKF90aGlzLCBjb25zdGFudHNbJ3VuZGVmaW5lZCddLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgLy8gMTUuMS4yXG4gICAgICAgICAgICBlY21hLkRlZmluZVRGVChfdGhpcywgY29uc3RhbnRzWydldmFsJ10sIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdChfX2V2YWwsIDEsIGhvc3QuZXZhbCkpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXMsIGNvbnN0YW50cy5wYXJzZUludCwgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KF9fcGFyc2VJbnQsIDIsIGhvc3QucGFyc2VJbnQpKTtcbiAgICAgICAgICAgIGVjbWEuRGVmaW5lVEZUKF90aGlzLCBjb25zdGFudHMucGFyc2VGbG9hdCwgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KF9fcGFyc2VGbG9hdCwgMSwgaG9zdC5wYXJzZUZsb2F0KSk7XG4gICAgICAgICAgICBlY21hLkRlZmluZVRGVChfdGhpcywgY29uc3RhbnRzLmlzTmFOLCBuZXcgZnVuY3Rpb25fMS5CdWlsdGluRnVuY3Rpb25PYmplY3QoX19pc05hTiwgMSwgaG9zdC5pc05hTikpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXMsIGNvbnN0YW50cy5pc0Zpbml0ZSwgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KF9faXNGaW5pdGUsIDEsIGhvc3QuaXNGaW5pdGUpKTtcbiAgICAgICAgICAgIC8vIDE1LjEuM1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXMsIGNvbnN0YW50cy5kZWNvZGVVUkksIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdChfX2RlY29kZVVSSSwgMSwgaG9zdC5kZWNvZGVVUkkpKTtcbiAgICAgICAgICAgIGVjbWEuRGVmaW5lVEZUKF90aGlzLCBjb25zdGFudHMuZGVjb2RlVVJJQ29tcG9uZW50LCBuZXcgZnVuY3Rpb25fMS5CdWlsdGluRnVuY3Rpb25PYmplY3QoX19kZWNvZGVVUklDb21wb25lbnQsIDEsIGhvc3QuZGVjb2RlVVJJQ29tcG9uZW50KSk7XG4gICAgICAgICAgICBlY21hLkRlZmluZVRGVChfdGhpcywgY29uc3RhbnRzLmVuY29kZVVSSSwgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KF9fZW5jb2RlVVJJLCAxLCBob3N0LmVuY29kZVVSSSkpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXMsIGNvbnN0YW50cy5lbmNvZGVVUklDb21wb25lbnQsIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdChfX2VuY29kZVVSSUNvbXBvbmVudCwgMSwgaG9zdC5lbmNvZGVVUklDb21wb25lbnQpKTtcbiAgICAgICAgICAgIC8vIDE1LjEuNFxuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXMsIGNvbnN0YW50cy5PYmplY3QsIG1vbml0b3IuaW5zdGFuY2VzLk9iamVjdENvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgIGVjbWEuRGVmaW5lVEZUKF90aGlzLCBjb25zdGFudHMuRnVuY3Rpb24sIG1vbml0b3IuaW5zdGFuY2VzLkZ1bmN0aW9uQ29uc3RydWN0b3IpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXMsIGNvbnN0YW50cy5BcnJheSwgbW9uaXRvci5pbnN0YW5jZXMuQXJyYXlDb25zdHJ1Y3Rvcik7XG4gICAgICAgICAgICBlY21hLkRlZmluZVRGVChfdGhpcywgY29uc3RhbnRzLlN0cmluZywgbW9uaXRvci5pbnN0YW5jZXMuU3RyaW5nQ29uc3RydWN0b3IpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXMsIGNvbnN0YW50cy5Cb29sZWFuLCBtb25pdG9yLmluc3RhbmNlcy5Cb29sZWFuQ29uc3RydWN0b3IpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXMsIGNvbnN0YW50cy5OdW1iZXIsIG1vbml0b3IuaW5zdGFuY2VzLk51bWJlckNvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgIGVjbWEuRGVmaW5lVEZUKF90aGlzLCBjb25zdGFudHMuRGF0ZSwgbW9uaXRvci5pbnN0YW5jZXMuRGF0ZUNvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgIGVjbWEuRGVmaW5lVEZUKF90aGlzLCBjb25zdGFudHMuUmVnRXhwLCBtb25pdG9yLmluc3RhbmNlcy5SZWdFeHBDb25zdHJ1Y3Rvcik7XG4gICAgICAgICAgICBlY21hLkRlZmluZVRGVChfdGhpcywgY29uc3RhbnRzLkVycm9yLCBtb25pdG9yLmluc3RhbmNlcy5FcnJvckNvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgIGVjbWEuRGVmaW5lVEZUKF90aGlzLCBjb25zdGFudHMuRXZhbEVycm9yLCBtb25pdG9yLmluc3RhbmNlcy5FdmFsRXJyb3JDb25zdHJ1Y3Rvcik7XG4gICAgICAgICAgICBlY21hLkRlZmluZVRGVChfdGhpcywgY29uc3RhbnRzLlJhbmdlRXJyb3IsIG1vbml0b3IuaW5zdGFuY2VzLlJhbmdlRXJyb3JDb25zdHJ1Y3Rvcik7XG4gICAgICAgICAgICBlY21hLkRlZmluZVRGVChfdGhpcywgY29uc3RhbnRzLlJlZmVyZW5jZUVycm9yLCBtb25pdG9yLmluc3RhbmNlcy5SZWZlcmVuY2VFcnJvckNvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgIGVjbWEuRGVmaW5lVEZUKF90aGlzLCBjb25zdGFudHMuU3ludGF4RXJyb3IsIG1vbml0b3IuaW5zdGFuY2VzLlN5bnRheEVycm9yQ29uc3RydWN0b3IpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXMsIGNvbnN0YW50cy5UeXBlRXJyb3IsIG1vbml0b3IuaW5zdGFuY2VzLlR5cGVFcnJvckNvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgIGVjbWEuRGVmaW5lVEZUKF90aGlzLCBjb25zdGFudHMuVVJJRXJyb3IsIG1vbml0b3IuaW5zdGFuY2VzLlVSSUVycm9yQ29uc3RydWN0b3IpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXMsIGNvbnN0YW50cy5NYXRoLCBtb25pdG9yLmluc3RhbmNlcy5NYXRoT2JqZWN0KTtcbiAgICAgICAgICAgIGVjbWEuRGVmaW5lVEZUKF90aGlzLCBjb25zdGFudHMuSlNPTiwgbW9uaXRvci5pbnN0YW5jZXMuSlNPTk9iamVjdCk7XG4gICAgICAgICAgICBlY21hLkRlZmluZVRGVChfdGhpcywgbmV3IHZhbHVlc18xLlZhbHVlKCd3cml0ZScsIGJvdCksIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdChfX3ByaW50LCAwLCAnd3JpdGUnKSk7XG4gICAgICAgICAgICBlY21hLkRlZmluZVRGVChfdGhpcywgbmV3IHZhbHVlc18xLlZhbHVlKCdwcmludCcsIGJvdCksIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdChfX2xwcmludCwgMCwgJ3ByaW50JykpO1xuICAgICAgICAgICAgaWYgKG1vbml0b3IuaW5zdGFuY2VzLkxhYmVsQ29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgICAgICBlY21hLkRlZmluZVRGVChfdGhpcywgbmV3IHZhbHVlc18xLlZhbHVlKCdMYWJlbCcsIGJvdCksIG1vbml0b3IuaW5zdGFuY2VzLkxhYmVsQ29uc3RydWN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vbml0b3IuaW5zdGFuY2VzLlZhbHVlQ29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgICAgICBlY21hLkRlZmluZVRGVChfdGhpcywgbmV3IHZhbHVlc18xLlZhbHVlKCdWYWx1ZScsIGJvdCksIG1vbml0b3IuaW5zdGFuY2VzLlZhbHVlQ29uc3RydWN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWNtYS5EZWZpbmVGRkYoX3RoaXMsIG5ldyB2YWx1ZXNfMS5WYWx1ZSgndXBnJywgYm90KSwgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KF9fZHVwZywgMSwgdW5kZWZpbmVkKSk7XG4gICAgICAgICAgICBlY21hLkRlZmluZUZGRihfdGhpcywgbmV3IHZhbHVlc18xLlZhbHVlKCd1cGdzJywgYm90KSwgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KF9fZHVwZ3MsIDEsIHVuZGVmaW5lZCkpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVGRkYoX3RoaXMsIG5ldyB2YWx1ZXNfMS5WYWx1ZSgndXBnZScsIGJvdCksIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdChfX2R1cGdlLCAxLCB1bmRlZmluZWQpKTtcbiAgICAgICAgICAgIGVjbWEuRGVmaW5lRkZGKF90aGlzLCBuZXcgdmFsdWVzXzEuVmFsdWUoJ2xibCcsIGJvdCksIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdChfX3VwZywgMSwgdW5kZWZpbmVkKSk7XG4gICAgICAgICAgICBlY21hLkRlZmluZUZGRihfdGhpcywgbmV3IHZhbHVlc18xLlZhbHVlKCdsYmxzJywgYm90KSwgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KF9fdXBncywgMSwgdW5kZWZpbmVkKSk7XG4gICAgICAgICAgICBlY21hLkRlZmluZUZGRihfdGhpcywgbmV3IHZhbHVlc18xLlZhbHVlKCdsYmxlJywgYm90KSwgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KF9fdXBnZSwgMSwgdW5kZWZpbmVkKSk7XG4gICAgICAgICAgICBlY21hLkRlZmluZUZGRihfdGhpcywgbmV3IHZhbHVlc18xLlZhbHVlKCd1cGdsJywgYm90KSwgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KF9fdXBnbCwgMSwgdW5kZWZpbmVkKSk7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQodGhpcywgbmV3IFZhbHVlKCdMYWJlbCcsYm90KSAsX19MYWJlbCk7XG4gICAgICAgIFxuICAgICAgICAgICAgZWNtYS5EZWZpbmVGRkYodGhpcyAsIG5ldyBWYWx1ZSgnZGVjbGFzc2lmeScgICAgLCBib3QpICwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChfX2RlY2xhc3NpZnkgICAgLCAxLCB1bmRlZmluZWQpKTtcbiAgICAgICAgXG4gICAgICAgICAgICBlY21hLkRlZmluZUZGRih0aGlzICwgbmV3IFZhbHVlKCd1cGdzJyAgICwgYm90KSAsIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3QoX191cGdzICAgLCAxLCB1bmRlZmluZWQpKTtcbiAgICAgICAgICAgIGVjbWEuRGVmaW5lRkZGKHRoaXMgLCBuZXcgVmFsdWUoJ2R1cGdzJyAgLCBib3QpICwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChfX2R1cGdzICAsIDEsIHVuZGVmaW5lZCkpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVGRkYodGhpcyAsIG5ldyBWYWx1ZSgnZ2V0UEMnICAsIGJvdCkgLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KF9fZ2V0UEMgICwgMCwgdW5kZWZpbmVkKSk7XG4gICAgICAgICAgICBlY21hLkRlZmluZUZGRih0aGlzICwgbmV3IFZhbHVlKCdzZXRQQycgICwgYm90KSAsIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3QoX19zZXRQQyAgLCAxLCB1bmRlZmluZWQpKTtcbiAgICAgICAgICAgIGVjbWEuRGVmaW5lRkZGKHRoaXMgLCBuZXcgVmFsdWUoJ2dldEVYQycgLCBib3QpICwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChfX2dldEVYQyAsIDAsIHVuZGVmaW5lZCkpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVGRkYodGhpcyAsIG5ldyBWYWx1ZSgnc2V0RVhDJyAsIGJvdCkgLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KF9fc2V0RVhDICwgMSwgdW5kZWZpbmVkKSk7XG4gICAgICAgICAgICBlY21hLkRlZmluZUZGRih0aGlzICwgbmV3IFZhbHVlKCdnZXRSRVQnICwgYm90KSAsIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3QoX19nZXRSRVQgLCAwLCB1bmRlZmluZWQpKTtcbiAgICAgICAgICAgIGVjbWEuRGVmaW5lRkZGKHRoaXMgLCBuZXcgVmFsdWUoJ3NldFJFVCcgLCBib3QpICwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChfX3NldFJFVCAsIDEsIHVuZGVmaW5lZCkpO1xuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGVjbWEuRGVmaW5lVEZUKF90aGlzLCBuZXcgdmFsdWVzXzEuVmFsdWUoJ3VuZXNjYXBlJywgYm90KSwgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KF9fdW5lc2NhcGUsIDEsIGhvc3QudW5lc2NhcGUpKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gR2xvYmFsT2JqZWN0O1xuICAgIH0oZWNtYS5FY21hKSk7XG4gICAgLypcbiAgICBHbG9iYWxPYmplY3QuZXh0ZW5zaW9ucyA9IFtdO1xuICAgIEdsb2JhbE9iamVjdC5hZGRFeHRlbnNpb24gPSBmdW5jdGlvbihleHQpIHtcbiAgICAgIEdsb2JhbE9iamVjdC5leHRlbnNpb25zLnB1c2goZXh0KTtcbiAgICB9O1xuICAgICovXG4gICAgR2xvYmFsT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdbZ2xvYmFsIG9iamVjdF0nOyB9O1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIHVuZXNjYXBlLCBCMi4yXG4gICAgdmFyIF9fdW5lc2NhcGUgPSBmdW5jdGlvbiAodGhpc0FyZywgYXJncykge1xuICAgICAgICB2YXIgc3RyID0gYXJnc1swXSA/IGFyZ3NbMF0gOiBuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgICAgICBzdHIgPSBUb1N0cmluZ18xLlRvU3RyaW5nKHN0cik7XG4gICAgICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUodW5lc2NhcGUoc3RyLnZhbHVlKSwgc3RyLmxhYmVsKTtcbiAgICB9O1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIDE1LjEuMi4xXG4gICAgdmFyIF9fZXZhbCA9IGZ1bmN0aW9uICh0aGlzQXJnLCBhcmdzKSB7XG4gICAgICAgIHZhciBhcmcwID0gYXJnc1swXTtcbiAgICAgICAgaWYgKGFyZzAgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgICAgICBpZiAodHlwZW9mIGFyZzAudmFsdWUgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIGFyZzA7XG4gICAgICAgIHZhciBwcm9nO1xuICAgICAgICAvLyByYWlzZSB0aGUgcGMgdy5yLnQuIHRoZSBwcm9ncmFtIHN0cmluZzsgcGFyc2luZyBtYXkgcmVzdWx0IGluIGFuIGV4Y2VwdGlvblxuICAgICAgICBtb25pdG9yLmNvbnRleHQucHVzaFBDKGFyZzAubGFiZWwpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcHJvZyA9IGVzcHJpbWEucGFyc2UoYXJnMC52YWx1ZSwgeyBsb2M6IHRydWUsIHNvdXJjZTogJ2V2YWwnIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB2YXIgbXNnID0gZS5kZXNjcmlwdGlvbiArICcgaW4gZXZhbDonICsgZS5saW5lTnVtYmVyICsgJzonICsgZS5jb2x1bW47XG4gICAgICAgICAgICBtb25pdG9yLlRocm93KGVycm9yLlN5bnRheEVycm9yT2JqZWN0LCBtc2csIGFyZzAubGFiZWwpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBldmFsQ3R4ID0gZnVuY3Rpb25fMS5lbnRlckV2YWxDb2RlKHByb2csIF9fZXZhbCk7XG4gICAgICAgIG1vbml0b3IuY29udGV4dFN0YWNrLnB1c2goZXZhbEN0eCk7XG4gICAgICAgIC8vIHRoaXMgaXMgbm90IGEgdmFsdWUsIGl0IGlzIGEgcmVzdWx0ISFcbiAgICAgICAgdmFyIHJlc3VsdCA9IG1vbml0b3IubW9kdWxlcy5leGVjLmV4ZWN1dGUocHJvZywgZmFsc2UpO1xuICAgICAgICAvLyBpZiB2YWx1ZSBpcyAnZW1wdHknIChyZXByZXNlbnRlZCBieSBudWxsKVxuICAgICAgICBpZiAoIXJlc3VsdC52YWx1ZSkge1xuICAgICAgICAgICAgcmVzdWx0LnZhbHVlID0gbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgYm90KTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQudmFsdWUucmFpc2UoYXJnMC5sYWJlbCk7XG4gICAgICAgIC8vIE5PVEU6IHBhcnNlciBzaG91bGQgZ3VhcmFudGVlIHRoZSByZXN1bHQgdHlwZSBpcyBuZXZlciByZXR1cm5cbiAgICAgICAgaWYgKHJlc3VsdC50eXBlID09PSAndGhyb3cnKSB7XG4gICAgICAgICAgICB0aHJvdyByZXN1bHQudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcG9wIGFmdGVyIHRocm93LCBvdGhlcndpc2UgaW50ZXJuYWwgY29udGV4dCB0aHJvd24gYXdheSBiZWZvcmUgaGFuZGxlciAoY2F0Y2gpXG4gICAgICAgIG1vbml0b3IuY29udGV4dFN0YWNrLnBvcCgpO1xuICAgICAgICBtb25pdG9yLmNvbnRleHQucG9wUEMoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbiAgICB9O1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIDE1LjEuMi4yXG4gICAgdmFyIF9fcGFyc2VJbnQgPSBmdW5jdGlvbiAodGhpc0FyZywgYXJncykge1xuICAgICAgICB2YXIgc3RyaW5nID0gYXJnc1swXSB8fCBuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgICAgICB2YXIgcmFkaXggPSBhcmdzWzFdIHx8IG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG4gICAgICAgIHN0cmluZyA9IFRvU3RyaW5nXzEuVG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgICAgdmFyIHZhbHVlID0gcGFyc2VJbnQoc3RyaW5nLnZhbHVlLCByYWRpeC52YWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUodmFsdWUsIGx1YihzdHJpbmcubGFiZWwsIHJhZGl4LmxhYmVsKSk7XG4gICAgfTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyAxNS4xLjIuM1xuICAgIHZhciBfX3BhcnNlRmxvYXQgPSBmdW5jdGlvbiAodGhpc0FyZywgYXJncykge1xuICAgICAgICB2YXIgc3RyaW5nID0gYXJnc1swXSB8fCBuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgICAgICBzdHJpbmcgPSBUb1N0cmluZ18xLlRvU3RyaW5nKHN0cmluZyk7XG4gICAgICAgIHZhciB2YWx1ZSA9IHBhcnNlRmxvYXQoc3RyaW5nLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZSh2YWx1ZSwgc3RyaW5nLmxhYmVsKTtcbiAgICB9O1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIDE1LjEuMi40XG4gICAgdmFyIF9faXNOYU4gPSBmdW5jdGlvbiAodGhpc0FyZywgYXJncykge1xuICAgICAgICB2YXIgbnVtYmVyID0gYXJnc1swXSB8fCBuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgICAgICBudW1iZXIgPSBUb051bWJlcl8xLlRvTnVtYmVyKG51bWJlcik7XG4gICAgICAgIHZhciB2YWx1ZSA9IGlzTmFOKG51bWJlci52YWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUodmFsdWUsIG51bWJlci5sYWJlbCk7XG4gICAgfTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyAxNS4xLjIuNVxuICAgIHZhciBfX2lzRmluaXRlID0gZnVuY3Rpb24gKHRoaXNBcmcsIGFyZ3MpIHtcbiAgICAgICAgdmFyIG51bWJlciA9IGFyZ3NbMF0gfHwgbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgYm90KTtcbiAgICAgICAgbnVtYmVyID0gVG9OdW1iZXJfMS5Ub051bWJlcihudW1iZXIpO1xuICAgICAgICB2YXIgdmFsdWUgPSBpc0Zpbml0ZShudW1iZXIudmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IHZhbHVlc18xLlZhbHVlKHZhbHVlLCBudW1iZXIubGFiZWwpO1xuICAgIH07XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gMTUuMS4zLjFcbiAgICB2YXIgX19kZWNvZGVVUkkgPSBmdW5jdGlvbiAodGhpc0FyZywgYXJncykge1xuICAgICAgICB2YXIgYXJnMCA9IGFyZ3NbMF0gPyBhcmdzWzBdIDogbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgYm90KTtcbiAgICAgICAgdmFyIGVuYyA9IFRvU3RyaW5nXzEuVG9TdHJpbmcoYXJnMCk7XG4gICAgICAgIHZhciByZXMgPSBuZXcgdmFsdWVzXzEuVmFsdWUoZGVjb2RlVVJJKGVuYy52YWx1ZSksIGVuYy5sYWJlbCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyAxNS4xLjMuMlxuICAgIHZhciBfX2RlY29kZVVSSUNvbXBvbmVudCA9IGZ1bmN0aW9uICh0aGlzQXJnLCBhcmdzKSB7XG4gICAgICAgIHZhciBhcmcwID0gYXJnc1swXSA/IGFyZ3NbMF0gOiBuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgICAgICB2YXIgZW5jID0gVG9TdHJpbmdfMS5Ub1N0cmluZyhhcmcwKTtcbiAgICAgICAgdmFyIHJlcyA9IG5ldyB2YWx1ZXNfMS5WYWx1ZShkZWNvZGVVUklDb21wb25lbnQoZW5jLnZhbHVlKSwgZW5jLmxhYmVsKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIDE1LjEuMi4zXG4gICAgdmFyIF9fZW5jb2RlVVJJID0gZnVuY3Rpb24gKHRoaXNBcmcsIGFyZ3MpIHtcbiAgICAgICAgdmFyIGFyZzAgPSBhcmdzWzBdID8gYXJnc1swXSA6IG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG4gICAgICAgIHZhciBlbmMgPSBUb1N0cmluZ18xLlRvU3RyaW5nKGFyZzApO1xuICAgICAgICB2YXIgcmVzID0gbmV3IHZhbHVlc18xLlZhbHVlKGVuY29kZVVSSShlbmMudmFsdWUpLCBlbmMubGFiZWwpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gMTUuMS4zLjRcbiAgICB2YXIgX19lbmNvZGVVUklDb21wb25lbnQgPSBmdW5jdGlvbiAodGhpc0FyZywgYXJncykge1xuICAgICAgICB2YXIgYXJnMCA9IGFyZ3NbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3NbMF0gOiBuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgICAgICB2YXIgY29tcG9uZW50U3RyaW5nID0gVG9TdHJpbmdfMS5Ub1N0cmluZyhhcmcwKTtcbiAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZShlbmNvZGVVUklDb21wb25lbnQoY29tcG9uZW50U3RyaW5nLnZhbHVlKSwgY29tcG9uZW50U3RyaW5nLmxhYmVsKTtcbiAgICB9O1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHZhciBfX3ByaW50ID0gZnVuY3Rpb24gKHRoaXNBcmcsIGFyZ3MpIHtcbiAgICAgICAgdmFyIHN0ciA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBzdHIgKz0gYXJnc1tpXS52YWx1ZTtcbiAgICAgICAgbW9uaXRvci5wcmludChzdHIpO1xuICAgICAgICByZXR1cm4gbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgYm90KTtcbiAgICB9O1xuICAgIHZhciBfX2xwcmludCA9IGZ1bmN0aW9uICh0aGlzQXJnLCBhcmdzKSB7XG4gICAgICAgIGlmIChtb25pdG9yLm9wdGlvbnMuZ2V0KCdtb25pdG9yLnRlc3RNb2RlJykpIHtcbiAgICAgICAgICAgIF9fcHJpbnQodGhpc0FyZywgYXJncyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgYm90KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RyID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHN0ciArPSBhcmdzW2ldO1xuICAgICAgICBpZiAobW9uaXRvci5vcHRpb25zLmdldCgnbW9uaXRvci50YWludE1vZGUnKSkge1xuICAgICAgICAgICAgbW9uaXRvci5wcmludChzdHIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbW9uaXRvci5wcmludCgnKCcgKyBtb25pdG9yLmNvbnRleHQuZWZmZWN0aXZlUEMgKyAnKTonICsgc3RyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgYm90KTtcbiAgICB9O1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHZhciBfX2FsZXJ0ID0gZnVuY3Rpb24gKHRoaXNBcmcsIGFyZ3MpIHtcbiAgICAgICAgdmFyIHN0ciA9ICdhbGVydDogJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgc3RyICs9IGFyZ3NbaV0udmFsdWU7XG4gICAgICAgIG1vbml0b3IucHJpbnQoc3RyKTtcbiAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG4gICAgfTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICB2YXIgX191cGdsID0gZnVuY3Rpb24gKHRoaXNBcmcsIGFyZ3MpIHtcbiAgICAgICAgdmFyIGxhYmVsTmFtZSA9IGFyZ3NbMF0gPyBhcmdzWzBdIDogbmV3IHZhbHVlc18xLlZhbHVlKCdkZWZhdWx0JywgYm90KTtcbiAgICAgICAgbW9uaXRvci5hc3NlcnQobGUobGFiZWxOYW1lLmxhYmVsLCBib3QpKTtcbiAgICAgICAgdmFyIGxibCA9IGJvdDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBtb25pdG9yLmFzc2VydChsZShhcmdzW2ldLmxhYmVsLCBib3QpKTtcbiAgICAgICAgICAgIGxibCA9IGx1YihsYmwsIExhYmVsLmZyb21TdHJpbmcoYXJnc1tpXS52YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGxibCA9IGxibC5lcXVhbHMoYm90KSA/IExhYmVsLnRvcCA6IGxibDtcbiAgICAgICAgdmFyIGxibG1hcCA9IG1vbml0b3IuY29udGV4dC5sYWJlbHMubGFiZWxtYXA7XG4gICAgICAgIHZhciBuYW1lID0gbGFiZWxOYW1lLnZhbHVlO1xuICAgICAgICBpZiAoIWxibG1hcFtuYW1lXSkge1xuICAgICAgICAgICAgbGJsbWFwW25hbWVdID0ge1xuICAgICAgICAgICAgICAgIGxhYmVsOiBsYmwsXG4gICAgICAgICAgICAgICAgcGNtYXJrZXI6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBsYmxtYXBbbmFtZV0ubGFiZWwgPSBsdWIobGJsbWFwW25hbWVdLmxhYmVsLCBsYmwpO1xuICAgICAgICBpZiAobGJsbWFwW25hbWVdLnBjbWFya2VyKSB7XG4gICAgICAgICAgICBtb25pdG9yLmNvbnRleHQucGNTdGFjay5tYXAoZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbHViKGwsIGxibCk7XG4gICAgICAgICAgICB9LCBsYmxtYXBbbmFtZV0ucGNtYXJrZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgIH07XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgdmFyIF9fdXBnID0gZnVuY3Rpb24gKHRoaXNBcmcsIGFyZ3MpIHtcbiAgICAgICAgdmFyIGFyZzAgPSBhcmdzWzBdID8gYXJnc1swXSA6IG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG4gICAgICAgIHZhciBsYmwgPSBib3Q7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbW9uaXRvci5hc3NlcnQobGUoYXJnc1tpXS5sYWJlbCwgYm90KSk7XG4gICAgICAgICAgICBsYmwgPSBsdWIobGJsLCBMYWJlbC5mcm9tU3RyaW5nKGFyZ3NbaV0udmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICBsYmwgPSBsYmwuZXF1YWxzKGJvdCkgPyBMYWJlbC50b3AgOiBsYmw7XG4gICAgICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUoYXJnMC52YWx1ZSwgbHViKGFyZzAubGFiZWwsIGxibCkpO1xuICAgIH07XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgdmFyIF9fZHVwZyA9IGZ1bmN0aW9uICh0aGlzQXJnLCBhcmdzKSB7XG4gICAgICAgIHZhciBhcmcwID0gYXJnc1swXSA/IGFyZ3NbMF0gOiBuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgICAgICB2YXIgbGJsID0gYm90O1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxibCA9IGx1YihsYmwsIGFyZ3NbaV0ubGFiZWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUoYXJnMC52YWx1ZSwgbHViKGFyZzAubGFiZWwsIGxibCkpO1xuICAgIH07XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgdmFyIF9fdXBncyA9IGZ1bmN0aW9uICh0aGlzQXJnLCBhcmdzKSB7XG4gICAgICAgIHZhciBvYmogPSBhcmdzWzBdID8gYXJnc1swXSA6IG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG4gICAgICAgIHZhciBsYmwgPSBib3Q7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbW9uaXRvci5hc3NlcnQobGUoYXJnc1tpXS5sYWJlbCwgYm90KSk7XG4gICAgICAgICAgICBsYmwgPSBsdWIobGJsLCBMYWJlbC5mcm9tU3RyaW5nKGFyZ3NbaV0udmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICBsYmwgPSBsYmwuZXF1YWxzKGJvdCkgPyBMYWJlbC50b3AgOiBsYmw7XG4gICAgICAgIGlmIChvYmoudmFsdWUgIT0gdW5kZWZpbmVkICYmIG9iai52YWx1ZS5zdHJ1Y3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb2JqLnZhbHVlLnN0cnVjdCA9IGx1YihvYmoudmFsdWUuc3RydWN0LCBsYmwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICB2YXIgX19kdXBncyA9IGZ1bmN0aW9uICh0aGlzQXJnLCBhcmdzKSB7XG4gICAgICAgIHZhciBhcmcwID0gYXJnc1swXSA/IGFyZ3NbMF0gOiBuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgICAgICB2YXIgbGJsID0gYm90O1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxibCA9IGx1YihsYmwsIGFyZ3NbaV0ubGFiZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmcwLnZhbHVlICE9IHVuZGVmaW5lZCAmJiBhcmcwLnZhbHVlLnN0cnVjdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhcmcwLnZhbHVlLnN0cnVjdCA9IGx1YihhcmcwLnZhbHVlLnN0cnVjdCwgbGJsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJnMDtcbiAgICB9O1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHZhciBfX3VwZ2UgPSBmdW5jdGlvbiAodGhpc0FyZywgYXJncykge1xuICAgICAgICB2YXIgb2JqID0gYXJnc1swXSA/IGFyZ3NbMF0gOiBuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgICAgICB2YXIgaXggPSBhcmdzWzFdID8gYXJnc1sxXSA6IG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG4gICAgICAgIGlmIChvYmoudmFsdWUgPT09IHVuZGVmaW5lZCB8fCBvYmoudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgICAgICB9XG4gICAgICAgIGl4ID0gVG9TdHJpbmdfMS5Ub1N0cmluZyhpeCk7XG4gICAgICAgIHZhciBsYmwgPSBib3Q7XG4gICAgICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbW9uaXRvci5hc3NlcnQobGUoYXJnc1tpXS5sYWJlbCwgYm90KSk7XG4gICAgICAgICAgICBsYmwgPSBsdWIobGJsLCBMYWJlbC5mcm9tU3RyaW5nKGFyZ3NbaV0udmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICBsYmwgPSBsYmwuZXF1YWxzKGJvdCkgPyBMYWJlbC50b3AgOiBsYmw7XG4gICAgICAgIHZhciBwcm9wID0gb2JqLnZhbHVlLm1hcC5nZXQoaXgudmFsdWUpO1xuICAgICAgICBpZiAocHJvcCkge1xuICAgICAgICAgICAgcHJvcC5leGlzdGVuY2UgPSBsdWIocHJvcC5leGlzdGVuY2UsIGxibCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG4gICAgfTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICB2YXIgX19kdXBnZSA9IGZ1bmN0aW9uICh0aGlzQXJnLCBhcmdzKSB7XG4gICAgICAgIHZhciBvYmogPSBhcmdzWzBdID8gYXJnc1swXSA6IG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG4gICAgICAgIHZhciBpeCA9IGFyZ3NbMV0gPyBhcmdzWzFdIDogbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgYm90KTtcbiAgICAgICAgaWYgKG9iai52YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IG9iai52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG4gICAgICAgIH1cbiAgICAgICAgaXggPSBUb1N0cmluZ18xLlRvU3RyaW5nKGl4KTtcbiAgICAgICAgdmFyIGxibCA9IGJvdDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsYmwgPSBsdWIobGJsLCBhcmdzW2ldLmxhYmVsKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvcCA9IG9iai52YWx1ZS5tYXAuZ2V0KGl4LnZhbHVlKTtcbiAgICAgICAgaWYgKHByb3ApIHtcbiAgICAgICAgICAgIHByb3AuZXhpc3RlbmNlID0gbHViKHByb3AuZXhpc3RlbmNlLCBsYmwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgIH07XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgdmFyIF9fZGVjbGFzc2lmeSA9IGZ1bmN0aW9uICh0aGlzQXJnLCBhcmdzKSB7XG4gICAgICAgIHZhciB2YWwgPSBuZXcgdmFsdWVzXzEuVmFsdWUoYXJnc1swXSA/IGFyZ3NbMF0udmFsdWUgOiB1bmRlZmluZWQsIGJvdCk7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICB2YXIgbW9kdWxlID0ge307XG4gICAgbW9kdWxlLkdsb2JhbE9iamVjdCA9IEdsb2JhbE9iamVjdDtcbiAgICBtb2R1bGUuYWxsb2NhdGUgPSBhbGxvY2F0ZTtcbiAgICByZXR1cm4gbW9kdWxlO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdsb2JhbC5qcy5tYXAiLCIvKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLiAqL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbGFiZWwgPSByZXF1aXJlKFwiLi9sYWJlbFwiKTtcbnZhciB2YWx1ZXNfMSA9IHJlcXVpcmUoXCIuL3ZhbHVlc1wiKTtcbnZhciBlY21hID0gcmVxdWlyZShcIi4vZWNtYVwiKTtcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG52YXIgZnVuY3Rpb25fMSA9IHJlcXVpcmUoXCIuL2Z1bmN0aW9uXCIpO1xudmFyIE9iamVjdE9iamVjdF8xID0gcmVxdWlyZShcIi4vT2JqZWN0cy9PYmplY3RPYmplY3RcIik7XG52YXIgQXJyYXlPYmplY3RfMSA9IHJlcXVpcmUoXCIuL09iamVjdHMvQXJyYXlPYmplY3RcIik7XG52YXIgVG9OdW1iZXJfMSA9IHJlcXVpcmUoXCIuL0NvbnZlcnNpb24vVG9OdW1iZXJcIik7XG52YXIgVG9JbnRlZ2VyXzEgPSByZXF1aXJlKFwiLi9Db252ZXJzaW9uL1RvSW50ZWdlclwiKTtcbnZhciBUb1N0cmluZ18xID0gcmVxdWlyZShcIi4vQ29udmVyc2lvbi9Ub1N0cmluZ1wiKTtcbnZhciBJc0NhbGxhYmxlXzEgPSByZXF1aXJlKFwiLi9VdGlsaXR5L0lzQ2FsbGFibGVcIik7XG5leHBvcnRzLmZ1bmN0b3IgPSBmdW5jdGlvbiAobW9uaXRvcikge1xuICAgIHZhciBMYWJlbCA9IGxhYmVsLkxhYmVsO1xuICAgIHZhciBsdWIgPSBsYWJlbC5sdWI7XG4gICAgdmFyIGdsYiA9IGxhYmVsLmdsYjtcbiAgICB2YXIgbGUgPSBsYWJlbC5sZTtcbiAgICB2YXIgYm90ID0gTGFiZWwuYm90O1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIGFsbG9jYXRlKGhvc3QpIHtcbiAgICAgICAgdmFyIGpzb25PYmplY3QgPSBuZXcgSlNPTk9iamVjdChob3N0LkpTT04pO1xuICAgICAgICByZXR1cm4geyBKU09OT2JqZWN0OiBqc29uT2JqZWN0IH07XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFRoZSBKU09OIG9iamVjdCwgMTUuMTJcbiAgICB2YXIgSlNPTk9iamVjdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKEpTT05PYmplY3QsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEpTT05PYmplY3QoaG9zdCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLlByb3RvdHlwZSA9IG5ldyB2YWx1ZXNfMS5WYWx1ZShtb25pdG9yLmluc3RhbmNlcy5PYmplY3RQcm90b3R5cGUsIGJvdCk7XG4gICAgICAgICAgICBfdGhpcy5DbGFzcyA9ICdKU09OJztcbiAgICAgICAgICAgIF90aGlzLkV4dGVuc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgX3RoaXMuaG9zdCA9IGhvc3Q7XG4gICAgICAgICAgICBlY21hLkRlZmluZUZGRihfdGhpcywgY29uc3RhbnRzLnByb3RvdHlwZSwgbW9uaXRvci5pbnN0YW5jZXMuT2JqZWN0UHJvdG90eXBlKTtcbiAgICAgICAgICAgIGVjbWEuRGVmaW5lVEZUKF90aGlzLCBjb25zdGFudHMucGFyc2UsIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdChwYXJzZSwgMiwgX3RoaXMuaG9zdC5wYXJzZSkpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXMsIGNvbnN0YW50cy5zdHJpbmdpZnksIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdChzdHJpbmdpZnksIDMsIF90aGlzLmhvc3Quc3RyaW5naWZ5KSk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEpTT05PYmplY3Q7XG4gICAgfShlY21hLkVjbWEpKTtcbiAgICAvLyBCeSB0aGUgc3RhbmRhcmQsIHRoZXJlIHNob3VsZCBiZSBubyBDYWxsIG9yIENvbnN0cnVjdCBmb3IgSlNPTiBvYmplY3QsXG4gICAgLy8gc28gdGhyb3cgYSBUeXBlRXJyb3IgKGFzIFNwaWRlck1vbmtleSBzZWVtIHRvIGRvKVxuICAgIEpTT05PYmplY3QucHJvdG90eXBlLkNhbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG1vbml0b3IuVGhyb3cobW9uaXRvci5tb2R1bGVzLmVycm9yLlR5cGVFcnJvck9iamVjdCwgJ0pTT04gaXMgbm90IGEgZnVuY3Rpb24nLCBib3QpO1xuICAgIH07XG4gICAgSlNPTk9iamVjdC5wcm90b3R5cGUuQ29uc3RydWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBtb25pdG9yLlRocm93KG1vbml0b3IubW9kdWxlcy5lcnJvci5UeXBlRXJyb3JPYmplY3QsICdKU09OIGlzIG5vdCBhIGNvbnN0cnVjdG9yJywgYm90KTtcbiAgICB9O1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIHBhcnNlLCAxNS4xMi4yXG4gICAgdmFyIHBhcnNlID0gZnVuY3Rpb24gKHRoaXNBcmcsIGFyZ3MpIHtcbiAgICAgICAgaWYgKGFyZ3NbMF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbW9uaXRvci5UaHJvdyhtb25pdG9yLm1vZHVsZXMuZXJyb3IuU3ludGF4RXJyb3JPYmplY3QsICdKU09OLnBhcnNlOiBObyBzdHJpbmcgdG8gcGFyc2UnLCBib3QpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBKVGV4dCA9IFRvU3RyaW5nXzEuVG9TdHJpbmcoYXJnc1swXSkgfHwgbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgYm90KTtcbiAgICAgICAgdmFyIHJldml2ZXIgPSBhcmdzWzFdIHx8IG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG4gICAgICAgIHZhciB1bmZpbHRlcmVkID0gcGFyc2VBbmRFdmFsdWF0ZShKVGV4dCk7XG4gICAgICAgIC8vIERvIHdlIGhhdmUgYW55IGp1bmsgY2hhcmFjdGVycyBsZWZ0PyBJZiBzbywgYSBiYWQgc3RyaW5nIVxuICAgICAgICBpZiAodW5maWx0ZXJlZC5maW5hbEluZGV4IDw9IEpUZXh0LnZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgbW9uaXRvci5UaHJvdyhtb25pdG9yLm1vZHVsZXMuZXJyb3IuU3ludGF4RXJyb3JPYmplY3QsICdKU09OLnBhcnNlOiBTdHJpbmcgY29udGFpbnMgYmFkIHN5bWJvbHMgaW4gdGhlIGVuZCcsIGJvdCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlzUmV2aXZlckNhbGxhYmxlID0gSXNDYWxsYWJsZV8xLklzQ2FsbGFibGUocmV2aXZlcik7XG4gICAgICAgIG1vbml0b3IuY29udGV4dC5wdXNoUEMoaXNSZXZpdmVyQ2FsbGFibGUubGFiZWwpO1xuICAgICAgICBpZiAoaXNSZXZpdmVyQ2FsbGFibGUudmFsdWUpIHtcbiAgICAgICAgICAgIHZhciByb290ID0gbmV3IG9iamVjdC5PYmplY3RPYmplY3QoKTtcbiAgICAgICAgICAgIHJvb3QuRGVmaW5lT3duUHJvcGVydHkobmV3IHZhbHVlc18xLlZhbHVlKFwiXCIsIGJvdCksIHsgdmFsdWU6IHVuZmlsdGVyZWQsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgbGFiZWw6IHVuZmlsdGVyZWQubGFiZWxcbiAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgICAgIG1vbml0b3IuY29udGV4dC5wb3BQQygpO1xuICAgICAgICAgICAgcmV0dXJuIFdhbGsocm9vdCwgbmV3IHZhbHVlc18xLlZhbHVlKFwiXCIsIGx1Yih1bmZpbHRlcmVkLmxhYmVsLCBsdWIoSlRleHQubGFiZWwsIHJldml2ZXIubGFiZWwpKSksIHJldml2ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbW9uaXRvci5jb250ZXh0LnBvcFBDKCk7XG4gICAgICAgICAgICByZXR1cm4gdW5maWx0ZXJlZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gV2FsaywgcGFydCBvZiAxNS4xMi4yXG4gICAgdmFyIFdhbGsgPSBmdW5jdGlvbiAoaG9sZGVyLCBuYW1lLCByZXZpdmVyKSB7XG4gICAgICAgIHZhciB2YWwgPSBob2xkZXIuR2V0KG5hbWUpO1xuICAgICAgICBtb25pdG9yLmNvbnRleHQucHVzaFBDKHZhbC5sYWJlbCk7XG4gICAgICAgIGlmICh2YWwudmFsdWUgJiYgdHlwZW9mIHZhbC52YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHZhbCA9IHZhbC52YWx1ZTtcbiAgICAgICAgICAgIG1vbml0b3IuY29udGV4dC5wdXNoUEModmFsLmxhYmVsKTtcbiAgICAgICAgICAgIGlmICh2YWwudmFsdWUuQ2xhc3MgPT09ICdBcnJheScpIHtcbiAgICAgICAgICAgICAgICB2YXIgSSA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgwLCBib3QpO1xuICAgICAgICAgICAgICAgIHZhciBsZW4gPSB2YWwudmFsdWUuR2V0KGNvbnN0YW50cy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChJLnZhbHVlIDwgbGVuLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdFbGVtZW50ID0gV2Fsayh2YWwsIFRvU3RyaW5nXzEuVG9TdHJpbmcoSSksIHJldml2ZXIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3RWxlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwuRGVsZXRlKFRvU3RyaW5nXzEuVG9TdHJpbmcoSSksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbC5EZWZpbmVPd25Qcm9wZXJ0eShUb1N0cmluZ18xLlRvU3RyaW5nKEkpLCB7IHZhbHVlOiBuZXdFbGVtZW50LnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiB2YWwubGFiZWxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBJLnZhbHVlKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleXMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgYWxsS2V5cyA9IE9iamVjdC5rZXlzKHZhbC52YWx1ZS5wcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleVZhbCA9IHZhbC5HZXRQcm9wZXJ0eShuZXcgdmFsdWVzXzEuVmFsdWUoYWxsS2V5c1tpXSwgYm90KSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXlWYWwudmFsdWUgJiYga2V5VmFsLnZhbHVlLmVudW1lcmFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleXMucHVzaChuZXcgdmFsdWVzXzEuVmFsdWUoYWxsS2V5c1tpXSwgYm90KSk7IC8va2V5VmFsLmxhYmVsP1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgUCA9IFRvU3RyaW5nXzEuVG9TdHJpbmcoa2V5c1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdFbGVtZW50ID0gV2Fsayh2YWwsIFAsIHJldml2ZXIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3RWxlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwuRGVsZXRlKFAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbC5EZWZpbmVPd25Qcm9wZXJ0eShQLCB7IHZhbHVlOiBuZXdFbGVtZW50LnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiB2YWwubGFiZWxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1vbml0b3IuY29udGV4dC5wb3BQQygpO1xuICAgICAgICB9XG4gICAgICAgIG1vbml0b3IuY29udGV4dC5wb3BQQygpO1xuICAgICAgICByZXR1cm4gcmV2aXZlci5DYWxsKGhvbGRlciwgW25hbWUsIHZhbF0pO1xuICAgIH07XG4gICAgLy8gSW5zcGlyYXRpb24gZnJvbSBEb3VnbGFzIENyb2NrZm9yZCwgaHR0cHM6Ly9naXRodWIuY29tL2RvdWdsYXNjcm9ja2ZvcmQvSlNPTi1qcy9ibG9iL21hc3Rlci9qc29uX3BhcnNlLmpzXG4gICAgLy8gVGhpcyBpcyB1c2VkIGZvciB0aGUgMm5kIGFuZCAzcmQgc3RlcCBpbiBwYXJzZSwgMTUuMTIuMlxuICAgIHZhciBwYXJzZUFuZEV2YWx1YXRlID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRDaGFyID0gJyAnO1xuICAgICAgICB2YXIgY3VycmVudEluZGV4ID0gMDtcbiAgICAgICAgLy8gRnJvbSAxNS4xMi4xLjEsIEpTT05Fc2NhcGVDaGFyYWN0ZXIgOjogb25lIG9mIFwiIC8gXFwgYiBmIG4gciB0XG4gICAgICAgIHZhciBlc2NhcGVDaGFyYWN0ZXJzID0ge1xuICAgICAgICAgICAgJ1wiJzogJ1wiJyxcbiAgICAgICAgICAgICcvJzogJy8nLFxuICAgICAgICAgICAgJ1xcXFwnOiAnXFxcXCcsXG4gICAgICAgICAgICBiOiAnXFxiJyxcbiAgICAgICAgICAgIGY6ICdcXGYnLFxuICAgICAgICAgICAgbjogJ1xcbicsXG4gICAgICAgICAgICByOiAnXFxyJyxcbiAgICAgICAgICAgIHQ6ICdcXHQnXG4gICAgICAgIH07XG4gICAgICAgIC8vIFRoZXNlIGFyZSBub3QgYWxsb3dlZCB0byBoYXZlIGluIGEgc3RyaW5nIVxuICAgICAgICB2YXIgaW52YWxpZFN0cmluZ0NoYXJhY3RlcnMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDB4MDA7IGkgPD0gMHgxRjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSk7XG4gICAgICAgICAgICBpbnZhbGlkU3RyaW5nQ2hhcmFjdGVyc1tzXSA9IHM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1rRXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgbW9uaXRvci5UaHJvdyhtb25pdG9yLm1vZHVsZXMuZXJyb3IuU3ludGF4RXJyb3JPYmplY3QsICdKU09OLnBhcnNlOiAnICsgbWVzc2FnZSwgYm90KTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG5leHRDaGFyID0gZnVuY3Rpb24gKGNoYXIpIHtcbiAgICAgICAgICAgIGlmIChjaGFyICYmIGNoYXIgIT09IGN1cnJlbnRDaGFyKSB7XG4gICAgICAgICAgICAgICAgbWtFcnJvcignZXhwZWN0ZWQgJyArIGNoYXIgKyAnIHRvIG1hdGNoICcgKyBjdXJyZW50Q2hhcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Q2hhciA9IHRleHQuY2hhckF0KGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICBjdXJyZW50SW5kZXgrKztcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50Q2hhcjtcbiAgICAgICAgfTtcbiAgICAgICAgLy9KU09OV2hpdGVTcGFjZSA6OiA8VEFCPiA8Q1I+IDxMRj4gPFNQPlxuICAgICAgICB2YXIgZWF0V2hpdGVTcGFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50Q2hhciAmJiBjdXJyZW50Q2hhciA8PSAnICcpIHtcbiAgICAgICAgICAgICAgICBuZXh0Q2hhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKiBKU09OVmFsdWUgOlxuICAgICAgICAgICAgIEpTT05OdWxsTGl0ZXJhbFxuICAgICAgICAgICAgIEpTT05Cb29sZWFuTGl0ZXJhbFxuICAgICAgICAgICAgIEpTT05PYmplY3RcbiAgICAgICAgICAgICBKU09OQXJyYXlcbiAgICAgICAgICAgICBKU09OU3RyaW5nXG4gICAgICAgICAgICAgSlNPTk51bWJlclxuICAgICAgICAqL1xuICAgICAgICB2YXIganNvblZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZWF0V2hpdGVTcGFjZSgpO1xuICAgICAgICAgICAgc3dpdGNoIChjdXJyZW50Q2hhcikge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3snOlxuICAgICAgICAgICAgICAgICAgICAvLyBJdCBtdXN0IGJlIGFuIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ganNvbk9iamVjdCgpO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1snOlxuICAgICAgICAgICAgICAgICAgICAvLyBJdCBtdXN0IGJlIGFuIGFycmF5XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBqc29uQXJyYXkoKTtcbiAgICAgICAgICAgICAgICBjYXNlICdcIic6XG4gICAgICAgICAgICAgICAgICAgIC8vIEl0IG11c3QgYmUgYSBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGpzb25TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgICAgICAgICAgLy8gSXQgbXVzdCBiZSBhIG51bWJlclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ganNvbk51bWJlcigpO1xuICAgICAgICAgICAgICAgIGNhc2UgJ24nOlxuICAgICAgICAgICAgICAgICAgICAvLyBJdCBtdXN0IGJlIGEgbnVsbCBsaXRlcmFsXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBqc29uTnVsbCgpO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICAgICAgICAgICAgICAvLyBJdCBtdXN0IGJlIGEgYm9vbGVhbiBsaXRlcmFsXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBqc29uQm9vbCgpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Q2hhciA+PSAnMCcgJiYgY3VycmVudENoYXIgPD0gJzknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJdCBtdXN0IGJlIGEgbnVtYmVyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ganNvbk51bWJlcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgc29tZXRoaW5nIGhhcyBnb25lIHdyb25nIVxuICAgICAgICAgICAgICAgICAgICBta0Vycm9yKCdDYW5ub3QgcGFyc2UgdGhlIHN0cnVjdHVyZSEnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGpzb25PYmplY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IG9iamVjdC5PYmplY3RPYmplY3QoKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50Q2hhciA9PT0gJ3snKSB7XG4gICAgICAgICAgICAgICAgbmV4dENoYXIoJ3snKTtcbiAgICAgICAgICAgICAgICBlYXRXaGl0ZVNwYWNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGFyID09PSAnfScpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRW50ZXIgaGVyZSBhbmQgd2UgaGF2ZSBhbiBcImVtcHR5XCIgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIG5leHRDaGFyKCd9Jyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJyZW50Q2hhcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0ganNvblN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBlYXRXaGl0ZVNwYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIG5leHRDaGFyKCc6Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWtFcnJvcignQmFkIG9iamVjdCwgZHVwbGljYXRlIGtleSAnICsga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuRGVmaW5lT3duUHJvcGVydHkobmV3IHZhbHVlc18xLlZhbHVlKGtleSwgYm90KSwgeyB2YWx1ZToganNvblZhbHVlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogYm90XG4gICAgICAgICAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgZWF0V2hpdGVTcGFjZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudENoYXIgPT09ICd9Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dENoYXIoJ30nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbmV4dENoYXIoJywnKTtcbiAgICAgICAgICAgICAgICAgICAgZWF0V2hpdGVTcGFjZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1rRXJyb3IoJ01hbGZvcm1lZCBvYmplY3QnKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGpzb25BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50Q2hhciA9PT0gJ1snKSB7XG4gICAgICAgICAgICAgICAgbmV4dENoYXIoJ1snKTtcbiAgICAgICAgICAgICAgICBlYXRXaGl0ZVNwYWNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGFyID09PSAnXScpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRW50ZXIgaGVyZSBhbmQgd2UgaGF2ZSBhbiBlbXB0eSBhcnJheS4uXG4gICAgICAgICAgICAgICAgICAgIG5leHRDaGFyKCddJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBBcnJheU9iamVjdF8xLkFycmF5T2JqZWN0LmZyb21WYWx1ZUFycmF5KHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJyZW50Q2hhcikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChqc29uVmFsdWUoKSk7XG4gICAgICAgICAgICAgICAgICAgIGVhdFdoaXRlU3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGFyID09PSAnXScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVudGVyIGhlcmUgYW5kIHdlIGFyZSBkb25lLi5cbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRDaGFyKCddJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IG5ldyB2YWx1ZXNfMS5WYWx1ZShyZXN1bHRbaV0sIGJvdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXlPYmplY3RfMS5BcnJheU9iamVjdC5mcm9tVmFsdWVBcnJheShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5leHRDaGFyKCcsJyk7IC8vIElmIHdlIGFyZSBub3QgZG9uZSwgd2UgZXhwZWN0IGEgJywnXG4gICAgICAgICAgICAgICAgICAgIGVhdFdoaXRlU3BhY2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBta0Vycm9yKCdDb3VsZCBub3QgcGFyc2UgdGhlIGFycmF5Jyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qXG4gICAgICAgICAgSlNPTlN0cmluZyA6OiBcIiBKU09OU3RyaW5nQ2hhcmFjdGVyc19vcHQgXCJcbiAgICAgICAgICBKU09OU3RyaW5nQ2hhcmFjdGVycyA6OiBKU09OU3RyaW5nQ2hhcmFjdGVyIEpTT05TdHJpbmdDaGFyYWN0ZXJzX29wdFxuICAgICAgICAgIEpTT05TdHJpbmdDaGFyYWN0ZXIgOjogU291cmNlQ2hhcmFjdGVyIGJ1dCBub3Qgb25lIG9mIFwiIG9yIFxcIG9yIFUrMDAwMCB0aHJvdWdoIFUrMDAxRiBcXCBKU09ORXNjYXBlU2VxdWVuY2VcbiAgICAgICAgICBKU09ORXNjYXBlU2VxdWVuY2UgOjogSlNPTkVzY2FwZUNoYXJhY3RlciBVbmljb2RlRXNjYXBlU2VxdWVuY2VcbiAgICAgICAgICovXG4gICAgICAgIHZhciBqc29uU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFwiXCI7XG4gICAgICAgICAgICBpZiAoY3VycmVudENoYXIgPT09ICdcIicpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAobmV4dENoYXIoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudENoYXIgPT09ICdcIicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRDaGFyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBjdXJyZW50IGNoYXJhY3RlciBpcyBhbiBpbnZhbGlkIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW52YWxpZFN0cmluZ0NoYXJhY3RlcnNbY3VycmVudENoYXJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBta0Vycm9yKFwiSW52YWxpZCBjaGFyYWN0ZXIgaW4gc3RyaW5nXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Q2hhciA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Q2hhcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGFyID09PSAndScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGV4VmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoZXggPSBwYXJzZUludChuZXh0Q2hhcigpLCAxNik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNGaW5pdGUoaGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGV4VmFsdWUgPSBoZXhWYWx1ZSAqIDE2ICsgaGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShoZXhWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZXNjYXBlQ2hhcmFjdGVyc1tjdXJyZW50Q2hhcl0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGVzY2FwZUNoYXJhY3RlcnNbY3VycmVudENoYXJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gY3VycmVudENoYXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBta0Vycm9yKCdCYWQgaW5wdXQgc3RyaW5nJyk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIEpTT05OdW1iZXIgOjogLV9vcHQgRGVjaW1hbEludGVnZXJMaXRlcmFsIEpTT05GcmFjdGlvbl9vcHQgRXhwb25lbnRQYXJ0X29wdFxuICAgICAgICB2YXIganNvbk51bWJlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBcIlwiLCBjaGVja09jdGFsID0gZmFsc2UsIGNoZWNrRmxvYXQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50Q2hhciA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGN1cnJlbnRDaGFyO1xuICAgICAgICAgICAgICAgIG5leHRDaGFyKCctJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudENoYXIgPT09ICcwJykge1xuICAgICAgICAgICAgICAgIGNoZWNrT2N0YWwgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2V0IGFsbCB0aGUgbnVtYmVyc1xuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnRDaGFyID49ICcwJyAmJiBjdXJyZW50Q2hhciA8PSAnOScpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gY3VycmVudENoYXI7XG4gICAgICAgICAgICAgICAgbmV4dENoYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGVja09jdGFsICYmIHJlc3VsdC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgbWtFcnJvcihcIkpTT04ucGFyc2U6IE51bWJlcnMgY2Fubm90IHN0YXJ0IHdpdGggYSAwXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXQgaXMgYSBmbG9hdFxuICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGFyID09PSAnLicpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gY3VycmVudENoYXI7XG4gICAgICAgICAgICAgICAgY2hlY2tGbG9hdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gR2V0IGFsbCB0aGUgcmVtYWluaW5nIG51bWJlcnMgaW4gdGhlIGZsb2F0XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5leHRDaGFyKCkgJiYgY3VycmVudENoYXIgPj0gJzAnICYmIGN1cnJlbnRDaGFyIDw9ICc5Jykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gY3VycmVudENoYXI7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrRmxvYXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hlY2tGbG9hdCkge1xuICAgICAgICAgICAgICAgIG1rRXJyb3IoXCJKU09OLnBhcnNlOiBOdW1iZXIgd2l0aCBub3RoaW5nIGFmdGVyIHRoZSBkZWNpbWFsXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGFyID09PSAnZScgfHwgY3VycmVudENoYXIgPT09ICdFJykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBjdXJyZW50Q2hhcjtcbiAgICAgICAgICAgICAgICBuZXh0Q2hhcigpO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Q2hhciA9PT0gJy0nIHx8IGN1cnJlbnRDaGFyID09PSAnKycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGN1cnJlbnRDaGFyO1xuICAgICAgICAgICAgICAgICAgICBuZXh0Q2hhcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoY3VycmVudENoYXIgPj0gJzAnICYmIGN1cnJlbnRDaGFyIDw9ICc5Jykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gY3VycmVudENoYXI7XG4gICAgICAgICAgICAgICAgICAgIG5leHRDaGFyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG51bSA9ICtyZXN1bHQ7IC8vIE5hc3R5IGNvbnZlcnNpb24uIDopXG4gICAgICAgICAgICBpZiAoIWlzRmluaXRlKG51bSkpIHtcbiAgICAgICAgICAgICAgICBta0Vycm9yKCdCYWQgbnVtYmVyLCBub3QgZmluaXRlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVtO1xuICAgICAgICB9O1xuICAgICAgICAvLyBKU09OTnVsbExpdGVyYWwgOjogTnVsbExpdGVyYWxcbiAgICAgICAgdmFyIGpzb25OdWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbmV4dENoYXIoJ24nKTtcbiAgICAgICAgICAgIG5leHRDaGFyKCd1Jyk7XG4gICAgICAgICAgICBuZXh0Q2hhcignbCcpO1xuICAgICAgICAgICAgbmV4dENoYXIoJ2wnKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICAvLyBKU09OQm9vbGVhbkxpdGVyYWwgOjogQm9vbGVhbkxpdGVyYWxcbiAgICAgICAgdmFyIGpzb25Cb29sID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3dpdGNoIChjdXJyZW50Q2hhcikge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgICAgICAgICBuZXh0Q2hhcigndCcpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0Q2hhcigncicpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0Q2hhcigndScpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0Q2hhcignZScpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgICAgICAgICAgbmV4dENoYXIoJ2YnKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dENoYXIoJ2EnKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dENoYXIoJ2wnKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dENoYXIoJ3MnKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dENoYXIoJ2UnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIG1rRXJyb3IoJ0NvdWxkIG5vdCBkZWR1Y2UgYSBib29sZWFuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0ZXh0LnZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgdGV4dExhYmVsID0gdGV4dC5sYWJlbDtcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnZhbHVlO1xuICAgICAgICAgICAgdmFyIHJlcyA9IG5ldyB2YWx1ZXNfMS5WYWx1ZShqc29uVmFsdWUoKSwgdGV4dExhYmVsKTtcbiAgICAgICAgICAgIGVhdFdoaXRlU3BhY2UoKTsgLy8gRWF0IGFsbCB0cmFpbGluZyB3aGl0ZSBzcGFjZXNcbiAgICAgICAgICAgIHJlcy5maW5hbEluZGV4ID0gY3VycmVudEluZGV4OyAvLyBUaGlzIGlzIG5lZWRlZCB0byBrbm93IGlmIHdlIGhhdmUgc29tZSBnYXJiYWdlIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZ1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1rRXJyb3IoJ0JhZCBmb3JtYXQgb24gaW5wdXQnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gc3RyaW5naWZ5LCAxNS4xMi4zXG4gICAgdmFyIHN0cmluZ2lmeSA9IGZ1bmN0aW9uICh0aGlzQXJnLCBhcmdzKSB7XG4gICAgICAgIC8vIFRoZXNlIGFyZSB1c2VkIGZvciBjeWNsZSBkZXRlY3Rpb25cbiAgICAgICAgdmFyIEpBX2NvdW50ZXIgPSAwO1xuICAgICAgICB2YXIgSk9fY291bnRlciA9IDA7XG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICAgICAgdmFyIGluZGVudCA9IFwiXCI7XG4gICAgICAgIHZhciBQcm9wZXJ0eUxpc3QsIFJlcGxhY2VyRnVuY3Rpb247XG4gICAgICAgIHZhciBnYXAgPSBcIlwiO1xuICAgICAgICB2YXIgdmFsdWUgPSBhcmdzWzBdIHx8IG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG4gICAgICAgIHZhciByZXBsYWNlciA9IGFyZ3NbMV0gfHwgbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgYm90KTtcbiAgICAgICAgdmFyIHNwYWNlID0gYXJnc1syXSB8fCBuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgICAgICB2YXIgcmV0TGFiZWwgPSBsdWIodmFsdWUubGFiZWwsIGx1YihyZXBsYWNlci5sYWJlbCwgc3BhY2UubGFiZWwpKTtcbiAgICAgICAgbW9uaXRvci5jb250ZXh0LnB1c2hQQyhyZXBsYWNlci5sYWJlbCk7XG4gICAgICAgIGlmICh0eXBlb2YgcmVwbGFjZXIudmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiByZXBsYWNlci52YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaWYgKElzQ2FsbGFibGVfMS5Jc0NhbGxhYmxlKHJlcGxhY2VyKS52YWx1ZSkge1xuICAgICAgICAgICAgICAgIFJlcGxhY2VyRnVuY3Rpb24gPSByZXBsYWNlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlcGxhY2VyLnZhbHVlICYmIHJlcGxhY2VyLnZhbHVlLkNsYXNzID09PSAnQXJyYXknKSB7XG4gICAgICAgICAgICAgICAgUHJvcGVydHlMaXN0ID0gW107XG4gICAgICAgICAgICAgICAgdmFyIGluaXRpYWxSZXBsYWNlckxlbmd0aCA9IHJlcGxhY2VyLnZhbHVlLnByb3BlcnRpZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5pdGlhbFJlcGxhY2VyTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2ID0gcmVwbGFjZXIuR2V0KG5ldyB2YWx1ZXNfMS5WYWx1ZShpLCBib3QpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHYudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2LnZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gPSB2O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHYudmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSA9IFRvU3RyaW5nXzEuVG9TdHJpbmcodik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygdi52YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodi52YWx1ZSAmJiAodi52YWx1ZS5DbGFzcyA9PT0gJ1N0cmluZycgfHwgdi52YWx1ZS5DbGFzcyA9PT0gJ051bWJlcicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gPSBUb1N0cmluZ18xLlRvU3RyaW5nKHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbU5vdEluQXJyYXkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgUHJvcGVydHlMaXN0Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnZhbHVlID09PSBQcm9wZXJ0eUxpc3Rbal0udmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1Ob3RJbkFycmF5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbU5vdEluQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUHJvcGVydHlMaXN0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1vbml0b3IuY29udGV4dC5wb3BQQygpO1xuICAgICAgICBtb25pdG9yLmNvbnRleHQucHVzaFBDKHNwYWNlLmxhYmVsKTtcbiAgICAgICAgaWYgKHR5cGVvZiBzcGFjZS52YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlmIChzcGFjZS52YWx1ZS5DbGFzcyA9PT0gJ051bWJlcicpIHtcbiAgICAgICAgICAgICAgICBzcGFjZSA9IFRvTnVtYmVyXzEuVG9OdW1iZXIoc3BhY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3BhY2UudmFsdWUuQ2xhc3MgPT09ICdTdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgc3BhY2UgPSBUb1N0cmluZ18xLlRvU3RyaW5nKHNwYWNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNwYWNlLnZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdmFyIGludFNwYWNlID0gVG9JbnRlZ2VyXzEuVG9JbnRlZ2VyKHNwYWNlKTtcbiAgICAgICAgICAgIGlmIChpbnRTcGFjZS52YWx1ZSA+IDEwKSB7XG4gICAgICAgICAgICAgICAgc3BhY2UgPSBuZXcgdmFsdWVzXzEuVmFsdWUoMTAsIHNwYWNlLmxhYmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNwYWNlID0gaW50U3BhY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYWNlLnZhbHVlOyBpKyspIHtcbiAgICAgICAgICAgICAgICBnYXAgPSBnYXAgKyBcIiBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc3BhY2UudmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAoc3BhY2UudmFsdWUubGVuZ3RoIDw9IDEwKSB7XG4gICAgICAgICAgICAgICAgZ2FwID0gc3BhY2UudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnYXAgPSBzcGFjZS52YWx1ZS5zdWJzdHJpbmcoMCwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIExlYXZlIHRoZSBsYXN0IGVsc2UsIGdhcCB3aWxsIGJlIGVtcHR5IHN0cmluZyBpZiBub25lIG9mIHRoZSBhYm92ZSBoYXMgYmVlbiBoaXRcbiAgICAgICAgbW9uaXRvci5jb250ZXh0LnBvcFBDKCk7IC8vIFBvcCBzcGFjZS5sYWJlbCBmcm9tIHRoZSBQQyBzdGFja1xuICAgICAgICB2YXIgd3JhcHBlciA9IG5ldyBPYmplY3RPYmplY3RfMS5PYmplY3RPYmplY3QoKTtcbiAgICAgICAgd3JhcHBlci5EZWZpbmVPd25Qcm9wZXJ0eShuZXcgdmFsdWVzXzEuVmFsdWUoXCJcIiwgYm90KSwgeyB2YWx1ZTogdmFsdWUudmFsdWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBsYWJlbDogdmFsdWUubGFiZWxcbiAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICB2YXIgU3RyID0gZnVuY3Rpb24gKGtleSwgaG9sZGVyKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBob2xkZXIuR2V0KGtleSk7XG4gICAgICAgICAgICByZXRMYWJlbCA9IGx1YihyZXRMYWJlbCwgdmFsdWUubGFiZWwpO1xuICAgICAgICAgICAgbW9uaXRvci5jb250ZXh0LnB1c2hQQyh2YWx1ZS5sYWJlbCk7XG4gICAgICAgICAgICBpZiAodmFsdWUudmFsdWUgJiYgdHlwZW9mIHZhbHVlLnZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHZhciB0b0pTT04gPSB2YWx1ZS5HZXQobmV3IHZhbHVlc18xLlZhbHVlKFwidG9KU09OXCIsIGJvdCkpO1xuICAgICAgICAgICAgICAgIGlmIChJc0NhbGxhYmxlXzEuSXNDYWxsYWJsZSh0b0pTT04pLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdG9KU09OLkNhbGwodmFsdWUsIFtrZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtb25pdG9yLmNvbnRleHQucG9wUEMoKTsgLy8gQXMgaXQgaXMgYmVpbmcgcHVzaGVkIGFnYWluIGxhdGVyLCBpcyB0aGlzIG5lZWRlZD9cbiAgICAgICAgICAgIGlmIChSZXBsYWNlckZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgbW9uaXRvci5jb250ZXh0LnB1c2hQQyhSZXBsYWNlckZ1bmN0aW9uLmxhYmVsKTtcbiAgICAgICAgICAgICAgICBpZiAoUmVwbGFjZXJGdW5jdGlvbi52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFJlcGxhY2VyRnVuY3Rpb24uQ2FsbChob2xkZXIsIFtrZXksIHZhbHVlXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1vbml0b3IuY29udGV4dC5wb3BQQygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbW9uaXRvci5jb250ZXh0LnB1c2hQQyh2YWx1ZS5sYWJlbCk7XG4gICAgICAgICAgICBpZiAodmFsdWUudmFsdWUgJiYgdHlwZW9mIHZhbHVlLnZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS52YWx1ZS5DbGFzcyA9PT0gJ051bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBUb051bWJlcl8xLlRvTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUudmFsdWUuQ2xhc3MgPT09ICdTdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gVG9TdHJpbmdfMS5Ub1N0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLnZhbHVlLkNsYXNzID09PSAnQm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgdmFsdWVzXzEuVmFsdWUodmFsdWUudmFsdWUuUHJpbWl0aXZlVmFsdWUudmFsdWVPZigpLCByZXRMYWJlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlLnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbW9uaXRvci5jb250ZXh0LnBvcFBDKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZShcIm51bGxcIiwgcmV0TGFiZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlLnZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgbW9uaXRvci5jb250ZXh0LnBvcFBDKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZShcInRydWVcIiwgcmV0TGFiZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlLnZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIG1vbml0b3IuY29udGV4dC5wb3BQQygpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUoXCJmYWxzZVwiLCByZXRMYWJlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlLnZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSBRdW90ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgbW9uaXRvci5jb250ZXh0LnBvcFBDKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUudmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzRmluaXRlKHZhbHVlLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzID0gVG9TdHJpbmdfMS5Ub1N0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIG1vbml0b3IuY29udGV4dC5wb3BQQygpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtb25pdG9yLmNvbnRleHQucG9wUEMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHZhbHVlc18xLlZhbHVlKFwibnVsbFwiLCByZXRMYWJlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlLnZhbHVlID09PSAnb2JqZWN0JyAmJiAhSXNDYWxsYWJsZV8xLklzQ2FsbGFibGUodmFsdWUpLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLnZhbHVlLkNsYXNzID09PSAnQXJyYXknKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXMgPSBKQSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIG1vbml0b3IuY29udGV4dC5wb3BQQygpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gSk8odmFsdWUpO1xuICAgICAgICAgICAgICAgIG1vbml0b3IuY29udGV4dC5wb3BQQygpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtb25pdG9yLmNvbnRleHQucG9wUEMoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCByZXRMYWJlbCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBRdW90ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHByb2R1Y3QgPSBcIlxcXCJcIjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUudmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgQyA9IHZhbHVlLnZhbHVlW2ldO1xuICAgICAgICAgICAgICAgIHZhciBjQ29kZVBvaW50VmFsdWUgPSBDLmNvZGVQb2ludEF0KDApO1xuICAgICAgICAgICAgICAgIHZhciBzcGFjZUNvZGVQb2ludFZhbHVlID0gKFwiIFwiKS5jb2RlUG9pbnRBdCgwKTtcbiAgICAgICAgICAgICAgICBpZiAoQyA9PT0gXCJcXFwiXCIgfHwgQyA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvZHVjdCArPSBcIlxcXFxcIjtcbiAgICAgICAgICAgICAgICAgICAgcHJvZHVjdCArPSBDO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChDID09PSBcIlxcYlwiIHx8IEMgPT09IFwiXFxmXCIgfHwgQyA9PT0gXCJcXG5cIiB8fCBDID09PSBcIlxcclwiIHx8IEMgPT09IFwiXFx0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvZHVjdCArPSBcIlxcXFxcIjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFiYnJldjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEMgPT09IFwiXFxiXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBhYmJyZXYgPSBcImJcIjtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoQyA9PT0gXCJcXGZcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIGFiYnJldiA9IFwiZlwiO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChDID09PSBcIlxcblwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgYWJicmV2ID0gXCJuXCI7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKEMgPT09IFwiXFxyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBhYmJyZXYgPSBcInJcIjtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgYWJicmV2ID0gXCJ0XCI7XG4gICAgICAgICAgICAgICAgICAgIHByb2R1Y3QgKz0gYWJicmV2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjQ29kZVBvaW50VmFsdWUgPCBzcGFjZUNvZGVQb2ludFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2R1Y3QgKz0gXCJcXFxcXCI7XG4gICAgICAgICAgICAgICAgICAgIHByb2R1Y3QgKz0gXCJ1XCI7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoZXggPSBjQ29kZVBvaW50VmFsdWUudG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gaGV4Lmxlbmd0aDsgaiA8IDQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGV4ID0gXCIwXCIgKyBoZXg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJvZHVjdCArPSBoZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcm9kdWN0ICs9IEM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvZHVjdCArPSBcIlxcXCJcIjtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUocHJvZHVjdCwgbHViKG1vbml0b3IuY29udGV4dC5lZmZlY3RpdmVQQywgdmFsdWUubGFiZWwpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIEpPID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgSk9fa2V5ID0gbmV3IHZhbHVlc18xLlZhbHVlKFwiSk9fcHJvcGVydHlcIiwgYm90KTtcbiAgICAgICAgICAgIGlmICghdmFsdWUuR2V0KEpPX2tleSkudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBKT19jb3VudGVyKys7XG4gICAgICAgICAgICAgICAgdmFsdWUuRGVmaW5lT3duUHJvcGVydHkoSk9fa2V5LCB7IHZhbHVlOiBuZXcgdmFsdWVzXzEuVmFsdWUoSk9fY291bnRlciwgYm90KSxcbiAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGJvdFxuICAgICAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoZWNrQ3ljbGUoSk9fa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFjay5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIHZhciBzdGVwYmFjayA9IGluZGVudDtcbiAgICAgICAgICAgIGluZGVudCA9IGluZGVudCArIGdhcDtcbiAgICAgICAgICAgIGlmIChQcm9wZXJ0eUxpc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciBLID0gUHJvcGVydHlMaXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIEsgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgYWxsS2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlLnZhbHVlLnByb3BlcnRpZXMpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5VmFsID0gdmFsdWUuR2V0UHJvcGVydHkobmV3IHZhbHVlc18xLlZhbHVlKGFsbEtleXNbaV0sIGJvdCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5VmFsLnZhbHVlICYmIGtleVZhbC52YWx1ZS5lbnVtZXJhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBLLnB1c2gobmV3IHZhbHVlc18xLlZhbHVlKGFsbEtleXNbaV0sIHJldExhYmVsKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcGFydGlhbCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBLLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIFAgPSBLW2ldO1xuICAgICAgICAgICAgICAgIHZhciBzdHJQID0gU3RyKFAsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RyUCAmJiBzdHJQLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1lbWJlciA9IFF1b3RlKFApO1xuICAgICAgICAgICAgICAgICAgICBtZW1iZXIudmFsdWUgKz0gXCI6XCI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnYXAgIT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lbWJlci52YWx1ZSArPSAnICc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVtYmVyLnZhbHVlICs9IHN0clAudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRpYWwucHVzaChtZW1iZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBmaW5hbDtcbiAgICAgICAgICAgIGlmIChwYXJ0aWFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGZpbmFsID0gXCJ7fVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGlmIChnYXAgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0aWFsLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllcyArPSBwYXJ0aWFsW2ldLnZhbHVlICsgJywnO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0TGFiZWwgPSBsdWIocmV0TGFiZWwsIHBhcnRpYWxbaV0ubGFiZWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXMgKz0gcGFydGlhbFtwYXJ0aWFsLmxlbmd0aCAtIDFdLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICByZXRMYWJlbCA9IGx1YihyZXRMYWJlbCwgcGFydGlhbFtwYXJ0aWFsLmxlbmd0aCAtIDFdLmxhYmVsKTtcbiAgICAgICAgICAgICAgICAgICAgZmluYWwgPSAneycgKyBwcm9wZXJ0aWVzICsgJ30nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlcGFyYXRvciA9IFwiLFxcblwiICsgaW5kZW50O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRpYWwubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzICs9IHBhcnRpYWxbaV0udmFsdWUgKyBzZXBhcmF0b3I7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXRMYWJlbCA9IGx1YihyZXRMYWJlbCwgcGFydGlhbFtpXS5sYWJlbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllcyArPSBwYXJ0aWFsW3BhcnRpYWwubGVuZ3RoIC0gMV0udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHJldExhYmVsID0gbHViKHJldExhYmVsLCBwYXJ0aWFsW3BhcnRpYWwubGVuZ3RoIC0gMV0ubGFiZWwpO1xuICAgICAgICAgICAgICAgICAgICBmaW5hbCA9ICd7XFxuJyArIGluZGVudCArIHByb3BlcnRpZXMgKyAnXFxuJyArIHN0ZXBiYWNrICsgJ30nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBvcCBhbmQgcmVtb3ZlIEpPX3Byb3BlcnR5XG4gICAgICAgICAgICB2YXIgdiA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgdi5EZWxldGUoSk9fa2V5KTtcbiAgICAgICAgICAgIGluZGVudCA9IHN0ZXBiYWNrO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZShmaW5hbCwgcmV0TGFiZWwpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgSkEgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBKQV9rZXkgPSBuZXcgdmFsdWVzXzEuVmFsdWUoXCJKQV9wcm9wZXJ0eVwiLCBib3QpO1xuICAgICAgICAgICAgaWYgKCF2YWx1ZS5HZXQoSkFfa2V5KS52YWx1ZSkge1xuICAgICAgICAgICAgICAgIEpBX2NvdW50ZXIrKztcbiAgICAgICAgICAgICAgICB2YWx1ZS5EZWZpbmVPd25Qcm9wZXJ0eShKQV9rZXksIHsgdmFsdWU6IG5ldyB2YWx1ZXNfMS5WYWx1ZShKQV9jb3VudGVyLCBib3QpLFxuICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogYm90XG4gICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hlY2tDeWNsZShKQV9rZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YWNrLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgdmFyIHN0ZXBiYWNrID0gaW5kZW50O1xuICAgICAgICAgICAgaW5kZW50ID0gaW5kZW50ICsgZ2FwO1xuICAgICAgICAgICAgdmFyIHBhcnRpYWwgPSBbXTtcbiAgICAgICAgICAgIHZhciBsZW4gPSB2YWx1ZS5HZXQobmV3IHZhbHVlc18xLlZhbHVlKCdsZW5ndGgnLCBib3QpKTtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IG5ldyB2YWx1ZXNfMS5WYWx1ZSgwLCBib3QpO1xuICAgICAgICAgICAgd2hpbGUgKGluZGV4LnZhbHVlIDwgbGVuLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0clAgPSBTdHIoVG9TdHJpbmdfMS5Ub1N0cmluZyhpbmRleCksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoIXN0clAgfHwgc3RyUC52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRpYWwucHVzaChuZXcgdmFsdWVzXzEuVmFsdWUoXCJudWxsXCIsIHJldExhYmVsKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsLnB1c2goc3RyUCk7XG4gICAgICAgICAgICAgICAgICAgIHJldExhYmVsID0gbHViKHJldExhYmVsLCBzdHJQLmxhYmVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5kZXgudmFsdWUrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBmaW5hbDtcbiAgICAgICAgICAgIGlmIChwYXJ0aWFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGZpbmFsID0gXCJbXVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGlmIChnYXAgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0aWFsLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllcyArPSBwYXJ0aWFsW2ldLnZhbHVlICsgJywnO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0TGFiZWwgPSBsdWIocmV0TGFiZWwsIHBhcnRpYWxbaV0ubGFiZWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXMgKz0gcGFydGlhbFtwYXJ0aWFsLmxlbmd0aCAtIDFdLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICByZXRMYWJlbCA9IGx1YihyZXRMYWJlbCwgcGFydGlhbFtwYXJ0aWFsLmxlbmd0aCAtIDFdLmxhYmVsKTtcbiAgICAgICAgICAgICAgICAgICAgZmluYWwgPSAnWycgKyBwcm9wZXJ0aWVzICsgJ10nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlcGFyYXRvciA9IFwiLFxcblwiICsgaW5kZW50O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRpYWwubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzICs9IHBhcnRpYWxbaV0udmFsdWUgKyBzZXBhcmF0b3I7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXRMYWJlbCA9IGx1YihyZXRMYWJlbCwgcGFydGlhbFtpXS5sYWJlbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllcyArPSBwYXJ0aWFsW3BhcnRpYWwubGVuZ3RoIC0gMV0udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHJldExhYmVsID0gbHViKHJldExhYmVsLCBwYXJ0aWFsW3BhcnRpYWwubGVuZ3RoIC0gMV0ubGFiZWwpO1xuICAgICAgICAgICAgICAgICAgICBmaW5hbCA9ICdbXFxuJyArIGluZGVudCArIHByb3BlcnRpZXMgKyAnXFxuJyArIHN0ZXBiYWNrICsgJ10nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBvcCBhbmQgcmVtb3ZlIHByb3BlcnR5IG9mIEpBX2tleVxuICAgICAgICAgICAgdmFyIHYgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHYuRGVsZXRlKEpBX2tleSk7XG4gICAgICAgICAgICBpbmRlbnQgPSBzdGVwYmFjaztcbiAgICAgICAgICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUoZmluYWwsIHJldExhYmVsKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNoZWNrQ3ljbGUgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5HZXQoa2V5KS52YWx1ZSA9PT0gc3RhY2tbaV0uR2V0KGtleSkudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9uaXRvci5UaHJvdyhtb25pdG9yLm1vZHVsZXMuZXJyb3IuVHlwZUVycm9yT2JqZWN0LCAnSlNPTi5zdHJpbmdpZnk6IEN5Y2xpYyBzdHJ1Y3R1cmUnLCBib3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFN0cihuZXcgdmFsdWVzXzEuVmFsdWUoXCJcIiwgYm90KSwgd3JhcHBlcik7XG4gICAgfTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICB2YXIgbW9kdWxlID0ge307XG4gICAgbW9kdWxlLmFsbG9jYXRlID0gYWxsb2NhdGU7XG4gICAgcmV0dXJuIG1vZHVsZTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1qc29uLmpzLm1hcCIsIi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uICovXG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbiAobykge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gXG52YXIgVG9wO1xuKGZ1bmN0aW9uIChUb3ApIHtcbiAgICBUb3BbVG9wW1wiVG9wXCJdID0gMF0gPSBcIlRvcFwiO1xufSkoVG9wIHx8IChUb3AgPSB7fSkpO1xuO1xudmFyIExhYmVsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExhYmVsKHApIHtcbiAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgIHZhciByZXN0ID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICByZXN0W19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwID09PSBUb3AuVG9wKSB7XG4gICAgICAgICAgICB0aGlzLnByaW5jaXBhbHMgPSBUb3AuVG9wO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJpbmNpcGFscyA9IG5ldyBTZXQocmVzdCk7XG4gICAgICAgIGlmICh0eXBlb2YgcCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhpcy5wcmluY2lwYWxzLmFkZChwKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHAgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHBfMSA9IF9fdmFsdWVzKHApLCBwXzFfMSA9IHBfMS5uZXh0KCk7ICFwXzFfMS5kb25lOyBwXzFfMSA9IHBfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBwXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmluY2lwYWxzLmFkZCh4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBfMV8xICYmICFwXzFfMS5kb25lICYmIChfYSA9IHBfMS5yZXR1cm4pKSBfYS5jYWxsKHBfMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBcbiAgICBMYWJlbC5mcm9tU3RyaW5nID0gZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMYWJlbChsLnNwbGl0KCcsJykpO1xuICAgIH07XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gXG4gICAgTGFiZWwuZnJvbVVSTCA9IGZ1bmN0aW9uIChsKSB7XG4gICAgICAgIHZhciByZSA9IG5ldyBSZWdFeHAoJ2h0dHA6Ly9bXi9dKi8nKTtcbiAgICAgICAgdmFyIHJlcyA9IHJlLmV4ZWMobCk7XG4gICAgICAgIGlmIChyZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGFiZWwobC5zcGxpdCgnLCcpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGFiZWwoW3Jlc1swXV0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBcbiAgICBMYWJlbC5wcm90b3R5cGUubHViID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZV8yLCBfYSwgZV8zLCBfYiwgZV80LCBfYywgZV81LCBfZCwgZV82LCBfZTtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcmluY2lwYWxzID09PSBUb3AuVG9wKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgYXJnc18xID0gX192YWx1ZXMoYXJncyksIGFyZ3NfMV8xID0gYXJnc18xLm5leHQoKTsgIWFyZ3NfMV8xLmRvbmU7IGFyZ3NfMV8xID0gYXJnc18xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBsID0gYXJnc18xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGwucHJpbmNpcGFscyA9PT0gVG9wLlRvcCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByaW5jaXBhbHMgPSBUb3AuVG9wO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2YgPSBfX3ZhbHVlcyhsLnByaW5jaXBhbHMpLCBfZyA9IF9mLm5leHQoKTsgIV9nLmRvbmU7IF9nID0gX2YubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IF9nLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmluY2lwYWxzLmFkZChwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZV8zXzEpIHsgZV8zID0geyBlcnJvcjogZV8zXzEgfTsgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9nICYmICFfZy5kb25lICYmIChfYiA9IF9mLnJldHVybikpIF9iLmNhbGwoX2YpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8zKSB0aHJvdyBlXzMuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChhcmdzXzFfMSAmJiAhYXJnc18xXzEuZG9uZSAmJiAoX2EgPSBhcmdzXzEucmV0dXJuKSkgX2EuY2FsbChhcmdzXzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBiYWRfcHJpbmNpcGFscyA9IFsnZ2xvYmFsLm5hdmlnYXRvci5wbHVnaW5zJyxcbiAgICAgICAgICAgICdnbG9iYWwubmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzJyxcbiAgICAgICAgICAgICdnbG9iYWwuSW50bC5EYXRlVGltZUZvcm1hdCcsXG4gICAgICAgICAgICAnZ2xvYmFsLm5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5JyxcbiAgICAgICAgICAgICdnbG9iYWwubmF2aWdhdG9yLmRldmljZU1lbW9yeScsXG4gICAgICAgICAgICAnZ2xvYmFsLnNjcmVlbi5jb2xvckRlcHRoJyxcbiAgICAgICAgICAgICdnbG9iYWwubmF2aWdhdG9yLnVzZXJBZ2VudCcsXG4gICAgICAgICAgICAnZ2xvYmFsLm5hdmlnYXRvci5hcHBOYW1lJyxcbiAgICAgICAgICAgICdnbG9iYWwubmF2aWdhdG9yLmxhbmd1YWdlJyxcbiAgICAgICAgICAgICdnbG9iYWwubmF2aWdhdG9yLmxhbmd1YWdlcycsXG4gICAgICAgICAgICAnLnRvRGF0YVVSTCcsXG4gICAgICAgICAgICAnZ2V0Q29udGV4dC5nZXRFeHRlbnNpb24nLFxuICAgICAgICAgICAgJ2dsb2JhbC5zY3JlZW4uYXZhaWxXaWR0aCcsXG4gICAgICAgICAgICAnZ2xvYmFsLnNjcmVlbi5hdmFpbEhlaWdodCcsXG4gICAgICAgICAgICAnZ2xvYmFsLnNjcmVlbi53aWR0aCcsXG4gICAgICAgICAgICAnZ2xvYmFsLnNjcmVlbi5oZWlnaHQnXG4gICAgICAgIF07XG4gICAgICAgIHZhciBiYWRfY291bnQgPSAwO1xuICAgICAgICB2YXIgYmFkX2xpbWl0ID0gNztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9oID0gX192YWx1ZXModGhpcy5wcmluY2lwYWxzKSwgX2ogPSBfaC5uZXh0KCk7ICFfai5kb25lOyBfaiA9IF9oLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBwID0gX2oudmFsdWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYmFkX3ByaW5jaXBhbHNfMSA9IF9fdmFsdWVzKGJhZF9wcmluY2lwYWxzKSwgYmFkX3ByaW5jaXBhbHNfMV8xID0gYmFkX3ByaW5jaXBhbHNfMS5uZXh0KCk7ICFiYWRfcHJpbmNpcGFsc18xXzEuZG9uZTsgYmFkX3ByaW5jaXBhbHNfMV8xID0gYmFkX3ByaW5jaXBhbHNfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBicCA9IGJhZF9wcmluY2lwYWxzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwLmluY2x1ZGVzKGJwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhZF9jb3VudCArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlXzVfMSkgeyBlXzUgPSB7IGVycm9yOiBlXzVfMSB9OyB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmFkX3ByaW5jaXBhbHNfMV8xICYmICFiYWRfcHJpbmNpcGFsc18xXzEuZG9uZSAmJiAoX2QgPSBiYWRfcHJpbmNpcGFsc18xLnJldHVybikpIF9kLmNhbGwoYmFkX3ByaW5jaXBhbHNfMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzUpIHRocm93IGVfNS5lcnJvcjsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV80XzEpIHsgZV80ID0geyBlcnJvcjogZV80XzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF9qICYmICFfai5kb25lICYmIChfYyA9IF9oLnJldHVybikpIF9jLmNhbGwoX2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzQpIHRocm93IGVfNC5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChiYWRfY291bnQgPiBiYWRfbGltaXQpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSBcIlwiO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfayA9IF9fdmFsdWVzKHRoaXMucHJpbmNpcGFscyksIF9sID0gX2submV4dCgpOyAhX2wuZG9uZTsgX2wgPSBfay5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBfbC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgZXJyICs9IHAgKyBcIiwgXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfNl8xKSB7IGVfNiA9IHsgZXJyb3I6IGVfNl8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfbCAmJiAhX2wuZG9uZSAmJiAoX2UgPSBfay5yZXR1cm4pKSBfZS5jYWxsKF9rKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzYpIHRocm93IGVfNi5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgXCJCYWQgbGFiZWxzOiBcIiArIGVycjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFxuICAgIExhYmVsLnByb3RvdHlwZS5nbGIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlXzcsIF9hLCBlXzgsIF9iO1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBhcmdzXzIgPSBfX3ZhbHVlcyhhcmdzKSwgYXJnc18yXzEgPSBhcmdzXzIubmV4dCgpOyAhYXJnc18yXzEuZG9uZTsgYXJnc18yXzEgPSBhcmdzXzIubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGwgPSBhcmdzXzJfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAobC5wcmluY2lwYWxzID09PSBUb3AuVG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcmluY2lwYWxzID09PSBUb3AuVG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJpbmNpcGFscyA9IG5ldyBTZXQobC5wcmluY2lwYWxzKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9jID0gX192YWx1ZXMobC5wcmluY2lwYWxzKSwgX2QgPSBfYy5uZXh0KCk7ICFfZC5kb25lOyBfZCA9IF9jLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBfZC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJpbmNpcGFscy5hZGQocCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVfOF8xKSB7IGVfOCA9IHsgZXJyb3I6IGVfOF8xIH07IH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfZCAmJiAhX2QuZG9uZSAmJiAoX2IgPSBfYy5yZXR1cm4pKSBfYi5jYWxsKF9jKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfOCkgdGhyb3cgZV84LmVycm9yOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzdfMSkgeyBlXzcgPSB7IGVycm9yOiBlXzdfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoYXJnc18yXzEgJiYgIWFyZ3NfMl8xLmRvbmUgJiYgKF9hID0gYXJnc18yLnJldHVybikpIF9hLmNhbGwoYXJnc18yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV83KSB0aHJvdyBlXzcuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFxuICAgIExhYmVsLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAobCkge1xuICAgICAgICB2YXIgZV85LCBfYSwgZV8xMCwgX2I7XG4gICAgICAgIHZhciBBID0gdGhpcy5wcmluY2lwYWxzO1xuICAgICAgICB2YXIgQiA9IGwucHJpbmNpcGFscztcbiAgICAgICAgaWYgKEEgPT09IFRvcC5Ub3AgfHwgQiA9PT0gVG9wLlRvcCkge1xuICAgICAgICAgICAgcmV0dXJuIEEgPT09IEI7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIEFfMSA9IF9fdmFsdWVzKEEpLCBBXzFfMSA9IEFfMS5uZXh0KCk7ICFBXzFfMS5kb25lOyBBXzFfMSA9IEFfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IEFfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICghQi5oYXMocCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV85XzEpIHsgZV85ID0geyBlcnJvcjogZV85XzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKEFfMV8xICYmICFBXzFfMS5kb25lICYmIChfYSA9IEFfMS5yZXR1cm4pKSBfYS5jYWxsKEFfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfOSkgdGhyb3cgZV85LmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIEJfMSA9IF9fdmFsdWVzKEIpLCBCXzFfMSA9IEJfMS5uZXh0KCk7ICFCXzFfMS5kb25lOyBCXzFfMSA9IEJfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IEJfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICghQi5oYXMocCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8xMF8xKSB7IGVfMTAgPSB7IGVycm9yOiBlXzEwXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKEJfMV8xICYmICFCXzFfMS5kb25lICYmIChfYiA9IEJfMS5yZXR1cm4pKSBfYi5jYWxsKEJfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMTApIHRocm93IGVfMTAuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFxuICAgIExhYmVsLnByb3RvdHlwZS5sZSA9IGZ1bmN0aW9uIChsKSB7XG4gICAgICAgIHZhciBBID0gdGhpcy5wcmluY2lwYWxzO1xuICAgICAgICB2YXIgQiA9IGwucHJpbmNpcGFscztcbiAgICAgICAgaWYgKEEgPT09IFRvcC5Ub3ApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQiA9PT0gVG9wLlRvcCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgcCBpbiBBKSB7XG4gICAgICAgICAgICBpZiAoIUIuaGFzKHApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gXG4gICAgTGFiZWwucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RyID0gJ1QnO1xuICAgICAgICBpZiAodGhpcy5wcmluY2lwYWxzICE9PSBUb3AuVG9wKSB7XG4gICAgICAgICAgICBzdHIgPSBBcnJheS5mcm9tKHRoaXMucHJpbmNpcGFscykuam9pbignLCAnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCI8XCIgKyBzdHIgKyBcIj5cIjtcbiAgICB9O1xuICAgIExhYmVsLmJvdCA9IG5ldyBMYWJlbCgpO1xuICAgIExhYmVsLnRvcCA9IG5ldyBMYWJlbChUb3AuVG9wKTtcbiAgICByZXR1cm4gTGFiZWw7XG59KCkpO1xuZXhwb3J0cy5MYWJlbCA9IExhYmVsO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gXG5leHBvcnRzLnRvcCA9IG5ldyBMYWJlbChUb3AuVG9wKTtcbmV4cG9ydHMuYm90ID0gbmV3IExhYmVsKCk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBcbmZ1bmN0aW9uIGxlKGwxLCBsMikge1xuICAgIHJldHVybiAobDEubGUobDIpKTtcbn1cbmV4cG9ydHMubGUgPSBsZTtcbmZ1bmN0aW9uIGx1YigpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIGwgPSBuZXcgTGFiZWwoKTtcbiAgICBsLmx1Yi5hcHBseShsLCBhcmdzKTtcbiAgICByZXR1cm4gbDtcbn1cbmV4cG9ydHMubHViID0gbHViO1xuZnVuY3Rpb24gZ2xiKCkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgbCA9IG5ldyBMYWJlbChUb3AuVG9wKTtcbiAgICBsLmdsYi5hcHBseShsLCBhcmdzKTtcbiAgICByZXR1cm4gbDtcbn1cbmV4cG9ydHMuZ2xiID0gZ2xiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGFiZWwuanMubWFwIiwiLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy4gKi9cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGxhYmVsID0gcmVxdWlyZShcIi4vbGFiZWxcIik7XG52YXIgdmFsdWVzXzEgPSByZXF1aXJlKFwiLi92YWx1ZXNcIik7XG52YXIgZWNtYSA9IHJlcXVpcmUoXCIuL2VjbWFcIik7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xudmFyIGZ1bmN0aW9uXzEgPSByZXF1aXJlKFwiLi9mdW5jdGlvblwiKTtcbnZhciBUb051bWJlcl8xID0gcmVxdWlyZShcIi4vQ29udmVyc2lvbi9Ub051bWJlclwiKTtcbi8vIDE1LjhcbmV4cG9ydHMuZnVuY3RvciA9IGZ1bmN0aW9uIChtb25pdG9yKSB7XG4gICAgdmFyIEVjbWEgPSBlY21hLkVjbWE7XG4gICAgdmFyIExhYmVsID0gbGFiZWwuTGFiZWw7XG4gICAgdmFyIGx1YiA9IGxhYmVsLmx1YjtcbiAgICB2YXIgbGUgPSBsYWJlbC5sZTtcbiAgICB2YXIgYm90ID0gTGFiZWwuYm90O1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIGFsbG9jYXRlKGhvc3QpIHtcbiAgICAgICAgdmFyIG1hdGhPYmplY3QgPSBuZXcgTWF0aE9iamVjdChob3N0Lk1hdGgpO1xuICAgICAgICByZXR1cm4geyBNYXRoT2JqZWN0OiBtYXRoT2JqZWN0IH07XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFRoZSBNYXRoIE9iamVjdCwgMTUuOC4yXG4gICAgdmFyIE1hdGhPYmplY3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhNYXRoT2JqZWN0LCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBNYXRoT2JqZWN0KGhvc3QpIHtcbiAgICAgICAgICAgIHZhciBfdGhpc18xID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzXzEuUHJvdG90eXBlID0gbmV3IHZhbHVlc18xLlZhbHVlKG1vbml0b3IuaW5zdGFuY2VzLkZ1bmN0aW9uUHJvdG90eXBlLCBib3QpO1xuICAgICAgICAgICAgX3RoaXNfMS5DbGFzcyA9ICdNYXRoJztcbiAgICAgICAgICAgIC8vIG5vdCBtYW5kYXRlZCBieSBzdGFuZGFyZFxuICAgICAgICAgICAgX3RoaXNfMS5FeHRlbnNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIF90aGlzXzEuaG9zdCA9IGhvc3Q7XG4gICAgICAgICAgICBlY21hLkRlZmluZUZGRihfdGhpc18xLCBjb25zdGFudHMubGVuZ3RoLCAxKTtcbiAgICAgICAgICAgIGVjbWEuRGVmaW5lRkZGKF90aGlzXzEsIGNvbnN0YW50cy5wcm90b3R5cGUsIG1vbml0b3IuaW5zdGFuY2VzLk9iamVjdFByb3RvdHlwZSk7XG4gICAgICAgICAgICBlY21hLkRlZmluZUZGRihfdGhpc18xLCBjb25zdGFudHMuRSwgX3RoaXNfMS5ob3N0LkUpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVGRkYoX3RoaXNfMSwgY29uc3RhbnRzLkxOMTAsIF90aGlzXzEuaG9zdC5MTjEwKTtcbiAgICAgICAgICAgIGVjbWEuRGVmaW5lRkZGKF90aGlzXzEsIGNvbnN0YW50cy5MTjIsIF90aGlzXzEuaG9zdC5MTjIpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVGRkYoX3RoaXNfMSwgY29uc3RhbnRzLkxPRzJFLCBfdGhpc18xLmhvc3QuTE9HMkUpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVGRkYoX3RoaXNfMSwgY29uc3RhbnRzLkxPRzEwRSwgX3RoaXNfMS5ob3N0LkxPRzEwRSk7XG4gICAgICAgICAgICBlY21hLkRlZmluZUZGRihfdGhpc18xLCBjb25zdGFudHMuUEksIF90aGlzXzEuaG9zdC5QSSk7XG4gICAgICAgICAgICBlY21hLkRlZmluZUZGRihfdGhpc18xLCBjb25zdGFudHMuU1FSVDFfMiwgX3RoaXNfMS5ob3N0LlNRUlQxXzIpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVGRkYoX3RoaXNfMSwgY29uc3RhbnRzLlNRUlQyLCBfdGhpc18xLmhvc3QuU1FSVDIpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXNfMSwgY29uc3RhbnRzLmFicywgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KGFicywgMSwgX3RoaXNfMS5ob3N0LmFicykpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXNfMSwgY29uc3RhbnRzLmFjb3MsIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdChhY29zLCAxLCBfdGhpc18xLmhvc3QuYWNvcykpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXNfMSwgY29uc3RhbnRzLmFzaW4sIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdChhc2luLCAxLCBfdGhpc18xLmhvc3QuYXNpbikpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXNfMSwgY29uc3RhbnRzLmF0YW4sIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdChhdGFuLCAxLCBfdGhpc18xLmhvc3QuYXRhbikpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXNfMSwgY29uc3RhbnRzLmF0YW4yLCBuZXcgZnVuY3Rpb25fMS5CdWlsdGluRnVuY3Rpb25PYmplY3QoYXRhbjIsIDIsIF90aGlzXzEuaG9zdC5hdGFuMikpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXNfMSwgY29uc3RhbnRzLmNlaWwsIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdChjZWlsLCAxLCBfdGhpc18xLmhvc3QuY2VpbCkpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXNfMSwgY29uc3RhbnRzLmNvcywgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KGNvcywgMSwgX3RoaXNfMS5ob3N0LmNvcykpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXNfMSwgY29uc3RhbnRzLmV4cCwgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KGV4cCwgMSwgX3RoaXNfMS5ob3N0LmV4cCkpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXNfMSwgY29uc3RhbnRzLmZsb29yLCBuZXcgZnVuY3Rpb25fMS5CdWlsdGluRnVuY3Rpb25PYmplY3QoZmxvb3IsIDEsIF90aGlzXzEuaG9zdC5mbG9vcikpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXNfMSwgY29uc3RhbnRzLmxvZywgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KGxvZywgMSwgX3RoaXNfMS5ob3N0LmxvZykpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXNfMSwgY29uc3RhbnRzLm1heCwgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KG1heCwgMiwgX3RoaXNfMS5ob3N0Lm1heCkpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXNfMSwgY29uc3RhbnRzLm1pbiwgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KG1pbiwgMiwgX3RoaXNfMS5ob3N0Lm1pbikpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXNfMSwgY29uc3RhbnRzLnBvdywgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHBvdywgMiwgX3RoaXNfMS5ob3N0LnBvdykpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXNfMSwgY29uc3RhbnRzLnJhbmRvbSwgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHJhbmRvbSwgMCwgX3RoaXNfMS5ob3N0LnJhbmRvbSkpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXNfMSwgY29uc3RhbnRzLnJvdW5kLCBuZXcgZnVuY3Rpb25fMS5CdWlsdGluRnVuY3Rpb25PYmplY3Qocm91bmQsIDEsIF90aGlzXzEuaG9zdC5yb3VuZCkpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXNfMSwgY29uc3RhbnRzLnNpbiwgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHNpbiwgMSwgX3RoaXNfMS5ob3N0LnNpbikpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXNfMSwgY29uc3RhbnRzLnNxcnQsIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdChzcXJ0LCAxLCBfdGhpc18xLmhvc3Quc3FydCkpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXNfMSwgY29uc3RhbnRzLnRhbiwgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHRhbiwgMSwgX3RoaXNfMS5ob3N0LnRhbikpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzXzE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1hdGhPYmplY3Q7XG4gICAgfShFY21hKSk7XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gYWJzLCAxNS44LjIuMVxuICAgIHZhciBhYnMgPSBmdW5jdGlvbiAodGhpc0FyZywgYXJncykge1xuICAgICAgICB2YXIgeCA9IGFyZ3NbMF0gPyBUb051bWJlcl8xLlRvTnVtYmVyKGFyZ3NbMF0pIDogbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgYm90KTtcbiAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZSh0aGlzLmhvc3QoeC52YWx1ZSksIHgubGFiZWwpO1xuICAgIH07XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gYWNvcywgMTUuOC4yLjJcbiAgICB2YXIgYWNvcyA9IGZ1bmN0aW9uICh0aGlzQXJnLCBhcmdzKSB7XG4gICAgICAgIHZhciB4ID0gYXJnc1swXSA/IFRvTnVtYmVyXzEuVG9OdW1iZXIoYXJnc1swXSkgOiBuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgICAgICByZXR1cm4gbmV3IHZhbHVlc18xLlZhbHVlKHRoaXMuaG9zdCh4LnZhbHVlKSwgeC5sYWJlbCk7XG4gICAgfTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBhc2luLCAxNS44LjIuM1xuICAgIHZhciBhc2luID0gZnVuY3Rpb24gKHRoaXNBcmcsIGFyZ3MpIHtcbiAgICAgICAgdmFyIHggPSBhcmdzWzBdID8gVG9OdW1iZXJfMS5Ub051bWJlcihhcmdzWzBdKSA6IG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG4gICAgICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUodGhpcy5ob3N0KHgudmFsdWUpLCB4LmxhYmVsKTtcbiAgICB9O1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIGF0YW4sIDE1LjguMi40XG4gICAgdmFyIGF0YW4gPSBmdW5jdGlvbiAodGhpc0FyZywgYXJncykge1xuICAgICAgICB2YXIgeCA9IGFyZ3NbMF0gPyBUb051bWJlcl8xLlRvTnVtYmVyKGFyZ3NbMF0pIDogbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgYm90KTtcbiAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZSh0aGlzLmhvc3QoeC52YWx1ZSksIHgubGFiZWwpO1xuICAgIH07XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gYXRhbjIsIDE1LjguMi41XG4gICAgdmFyIGF0YW4yID0gZnVuY3Rpb24gKHRoaXNBcmcsIGFyZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpc0FyZy52YWx1ZTtcbiAgICAgICAgdmFyIHggPSBhcmdzWzBdID8gVG9OdW1iZXJfMS5Ub051bWJlcihhcmdzWzBdKSA6IG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG4gICAgICAgIHZhciB5ID0gYXJnc1sxXSA/IFRvTnVtYmVyXzEuVG9OdW1iZXIoYXJnc1sxXSkgOiBuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgICAgICByZXR1cm4gbmV3IHZhbHVlc18xLlZhbHVlKF90aGlzLmhvc3QoeC52YWx1ZSwgeS52YWx1ZSksIGx1Yih4LmxhYmVsLCB5LmxhYmVsKSk7XG4gICAgfTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBjZWlsLCAxNS44LjIuNlxuICAgIHZhciBjZWlsID0gZnVuY3Rpb24gKHRoaXNBcmcsIGFyZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpc0FyZy52YWx1ZTtcbiAgICAgICAgdmFyIHggPSBhcmdzWzBdID8gVG9OdW1iZXJfMS5Ub051bWJlcihhcmdzWzBdKSA6IG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG4gICAgICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUoX3RoaXMuaG9zdCh4LnZhbHVlKSwgeC5sYWJlbCk7XG4gICAgfTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBjb3MsIDE1LjguMi43XG4gICAgdmFyIGNvcyA9IGZ1bmN0aW9uICh0aGlzQXJnLCBhcmdzKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKHRoaXNBcmcpO1xuICAgICAgICB2YXIgeCA9IGFyZ3NbMF0gPyBUb051bWJlcl8xLlRvTnVtYmVyKGFyZ3NbMF0pIDogbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgYm90KTtcbiAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZSh0aGlzLmhvc3QoeC52YWx1ZSksIHgubGFiZWwpO1xuICAgIH07XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gZXhwLCAxNS44LjIuOFxuICAgIHZhciBleHAgPSBmdW5jdGlvbiAodGhpc0FyZywgYXJncykge1xuICAgICAgICB2YXIgeCA9IGFyZ3NbMF0gPyBUb051bWJlcl8xLlRvTnVtYmVyKGFyZ3NbMF0pIDogbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgYm90KTtcbiAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZSh0aGlzLmhvc3QoeC52YWx1ZSksIHgubGFiZWwpO1xuICAgIH07XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gZmxvb3IsIDE1LjguMi45XG4gICAgdmFyIGZsb29yID0gZnVuY3Rpb24gKHRoaXNBcmcsIGFyZ3MpIHtcbiAgICAgICAgdmFyIHggPSBhcmdzWzBdID8gVG9OdW1iZXJfMS5Ub051bWJlcihhcmdzWzBdKSA6IG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG4gICAgICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUodGhpcy5ob3N0KHgudmFsdWUpLCB4LmxhYmVsKTtcbiAgICB9O1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIGxvZywgMTUuOC4yLjEwXG4gICAgdmFyIGxvZyA9IGZ1bmN0aW9uICh0aGlzQXJnLCBhcmdzKSB7XG4gICAgICAgIHZhciB4ID0gYXJnc1swXSA/IFRvTnVtYmVyXzEuVG9OdW1iZXIoYXJnc1swXSkgOiBuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgICAgICByZXR1cm4gbmV3IHZhbHVlc18xLlZhbHVlKHRoaXMuaG9zdCh4LnZhbHVlKSwgeC5sYWJlbCk7XG4gICAgfTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBtYXgsIDE1LjguMi4xMVxuICAgIHZhciBtYXggPSBmdW5jdGlvbiAodGhpc0FyZywgYXJncykge1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gbmV3IHZhbHVlc18xLlZhbHVlKE51bWJlci5ORUdBVElWRV9JTkZJTklUWSwgYm90KTtcbiAgICAgICAgdmFyIG15QXJncyA9IFtdO1xuICAgICAgICB2YXIgbCA9IGJvdDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBteUFyZ3NbaV0gPSBhcmdzW2ldLnZhbHVlO1xuICAgICAgICAgICAgbCA9IGx1YihsLCBhcmdzW2ldLmxhYmVsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IHZhbHVlc18xLlZhbHVlKHRoaXMuaG9zdC5hcHBseShudWxsLCBteUFyZ3MpLCBsKTtcbiAgICB9O1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIG1pbiwgMTUuOC4yLjEyXG4gICAgdmFyIG1pbiA9IGZ1bmN0aW9uICh0aGlzQXJnLCBhcmdzKSB7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUoTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBib3QpO1xuICAgICAgICB2YXIgbXlBcmdzID0gW107XG4gICAgICAgIHZhciBsID0gYm90O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG15QXJnc1tpXSA9IGFyZ3NbaV0udmFsdWU7XG4gICAgICAgICAgICBsID0gbHViKGwsIGFyZ3NbaV0ubGFiZWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUodGhpcy5ob3N0LmFwcGx5KG51bGwsIG15QXJncyksIGwpO1xuICAgIH07XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gcG93LCAxNS44LjIuMTNcbiAgICB2YXIgcG93ID0gZnVuY3Rpb24gKHRoaXNBcmcsIGFyZ3MpIHtcbiAgICAgICAgdmFyIHggPSBhcmdzWzBdID8gVG9OdW1iZXJfMS5Ub051bWJlcihhcmdzWzBdKSA6IG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG4gICAgICAgIHZhciB5ID0gYXJnc1sxXSA/IFRvTnVtYmVyXzEuVG9OdW1iZXIoYXJnc1sxXSkgOiBuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgICAgICByZXR1cm4gbmV3IHZhbHVlc18xLlZhbHVlKHRoaXMuaG9zdCh4LnZhbHVlLCB5LnZhbHVlKSwgbHViKHgubGFiZWwsIHkubGFiZWwpKTtcbiAgICB9O1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIHJhbmRvbSwgMTUuOC4yLjE0XG4gICAgdmFyIHJhbmRvbSA9IGZ1bmN0aW9uICh0aGlzQXJnLCBhcmdzKSB7XG4gICAgICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUodGhpcy5ob3N0KCksIGJvdCk7XG4gICAgfTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyByb3VuZCwgMTUuOC4yLjE1XG4gICAgdmFyIHJvdW5kID0gZnVuY3Rpb24gKHRoaXNBcmcsIGFyZ3MpIHtcbiAgICAgICAgdmFyIHggPSBhcmdzWzBdID8gVG9OdW1iZXJfMS5Ub051bWJlcihhcmdzWzBdKSA6IG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG4gICAgICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUodGhpcy5ob3N0KHgudmFsdWUpLCB4LmxhYmVsKTtcbiAgICB9O1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIHNpbiwgMTUuOC4yLjE2XG4gICAgdmFyIHNpbiA9IGZ1bmN0aW9uICh0aGlzQXJnLCBhcmdzKSB7XG4gICAgICAgIHZhciB4ID0gYXJnc1swXSA/IFRvTnVtYmVyXzEuVG9OdW1iZXIoYXJnc1swXSkgOiBuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgICAgICByZXR1cm4gbmV3IHZhbHVlc18xLlZhbHVlKHRoaXMuaG9zdCh4LnZhbHVlKSwgeC5sYWJlbCk7XG4gICAgfTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBzcXJ0LCAxNS44LjIuMTdcbiAgICB2YXIgc3FydCA9IGZ1bmN0aW9uICh0aGlzQXJnLCBhcmdzKSB7XG4gICAgICAgIHZhciB4ID0gYXJnc1swXSA/IFRvTnVtYmVyXzEuVG9OdW1iZXIoYXJnc1swXSkgOiBuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgICAgICByZXR1cm4gbmV3IHZhbHVlc18xLlZhbHVlKHRoaXMuaG9zdCh4LnZhbHVlKSwgeC5sYWJlbCk7XG4gICAgfTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyB0YW4sIDE1LjguMi4xOFxuICAgIHZhciB0YW4gPSBmdW5jdGlvbiAodGhpc0FyZywgYXJncykge1xuICAgICAgICB2YXIgeCA9IGFyZ3NbMF0gPyBUb051bWJlcl8xLlRvTnVtYmVyKGFyZ3NbMF0pIDogbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgYm90KTtcbiAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZSh0aGlzLmhvc3QoeC52YWx1ZSksIHgubGFiZWwpO1xuICAgIH07XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgdmFyIG1vZHVsZSA9IHt9O1xuICAgIG1vZHVsZS5hbGxvY2F0ZSA9IGFsbG9jYXRlO1xuICAgIHJldHVybiBtb2R1bGU7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF0aC5qcy5tYXAiLCIvKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLiAqL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbGFiZWxfMSA9IHJlcXVpcmUoXCIuL2xhYmVsXCIpO1xudmFyIHZhbHVlc18xID0gcmVxdWlyZShcIi4vdmFsdWVzXCIpO1xudmFyIGNvbnRleHRfMSA9IHJlcXVpcmUoXCIuL2NvbnRleHRcIik7XG52YXIgcHJlbHVkZSA9IHJlcXVpcmUoXCIuL3ByZWx1ZGVcIik7XG52YXIgb3B0aW9uc18xID0gcmVxdWlyZShcIi4vb3B0aW9uc1wiKTtcbnZhciBzdGFja18xID0gcmVxdWlyZShcIi4vc3RhY2tcIik7XG52YXIgRnVuY3Rpb25Qcm90b3R5cGVfMSA9IHJlcXVpcmUoXCIuL1Byb3RvdHlwZXMvRnVuY3Rpb25Qcm90b3R5cGVcIik7XG52YXIgRnVuY3Rpb25Db25zdHJ1Y3Rvcl8xID0gcmVxdWlyZShcIi4vQ29uc3RydWN0b3JzL0Z1bmN0aW9uQ29uc3RydWN0b3JcIik7XG52YXIgT2JqZWN0Q29uc3RydWN0b3JfMSA9IHJlcXVpcmUoXCIuL0NvbnN0cnVjdG9ycy9PYmplY3RDb25zdHJ1Y3RvclwiKTtcbnZhciBPYmplY3RQcm90b3R5cGVfMSA9IHJlcXVpcmUoXCIuL1Byb3RvdHlwZXMvT2JqZWN0UHJvdG90eXBlXCIpO1xudmFyIEJvb2xlYW5Db25zdHJ1Y3Rvcl8xID0gcmVxdWlyZShcIi4vQ29uc3RydWN0b3JzL0Jvb2xlYW5Db25zdHJ1Y3RvclwiKTtcbnZhciBCb29sZWFuUHJvdG90eXBlXzEgPSByZXF1aXJlKFwiLi9Qcm90b3R5cGVzL0Jvb2xlYW5Qcm90b3R5cGVcIik7XG52YXIgQXJyYXlQcm90b3R5cGVfMSA9IHJlcXVpcmUoXCIuL1Byb3RvdHlwZXMvQXJyYXlQcm90b3R5cGVcIik7XG52YXIgQXJyYXlDb25zdHJ1Y3Rvcl8xID0gcmVxdWlyZShcIi4vQ29uc3RydWN0b3JzL0FycmF5Q29uc3RydWN0b3JcIik7XG52YXIgTnVtYmVyUHJvdG90eXBlXzEgPSByZXF1aXJlKFwiLi9Qcm90b3R5cGVzL051bWJlclByb3RvdHlwZVwiKTtcbnZhciBOdW1iZXJDb25zdHJ1Y3Rvcl8xID0gcmVxdWlyZShcIi4vQ29uc3RydWN0b3JzL051bWJlckNvbnN0cnVjdG9yXCIpO1xudmFyIGltcG9ydHMgPSB7XG4gICAgZXJyb3I6IHJlcXVpcmUoJy4vZXJyb3InKSxcbiAgICBzdHJpbmc6IHJlcXVpcmUoJy4vc3RyaW5nJyksXG4gICAgcmVnZXhwOiByZXF1aXJlKCcuL3JlZ2V4cCcpLFxuICAgIGRhdGU6IHJlcXVpcmUoJy4vZGF0ZScpLFxuICAgIG1hdGg6IHJlcXVpcmUoJy4vbWF0aCcpLFxuICAgIGpzb246IHJlcXVpcmUoJy4vanNvbicpLFxuICAgIGdsb2JhbDogcmVxdWlyZSgnLi9nbG9iYWwnKSxcbiAgICBleGVjOiByZXF1aXJlKCcuL2V4ZWMnKVxufTtcbnZhciBib3QgPSBsYWJlbF8xLkxhYmVsLmJvdDtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgSlNGbG93RXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEpTRmxvd0Vycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEpTRmxvd0Vycm9yKG1zZykge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgbXNnKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gSlNGbG93RXJyb3I7XG59KEVycm9yKSk7XG5leHBvcnRzLkpTRmxvd0Vycm9yID0gSlNGbG93RXJyb3I7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIFNlY3VyaXR5RXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNlY3VyaXR5RXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2VjdXJpdHlFcnJvcihtc2cpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG1zZykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFNlY3VyaXR5RXJyb3I7XG59KEpTRmxvd0Vycm9yKSk7XG5leHBvcnRzLlNlY3VyaXR5RXJyb3IgPSBTZWN1cml0eUVycm9yO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBGYXRhbEVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGYXRhbEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZhdGFsRXJyb3IobXNnKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBtc2cpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBGYXRhbEVycm9yO1xufShKU0Zsb3dFcnJvcikpO1xuZXhwb3J0cy5GYXRhbEVycm9yID0gRmF0YWxFcnJvcjtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgSW5zdGFuY2VzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEluc3RhbmNlcyhnbG9iYWwpIHtcbiAgICAgICAgLy8gcHJlLWFsbG9jYXRlcyBpbnN0YW5jZXMsIHdpdGhvdXQgc2V0dGluZyB0aGVtIHVwIGR1ZSB0byBjaXJjdWxhcml0eVxuICAgICAgICB0aGlzLkZ1bmN0aW9uQ29uc3RydWN0b3IgPSBuZXcgRnVuY3Rpb25Db25zdHJ1Y3Rvcl8xLkZ1bmN0aW9uQ29uc3RydWN0b3IoZ2xvYmFsLkZ1bmN0aW9uKTtcbiAgICAgICAgdGhpcy5GdW5jdGlvblByb3RvdHlwZSA9IG5ldyBGdW5jdGlvblByb3RvdHlwZV8xLkZ1bmN0aW9uUHJvdG90eXBlKE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwuRnVuY3Rpb24pKTtcbiAgICAgICAgdGhpcy5PYmplY3RDb25zdHJ1Y3RvciA9IG5ldyBPYmplY3RDb25zdHJ1Y3Rvcl8xLk9iamVjdENvbnN0cnVjdG9yKGdsb2JhbC5PYmplY3QpO1xuICAgICAgICB0aGlzLk9iamVjdFByb3RvdHlwZSA9IG5ldyBPYmplY3RQcm90b3R5cGVfMS5PYmplY3RQcm90b3R5cGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKGdsb2JhbC5PYmplY3QpKTtcbiAgICAgICAgdGhpcy5Cb29sZWFuQ29uc3RydWN0b3IgPSBuZXcgQm9vbGVhbkNvbnN0cnVjdG9yXzEuQm9vbGVhbkNvbnN0cnVjdG9yKGdsb2JhbC5Cb29sZWFuKTtcbiAgICAgICAgdGhpcy5Cb29sZWFuUHJvdG90eXBlID0gbmV3IEJvb2xlYW5Qcm90b3R5cGVfMS5Cb29sZWFuUHJvdG90eXBlKE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwuQm9vbGVhbikpO1xuICAgICAgICB0aGlzLkFycmF5Q29uc3RydWN0b3IgPSBuZXcgQXJyYXlDb25zdHJ1Y3Rvcl8xLkFycmF5Q29uc3RydWN0b3IoZ2xvYmFsLkFycmF5KTtcbiAgICAgICAgdGhpcy5BcnJheVByb3RvdHlwZSA9IG5ldyBBcnJheVByb3RvdHlwZV8xLkFycmF5UHJvdG90eXBlKE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwuQXJyYXkpKTtcbiAgICAgICAgdGhpcy5OdW1iZXJDb25zdHJ1Y3RvciA9IG5ldyBOdW1iZXJDb25zdHJ1Y3Rvcl8xLk51bWJlckNvbnN0cnVjdG9yKGdsb2JhbC5BcnJheSk7XG4gICAgICAgIHRoaXMuTnVtYmVyUHJvdG90eXBlID0gbmV3IE51bWJlclByb3RvdHlwZV8xLk51bWJlclByb3RvdHlwZShPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2xvYmFsLkFycmF5KSk7XG4gICAgfVxuICAgIEluc3RhbmNlcy5wcm90b3R5cGUuU2V0dXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuRnVuY3Rpb25Db25zdHJ1Y3Rvci5TZXR1cCgpO1xuICAgICAgICB0aGlzLkZ1bmN0aW9uUHJvdG90eXBlLlNldHVwKCk7XG4gICAgICAgIHRoaXMuT2JqZWN0Q29uc3RydWN0b3IuU2V0dXAoKTtcbiAgICAgICAgdGhpcy5PYmplY3RQcm90b3R5cGUuU2V0dXAoKTtcbiAgICAgICAgdGhpcy5Cb29sZWFuQ29uc3RydWN0b3IuU2V0dXAoKTtcbiAgICAgICAgdGhpcy5Cb29sZWFuUHJvdG90eXBlLlNldHVwKCk7XG4gICAgICAgIHRoaXMuQXJyYXlDb25zdHJ1Y3Rvci5TZXR1cCgpO1xuICAgICAgICB0aGlzLkFycmF5UHJvdG90eXBlLlNldHVwKCk7XG4gICAgICAgIHRoaXMuTnVtYmVyQ29uc3RydWN0b3IuU2V0dXAoKTtcbiAgICAgICAgdGhpcy5OdW1iZXJQcm90b3R5cGUuU2V0dXAoKTtcbiAgICB9O1xuICAgIHJldHVybiBJbnN0YW5jZXM7XG59KCkpO1xudmFyIE1vbml0b3JCYXNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8vIC0tLVxuICAgIC8vIGNvbnN0cnVjdG9yXG4gICAgZnVuY3Rpb24gTW9uaXRvckJhc2UoZ2xvYmFsLCBwcmludCwgbG9nLCB3YXJuLCBlcnJvcikge1xuICAgICAgICB0aGlzLmNvbnRleHRTdGFjayA9IG5ldyBzdGFja18xLlN0YWNrKCk7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb2RlYnVmZmVyID0gXCJcIjtcbiAgICAgICAgZ2xvYmFsLm1vbml0b3IgPSB0aGlzO1xuICAgICAgICB0aGlzLnByaW50ID0gcHJpbnQgPyBwcmludCA6IGNvbnNvbGUubG9nO1xuICAgICAgICB0aGlzLmxvZyA9IGxvZyA/IGxvZyA6IGNvbnNvbGUubG9nO1xuICAgICAgICB0aGlzLndhcm4gPSB3YXJuID8gd2FybiA6IGNvbnNvbGUubG9nO1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3IgPyBlcnJvciA6IGNvbnNvbGUubG9nO1xuICAgICAgICB0aGlzLm1vZHVsZXMgPSB7fTtcbiAgICAgICAgdmFyIGxvYWQgPSBbXG4gICAgICAgICAgICAnZXJyb3InLFxuICAgICAgICAgICAgJ3N0cmluZycsXG4gICAgICAgICAgICAncmVnZXhwJyxcbiAgICAgICAgICAgICdkYXRlJyxcbiAgICAgICAgICAgICdtYXRoJyxcbiAgICAgICAgICAgICdqc29uJyxcbiAgICAgICAgICAgICdnbG9iYWwnLFxuICAgICAgICAgICAgJ2V4ZWMnXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuc2V0dXAodGhpcy5tb2R1bGVzLCBsb2FkLCBpbXBvcnRzKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gbmV3IG9wdGlvbnNfMS5PcHRpb25zKCk7XG4gICAgICAgIHRoaXMub3B0aW9ucy5kZWNsYXJlKCdtb25pdG9yLnRhaW50TW9kZScsICdib29sZWFuJywgdHJ1ZSwgJ3RhaW50IG1vZGUnKTtcbiAgICAgICAgdGhpcy5vcHRpb25zLmRlY2xhcmUoJ21vbml0b3IudGVzdE1vZGUnLCAnYm9vbGVhbicsIGZhbHNlLCAndGVzdCBtb2RlJyk7XG4gICAgICAgIHRoaXMub3B0aW9ucy5kZWNsYXJlKCdtb25pdG9yLm9ic2VydmFibGVNb2RlJywgJ2Jvb2xlYW4nLCBmYWxzZSwgJ29ic2VydmFibGUgbW9kZScpO1xuICAgICAgICB2YXIgY29udGV4dCA9IG5ldyBjb250ZXh0XzEuQ29udGV4dChudWxsLCBudWxsLCBudWxsKTtcbiAgICAgICAgY29udGV4dC5vd25lciA9ICc8bW9uaXRvcj4nO1xuICAgICAgICB0aGlzLmNvbnRleHRTdGFjay5wdXNoKGNvbnRleHQpO1xuICAgICAgICB0aGlzLmluc3RhbmNlcyA9IG5ldyBJbnN0YW5jZXMoZ2xvYmFsKTtcbiAgICAgICAgdGhpcy5pbnN0YW5jZXMuU2V0dXAoKTtcbiAgICAgICAgdGhpcy5kZWJ1ZyA9IHsgYWN0aXZlOiBmYWxzZSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9uaXRvckJhc2UucHJvdG90eXBlLCBcImNvbnRleHRcIiwge1xuICAgICAgICAvLyAtLS1cbiAgICAgICAgLy8gYWNjZXNzb3JzXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dFN0YWNrLnBlZWsoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLy8gLS0tXG4gICAgLy8gbWV0aG9kc1xuICAgIE1vbml0b3JCYXNlLnByb3RvdHlwZS5zZXR1cCA9IGZ1bmN0aW9uICh0YXJnZXQsIGxvYWQsIGltcG9ydHMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxvYWQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gbG9hZFtpXTtcbiAgICAgICAgICAgIHZhciBtb2R1bGUgPSBpbXBvcnRzW25hbWVdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtb2R1bGUuZnVuY3RvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRhcmdldFtuYW1lXSA9IG1vZHVsZS5mdW5jdG9yKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W25hbWVdID0gbW9kdWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyAtLS1cbiAgICBNb25pdG9yQmFzZS5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChnbG9iYWwpIHtcbiAgICAgICAgdGhpcy5kZWJ1Zy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdmFyIGluc3RhbmNlTGlzdCA9IFtcbiAgICAgICAgICAgIHRoaXMubW9kdWxlcy5lcnJvcixcbiAgICAgICAgICAgIHRoaXMubW9kdWxlcy5zdHJpbmcsXG4gICAgICAgICAgICB0aGlzLm1vZHVsZXMucmVnZXhwLFxuICAgICAgICAgICAgdGhpcy5tb2R1bGVzLmRhdGUsXG4gICAgICAgICAgICB0aGlzLm1vZHVsZXMubWF0aCxcbiAgICAgICAgICAgIHRoaXMubW9kdWxlcy5qc29uXG4gICAgICAgIF07XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBpbnN0YW5jZUxpc3QubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZXMgPSBpbnN0YW5jZUxpc3RbaV0uYWxsb2NhdGUoZ2xvYmFsKTtcbiAgICAgICAgICAgIHByZWx1ZGUuY29weShpbnN0YW5jZXMsIHRoaXMuaW5zdGFuY2VzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gLS0tXG4gICAgTW9uaXRvckJhc2UucHJvdG90eXBlLnJ1bm5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZHVsZXMuZXhlYy5ydW5uaW5nKCk7XG4gICAgfTtcbiAgICA7XG4gICAgLy8gLS0tXG4gICAgTW9uaXRvckJhc2UucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAoY29kZSwgZmlsZW5hbWUpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhjb2RlKTtcbiAgICAgICAgdGhpcy5jb2RlYnVmZmVyICs9IFwiXFxuLyogbmV3IGNvbW1hbmQgYXQgXCIgKyAobmV3IERhdGUoKS5nZXRUaW1lKCkpICsgXCIqL1xcblwiO1xuICAgICAgICB0aGlzLmNvZGVidWZmZXIgKz0gY29kZTtcbiAgICAgICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiB0aHJvdyBlcnJvclxuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLm1vZHVsZXMuZXhlYy5leGVjdXRlR2xvYmFsQ29kZShjb2RlLCBmaWxlbmFtZSk7XG4gICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gJ3Rocm93Jykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJFUlJPUiBUSFJPV046IFwiICsgdGhpcy5jb2RlYnVmZmVyKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBKU0Zsb3dFcnJvcihyZXN1bHQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gICAgfTtcbiAgICAvLyAtLS1cbiAgICBNb25pdG9yQmFzZS5wcm90b3R5cGUuaW50ZXJhY3RpdmUgPSBmdW5jdGlvbiAoY29kZSwgZmlsZW5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kdWxlcy5leGVjLmV4ZWN1dGVHbG9iYWxDb2RlKGNvZGUsIGZpbGVuYW1lKTtcbiAgICB9O1xuICAgIC8vIC0tLVxuICAgIE1vbml0b3JCYXNlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGVidWcuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZHVsZXMuZXhlYy5yZXN1bWUoKTtcbiAgICB9O1xuICAgIC8vIC0tLVxuICAgIE1vbml0b3JCYXNlLnByb3RvdHlwZS5zdGVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2R1bGVzLmV4ZWMucmVzdW1lKCk7XG4gICAgfTtcbiAgICAvLyAtLS1cbiAgICBNb25pdG9yQmFzZS5wcm90b3R5cGUucHJpbnRXb3JrTGlzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbW9uaXRvci5sb2coJ2NvbnRleHQgb3duZXI6ICcgKyB0aGlzLmNvbnRleHQub3duZXIpO1xuICAgICAgICBtb25pdG9yLmxvZyhTdHJpbmcodGhpcy5jb250ZXh0LndvcmtMaXN0KSk7XG4gICAgfTtcbiAgICAvLyAtLS1cbiAgICBNb25pdG9yQmFzZS5wcm90b3R5cGUucmVxdWlyZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBwYXRoID0gbmFtZS5zcGxpdCgnLycpO1xuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMubW9kdWxlcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhdGgubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50W3BhdGhbaV1dO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY3VycmVudCkge1xuICAgICAgICAgICAgdGhpcy5mYXRhbCgnTW9kdWxlICcgKyBuYW1lICsgJyBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9O1xuICAgIC8vIC0tLVxuICAgIC8vIFRPRE86IGZpeCBwcm9wZXIgcHJpbnRpbmdcbiAgICBNb25pdG9yQmFzZS5wcm90b3R5cGUuZmF0YWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV4YyA9IG5ldyBGYXRhbEVycm9yKGFyZ3MubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiBKU09OLnN0cmluZ2lmeSh4KTsgfSkuam9pbignICcpKTtcbiAgICAgICAgZXhjLnR5cGUgPSAnRmF0YWwnO1xuICAgICAgICB0aHJvdyBleGM7XG4gICAgfTtcbiAgICAvLyAtLS1cbiAgICBNb25pdG9yQmFzZS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgdmFyIGV4YyA9IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICBleGMudHlwZSA9ICdTdG9wJztcbiAgICAgICAgdGhyb3cgZXhjO1xuICAgIH07XG4gICAgLy8gLS0tXG4gICAgTW9uaXRvckJhc2UucHJvdG90eXBlLlRocm93ID0gZnVuY3Rpb24gKGV4YywgbXNnLCBsYmwpIHtcbiAgICAgICAgdGhpcy5hc3NlcnQobGFiZWxfMS5sZSh0aGlzLmNvbnRleHQuZWZmZWN0aXZlUEMsIHRoaXMuY29udGV4dC5sYWJlbHMuZXhjKSwgJ3Rocm93OiBlZmZlY3RpdmUgcGMgJyArIHRoaXMuY29udGV4dC5lZmZlY3RpdmVQQyArXG4gICAgICAgICAgICAnIG5vdCBiZWxvdyBleGNlcHRpb24gbGFiZWwgJyArIHRoaXMuY29udGV4dC5sYWJlbHMuZXhjKTtcbiAgICAgICAgdGhpcy5vZmZlbmRpbmdUcmFjZSA9IHRoaXMuc3RhY2tUcmFjZSgpO1xuICAgICAgICB0aHJvdyBuZXcgdmFsdWVzXzEuVmFsdWUobmV3IGV4YyhuZXcgdmFsdWVzXzEuVmFsdWUobXNnLCBsYmwpKSwgbGJsKTtcbiAgICB9O1xuICAgIC8vIC0tLVxuICAgIE1vbml0b3JCYXNlLnByb3RvdHlwZS5zdGFja1RyYWNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0YWNrVHJhY2UodGhpcy5jb250ZXh0U3RhY2sudG9BcnJheSgpKTtcbiAgICB9O1xuICAgIC8vIC0tLVxuICAgIE1vbml0b3JCYXNlLnByb3RvdHlwZS5zZWN1cml0eUVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5nZXQoJ21vbml0b3Iub2JzZXJ2YWJsZU1vZGUnKSkge1xuICAgICAgICAgICAgdGhpcy53YXJuKFwiW1NlY3VyaXR5IHZpb2xhdGlvbl0gXCIgKyBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBleGMgPSBuZXcgU2VjdXJpdHlFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgIHRocm93IGV4YztcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gLS0tXG4gICAgTW9uaXRvckJhc2UucHJvdG90eXBlLmFzc2VydCA9IGZ1bmN0aW9uIChiLCBtc2cpIHtcbiAgICAgICAgaWYgKCFiKVxuICAgICAgICAgICAgdGhpcy5zZWN1cml0eUVycm9yKG1zZyk7XG4gICAgfTtcbiAgICAvLyBsaWZ0cyBleGNlcHRpb25zIHRoYXQgXG4gICAgLy8gMS4gYXJlIG5vdCBKU0Zsb3cgaW50ZXJuYWwgZXhjZXB0aW9ucyAoaW5kaWNhdGVkIGJ5IHN1YmNsYXNzIG9mIEpTRmxvd0Vycm9yKVxuICAgIC8vIDIuIGhhdmUgYSBhIEpTRmxvdyBtb2RlbGVkIGNvdW50ZXJwYXJ0XG4gICAgLy8gb3RoZXJ3aXNlIHJldHVybnNcbiAgICBNb25pdG9yQmFzZS5wcm90b3R5cGUudHJ5UmV0aHJvdyA9IGZ1bmN0aW9uIChlLCBUaHJvdykge1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEpTRmxvd0Vycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgdmFsdWVzXzEuVmFsdWUpIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFRocm93ICYmIHRoaXMubW9kdWxlcy5lcnJvci5uYXRpdmVUYWJsZVtlLm5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuVGhyb3codGhpcy5tb2R1bGVzLmVycm9yLm5hdGl2ZVRhYmxlW2UubmFtZV0sIGUuc3RhY2ssIGJvdCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBNb25pdG9yQmFzZTtcbn0oKSk7XG5leHBvcnRzLk1vbml0b3JCYXNlID0gTW9uaXRvckJhc2U7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIE1vbml0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1vbml0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTW9uaXRvcihnbG9iYWwsIHByaW50LCBsb2csIHdhcm4sIGVycm9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGdsb2JhbCwgcHJpbnQsIGxvZywgd2FybiwgZXJyb3IpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmluaXRpYWxpemUoZ2xvYmFsKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTW9uaXRvcjtcbn0oTW9uaXRvckJhc2UpKTtcbmV4cG9ydHMuTW9uaXRvciA9IE1vbml0b3I7XG5Nb25pdG9yLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKGdsb2JhbCkge1xuICAgIE1vbml0b3JCYXNlLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgZ2xvYmFsKTtcbiAgICB2YXIgZ2xvYmFsSW5zdGFuY2UgPSB0aGlzLm1vZHVsZXMuZ2xvYmFsLmFsbG9jYXRlKGdsb2JhbCk7XG4gICAgcHJlbHVkZS5jb3B5KGdsb2JhbEluc3RhbmNlLCB0aGlzLmluc3RhbmNlcyk7XG4gICAgdGhpcy5tb2R1bGVzLmV4ZWMuaW5pdGlhbGl6ZSgpO1xufTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBcbnZhciBTdGFja1RyYWNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0YWNrVHJhY2Uoc3RhY2spIHtcbiAgICAgICAgdGhpcy50cmFjZSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc3RhY2subGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gc3RhY2tbaV07XG4gICAgICAgICAgICB2YXIgc3RtdCA9IGNvbnRleHQuY3VycmVudFN0YXRlbWVudDtcbiAgICAgICAgICAgIGlmIChzdG10ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsb2MgPSBzdG10LmxvYztcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBsb2Muc291cmNlO1xuICAgICAgICAgICAgdGhpcy50cmFjZS5wdXNoKHsgb3duZXI6IGNvbnRleHQub3duZXIsIHNvdXJjZTogc291cmNlLCBsb2M6IGxvYy5zdGFydCwgc3RtdDogc3RtdCB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gU3RhY2tUcmFjZTtcbn0oKSk7XG5TdGFja1RyYWNlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy50cmFjZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0O1xuICAgIHZhciBsZW4gPSB0aGlzLnRyYWNlLmxlbmd0aDtcbiAgICAvLyBsYXN0IGVudHJ5IGNvbnRhaW5zIG9mZmVuZGluZyBjb21tYW5kXG4gICAgdmFyIGxhc3QgPSB0aGlzLnRyYWNlW2xlbiAtIDFdO1xuICAgIHJlc3VsdCA9IGxhc3Quc291cmNlICsgJzonICsgbGFzdC5sb2MubGluZSArICc6JyArIGxhc3QubG9jLmNvbHVtbiArICdcXG4nO1xuICAgIHJlc3VsdCA9IHJlc3VsdCArICcgICAgJyArIGVzY29kZWdlbi5nZW5lcmF0ZShsYXN0LnN0bXQpICsgJ1xcblxcbic7XG4gICAgZm9yICh2YXIgaSA9IGxlbiAtIDI7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciB0ciA9IHRoaXMudHJhY2VbaV07XG4gICAgICAgIGlmICh0ci5vd25lcikge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ICsgJ2F0ICcgKyB0ci5vd25lciArICcgJztcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSByZXN1bHQgKyAnKCcgKyB0ci5zb3VyY2UgKyAnOicgKyB0ci5sb2MubGluZSArICc6JyArIHRyLmxvYy5jb2x1bW4gKyAnKVxcbic7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9uaXRvci5qcy5tYXAiLCIvKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIE9wdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPcHRpb24odHlwZSwgdmFsLCBkZXNjKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuc2V0KHZhbCk7XG4gICAgICAgIHRoaXMuZGVmID0gdGhpcy52YWx1ZTtcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IGRlc2M7XG4gICAgfVxuICAgIE9wdGlvbi5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICB2YXIgdiA9IFN0cmluZyh2YWwpO1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy50eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2ID09PSAndHJ1ZScgfHwgdiA9PT0gJzEnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBOdW1iZXIodik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9wdGlvbi5wcm90b3R5cGUuZ2V0RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVmO1xuICAgIH07XG4gICAgT3B0aW9uLnByb3RvdHlwZS52YWx1ZU9mID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9O1xuICAgIE9wdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcodGhpcy52YWx1ZSk7XG4gICAgfTtcbiAgICByZXR1cm4gT3B0aW9uO1xufSgpKTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9wdGlvbnNcbnZhciBPcHRpb25zID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9wdGlvbnMoKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IFtdO1xuICAgIH1cbiAgICBPcHRpb25zLnByb3RvdHlwZS5kZWNsYXJlID0gZnVuY3Rpb24gKG5hbWUsIHR5cGUsIGRlZiwgZGVzYykge1xuICAgICAgICB2YXIgZGVzY3JpcHRpb24gPSBkZXNjID8gZGVzYyA6IG5hbWU7XG4gICAgICAgIHRoaXMub3B0aW9uc1tuYW1lXSA9IG5ldyBPcHRpb24odHlwZSwgZGVmLCBkZXNjcmlwdGlvbik7XG4gICAgfTtcbiAgICBPcHRpb25zLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zW25hbWVdICE9PSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBPcHRpb25zLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zW25hbWVdLnZhbHVlT2YoKTtcbiAgICB9O1xuICAgIE9wdGlvbnMucHJvdG90eXBlLmdldE9wdGlvbiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbbmFtZV07XG4gICAgfTtcbiAgICBPcHRpb25zLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zW25hbWVdLnNldCh2YWx1ZSk7XG4gICAgfTtcbiAgICBPcHRpb25zLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzID0gW107XG4gICAgICAgIGZvciAodmFyIHggaW4gdGhpcy5vcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhhc093blByb3BlcnR5KHgpKSB7XG4gICAgICAgICAgICAgICAgcmVzLnB1c2goeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIHJldHVybiBPcHRpb25zO1xufSgpKTtcbmV4cG9ydHMuT3B0aW9ucyA9IE9wdGlvbnM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcHRpb25zLmpzLm1hcCIsIi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXNjb2RlZ2VuXzEgPSByZXF1aXJlKFwiZXNjb2RlZ2VuXCIpO1xuZXhwb3J0cy5wcmV0dHkgPSBlc2NvZGVnZW5fMS5nZW5lcmF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBwLmpzLm1hcCIsIi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBpbmhlcml0cyh0Z3QsIHNyYykge1xuICAgIGZvciAodmFyIHggaW4gc3JjLnByb3RvdHlwZSkge1xuICAgICAgICBpZiAoc3JjLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSh4KSAmJlxuICAgICAgICAgICAgIXRndC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoeCkpIHtcbiAgICAgICAgICAgIHRndC5wcm90b3R5cGVbeF0gPSBzcmMucHJvdG90eXBlW3hdO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5pbmhlcml0cyA9IGluaGVyaXRzO1xuZnVuY3Rpb24gY29weShzcmMsIHRndCkge1xuICAgIGZvciAodmFyIHggaW4gc3JjKSB7XG4gICAgICAgIGlmIChzcmMuaGFzT3duUHJvcGVydHkoeCkpIHtcbiAgICAgICAgICAgIHRndFt4XSA9IHNyY1t4XTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuY29weSA9IGNvcHk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcmVsdWRlLmpzLm1hcCIsIi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uICovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBsYWJlbCA9IHJlcXVpcmUoXCIuL2xhYmVsXCIpO1xudmFyIHZhbHVlc18xID0gcmVxdWlyZShcIi4vdmFsdWVzXCIpO1xudmFyIGVjbWEgPSByZXF1aXJlKFwiLi9lY21hXCIpO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbnZhciBmdW5jdGlvbl8xID0gcmVxdWlyZShcIi4vZnVuY3Rpb25cIik7XG52YXIgQXJyYXlPYmplY3RfMSA9IHJlcXVpcmUoXCIuL09iamVjdHMvQXJyYXlPYmplY3RcIik7XG52YXIgSGFzSW5zdGFuY2VfMSA9IHJlcXVpcmUoXCIuL0hhc0luc3RhbmNlXCIpO1xudmFyIFRvSW50ZWdlcl8xID0gcmVxdWlyZShcIi4vQ29udmVyc2lvbi9Ub0ludGVnZXJcIik7XG52YXIgVG9TdHJpbmdfMSA9IHJlcXVpcmUoXCIuL0NvbnZlcnNpb24vVG9TdHJpbmdcIik7XG5leHBvcnRzLmZ1bmN0b3IgPSBmdW5jdGlvbiAobW9uaXRvcikge1xuICAgIHZhciBMYWJlbCA9IGxhYmVsLkxhYmVsO1xuICAgIHZhciBsdWIgPSBsYWJlbC5sdWI7XG4gICAgdmFyIGdsYiA9IGxhYmVsLmdsYjtcbiAgICB2YXIgbGUgPSBsYWJlbC5sZTtcbiAgICB2YXIgYm90ID0gTGFiZWwuYm90O1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIGFsbG9jYXRlKGhvc3QpIHtcbiAgICAgICAgdmFyIHJlZ0V4cENvbnN0cnVjdG9yID0gbmV3IFJlZ0V4cENvbnN0cnVjdG9yKGhvc3QuUmVnRXhwKTtcbiAgICAgICAgdmFyIHJlZ0V4cFByb3RvdHlwZSA9IHJlZ0V4cENvbnN0cnVjdG9yLl9wcm90bztcbiAgICAgICAgcmV0dXJuIHsgUmVnRXhwQ29uc3RydWN0b3I6IHJlZ0V4cENvbnN0cnVjdG9yLFxuICAgICAgICAgICAgUmVnRXhwUHJvdG90eXBlOiByZWdFeHBQcm90b3R5cGVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gVGhlIFJlZ0V4cCBDb25zdHJ1Y3RvciwgMTUuMTAuNVxuICAgIHZhciBSZWdFeHBDb25zdHJ1Y3RvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKFJlZ0V4cENvbnN0cnVjdG9yLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBSZWdFeHBDb25zdHJ1Y3Rvcihob3N0KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMuUHJvdG90eXBlID0gbmV3IHZhbHVlc18xLlZhbHVlKG1vbml0b3IuaW5zdGFuY2VzLkZ1bmN0aW9uUHJvdG90eXBlLCBib3QpO1xuICAgICAgICAgICAgX3RoaXMuQ2xhc3MgPSAnRnVuY3Rpb24nO1xuICAgICAgICAgICAgLy8gbm90IG1hbmRhdGVkIGJ5IHN0YW5kYXJkXG4gICAgICAgICAgICBfdGhpcy5FeHRlbnNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIF90aGlzLmhvc3QgPSBob3N0O1xuICAgICAgICAgICAgX3RoaXMuX3Byb3RvID0gbmV3IFJlZ0V4cFByb3RvdHlwZShfdGhpcywgaG9zdC5wcm90b3R5cGUpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVGRkYoX3RoaXMsIGNvbnN0YW50cy5sZW5ndGgsIDIpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVGRkYoX3RoaXMsIGNvbnN0YW50cy5wcm90b3R5cGUsIF90aGlzLl9wcm90byk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJlZ0V4cENvbnN0cnVjdG9yO1xuICAgIH0oZWNtYS5FY21hKSk7XG4gICAgUmVnRXhwQ29uc3RydWN0b3IucHJvdG90eXBlLkhhc0luc3RhbmNlID0gSGFzSW5zdGFuY2VfMS5IYXNJbnN0YW5jZTtcbiAgICAvLyAxNS4xMC4zLjFcbiAgICBSZWdFeHBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuQ2FsbCA9IGZ1bmN0aW9uICh0aGlzQXJnLCBhcmdzKSB7XG4gICAgICAgIHZhciBwYXR0ZXJuID0gYXJnc1swXSB8fCBuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgICAgICB2YXIgZmxhZ3MgPSBhcmdzWzFdIHx8IG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG4gICAgICAgIGlmIChwYXR0ZXJuLnZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgcGF0dGVybi52YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIHBhdHRlcm4udmFsdWUuQ2xhc3MgPT09ICdSZWdFeHAnICYmXG4gICAgICAgICAgICBmbGFncy52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcGF0dGVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUmVnRXhwQ29uc3RydWN0b3IucHJvdG90eXBlLkNvbnN0cnVjdChhcmdzKTtcbiAgICB9O1xuICAgIC8vIDE1LjEwLjQuMVxuICAgIFJlZ0V4cENvbnN0cnVjdG9yLnByb3RvdHlwZS5Db25zdHJ1Y3QgPSBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICB2YXIgYyA9IG1vbml0b3IuY29udGV4dDtcbiAgICAgICAgdmFyIHBhdHRlcm4gPSBhcmdzWzBdIHx8IG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG4gICAgICAgIHZhciBmbGFncyA9IGFyZ3NbMV0gfHwgbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgYm90KTtcbiAgICAgICAgdmFyIFAgPSBcIlwiO1xuICAgICAgICB2YXIgRiA9IFwiXCI7XG4gICAgICAgIHZhciBsID0gbHViKHBhdHRlcm4ubGFiZWwsIGZsYWdzLmxhYmVsKTtcbiAgICAgICAgYy5wdXNoUEMobCk7XG4gICAgICAgIGlmIChwYXR0ZXJuLnZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgcGF0dGVybi52YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIHBhdHRlcm4udmFsdWUuQ2xhc3MgPT09ICdSZWdFeHAnKSB7XG4gICAgICAgICAgICBpZiAoZmxhZ3MudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciByeCA9IHBhdHRlcm4udmFsdWUuUHJpbWl0aXZlVmFsdWU7XG4gICAgICAgICAgICAgICAgUCA9IHJ4LnNvdXJjZTtcbiAgICAgICAgICAgICAgICBGID0gKHJ4Lmdsb2JhbCA/ICdnJyA6ICcnKSArIChyeC5pZ25vcmVDYXNlID8gJ2knIDogJycpICsgKHJ4Lm11bHRpbGluZSA/ICdtJyA6ICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vbml0b3IuVGhyb3cobW9uaXRvci5tb2R1bGVzLmVycm9yLlR5cGVFcnJvck9iamVjdCwgJycsIGJvdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgX1AgPSBwYXR0ZXJuLnZhbHVlID09PSB1bmRlZmluZWQgPyBuZXcgdmFsdWVzXzEuVmFsdWUoXCJcIiwgbCkgOiBUb1N0cmluZ18xLlRvU3RyaW5nKHBhdHRlcm4pO1xuICAgICAgICAgICAgdmFyIF9GID0gZmxhZ3MudmFsdWUgPT09IHVuZGVmaW5lZCA/IG5ldyB2YWx1ZXNfMS5WYWx1ZShcIlwiLCBsKSA6IFRvU3RyaW5nXzEuVG9TdHJpbmcoZmxhZ3MpO1xuICAgICAgICAgICAgbCA9IGx1YihsLCBfUC5sYWJlbCwgX0YubGFiZWwpO1xuICAgICAgICAgICAgUCA9IF9QLnZhbHVlO1xuICAgICAgICAgICAgRiA9IF9GLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXMgPSBuZXcgUmVnRXhwT2JqZWN0KG5ldyBSZWdFeHAoUCwgRiksIGwpO1xuICAgICAgICBjLnBvcFBDKCk7XG4gICAgICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUocmVzLCBib3QpO1xuICAgIH07XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gVGhlIFJlZ0V4cCBQcm90b3R5cGUsIDE1LjEwLjZcbiAgICB2YXIgUmVnRXhwUHJvdG90eXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoUmVnRXhwUHJvdG90eXBlLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBSZWdFeHBQcm90b3R5cGUoY29uc3RydWN0b3IsIGhvc3QpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy5DbGFzcyA9ICdSZWdFeHAnO1xuICAgICAgICAgICAgX3RoaXMuUHJvdG90eXBlID0gbmV3IHZhbHVlc18xLlZhbHVlKG1vbml0b3IuaW5zdGFuY2VzLk9iamVjdFByb3RvdHlwZSwgYm90KTtcbiAgICAgICAgICAgIF90aGlzLmhvc3QgPSBob3N0O1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVGRkYoX3RoaXMsIGNvbnN0YW50cy5zb3VyY2UsICcnKTtcbiAgICAgICAgICAgIGVjbWEuRGVmaW5lRkZGKF90aGlzLCBjb25zdGFudHMuZ2xvYmFsLCBmYWxzZSk7XG4gICAgICAgICAgICBlY21hLkRlZmluZUZGRihfdGhpcywgY29uc3RhbnRzLmlnbm9yZUNhc2UsIGZhbHNlKTtcbiAgICAgICAgICAgIGVjbWEuRGVmaW5lRkZGKF90aGlzLCBjb25zdGFudHMubXVsdGlsaW5lLCBmYWxzZSk7XG4gICAgICAgICAgICBlY21hLkRlZmluZVRGRihfdGhpcywgY29uc3RhbnRzLmxhc3RJbmRleCwgMCk7XG4gICAgICAgICAgICBlY21hLkRlZmluZUZGRihfdGhpcywgY29uc3RhbnRzLmxlbmd0aCwgMCk7XG4gICAgICAgICAgICBlY21hLkRlZmluZVRGVChfdGhpcywgY29uc3RhbnRzLmNvbnN0cnVjdG9yLCBjb25zdHJ1Y3Rvcik7XG4gICAgICAgICAgICBlY21hLkRlZmluZVRGVChfdGhpcywgY29uc3RhbnRzLmV4ZWMsIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdChleGVjLCAxLCBSZWdFeHAucHJvdG90eXBlLmV4ZWMpKTtcbiAgICAgICAgICAgIGVjbWEuRGVmaW5lVEZUKF90aGlzLCBjb25zdGFudHMudGVzdCwgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHRlc3QsIDEsIFJlZ0V4cC5wcm90b3R5cGUudGVzdCkpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXMsIGNvbnN0YW50cy50b1N0cmluZywgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHRvU3RyaW5nLCAwLCBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nKSk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJlZ0V4cFByb3RvdHlwZTtcbiAgICB9KGVjbWEuRWNtYSkpO1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIGV4ZWMsIDE1LjEwLjYuMlxuICAgIHZhciBleGVjID0gZnVuY3Rpb24gKHRoaXNBcmcsIGFyZ3MpIHtcbiAgICAgICAgdmFyIHN0cmluZyA9IGFyZ3NbMF0gfHwgbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgYm90KTtcbiAgICAgICAgdmFyIFMgPSBUb1N0cmluZ18xLlRvU3RyaW5nKHN0cmluZyk7XG4gICAgICAgIHZhciBsYXN0SW5kZXggPSBUb0ludGVnZXJfMS5Ub0ludGVnZXIodGhpc0FyZy5HZXQoY29uc3RhbnRzLmxhc3RJbmRleCkpO1xuICAgICAgICB2YXIgcHJlID0gdGhpc0FyZy52YWx1ZS5QcmltaXRpdmVWYWx1ZTtcbiAgICAgICAgcHJlLmxhc3RJbmRleCA9IGxhc3RJbmRleC52YWx1ZTtcbiAgICAgICAgdmFyIHJlcyA9IHByZS5leGVjKFMudmFsdWUpO1xuICAgICAgICB2YXIgbCA9IGx1Yih0aGlzQXJnLmxhYmVsLCBTLmxhYmVsLCBsYXN0SW5kZXgubGFiZWwpO1xuICAgICAgICBpZiAocmVzID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHZhbHVlc18xLlZhbHVlKG51bGwsIGwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNBcmcuUHV0KGNvbnN0YW50cy5sYXN0SW5kZXgsIG5ldyB2YWx1ZXNfMS5WYWx1ZShwcmUubGFzdEluZGV4LCBsKSk7XG4gICAgICAgIHZhciBhcnJheSA9IEFycmF5T2JqZWN0XzEuQXJyYXlPYmplY3QuZnJvbUFycmF5KHJlcywgbCwgbCk7XG4gICAgICAgIGFycmF5LkRlZmluZU93blByb3BlcnR5KGNvbnN0YW50cy5pbmRleCwgeyB2YWx1ZTogcmVzLmluZGV4LFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgbGFiZWw6IGxcbiAgICAgICAgfSk7XG4gICAgICAgIGFycmF5LkRlZmluZU93blByb3BlcnR5KGNvbnN0YW50cy5pbnB1dCwgeyB2YWx1ZTogcmVzLmlucHV0LFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgbGFiZWw6IGxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUoYXJyYXksIGJvdCk7XG4gICAgfTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyB0ZXN0LCAxNS4xMC42LjNcbiAgICB2YXIgdGVzdCA9IGZ1bmN0aW9uICh0aGlzQXJnLCBhcmdzKSB7XG4gICAgICAgIHZhciByZXMgPSBleGVjKHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gbmV3IHZhbHVlc18xLlZhbHVlKHJlcy52YWx1ZSAhPT0gbnVsbCwgcmVzLmxhYmVsKTtcbiAgICB9O1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIHRvU3RyaW5nLCAxNS4xMC42LjNcbiAgICB2YXIgdG9TdHJpbmcgPSBmdW5jdGlvbiAodGhpc0FyZywgYXJncykge1xuICAgICAgICByZXR1cm4gbmV3IHZhbHVlc18xLlZhbHVlKHRoaXNBcmcudmFsdWUuUHJpbWl0aXZlVmFsdWUudG9TdHJpbmcoKSwgdGhpc0FyZy5sYWJlbCk7XG4gICAgfTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBSZWdFeHAgT2JqZWN0LCAxNS4xMC40LjFcbiAgICB2YXIgUmVnRXhwT2JqZWN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoUmVnRXhwT2JqZWN0LCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBSZWdFeHBPYmplY3QobmF0aXZlUmVnRXhwLCBsKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMuQ2xhc3MgPSAnUmVnRXhwJztcbiAgICAgICAgICAgIF90aGlzLlByaW1pdGl2ZVZhbHVlID0gbmF0aXZlUmVnRXhwO1xuICAgICAgICAgICAgX3RoaXMuUHJpbWl0aXZlTGFiZWwgPSBsO1xuICAgICAgICAgICAgX3RoaXMuRXh0ZW5zaWJsZSA9IHRydWU7XG4gICAgICAgICAgICBfdGhpcy5Qcm90b3R5cGUgPSBuZXcgdmFsdWVzXzEuVmFsdWUobW9uaXRvci5pbnN0YW5jZXMuUmVnRXhwUHJvdG90eXBlLCBib3QpO1xuICAgICAgICAgICAgX3RoaXMuRGVmaW5lT3duUHJvcGVydHkoY29uc3RhbnRzLnNvdXJjZSwgeyB2YWx1ZTogX3RoaXMuUHJpbWl0aXZlVmFsdWUuc291cmNlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGxhYmVsOiBsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF90aGlzLkRlZmluZU93blByb3BlcnR5KGNvbnN0YW50cy5nbG9iYWwsIHsgdmFsdWU6IF90aGlzLlByaW1pdGl2ZVZhbHVlLmdsb2JhbCxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBsYWJlbDogbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfdGhpcy5EZWZpbmVPd25Qcm9wZXJ0eShjb25zdGFudHMuaWdub3JlQ2FzZSwgeyB2YWx1ZTogX3RoaXMuUHJpbWl0aXZlVmFsdWUuaWdub3JlQ2FzZSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBsYWJlbDogbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfdGhpcy5EZWZpbmVPd25Qcm9wZXJ0eShjb25zdGFudHMubXVsdGlsaW5lLCB7IHZhbHVlOiBfdGhpcy5QcmltaXRpdmVWYWx1ZS5tdWx0aWxpbmUsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgbGFiZWw6IGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX3RoaXMuRGVmaW5lT3duUHJvcGVydHkoY29uc3RhbnRzLmxhc3RJbmRleCwgeyB2YWx1ZTogX3RoaXMuUHJpbWl0aXZlVmFsdWUubGFzdEluZGV4LFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgbGFiZWw6IGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSZWdFeHBPYmplY3Q7XG4gICAgfShlY21hLkVjbWEpKTtcbiAgICBSZWdFeHBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdiA9IHRoaXMuUHJpbWl0aXZlVmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICB2YXIgbW9kdWxlID0ge307XG4gICAgbW9kdWxlLlJlZ0V4cE9iamVjdCA9IFJlZ0V4cE9iamVjdDtcbiAgICBtb2R1bGUuYWxsb2NhdGUgPSBhbGxvY2F0ZTtcbiAgICByZXR1cm4gbW9kdWxlO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZ2V4cC5qcy5tYXAiLCIvKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gU2V0KCkge1xuICAgIHRoaXMuZGF0YSA9IHt9O1xuICAgIHZhciB0b0FkZCA9IGFyZ3VtZW50cztcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB2YXIgYXJnID0gYXJndW1lbnRzWzBdO1xuICAgICAgICBpZiAoYXJnIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIHRvQWRkID0gYXJnO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0b0FkZC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgeCA9IHRvQWRkW2ldO1xuICAgICAgICBpZiAoeCBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgICAgdGhpcy51bmlvbih4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWRkKHgpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5TZXQgPSBTZXQ7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBcblNldC5wcm90b3R5cGUuaXRlciA9IGZ1bmN0aW9uIChmKSB7XG4gICAgZm9yICh2YXIgZSBpbiB0aGlzLmRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5oYXNPd25Qcm9wZXJ0eShlKSkge1xuICAgICAgICAgICAgZihlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBcblNldC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gKHRoaXMuaXNTdWJzZXQoeCkgJiYgeC5pc1N1YnNldCh0aGlzKSk7XG59O1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gXG5TZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgdGhpcy5kYXRhW3hdID0gdHJ1ZTtcbn07XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBcblNldC5wcm90b3R5cGUudW5pb24gPSBmdW5jdGlvbiAoeCkge1xuICAgIGZvciAodmFyIGUgaW4geC5kYXRhKSB7XG4gICAgICAgIGlmICh4LmRhdGEuaGFzT3duUHJvcGVydHkoZSkpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVtlXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59O1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gXG5TZXQucHJvdG90eXBlLmRlbCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgZGVsZXRlIHRoaXMuZGF0YVt4XTtcbn07XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBcblNldC5wcm90b3R5cGUuaW50ZXJzZWN0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICBmb3IgKHZhciBlIGluIHRoaXMuZGF0YSkge1xuICAgICAgICBpZiAodGhpcy5kYXRhLmhhc093blByb3BlcnR5KGUpICYmICF4LmRhdGEuaGFzT3duUHJvcGVydHkoZSkpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsKGUpO1xuICAgICAgICB9XG4gICAgfVxufTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFxuU2V0LnByb3RvdHlwZS5pc1N1YnNldCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgZm9yICh2YXIgZSBpbiB4LmRhdGEpIHtcbiAgICAgICAgaWYgKHguZGF0YS5oYXNPd25Qcm9wZXJ0eShlKSAmJiAhdGhpcy5kYXRhLmhhc093blByb3BlcnR5KGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gXG5TZXQucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLmhhc093blByb3BlcnR5KHgpO1xufTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFxuU2V0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYWNjID0gW107XG4gICAgZm9yICh2YXIgeCBpbiB0aGlzLmRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5oYXNPd25Qcm9wZXJ0eSh4KSkge1xuICAgICAgICAgICAgYWNjLnB1c2goeCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFjYy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgc3RyID0gYWNjWzBdO1xuICAgIGZvciAodmFyIGkgPSAxLCBsZW4gPSBhY2MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgc3RyICs9ICcsJyArIGFjY1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXQuanMubWFwIiwiLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIFRPRE86IG1ha2UgU3RhY2sgZ2VuZXJpY1xudmFyIFN0YWNrID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0YWNrKCkge1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBbXTtcbiAgICB9XG4gICAgU3RhY2sucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAodikge1xuICAgICAgICB0aGlzLmNvbnRlbnQucHVzaCh2KTtcbiAgICB9O1xuICAgIFN0YWNrLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQucG9wKCk7XG4gICAgfTtcbiAgICBTdGFjay5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudFt0aGlzLmNvbnRlbnQubGVuZ3RoIC0gMV07XG4gICAgfTtcbiAgICBTdGFjay5wcm90b3R5cGUuZHVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnB1c2godGhpcy5wZWVrKCkpO1xuICAgIH07XG4gICAgU3RhY2sucHJvdG90eXBlLm1hcmtlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHsgbGVuZ3RoOiB0aGlzLmNvbnRlbnQubGVuZ3RoIH07XG4gICAgfTtcbiAgICBTdGFjay5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAobSkge1xuICAgICAgICB0aGlzLmNvbnRlbnQubGVuZ3RoID0gbS5sZW5ndGg7XG4gICAgfTtcbiAgICBTdGFjay5wcm90b3R5cGUuaXRlciA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNvbnRlbnQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGYodGhpcy5jb250ZW50W2ldKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3RhY2sucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChmLCBtKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBtLmxlbmd0aCwgbGVuID0gdGhpcy5jb250ZW50Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRbaV0gPSBmKHRoaXMuY29udGVudFtpXSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0YWNrLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50Lmxlbmd0aDtcbiAgICB9O1xuICAgIFN0YWNrLnByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5sZW5ndGggPT09IDA7XG4gICAgfTtcbiAgICBTdGFjay5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5zbGljZSgwKTtcbiAgICB9O1xuICAgIHJldHVybiBTdGFjaztcbn0oKSk7XG5leHBvcnRzLlN0YWNrID0gU3RhY2s7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdGFjay5qcy5tYXAiLCIvKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLiAqL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbGFiZWwgPSByZXF1aXJlKFwiLi9sYWJlbFwiKTtcbnZhciB2YWx1ZXNfMSA9IHJlcXVpcmUoXCIuL3ZhbHVlc1wiKTtcbnZhciBlY21hID0gcmVxdWlyZShcIi4vZWNtYVwiKTtcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG52YXIgZnVuY3Rpb25fMSA9IHJlcXVpcmUoXCIuL2Z1bmN0aW9uXCIpO1xudmFyIEFycmF5T2JqZWN0XzEgPSByZXF1aXJlKFwiLi9PYmplY3RzL0FycmF5T2JqZWN0XCIpO1xudmFyIEhhc0luc3RhbmNlXzEgPSByZXF1aXJlKFwiLi9IYXNJbnN0YW5jZVwiKTtcbnZhciBUb0ludGVnZXJfMSA9IHJlcXVpcmUoXCIuL0NvbnZlcnNpb24vVG9JbnRlZ2VyXCIpO1xudmFyIFRvVUludDE2XzEgPSByZXF1aXJlKFwiLi9Db252ZXJzaW9uL1RvVUludDE2XCIpO1xudmFyIFRvU3RyaW5nXzEgPSByZXF1aXJlKFwiLi9Db252ZXJzaW9uL1RvU3RyaW5nXCIpO1xudmFyIENoZWNrT2JqZWN0Q29lcmNpYmxlXzEgPSByZXF1aXJlKFwiLi9VdGlsaXR5L0NoZWNrT2JqZWN0Q29lcmNpYmxlXCIpO1xuZXhwb3J0cy5mdW5jdG9yID0gZnVuY3Rpb24gKG1vbml0b3IpIHtcbiAgICB2YXIgZXJyb3IgPSBtb25pdG9yLnJlcXVpcmUoJ2Vycm9yJyk7XG4gICAgdmFyIEVjbWEgPSBlY21hLkVjbWE7XG4gICAgdmFyIExhYmVsID0gbGFiZWwuTGFiZWw7XG4gICAgdmFyIGx1YiA9IGxhYmVsLmx1YjtcbiAgICB2YXIgbGUgPSBsYWJlbC5sZTtcbiAgICB2YXIgYm90ID0gTGFiZWwuYm90O1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIGFsbG9jYXRlKGhvc3QpIHtcbiAgICAgICAgdmFyIHN0cmluZ0NvbnN0cnVjdG9yID0gbmV3IFN0cmluZ0NvbnN0cnVjdG9yKGhvc3QuU3RyaW5nKTtcbiAgICAgICAgdmFyIHN0cmluZ1Byb3RvdHlwZSA9IHN0cmluZ0NvbnN0cnVjdG9yLl9wcm90bztcbiAgICAgICAgcmV0dXJuIHsgU3RyaW5nQ29uc3RydWN0b3I6IHN0cmluZ0NvbnN0cnVjdG9yLFxuICAgICAgICAgICAgU3RyaW5nUHJvdG90eXBlOiBzdHJpbmdQcm90b3R5cGVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gVGhlIFN0cmluZyBDb25zdHJ1Y3RvciwgMTUuNS4yXG4gICAgdmFyIFN0cmluZ0NvbnN0cnVjdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoU3RyaW5nQ29uc3RydWN0b3IsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFN0cmluZ0NvbnN0cnVjdG9yKGhvc3QpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy5Qcm90b3R5cGUgPSBuZXcgdmFsdWVzXzEuVmFsdWUobW9uaXRvci5pbnN0YW5jZXMuRnVuY3Rpb25Qcm90b3R5cGUsIGJvdCk7XG4gICAgICAgICAgICBfdGhpcy5DbGFzcyA9ICdGdW5jdGlvbic7XG4gICAgICAgICAgICAvLyBub3QgbWFuZGF0ZWQgYnkgc3RhbmRhcmRcbiAgICAgICAgICAgIF90aGlzLkV4dGVuc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgX3RoaXMuaG9zdCA9IGhvc3Q7XG4gICAgICAgICAgICBfdGhpcy5fcHJvdG8gPSBuZXcgU3RyaW5nUHJvdG90eXBlKF90aGlzLCBob3N0LnByb3RvdHlwZSk7XG4gICAgICAgICAgICBlY21hLkRlZmluZUZGRihfdGhpcywgY29uc3RhbnRzLmxlbmd0aCwgMSk7XG4gICAgICAgICAgICBlY21hLkRlZmluZUZGRihfdGhpcywgY29uc3RhbnRzLnByb3RvdHlwZSwgX3RoaXMuX3Byb3RvKTtcbiAgICAgICAgICAgIGVjbWEuRGVmaW5lVEZUKF90aGlzLCBjb25zdGFudHMuZnJvbUNoYXJDb2RlLCBuZXcgZnVuY3Rpb25fMS5CdWlsdGluRnVuY3Rpb25PYmplY3QoZnJvbUNoYXJDb2RlLCAxLCBfdGhpcy5ob3N0LmZyb21DaGFyQ29kZSkpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTdHJpbmdDb25zdHJ1Y3RvcjtcbiAgICB9KEVjbWEpKTtcbiAgICBTdHJpbmdDb25zdHJ1Y3Rvci5wcm90b3R5cGUuSGFzSW5zdGFuY2UgPSBIYXNJbnN0YW5jZV8xLkhhc0luc3RhbmNlO1xuICAgIC8vIDE1LjUuMS4xIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgU3RyaW5nQ29uc3RydWN0b3IucHJvdG90eXBlLkNhbGwgPSBmdW5jdGlvbiAodGhpc0FyZywgYXJncykge1xuICAgICAgICBpZiAoIWFyZ3NbMF0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUoJycsIGJvdCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0ciA9IFRvU3RyaW5nXzEuVG9TdHJpbmcoYXJnc1swXSk7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfTtcbiAgICAvLyAxNS41LjIuMSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBcbiAgICBTdHJpbmdDb25zdHJ1Y3Rvci5wcm90b3R5cGUuQ29uc3RydWN0ID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJnc1swXTtcbiAgICAgICAgdmFyIHN0cjtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgeCA9IFRvU3RyaW5nXzEuVG9TdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgc3RyID0gbmV3IFN0cmluZ09iamVjdCh4LnZhbHVlLCB4LmxhYmVsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0ciA9IG5ldyBTdHJpbmdPYmplY3QoJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUoc3RyLCBib3QpO1xuICAgIH07XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBmcm9tQ2hhckNvZGUsIDE1LjUuMy4yIFxuICAgIHZhciBmcm9tQ2hhckNvZGUgPSBmdW5jdGlvbiAodGhpc0FyZywgYXJncykge1xuICAgICAgICB2YXIgbGJsID0gbmV3IExhYmVsKCk7XG4gICAgICAgIHZhciBfYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGFyZyA9IFRvVUludDE2XzEuVG9VSW50MTYoYXJnc1tpXSk7XG4gICAgICAgICAgICBsYmwubHViKGFyZy5sYWJlbCk7XG4gICAgICAgICAgICBfYXJnc1tpXSA9IGFyZy52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX1N0cmluZyA9IG1vbml0b3IuaW5zdGFuY2VzLlN0cmluZ0NvbnN0cnVjdG9yLmhvc3Q7XG4gICAgICAgIHZhciB2ID0gX1N0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoX1N0cmluZywgX2FyZ3MpO1xuICAgICAgICByZXR1cm4gbmV3IHZhbHVlc18xLlZhbHVlKHYsIGxibCk7XG4gICAgfTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBUaGUgU3RyaW5nIFByb3RvdHlwZSwgMTUuNS40XG4gICAgdmFyIFN0cmluZ1Byb3RvdHlwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKFN0cmluZ1Byb3RvdHlwZSwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gU3RyaW5nUHJvdG90eXBlKGNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMuQ2xhc3MgPSAnU3RyaW5nJztcbiAgICAgICAgICAgIF90aGlzLlByaW1pdGl2ZVZhbHVlID0gJyc7XG4gICAgICAgICAgICBfdGhpcy5QcmltaXRpdmVMYWJlbCA9IGJvdDtcbiAgICAgICAgICAgIF90aGlzLlByb3RvdHlwZSA9IG5ldyB2YWx1ZXNfMS5WYWx1ZShtb25pdG9yLmluc3RhbmNlcy5PYmplY3RQcm90b3R5cGUsIGJvdCk7XG4gICAgICAgICAgICBfdGhpcy5wcm9wZXJ0aWVzID0gbmV3IFN0cmluZygnJyk7XG4gICAgICAgICAgICBfdGhpcy5sYWJlbHMubGVuZ3RoID0ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBib3QsXG4gICAgICAgICAgICAgICAgZXhpc3RlbmNlOiBib3RcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfdGhpcy5ob3N0ID0gY29uc3RydWN0b3IuaG9zdC5wcm90b3R5cGU7XG4gICAgICAgICAgICBlY21hLkRlZmluZVRGVChfdGhpcywgY29uc3RhbnRzLmNvbnN0cnVjdG9yLCBjb25zdHJ1Y3Rvcik7XG4gICAgICAgICAgICBlY21hLkRlZmluZVRGVChfdGhpcywgY29uc3RhbnRzLnRvU3RyaW5nLCBuZXcgZnVuY3Rpb25fMS5CdWlsdGluRnVuY3Rpb25PYmplY3QodG9TdHJpbmcsIDAsIF90aGlzLmhvc3QudG9TdHJpbmcpKTtcbiAgICAgICAgICAgIGVjbWEuRGVmaW5lVEZUKF90aGlzLCBuZXcgdmFsdWVzXzEuVmFsdWUoJ3ZhbHVlT2YnLCBib3QpLCBuZXcgZnVuY3Rpb25fMS5CdWlsdGluRnVuY3Rpb25PYmplY3QodmFsdWVPZiwgMCwgX3RoaXMuaG9zdC52YWx1ZU9mKSk7XG4gICAgICAgICAgICBlY21hLkRlZmluZVRGVChfdGhpcywgY29uc3RhbnRzLmNoYXJBdCwgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KGNoYXJBdCwgMSwgX3RoaXMuaG9zdC5jaGFyQXQpKTtcbiAgICAgICAgICAgIGVjbWEuRGVmaW5lVEZUKF90aGlzLCBjb25zdGFudHMuY2hhckNvZGVBdCwgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KGNoYXJDb2RlQXQsIDEsIF90aGlzLmhvc3QuY2hhckNvZGVBdCkpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXMsIGNvbnN0YW50cy5jb25jYXQsIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdChjb25jYXQsIDEsIF90aGlzLmhvc3QuY29uY2F0KSk7XG4gICAgICAgICAgICBlY21hLkRlZmluZVRGVChfdGhpcywgY29uc3RhbnRzLmluZGV4T2YsIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdChpbmRleE9mLCAxLCBfdGhpcy5ob3N0LmluZGV4T2YpKTtcbiAgICAgICAgICAgIGVjbWEuRGVmaW5lVEZUKF90aGlzLCBjb25zdGFudHMubGFzdEluZGV4T2YsIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdChsYXN0SW5kZXhPZiwgMSwgX3RoaXMuaG9zdC5sYXN0SW5kZXhPZikpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXMsIGNvbnN0YW50cy5sb2NhbGVDb21wYXJlLCBuZXcgZnVuY3Rpb25fMS5CdWlsdGluRnVuY3Rpb25PYmplY3QobG9jYWxlQ29tcGFyZSwgMSwgX3RoaXMuaG9zdC5sb2NhbGVDb21wYXJlKSk7XG4gICAgICAgICAgICBlY21hLkRlZmluZVRGVChfdGhpcywgY29uc3RhbnRzLm1hdGNoLCBuZXcgZnVuY3Rpb25fMS5CdWlsdGluRnVuY3Rpb25PYmplY3QobWF0Y2gsIDEsIF90aGlzLmhvc3QubWF0Y2gpKTtcbiAgICAgICAgICAgIGVjbWEuRGVmaW5lVEZUKF90aGlzLCBjb25zdGFudHMucmVwbGFjZSwgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHJlcGxhY2UsIDIsIF90aGlzLmhvc3QucmVwbGFjZSkpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXMsIGNvbnN0YW50cy5zZWFyY2gsIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdChzZWFyY2gsIDEsIF90aGlzLmhvc3Quc2VhcmNoKSk7XG4gICAgICAgICAgICBlY21hLkRlZmluZVRGVChfdGhpcywgY29uc3RhbnRzLnNsaWNlLCBuZXcgZnVuY3Rpb25fMS5CdWlsdGluRnVuY3Rpb25PYmplY3Qoc2xpY2UsIDIsIF90aGlzLmhvc3Quc2xpY2UpKTtcbiAgICAgICAgICAgIGVjbWEuRGVmaW5lVEZUKF90aGlzLCBjb25zdGFudHMuc3BsaXQsIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdChzcGxpdCwgMiwgX3RoaXMuaG9zdC5zcGxpdCkpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXMsIGNvbnN0YW50cy5zdWJzdHJpbmcsIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdChzdWJzdHJpbmcsIDIsIF90aGlzLmhvc3Quc3Vic3RyaW5nKSk7XG4gICAgICAgICAgICBlY21hLkRlZmluZVRGVChfdGhpcywgY29uc3RhbnRzLnRvTG93ZXJDYXNlLCBuZXcgZnVuY3Rpb25fMS5CdWlsdGluRnVuY3Rpb25PYmplY3QodG9Mb3dlckNhc2UsIDAsIF90aGlzLmhvc3QudG9Mb3dlckNhc2UpKTtcbiAgICAgICAgICAgIGVjbWEuRGVmaW5lVEZUKF90aGlzLCBjb25zdGFudHMudG9Mb2NhbGVMb3dlckNhc2UsIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdCh0b0xvY2FsZUxvd2VyQ2FzZSwgMCwgX3RoaXMuaG9zdC50b0xvY2FsZUxvd2VyQ2FzZSkpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXMsIGNvbnN0YW50cy50b1VwcGVyQ2FzZSwgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHRvVXBwZXJDYXNlLCAwLCBfdGhpcy5ob3N0LnRvVXBwZXJDYXNlKSk7XG4gICAgICAgICAgICBlY21hLkRlZmluZVRGVChfdGhpcywgY29uc3RhbnRzLnRvTG9jYWxlVXBwZXJDYXNlLCBuZXcgZnVuY3Rpb25fMS5CdWlsdGluRnVuY3Rpb25PYmplY3QodG9Mb2NhbGVVcHBlckNhc2UsIDAsIF90aGlzLmhvc3QudG9Mb2NhbGVVcHBlckNhc2UpKTtcbiAgICAgICAgICAgIGVjbWEuRGVmaW5lVEZUKF90aGlzLCBjb25zdGFudHMudHJpbSwgbmV3IGZ1bmN0aW9uXzEuQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHRyaW0sIDAsIF90aGlzLmhvc3QudHJpbSkpO1xuICAgICAgICAgICAgZWNtYS5EZWZpbmVURlQoX3RoaXMsIGNvbnN0YW50cy5zdWJzdHIsIG5ldyBmdW5jdGlvbl8xLkJ1aWx0aW5GdW5jdGlvbk9iamVjdChzdWJzdHIsIDIsIF90aGlzLmhvc3Quc3Vic3RyKSk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN0cmluZ1Byb3RvdHlwZTtcbiAgICB9KEVjbWEpKTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyB0b1N0cmluZywgMTUuNS40LjJcbiAgICB2YXIgdG9TdHJpbmcgPSBmdW5jdGlvbiAodGhpc0FyZywgYXJncykge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXNBcmcudmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc0FyZztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRoaXNBcmcudmFsdWUgIT09ICdvYmplY3QnIHx8IHRoaXNBcmcudmFsdWUuQ2xhc3MgIT09ICdTdHJpbmcnKSB7XG4gICAgICAgICAgICBtb25pdG9yLlRocm93KGVycm9yLlR5cGVFcnJvck9iamVjdCwgJ1N0cmluZy5wcm90b3R5cGUudG9TdHJpbmcgaXMgbm90IGdlbmVyaWMnLCB0aGlzQXJnLmxhYmVsKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpc0FyZy52YWx1ZS5QcmltaXRpdmVWYWx1ZS50b1N0cmluZygpO1xuICAgICAgICByZXR1cm4gbmV3IHZhbHVlc18xLlZhbHVlKHJlc3VsdCwgdGhpc0FyZy52YWx1ZS5QcmltaXRpdmVMYWJlbCk7XG4gICAgfTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyB2YWx1ZU9mLCAxNS41LjQuM1xuICAgIHZhciB2YWx1ZU9mID0gdG9TdHJpbmc7XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gY2hhckF0LCAxNS41LjQuNFxuICAgIHZhciBjaGFyQXQgPSBmdW5jdGlvbiAodGhpc0FyZywgYXJncykge1xuICAgICAgICB2YXIgcG9zID0gYXJnc1swXSB8fCBuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgICAgICBDaGVja09iamVjdENvZXJjaWJsZV8xLkNoZWNrT2JqZWN0Q29lcmNpYmxlKHRoaXNBcmcpO1xuICAgICAgICB2YXIgUyA9IFRvU3RyaW5nXzEuVG9TdHJpbmcodGhpc0FyZyk7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IFRvSW50ZWdlcl8xLlRvSW50ZWdlcihwb3MpO1xuICAgICAgICB2YXIgYyA9IFMudmFsdWUuY2hhckF0KHBvc2l0aW9uLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZShjLCBsdWIocG9zaXRpb24ubGFiZWwsIFMubGFiZWwpKTtcbiAgICB9O1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIGNoYXJDb2RlQXQsIDE1LjUuNC41XG4gICAgdmFyIGNoYXJDb2RlQXQgPSBmdW5jdGlvbiAodGhpc0FyZywgYXJncykge1xuICAgICAgICB2YXIgcG9zID0gYXJnc1swXSB8fCBuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgICAgICBDaGVja09iamVjdENvZXJjaWJsZV8xLkNoZWNrT2JqZWN0Q29lcmNpYmxlKHRoaXNBcmcpO1xuICAgICAgICB2YXIgUyA9IFRvU3RyaW5nXzEuVG9TdHJpbmcodGhpc0FyZyk7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IFRvSW50ZWdlcl8xLlRvSW50ZWdlcihwb3MpO1xuICAgICAgICB2YXIgYyA9IFMudmFsdWUuY2hhckNvZGVBdChwb3NpdGlvbi52YWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUoYywgbHViKHBvc2l0aW9uLmxhYmVsLCB0aGlzQXJnLmxhYmVsKSk7XG4gICAgfTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBjb25jYXQsIDE1LjUuNC42XG4gICAgdmFyIGNvbmNhdCA9IGZ1bmN0aW9uICh0aGlzQXJnLCBhcmdzKSB7XG4gICAgICAgIENoZWNrT2JqZWN0Q29lcmNpYmxlXzEuQ2hlY2tPYmplY3RDb2VyY2libGUodGhpc0FyZyk7XG4gICAgICAgIHZhciBTID0gVG9TdHJpbmdfMS5Ub1N0cmluZyh0aGlzQXJnKTtcbiAgICAgICAgdmFyIGxibCA9IG5ldyBMYWJlbCgpO1xuICAgICAgICB2YXIgX2FyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBhcmcgPSBUb1N0cmluZ18xLlRvU3RyaW5nKGFyZ3NbaV0pO1xuICAgICAgICAgICAgbGJsLmx1YihhcmcubGFiZWwpO1xuICAgICAgICAgICAgX2FyZ3NbaV0gPSBhcmcudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0ciA9IFMudmFsdWUuY29uY2F0LmFwcGx5KFMudmFsdWUsIF9hcmdzKTtcbiAgICAgICAgbGJsLmx1Yih0aGlzQXJnLmxhYmVsKTtcbiAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZShzdHIsIGxibCk7XG4gICAgfTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBpbmRleE9mLCAxNS41LjQuN1xuICAgIHZhciBpbmRleE9mID0gZnVuY3Rpb24gKHRoaXNBcmcsIGFyZ3MpIHtcbiAgICAgICAgdmFyIHNlYXJjaFN0cmluZyA9IGFyZ3NbMF0gfHwgbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgYm90KTtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gYXJnc1sxXSB8fCBuZXcgdmFsdWVzXzEuVmFsdWUoMCwgYm90KTtcbiAgICAgICAgQ2hlY2tPYmplY3RDb2VyY2libGVfMS5DaGVja09iamVjdENvZXJjaWJsZSh0aGlzQXJnKTtcbiAgICAgICAgdmFyIFMgPSBUb1N0cmluZ18xLlRvU3RyaW5nKHRoaXNBcmcpO1xuICAgICAgICB2YXIgc2VhcmNoU3RyID0gVG9TdHJpbmdfMS5Ub1N0cmluZyhzZWFyY2hTdHJpbmcpO1xuICAgICAgICB2YXIgcG9zID0gVG9JbnRlZ2VyXzEuVG9JbnRlZ2VyKHBvc2l0aW9uKTtcbiAgICAgICAgdmFyIGxibCA9IGx1YihTLmxhYmVsLCBzZWFyY2hTdHIubGFiZWwsIHBvcy5sYWJlbCk7XG4gICAgICAgIHZhciBzdHIgPSBTLnZhbHVlLmluZGV4T2Yoc2VhcmNoU3RyLnZhbHVlLCBwb3MudmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IHZhbHVlc18xLlZhbHVlKHN0ciwgbGJsKTtcbiAgICB9O1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIGxhc3RJbmRleE9mLCAxNS41LjQuOFxuICAgIHZhciBsYXN0SW5kZXhPZiA9IGZ1bmN0aW9uICh0aGlzQXJnLCBhcmdzKSB7XG4gICAgICAgIHZhciBzZWFyY2hTdHJpbmcgPSBhcmdzWzBdIHx8IG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IGFyZ3NbMV0gfHwgbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgYm90KTtcbiAgICAgICAgQ2hlY2tPYmplY3RDb2VyY2libGVfMS5DaGVja09iamVjdENvZXJjaWJsZSh0aGlzQXJnKTtcbiAgICAgICAgdmFyIFMgPSBUb1N0cmluZ18xLlRvU3RyaW5nKHRoaXNBcmcpO1xuICAgICAgICB2YXIgc2VhcmNoU3RyID0gVG9TdHJpbmdfMS5Ub1N0cmluZyhzZWFyY2hTdHJpbmcpO1xuICAgICAgICB2YXIgcG9zID0gVG9JbnRlZ2VyXzEuVG9JbnRlZ2VyKHBvc2l0aW9uKTtcbiAgICAgICAgdmFyIGxibCA9IGx1YihTLmxhYmVsLCBzZWFyY2hTdHIubGFiZWwsIHBvcy5sYWJlbCk7XG4gICAgICAgIHZhciBzdHIgPSBTLnZhbHVlLmxhc3RJbmRleE9mKHNlYXJjaFN0ci52YWx1ZSwgcG9zLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZShzdHIsIGxibCk7XG4gICAgfTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBsb2NhbGVDb21wYXJlLCAxNS41LjQuOVxuICAgIHZhciBsb2NhbGVDb21wYXJlID0gZnVuY3Rpb24gKHRoaXNBcmcsIGFyZ3MpIHtcbiAgICAgICAgdmFyIHRoYXQgPSBhcmdzWzBdIHx8IG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG4gICAgICAgIENoZWNrT2JqZWN0Q29lcmNpYmxlXzEuQ2hlY2tPYmplY3RDb2VyY2libGUodGhpc0FyZyk7XG4gICAgICAgIHZhciBTID0gVG9TdHJpbmdfMS5Ub1N0cmluZyh0aGlzQXJnKTtcbiAgICAgICAgdGhhdCA9IFRvU3RyaW5nXzEuVG9TdHJpbmcodGhhdCk7XG4gICAgICAgIHZhciBsYmwgPSBsdWIoUy5sYWJlbCwgdGhhdC5sYWJlbCk7XG4gICAgICAgIHZhciByZXN1bHQgPSBTLnZhbHVlLmxvY2FsZUNvbXBhcmUodGhhdC52YWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUocmVzdWx0LCBsYmwpO1xuICAgIH07XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gbWF0Y2gsIDE1LjUuNC4xMFxuICAgIHZhciBtYXRjaCA9IGZ1bmN0aW9uICh0aGlzQXJnLCBhcmdzKSB7XG4gICAgICAgIHZhciByZWdleHAgPSBhcmdzWzBdIHx8IG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG4gICAgICAgIENoZWNrT2JqZWN0Q29lcmNpYmxlXzEuQ2hlY2tPYmplY3RDb2VyY2libGUodGhpc0FyZyk7XG4gICAgICAgIHZhciBTID0gVG9TdHJpbmdfMS5Ub1N0cmluZyh0aGlzQXJnKTtcbiAgICAgICAgdmFyIHJ4ID0gcmVnZXhwO1xuICAgICAgICBpZiAocngudmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHJ4LnZhbHVlICE9PSAnb2JqZWN0JyB8fCByeC52YWx1ZS5DbGFzcyAhPT0gJ1JlZ0V4cCcpIHtcbiAgICAgICAgICAgIHJ4ID0gbW9uaXRvci5pbnN0YW5jZXMuUmVnRXhwQ29uc3RydWN0b3IuQ29uc3RydWN0KFtyZWdleHBdKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGJsID0gbHViKFMubGFiZWwsIHJ4LnZhbHVlLlByaW1pdGl2ZUxhYmVsKTtcbiAgICAgICAgbW9uaXRvci5hc3NlcnQobGUocngubGFiZWwsIHJ4LnZhbHVlLlByaW1pdGl2ZUxhYmVsKSwgJ1N0cmluZy5wcm90b3R5cGUubWF0Y2g6IGxhYmVsIG9mIHJlZ3VsYXIgZXhwcmVzc2lvbiBvYmplY3Qgbm90IGJlbG93IHJlZ3VsYXIgZXhwcmVzc2lvbiBsYWJlbCcpO1xuICAgICAgICByeC52YWx1ZS5QcmltaXRpdmVMYWJlbCA9IGxibDtcbiAgICAgICAgdmFyIHByaW1pdGl2ZUFycmF5ID0gUy52YWx1ZS5tYXRjaChyeC52YWx1ZS5QcmltaXRpdmVWYWx1ZSk7XG4gICAgICAgIGlmIChwcmltaXRpdmVBcnJheSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZShudWxsLCBsYmwpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhcnJheSA9IEFycmF5T2JqZWN0XzEuQXJyYXlPYmplY3QuZnJvbUFycmF5KHByaW1pdGl2ZUFycmF5LCBsYmwsIGxibCk7XG4gICAgICAgIGFycmF5LkRlZmluZU93blByb3BlcnR5KGNvbnN0YW50cy5pbmRleCwgeyB2YWx1ZTogcHJpbWl0aXZlQXJyYXkuaW5kZXgsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBsYWJlbDogbGJsXG4gICAgICAgIH0pO1xuICAgICAgICBhcnJheS5EZWZpbmVPd25Qcm9wZXJ0eShjb25zdGFudHMuaW5wdXQsIHsgdmFsdWU6IHByaW1pdGl2ZUFycmF5LmlucHV0LFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgbGFiZWw6IGxibFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZShhcnJheSwgYm90KTtcbiAgICB9O1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIHJlcGxhY2UsIDE1LjUuNC4xMVxuICAgIHZhciByZXBsYWNlID0gZnVuY3Rpb24gKHRoaXNBcmcsIGFyZ3MpIHtcbiAgICAgICAgdmFyIHNlYXJjaFZhbHVlID0gYXJnc1swXSB8fCBuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgICAgICB2YXIgcmVwbGFjZVZhbHVlID0gYXJnc1sxXSB8fCBuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgICAgICBDaGVja09iamVjdENvZXJjaWJsZV8xLkNoZWNrT2JqZWN0Q29lcmNpYmxlKHRoaXNBcmcpO1xuICAgICAgICB2YXIgUyA9IFRvU3RyaW5nXzEuVG9TdHJpbmcodGhpc0FyZyk7XG4gICAgICAgIHZhciBzViwgclY7XG4gICAgICAgIGlmICh0eXBlb2Ygc2VhcmNoVmFsdWUudmFsdWUgPT09ICdvYmplY3QnICYmIHNlYXJjaFZhbHVlLnZhbHVlLkNsYXNzID09PSAnUmVnRXhwJykge1xuICAgICAgICAgICAgc1YgPSBzZWFyY2hWYWx1ZS52YWx1ZS5QcmltaXRpdmVWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlYXJjaFZhbHVlID0gVG9TdHJpbmdfMS5Ub1N0cmluZyhzZWFyY2hWYWx1ZSk7XG4gICAgICAgICAgICBzViA9IHNlYXJjaFZhbHVlLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmTCA9IGJvdDtcbiAgICAgICAgaWYgKHR5cGVvZiByZXBsYWNlVmFsdWUudmFsdWUgPT09ICdvYmplY3QnICYmIHJlcGxhY2VWYWx1ZS52YWx1ZS5DbGFzcyA9PT0gJ0Z1bmN0aW9uJykge1xuICAgICAgICAgICAgclYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGwgPSBsdWIoc2VhcmNoVmFsdWUubGFiZWwsIHJlcGxhY2VWYWx1ZS5sYWJlbCk7XG4gICAgICAgICAgICAgICAgdmFyIF9hcmdzID0ge307XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgX2FyZ3NbaV0gPSBuZXcgdmFsdWVzXzEuVmFsdWUoYXJndW1lbnRzW2ldLCBsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX2FyZ3MubGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gcmVwbGFjZVZhbHVlLkNhbGwocmVwbGFjZVZhbHVlLCBfYXJncyk7XG4gICAgICAgICAgICAgICAgZkwgPSBsdWIoZkwsIHJlcy5sYWJlbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcy52YWx1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXBsYWNlVmFsdWUgPSBUb1N0cmluZ18xLlRvU3RyaW5nKHJlcGxhY2VWYWx1ZSk7XG4gICAgICAgICAgICByViA9IHJlcGxhY2VWYWx1ZS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbCA9IGx1YihzZWFyY2hWYWx1ZS5sYWJlbCwgcmVwbGFjZVZhbHVlLmxhYmVsKTtcbiAgICAgICAgdmFyIHJlcyA9IFMudmFsdWUucmVwbGFjZShzViwgclYpO1xuICAgICAgICByZXR1cm4gbmV3IHZhbHVlc18xLlZhbHVlKHJlcywgbHViKGwsIGZMKSk7XG4gICAgfTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBzZWFyY2gsIDE1LjUuNC4xMlxuICAgIHZhciBzZWFyY2ggPSBmdW5jdGlvbiAodGhpc0FyZywgYXJncykge1xuICAgICAgICB2YXIgcmVnZXhwID0gYXJnc1swXSB8fCBuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgICAgICBDaGVja09iamVjdENvZXJjaWJsZV8xLkNoZWNrT2JqZWN0Q29lcmNpYmxlKHRoaXNBcmcpO1xuICAgICAgICB2YXIgc3RyaW5nID0gVG9TdHJpbmdfMS5Ub1N0cmluZyh0aGlzQXJnKTtcbiAgICAgICAgdmFyIHJ4ID0gcmVnZXhwO1xuICAgICAgICBpZiAocngudmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHJlZ2V4cC52YWx1ZSAhPT0gJ29iamVjdCcgfHwgcmVnZXhwLnZhbHVlLkNsYXNzICE9PSAnUmVnRXhwJykge1xuICAgICAgICAgICAgcnggPSBtb25pdG9yLmluc3RhbmNlcy5SZWdFeHBDb25zdHJ1Y3Rvci5Db25zdHJ1Y3QoW3JlZ2V4cF0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsYmwgPSBsdWIoc3RyaW5nLmxhYmVsLCByeC52YWx1ZS5QcmltaXRpdmVMYWJlbCk7XG4gICAgICAgIG1vbml0b3IuYXNzZXJ0KGxlKHJ4LmxhYmVsLCByeC52YWx1ZS5QcmltaXRpdmVMYWJlbCksICdTdHJpbmcucHJvdG90eXBlLm1hdGNoOiBsYWJlbCBvZiByZWd1bGFyIGV4cHJlc3Npb24gb2JqZWN0IG5vdCBiZWxvdyByZWd1bGFyIGV4cHJlc3Npb24gbGFiZWwnKTtcbiAgICAgICAgcngudmFsdWUuUHJpbWl0aXZlTGFiZWwgPSBsYmw7XG4gICAgICAgIHZhciByZXN1bHQgPSBzdHJpbmcudmFsdWUuc2VhcmNoKHJ4LnZhbHVlLlByaW1pdGl2ZVZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZShyZXN1bHQsIGxibCk7XG4gICAgfTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBzbGljZSwgMTUuNS40LjEzXG4gICAgdmFyIHNsaWNlID0gZnVuY3Rpb24gKHRoaXNBcmcsIGFyZ3MpIHtcbiAgICAgICAgdmFyIGMgPSBtb25pdG9yLmNvbnRleHQ7XG4gICAgICAgIHZhciBzdGFydCA9IGFyZ3NbMF0gfHwgbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgYm90KTtcbiAgICAgICAgdmFyIGVuZCA9IGFyZ3NbMV0gfHwgbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgYm90KTtcbiAgICAgICAgQ2hlY2tPYmplY3RDb2VyY2libGVfMS5DaGVja09iamVjdENvZXJjaWJsZSh0aGlzQXJnKTtcbiAgICAgICAgdmFyIFMgPSBUb1N0cmluZ18xLlRvU3RyaW5nKHRoaXNBcmcpO1xuICAgICAgICB2YXIgbGVuID0gUy52YWx1ZS5sZW5ndGg7XG4gICAgICAgIHZhciBpbnRTdGFydCA9IFRvSW50ZWdlcl8xLlRvSW50ZWdlcihzdGFydCk7XG4gICAgICAgIGMucHVzaFBDKGVuZC5sYWJlbCk7XG4gICAgICAgIGlmIChlbmQudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZW5kID0gbmV3IHZhbHVlc18xLlZhbHVlKGxlbiwgbHViKFMubGFiZWwsIGVuZC5sYWJlbCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZW5kID0gVG9JbnRlZ2VyXzEuVG9JbnRlZ2VyKGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgYy5wb3BQQygpO1xuICAgICAgICB2YXIgc3RyID0gUy52YWx1ZS5zbGljZShzdGFydC52YWx1ZSwgZW5kLnZhbHVlKTtcbiAgICAgICAgdmFyIGxibCA9IGx1YihTLmxhYmVsLCBzdGFydC5sYWJlbCwgZW5kLmxhYmVsKTtcbiAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZShzdHIsIGxibCk7XG4gICAgfTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBzcGxpdCwgMTUuNS40LjE0XG4gICAgdmFyIHNwbGl0ID0gZnVuY3Rpb24gKHRoaXNBcmcsIGFyZ3MpIHtcbiAgICAgICAgdmFyIHNlcGFyYXRvciA9IGFyZ3NbMF0gfHwgbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgYm90KTtcbiAgICAgICAgdmFyIGxpbWl0ID0gYXJnc1sxXSB8fCBuZXcgdmFsdWVzXzEuVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgICAgICBDaGVja09iamVjdENvZXJjaWJsZV8xLkNoZWNrT2JqZWN0Q29lcmNpYmxlKHRoaXNBcmcpO1xuICAgICAgICB2YXIgUyA9IFRvU3RyaW5nXzEuVG9TdHJpbmcodGhpc0FyZyk7XG4gICAgICAgIHZhciBzZXA7XG4gICAgICAgIHZhciBsYmwgPSBsdWIoUy5sYWJlbCwgc2VwYXJhdG9yLmxhYmVsKTtcbiAgICAgICAgaWYgKHNlcGFyYXRvci52YWx1ZSAmJiB0eXBlb2Ygc2VwYXJhdG9yLnZhbHVlID09PSAnb2JqZWN0JyAmJiBzZXBhcmF0b3IudmFsdWUuQ2xhc3MgPT09ICdSZWdFeHAnKSB7XG4gICAgICAgICAgICBzZXAgPSBzZXBhcmF0b3IudmFsdWUuUHJpbWl0aXZlVmFsdWU7XG4gICAgICAgICAgICBtb25pdG9yLmFzc2VydChsZShzZXBhcmF0b3IubGFiZWwsIHNlcGFyYXRvci52YWx1ZS5QcmltaXRpdmVMYWJlbCksICdTdHJpbmcucHJvdG90eXBlLnNwbGl0OiBsYWJlbCBvZiByZWd1bGFyIGV4cHJlc3Npb24gb2JqZWN0IG5vdCBiZWxvdyBsYWJlbCBvZiByZWd1bGFyIGV4cHJlc3Npb24nKTtcbiAgICAgICAgICAgIHNlcGFyYXRvci52YWx1ZS5QcmltaXRpdmVMYWJlbCA9IGxibDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlcGFyYXRvciA9IFRvU3RyaW5nXzEuVG9TdHJpbmcoc2VwYXJhdG9yKTtcbiAgICAgICAgICAgIHNlcCA9IHNlcGFyYXRvci52YWx1ZTtcbiAgICAgICAgICAgIGxibC5sdWIoc2VwYXJhdG9yLmxhYmVsKTtcbiAgICAgICAgfVxuICAgICAgICBsYmwubHViKGxpbWl0LmxhYmVsKTtcbiAgICAgICAgdmFyIHByaW1pdGl2ZUFycmF5ID0gUy52YWx1ZS5zcGxpdChzZXAsIGxpbWl0LnZhbHVlKTtcbiAgICAgICAgdmFyIGFycmF5ID0gQXJyYXlPYmplY3RfMS5BcnJheU9iamVjdC5mcm9tQXJyYXkocHJpbWl0aXZlQXJyYXksIGxibCwgbGJsKTtcbiAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZShhcnJheSwgYm90KTtcbiAgICB9O1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIHN1YnN0cmluZywgMTUuNS40LjE1XG4gICAgdmFyIHN1YnN0cmluZyA9IGZ1bmN0aW9uICh0aGlzQXJnLCBhcmdzKSB7XG4gICAgICAgIHZhciBzdGFydCA9IGFyZ3NbMF0gfHwgbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgYm90KTtcbiAgICAgICAgdmFyIGVuZCA9IGFyZ3NbMV0gfHwgbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgYm90KTtcbiAgICAgICAgQ2hlY2tPYmplY3RDb2VyY2libGVfMS5DaGVja09iamVjdENvZXJjaWJsZSh0aGlzQXJnKTtcbiAgICAgICAgdmFyIFMgPSBUb1N0cmluZ18xLlRvU3RyaW5nKHRoaXNBcmcpO1xuICAgICAgICBzdGFydCA9IFRvSW50ZWdlcl8xLlRvSW50ZWdlcihzdGFydCk7XG4gICAgICAgIHZhciBsZW4gPSBTLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgaWYgKGVuZC52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlbmQudmFsdWUgPSBsZW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbmQgPSBUb0ludGVnZXJfMS5Ub0ludGVnZXIoZW5kKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGJsID0gbHViKFMubGFiZWwsIHN0YXJ0LmxhYmVsLCBlbmQubGFiZWwpO1xuICAgICAgICB2YXIgc3RyID0gUy52YWx1ZS5zdWJzdHJpbmcoc3RhcnQudmFsdWUsIGVuZC52YWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUoc3RyLCBsYmwpO1xuICAgIH07XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgdmFyIHN1YnN0ciA9IGZ1bmN0aW9uICh0aGlzQXJnLCBhcmdzKSB7XG4gICAgICAgIHZhciBzdGFydCA9IGFyZ3NbMF0gfHwgbmV3IHZhbHVlc18xLlZhbHVlKHVuZGVmaW5lZCwgMCk7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcmdzWzFdIHx8IG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIDApO1xuICAgICAgICBDaGVja09iamVjdENvZXJjaWJsZV8xLkNoZWNrT2JqZWN0Q29lcmNpYmxlKHRoaXNBcmcpO1xuICAgICAgICB2YXIgUyA9IFRvU3RyaW5nXzEuVG9TdHJpbmcodGhpc0FyZyk7XG4gICAgICAgIHN0YXJ0ID0gVG9JbnRlZ2VyXzEuVG9JbnRlZ2VyKHN0YXJ0KTtcbiAgICAgICAgaWYgKGxlbmd0aC52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZW5ndGgudmFsdWUgPSBsZW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZW5ndGggPSBUb0ludGVnZXJfMS5Ub0ludGVnZXIobGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGJsID0gbHViKFMubGFiZWwsIHN0YXJ0LmxhYmVsLCBsZW5ndGgubGFiZWwpO1xuICAgICAgICB2YXIgc3RyID0gUy52YWx1ZS5zdWJzdHIoc3RhcnQudmFsdWUsIGxlbmd0aC52YWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUoc3RyLCBsYmwpO1xuICAgIH07XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gdG9Mb3dlckNhc2UsIDE1LjUuNC4xNlxuICAgIHZhciB0b0xvd2VyQ2FzZSA9IGZ1bmN0aW9uICh0aGlzQXJnLCBhcmdzKSB7XG4gICAgICAgIENoZWNrT2JqZWN0Q29lcmNpYmxlXzEuQ2hlY2tPYmplY3RDb2VyY2libGUodGhpc0FyZyk7XG4gICAgICAgIHZhciBTID0gVG9TdHJpbmdfMS5Ub1N0cmluZyh0aGlzQXJnKTtcbiAgICAgICAgdmFyIEwgPSBTLnZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUoTCwgUy5sYWJlbCk7XG4gICAgfTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyB0b0xvY2FsZUxvd2VyQ2FzZSwgMTUuNS40LjE3XG4gICAgdmFyIHRvTG9jYWxlTG93ZXJDYXNlID0gZnVuY3Rpb24gKHRoaXNBcmcsIGFyZ3MpIHtcbiAgICAgICAgQ2hlY2tPYmplY3RDb2VyY2libGVfMS5DaGVja09iamVjdENvZXJjaWJsZSh0aGlzQXJnKTtcbiAgICAgICAgdmFyIFMgPSBUb1N0cmluZ18xLlRvU3RyaW5nKHRoaXNBcmcpO1xuICAgICAgICB2YXIgTCA9IFMudmFsdWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZShMLCBTLmxhYmVsKTtcbiAgICB9O1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIHRvVXBwZXJDYXNlLCAxNS41LjQuMThcbiAgICB2YXIgdG9VcHBlckNhc2UgPSBmdW5jdGlvbiAodGhpc0FyZywgYXJncykge1xuICAgICAgICBDaGVja09iamVjdENvZXJjaWJsZV8xLkNoZWNrT2JqZWN0Q29lcmNpYmxlKHRoaXNBcmcpO1xuICAgICAgICB2YXIgUyA9IFRvU3RyaW5nXzEuVG9TdHJpbmcodGhpc0FyZyk7XG4gICAgICAgIHZhciBMID0gUy52YWx1ZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gbmV3IHZhbHVlc18xLlZhbHVlKEwsIFMubGFiZWwpO1xuICAgIH07XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gdG9Mb2NhbGVVcHBlckNhc2UsIDE1LjUuNC4xOVxuICAgIHZhciB0b0xvY2FsZVVwcGVyQ2FzZSA9IGZ1bmN0aW9uICh0aGlzQXJnLCBhcmdzKSB7XG4gICAgICAgIENoZWNrT2JqZWN0Q29lcmNpYmxlXzEuQ2hlY2tPYmplY3RDb2VyY2libGUodGhpc0FyZyk7XG4gICAgICAgIHZhciBTID0gVG9TdHJpbmdfMS5Ub1N0cmluZyh0aGlzQXJnKTtcbiAgICAgICAgdmFyIEwgPSBTLnZhbHVlLnRvTG9jYWxlVXBwZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUoTCwgUy5sYWJlbCk7XG4gICAgfTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyB0cmltLCAxNS41LjQuMjBcbiAgICB2YXIgdHJpbSA9IGZ1bmN0aW9uICh0aGlzQXJnLCBhcmdzKSB7XG4gICAgICAgIENoZWNrT2JqZWN0Q29lcmNpYmxlXzEuQ2hlY2tPYmplY3RDb2VyY2libGUodGhpc0FyZyk7XG4gICAgICAgIHZhciBTID0gVG9TdHJpbmdfMS5Ub1N0cmluZyh0aGlzQXJnKTtcbiAgICAgICAgdmFyIFQgPSBTLnZhbHVlLnRyaW0oKTtcbiAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZShULCBTLmxhYmVsKTtcbiAgICB9O1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFN0cmluZyBPYmplY3QsIDE1LjUuNVxuICAgIHZhciBTdHJpbmdPYmplY3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhTdHJpbmdPYmplY3QsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFN0cmluZ09iamVjdCh2YWwsIGxibCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLkNsYXNzID0gJ1N0cmluZyc7XG4gICAgICAgICAgICBfdGhpcy5QcmltaXRpdmVWYWx1ZSA9IHZhbDtcbiAgICAgICAgICAgIGxibCA9IGxibCB8fCBib3Q7XG4gICAgICAgICAgICBfdGhpcy5QcmltaXRpdmVMYWJlbCA9IGxibDtcbiAgICAgICAgICAgIF90aGlzLnByb3BlcnRpZXMgPSBuZXcgU3RyaW5nKHZhbCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdmFsLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubGFiZWxzW2ldID0ge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbGJsLFxuICAgICAgICAgICAgICAgICAgICBleGlzdGVuY2U6IGxibFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5sYWJlbHMubGVuZ3RoID0ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBsYmwsXG4gICAgICAgICAgICAgICAgZXhpc3RlbmNlOiBsYmxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfdGhpcy5FeHRlbnNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIF90aGlzLlByb3RvdHlwZSA9IG5ldyB2YWx1ZXNfMS5WYWx1ZShtb25pdG9yLmluc3RhbmNlcy5TdHJpbmdQcm90b3R5cGUsIGJvdCk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgICAgICAvLyBsZW5ndGggaXMgbm90IG1vZGVsZWQgaW4gdGhpcyB3YXksIGJ1dCBieSBHZXRPd25Qcm9wZXJ0eTsgaG93ZXZlciwgZS5nLixcbiAgICAgICAgICAgIC8vIGRlbGV0ZSB3aWxsIHVzZSB0aGUgcHJvcGVydGllcyBmaWVsZCBmb3IgZGVsZXRpb24uIFRodXMsIHdlIGFkZCBhIGZha2UgbW9kZWwuXG4gICAgICAgICAgICAvLyAgIGVjbWEuRGVmaW5lRkZGKHRoaXMsIGNvbnN0YW50cy5sZW5ndGgsIDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTdHJpbmdPYmplY3Q7XG4gICAgfShFY21hKSk7XG4gICAgLy8gLS0tXG4gICAgLy8gVE9ETzogd2UgZG9uJ3QgY29weSBvdGhlciBwcm9wZXJ0aWVzIG9uIHRoZSBTdHJpbmdzXG4gICAgLypcbiAgICAgIFN0cmluZ09iamVjdC5wcm90b3R5cGUudG9OYXRpdmUgPSBmdW5jdGlvbihkZWVwKSB7XG4gICAgICAgIHZhciB2ID0gbmV3IFN0cmluZyh0aGlzLnByb3BlcnRpZXMpO1xuICAgICAgICByZXR1cm4gbmV3IFZhbHVlKHYsIHRoaXMuUHJpbWl0aXZlTGFiZWwpO1xuICAgICAgfTtcbiAgICAqL1xuICAgIC8vIC0tLVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHZhciBtb2R1bGUgPSB7fTtcbiAgICBtb2R1bGUuU3RyaW5nT2JqZWN0ID0gU3RyaW5nT2JqZWN0O1xuICAgIG1vZHVsZS5hbGxvY2F0ZSA9IGFsbG9jYXRlO1xuICAgIHJldHVybiBtb2R1bGU7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyaW5nLmpzLm1hcCIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG1vbml0b3JfMSA9IHJlcXVpcmUoXCIuLi9tb25pdG9yXCIpO1xudmFyIHBvbGljeV8xID0gcmVxdWlyZShcIi4uL3BvbGljeVwiKTtcbnZhciBwcmVsdWRlID0gcmVxdWlyZShcIi4uLy4uL3ByZWx1ZGVcIik7XG52YXIgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xudmFyIGZzID0gcmVxdWlyZShcImZzXCIpO1xudmFyIGltcG9ydHMgPSB7XG4gICAgd2luZG93OiByZXF1aXJlKCcuL3dpbmRvdycpXG59O1xudmFyIENocm9tZU1vbml0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENocm9tZU1vbml0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2hyb21lTW9uaXRvcihnbG9iYWwsIHByaW50LCBsb2csIHdhcm4sIGVycm9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGdsb2JhbCwgcHJpbnQsIGxvZywgd2FybiwgZXJyb3IpIHx8IHRoaXM7XG4gICAgICAgIC8vIHNldHVwIGRvbSBzcGVjaWZpYyBtb2R1bGVzXG4gICAgICAgIF90aGlzLm1vZHVsZXMuY2hyb21lID0ge307XG4gICAgICAgIHZhciBsb2FkID0gW1xuICAgICAgICAgICAgJ3dpbmRvdydcbiAgICAgICAgXTtcbiAgICAgICAgX3RoaXMuc2V0dXAoX3RoaXMubW9kdWxlcy5jaHJvbWUsIGxvYWQsIGltcG9ydHMpO1xuICAgICAgICBfdGhpcy5pbml0aWFsaXplKGdsb2JhbCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ2hyb21lTW9uaXRvci5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChnbG9iYWwpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgZ2xvYmFsKTtcbiAgICAgICAgdmFyIHBvbGljaWVzID0gSlNPTi5wYXJzZShmcy5yZWFkRmlsZVN5bmMocGF0aC5qb2luKF9fZGlybmFtZSwgJy4uLy4uLy4uL3BvbGljaWVzL2Nocm9tZS1wb2xpY3kuanNvbicpLCAndXRmOCcpKTtcbiAgICAgICAgdGhpcy5wb2xpY3kgPSBuZXcgcG9saWN5XzEuU2VjdXJpdHlQb2xpY3kocG9saWNpZXMpO1xuICAgICAgICB2YXIgZ2xvYmFsSW5zdGFuY2UgPSB0aGlzLm1vZHVsZXMuY2hyb21lLndpbmRvdy5hbGxvY2F0ZShnbG9iYWwpO1xuICAgICAgICBwcmVsdWRlLmNvcHkoZ2xvYmFsSW5zdGFuY2UsIHRoaXMuaW5zdGFuY2VzKTtcbiAgICAgICAgdGhpcy5lbnRpdHltYXAuc2V0KHRoaXMuaW5zdGFuY2VzLmdsb2JhbE9iamVjdC5ob3N0LCB0aGlzLmluc3RhbmNlcy5nbG9iYWxPYmplY3QpO1xuICAgICAgICB0aGlzLm1vZHVsZXMuZXhlYy5pbml0aWFsaXplKCk7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH07XG4gICAgO1xuICAgIHJldHVybiBDaHJvbWVNb25pdG9yO1xufShtb25pdG9yXzEuV3JhcHBlck1vbml0b3JCYXNlKSk7XG5leHBvcnRzLkNocm9tZU1vbml0b3IgPSBDaHJvbWVNb25pdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9uaXRvci5qcy5tYXAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZW50aXR5XzEgPSByZXF1aXJlKFwiLi4vZW50aXR5XCIpO1xudmFyIGVjbWEgPSByZXF1aXJlKFwiLi4vLi4vZWNtYVwiKTtcbnZhciB2YWx1ZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi92YWx1ZXNcIik7XG5leHBvcnRzLmZ1bmN0b3IgPSBmdW5jdGlvbiAobW9uaXRvcikge1xuICAgIHZhciBnbG9iYWwgPSBtb25pdG9yLnJlcXVpcmUoJ2dsb2JhbCcpO1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFxuICAgIGZ1bmN0aW9uIGFsbG9jYXRlKGhvc3QpIHtcbiAgICAgICAgdmFyIHdvID0gbmV3IFdpbmRvd09iamVjdChob3N0KTtcbiAgICAgICAgcmV0dXJuIHsgZ2xvYmFsT2JqZWN0OiB3byB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYXNfb3duX3Byb3BlcnR5KG9iaiwgcHJvcCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFxuICAgIHZhciBXaW5kb3dPYmplY3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhXaW5kb3dPYmplY3QsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFdpbmRvd09iamVjdChob3N0KSB7XG4gICAgICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGhvc3QpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy5wcmVkZWZpbmVkID0ge307XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXMoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoX3RoaXMucHJvcGVydGllcykpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwID0gX2MudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnByZWRlZmluZWRbcF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLm1vZGVsc3RhdGUgPSBtb25pdG9yLnBvbGljeS5nbG9iYWxtb2RlbHN0YXRlO1xuICAgICAgICAgICAgbW9uaXRvci5lbnRpdHltYXAuc2V0KGhvc3QsIF90aGlzKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBkZWZhdWx0IHBvbGljeSBcbiAgICAgICAgLy8gMS4gcmVhZCB0aHJvdWdoIGRpc2FibGVkIGZvciBwcmVkZWZpbmVkIHByb3BlcnRpZXNcbiAgICAgICAgLy8gMi4gcmVhZC10aHJvdWdoIGRpc2FibGVkIGZvciBKU0Zsb3cgZGVmaW5lZCBwcm9wZXJ0aWVzXG4gICAgICAgIFdpbmRvd09iamVjdC5wcm90b3R5cGUuR2V0T3duUHJvcGVydHkgPSBmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgaWYgKCFoYXNfb3duX3Byb3BlcnR5KHRoaXMuaG9zdCwgcC52YWx1ZSlcbiAgICAgICAgICAgICAgICB8fCBoYXNfb3duX3Byb3BlcnR5KHRoaXMucHJlZGVmaW5lZCwgcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5HZXRPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsIHApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHByb3BlcnR5TGFiZWxlciA9IG1vbml0b3IucG9saWN5Lmdsb2JhbC5HZXRQcm9wZXJ0eUxhYmVsZXIocC52YWx1ZSk7XG4gICAgICAgICAgICB2YXIgbGFiZWwgPSBwcm9wZXJ0eUxhYmVsZXIuTGFiZWxlci5MYWJlbCh0aGlzLm1vZGVsc3RhdGUpO1xuICAgICAgICAgICAgaWYgKCFoYXNfb3duX3Byb3BlcnR5KHRoaXMubGFiZWxzLCBwLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGFiZWxzW3AudmFsdWVdID0ge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbGFiZWwsXG4gICAgICAgICAgICAgICAgICAgIGV4aXN0ZW5jZTogcC5sYWJlbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIganNkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0aGlzLmhvc3QsIHAudmFsdWUpO1xuICAgICAgICAgICAgaWYgKGpzZGVzYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIGxhYmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNfb3duX3Byb3BlcnR5KHRoaXMucHJvcGVydGllcywgcC52YWx1ZSlcbiAgICAgICAgICAgICAgICAmJiAoZWNtYS5Jc0RhdGFEZXNjcmlwdG9yKGpzZGVzYykgJiYgIWpzZGVzYy53cml0YWJsZSB8fFxuICAgICAgICAgICAgICAgICAgICBlY21hLklzQWNjZXNzb3JEZXNjcmlwdG9yKGpzZGVzYykgJiYgIWpzZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gbm9uLXdyaXRhYmxlIHByb3BlcnQgb3Igbm9uLWNvbmZpZ3VyYWJsZSBhY2Nlc3NvciBtZWFucyBjYW5ub3QgYmUgdXBkYXRlZFxuICAgICAgICAgICAgICAgIC8vIHJldHVybiB3aGF0IGlzIHRoZXJlICAgICAgICAgICBcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5HZXRPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsIHApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRlc2MgPSBlbnRpdHlfMS5yZWxhYmVsUHJvcGVydHlEZXNjcmlwdG9yKGpzZGVzYywgcHJvcGVydHlMYWJlbGVyLlJlYWRMYWJlbGVyLCB0aGlzLm1vZGVsc3RhdGUpO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMucHJvcGVydGllcywgcC52YWx1ZSwgZGVzYyk7XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5HZXRPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsIHApO1xuICAgICAgICB9O1xuICAgICAgICAvLyBkZWZhdWx0IHBvbGljeSBcbiAgICAgICAgLy8gMS4gd3JpdGUgdGhyb3VnaCBkaXNhYmxlZCBmb3IgcHJlZGVmaW5lZCBwcm9wZXJ0aWVzXG4gICAgICAgIC8vIDIuIHdyaXRlIHRocm91Z2ggZGlzYWJsZWQgZm9yIEpTRmxvdyBkZWZpbmVkIHByb3BlcnRpZXNcbiAgICAgICAgV2luZG93T2JqZWN0LnByb3RvdHlwZS5EZWZpbmVPd25Qcm9wZXJ0eSA9IGZ1bmN0aW9uIChwLCBkZXNjLCBUaHJvdykge1xuICAgICAgICAgICAgaWYgKGhhc19vd25fcHJvcGVydHkodGhpcy5wcmVkZWZpbmVkLCBwLnZhbHVlKVxuICAgICAgICAgICAgICAgIHx8ICFoYXNfb3duX3Byb3BlcnR5KHRoaXMuaG9zdCwgcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5EZWZpbmVPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsIHAsIGRlc2MsIFRocm93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eUxhYmVsZXIgPSBtb25pdG9yLnBvbGljeS5nbG9iYWwuR2V0UHJvcGVydHlMYWJlbGVyKHAudmFsdWUpO1xuICAgICAgICAgICAgaWYgKCFoYXNfb3duX3Byb3BlcnR5KHRoaXMubGFiZWxzLCBwLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhciBsYWJlbCA9IHByb3BlcnR5TGFiZWxlci5MYWJlbGVyLkxhYmVsKHRoaXMubW9kZWxzdGF0ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5sYWJlbHNbcC52YWx1ZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBsYWJlbCxcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RlbmNlOiBwLmxhYmVsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBqc2Rlc2MgPSBlbnRpdHlfMS51bmxhYmVsUHJvcGVydHlEZXNjcmlwdG9yKGRlc2MsIHByb3BlcnR5TGFiZWxlci5Xcml0ZVVubGFiZWxlciwgdGhpcy5tb2RlbHN0YXRlKTtcbiAgICAgICAgICAgIHZhciBob3N0UmVzdWx0ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuaG9zdCwgcC52YWx1ZSwganNkZXNjKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBfc3VwZXIucHJvdG90eXBlLkRlZmluZU93blByb3BlcnR5LmNhbGwodGhpcywgcCwgZGVzYywgVGhyb3cpO1xuICAgICAgICAgICAgcmVzdWx0LnZhbHVlID0gaG9zdFJlc3VsdDtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBXaW5kb3dPYmplY3Q7XG4gICAgfShnbG9iYWwuR2xvYmFsT2JqZWN0KSk7XG4gICAgdmFyIG1vZHVsZSA9IHt9O1xuICAgIG1vZHVsZS5XaW5kb3dPYmplY3QgPSBXaW5kb3dPYmplY3Q7XG4gICAgbW9kdWxlLmFsbG9jYXRlID0gYWxsb2NhdGU7XG4gICAgcmV0dXJuIG1vZHVsZTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD13aW5kb3cuanMubWFwIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbiAobykge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8gdGVtcG9yYXJ5IGhhY2sgdG8gZ2V0IHR5cGVzIGluXG52YXIgcG9saWN5XzEgPSByZXF1aXJlKFwiLi9wb2xpY3lcIik7XG52YXIgZWNtYV8xID0gcmVxdWlyZShcIi4uL2VjbWFcIik7XG52YXIgRnVuY3Rpb25PYmplY3RfMSA9IHJlcXVpcmUoXCIuLi9PYmplY3RzL0Z1bmN0aW9uT2JqZWN0XCIpO1xudmFyIGxhYmVsXzEgPSByZXF1aXJlKFwiLi4vbGFiZWxcIik7XG52YXIgdmFsdWVzXzEgPSByZXF1aXJlKFwiLi4vdmFsdWVzXCIpO1xudmFyIGJvdCA9IGxhYmVsXzEuTGFiZWwuYm90O1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGhhc19vd25fcHJvcGVydHkob2JqLCBwcm9wKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIC0tLSBFbnRpdHlPYmplY3Rcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgRW50aXR5T2JqZWN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFbnRpdHlPYmplY3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRW50aXR5T2JqZWN0KGhvc3QsIGxhYmVsZXIsIG91dGVybW9kZWxzdGF0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBpZiAobGFiZWxlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VudGl0eU9iamVjdDogdW5kZWZpbmVkIGxhYmVsbW9kZWwnKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5tb2RlbHN0YXRlID0gbmV3IHBvbGljeV8xLk1vZGVsU3RhdGUob3V0ZXJtb2RlbHN0YXRlKTtcbiAgICAgICAgX3RoaXMuQ2xhc3MgPSAnT2JqZWN0JztcbiAgICAgICAgX3RoaXMuaG9zdCA9IGhvc3Q7XG4gICAgICAgIF90aGlzLmxhYmVsZXIgPSBsYWJlbGVyO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbnRpdHlPYmplY3QucHJvdG90eXBlLCBcIlByb3RvdHlwZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubGFiZWxlZHByb3RvdHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3RvdHlwZUxhYmVsZXIgPSB0aGlzLmxhYmVsZXIuUHJvdG90eXBlTGFiZWxlcjtcbiAgICAgICAgICAgICAgICB2YXIgZGVzY0xhYmVsZXIgPSBwcm90b3R5cGVMYWJlbGVyLlJlYWRMYWJlbGVyO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHJlbGFiZWwoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMuaG9zdCksIGRlc2NMYWJlbGVyLlZhbHVlTGFiZWxlciwgdGhpcy5tb2RlbHN0YXRlKTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiB3aGF0IGFib3V0IHRoaXMgbGFiZWwgLSBzaG91bGQgd2Uga2VlcCBpdD9cbiAgICAgICAgICAgICAgICB2YXIgbGFiZWwxID0gcHJvdG90eXBlTGFiZWxlci5MYWJlbGVyLkxhYmVsKHRoaXMubW9kZWxzdGF0ZSk7XG4gICAgICAgICAgICAgICAgdmFyIGxhYmVsMiA9IGRlc2NMYWJlbGVyLkxhYmVsZXIuTGFiZWwodGhpcy5tb2RlbHN0YXRlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxhYmVsZWRwcm90b3R5cGUgPSBuZXcgdmFsdWVzXzEuVmFsdWUodmFsdWUsIGxhYmVsXzEubHViKGxhYmVsMSwgbGFiZWwyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYWJlbGVkcHJvdG90eXBlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvLyBUT0RPOiBUaGlzIG9uZSBzaG91bGQgYmUgYSBsb3QgbW9yZSBjbGV2ZXIuLi4uXG4gICAgRW50aXR5T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG9zdC50b1N0cmluZygpO1xuICAgIH07XG4gICAgLy8gLS0tXG4gICAgRW50aXR5T2JqZWN0LnByb3RvdHlwZS5HZXRPd25Qcm9wZXJ0eSA9IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIGlmICghaGFzX293bl9wcm9wZXJ0eSh0aGlzLmhvc3QsIHAudmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5HZXRPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsIHApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9wZXJ0eUxhYmVsZXIgPSB0aGlzLmxhYmVsZXIuR2V0UHJvcGVydHlMYWJlbGVyKHAudmFsdWUpO1xuICAgICAgICB2YXIgbGFiZWwgPSBwcm9wZXJ0eUxhYmVsZXIuTGFiZWxlci5MYWJlbCh0aGlzLm1vZGVsc3RhdGUpO1xuICAgICAgICBpZiAoIWhhc19vd25fcHJvcGVydHkodGhpcy5sYWJlbHMsIHAudmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLmxhYmVsc1twLnZhbHVlXSA9IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbGFiZWwsXG4gICAgICAgICAgICAgICAgZXhpc3RlbmNlOiBwLmxhYmVsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBqc2Rlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRoaXMuaG9zdCwgcC52YWx1ZSk7XG4gICAgICAgIGlmIChqc2Rlc2MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZSh1bmRlZmluZWQsIGxhYmVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzX293bl9wcm9wZXJ0eSh0aGlzLnByb3BlcnRpZXMsIHAudmFsdWUpXG4gICAgICAgICAgICAmJiAoZWNtYV8xLklzRGF0YURlc2NyaXB0b3IoanNkZXNjKSAmJiAhanNkZXNjLndyaXRhYmxlIHx8XG4gICAgICAgICAgICAgICAgZWNtYV8xLklzQWNjZXNzb3JEZXNjcmlwdG9yKGpzZGVzYykgJiYgIWpzZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICAgICAgICAvLyBub24td3JpdGFibGUgcHJvcGVydCBvciBub24tY29uZmlndXJhYmxlIGFjY2Vzc29yIG1lYW5zIGNhbm5vdCBiZSB1cGRhdGVkXG4gICAgICAgICAgICAvLyByZXR1cm4gd2hhdCBpcyB0aGVyZSAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5HZXRPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsIHApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkZXNjID0gcmVsYWJlbFByb3BlcnR5RGVzY3JpcHRvcihqc2Rlc2MsIHByb3BlcnR5TGFiZWxlci5SZWFkTGFiZWxlciwgdGhpcy5tb2RlbHN0YXRlKTtcbiAgICAgICAgZGVzYy5sYWJlbC5sdWIobGFiZWwpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5wcm9wZXJ0aWVzLCBwLnZhbHVlLCBkZXNjKTtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuR2V0T3duUHJvcGVydHkuY2FsbCh0aGlzLCBwKTtcbiAgICB9O1xuICAgIC8vIC0tLVxuICAgIEVudGl0eU9iamVjdC5wcm90b3R5cGUuRGVmaW5lT3duUHJvcGVydHkgPSBmdW5jdGlvbiAocCwgZGVzYywgVGhyb3cpIHtcbiAgICAgICAgdmFyIHByb3BlcnR5TGFiZWxlciA9IHRoaXMubGFiZWxlci5HZXRQcm9wZXJ0eUxhYmVsZXIocC52YWx1ZSk7XG4gICAgICAgIGlmIChoYXNfb3duX3Byb3BlcnR5KHRoaXMuaG9zdCwgcC52YWx1ZSlcbiAgICAgICAgICAgICYmICFoYXNfb3duX3Byb3BlcnR5KHRoaXMubGFiZWxzLCBwLnZhbHVlKSkge1xuICAgICAgICAgICAgdmFyIGxhYmVsID0gcHJvcGVydHlMYWJlbGVyLkxhYmVsZXIuTGFiZWwodGhpcy5tb2RlbHN0YXRlKTtcbiAgICAgICAgICAgIHRoaXMubGFiZWxzW3AudmFsdWVdID0ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBsYWJlbCxcbiAgICAgICAgICAgICAgICBleGlzdGVuY2U6IGxhYmVsXzEubHViKHAubGFiZWwsIGxhYmVsKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLkRlZmluZU93blByb3BlcnR5LmNhbGwodGhpcywgcCwgZGVzYywgVGhyb3cpO1xuICAgICAgICB2YXIganNkZXNjID0gdW5sYWJlbFByb3BlcnR5RGVzY3JpcHRvcihkZXNjLCBwcm9wZXJ0eUxhYmVsZXIuV3JpdGVVbmxhYmVsZXIsIHRoaXMubW9kZWxzdGF0ZSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLmhvc3QsIHAudmFsdWUsIGpzZGVzYyk7XG4gICAgICAgIHJldHVybiBuZXcgdmFsdWVzXzEuVmFsdWUodHJ1ZSwgYm90KTtcbiAgICB9O1xuICAgIC8vIC0tLVxuICAgIEVudGl0eU9iamVjdC5wcm90b3R5cGUuZ2V0T3duRW51bWVyYWJsZVByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiAobGFiZWwpIHtcbiAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgIHZhciBlbnVtZXJhYmxlcyA9IF9zdXBlci5wcm90b3R5cGUuZ2V0T3duRW51bWVyYWJsZVByb3BlcnR5TmFtZXMuY2FsbCh0aGlzLCBsYWJlbCk7XG4gICAgICAgIC8vIE5lZWQgdGhpcyB0byBlbnN1cmUgd2UncmUgbm90IHB1c2hpbmcgcHJvcGVydGllcyBmcm9tIHRoaXMuaG9zdCB0aGF0XG4gICAgICAgIC8vIHdlcmUgYWxyZWFkeSBwcmVzZW50IGluIHRoaXMucHJvcGVydGllcy5cbiAgICAgICAgdmFyIG93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMucHJvcGVydGllcyk7XG4gICAgICAgIHZhciBob3N0TmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzLmhvc3QpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgaG9zdE5hbWVzXzEgPSBfX3ZhbHVlcyhob3N0TmFtZXMpLCBob3N0TmFtZXNfMV8xID0gaG9zdE5hbWVzXzEubmV4dCgpOyAhaG9zdE5hbWVzXzFfMS5kb25lOyBob3N0TmFtZXNfMV8xID0gaG9zdE5hbWVzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBob3N0TmFtZXNfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICghb3duUHJvcE5hbWVzLmluY2x1ZGVzKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0aGlzLmhvc3QsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIGRlc2MgaXMgbm90IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVzYy5lbnVtZXJhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlcy5wdXNoKG5ldyB2YWx1ZXNfMS5WYWx1ZShuYW1lLCBsYWJlbCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoaG9zdE5hbWVzXzFfMSAmJiAhaG9zdE5hbWVzXzFfMS5kb25lICYmIChfYSA9IGhvc3ROYW1lc18xLnJldHVybikpIF9hLmNhbGwoaG9zdE5hbWVzXzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnVtZXJhYmxlcztcbiAgICB9O1xuICAgIHJldHVybiBFbnRpdHlPYmplY3Q7XG59KGVjbWFfMS5FY21hKSk7XG5leHBvcnRzLkVudGl0eU9iamVjdCA9IEVudGl0eU9iamVjdDtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAtLS0gRW50aXR5RnVuY3Rpb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgRW50aXR5RnVuY3Rpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEVudGl0eUZ1bmN0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEVudGl0eUZ1bmN0aW9uKGhvc3QsIGxhYmVsbW9kZWwsIG91dGVybW9kZWxzdGF0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBob3N0LCBsYWJlbG1vZGVsLCBvdXRlcm1vZGVsc3RhdGUpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLkNsYXNzID0gJ0Z1bmN0aW9uJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvLyAtLS1cbiAgICBFbnRpdHlGdW5jdGlvbi5wcm90b3R5cGUuQ2FsbCA9IGZ1bmN0aW9uICh0aGlzVmFsLCBhcmdzKSB7XG4gICAgICAgIHZhciBtb2RlbHN0YXRlID0gbmV3IHBvbGljeV8xLk1vZGVsU3RhdGUodGhpcy5tb2RlbHN0YXRlKTtcbiAgICAgICAgbW9uaXRvci5wb2xpY3kuUHVzaE1vZGVsU3RhdGUobW9kZWxzdGF0ZSk7XG4gICAgICAgIHZhciBhcmdzdW5sYWJlbG1vZGVscyA9IHRoaXMubGFiZWxlci5Bcmd1bWVudHNVbmxhYmVsZXI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyssIGorKykge1xuICAgICAgICAgICAgd2hpbGUgKCFhcmdzdW5sYWJlbG1vZGVscy5HZXRBcmd1bWVudFVubGFiZWxlcihqKS5Nb2RlbEZvcihhcmdzW2ldKSkge1xuICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFyZ3NbaV0gPSB1bmxhYmVsVmFsdWUoYXJnc1tpXSwgYXJnc3VubGFiZWxtb2RlbHMuR2V0QXJndW1lbnRVbmxhYmVsZXIoaiksIG1vZGVsc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0aGlzdW5sYWJlbG1vZGVsID0gdGhpcy5sYWJlbGVyLlNlbGZVbmxhYmVsZXI7XG4gICAgICAgIHZhciB1bmxhYmVsZWRUaGlzID0gdW5sYWJlbFZhbHVlKHRoaXNWYWwsIHRoaXN1bmxhYmVsbW9kZWwsIG1vZGVsc3RhdGUpO1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5ob3N0LmFwcGx5KHVubGFiZWxlZFRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBtYXkgcmV0aHJvdyB0cmFuc2xhdGVkIGV4Y3BldGlvbiwgb3RoZXJ3aXNlIHdlIHJldGhyb3cgb3Vyc2VsdmVzXG4gICAgICAgICAgICBtb25pdG9yLnRyeVJldGhyb3coZSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgZXhjbW9kZWwgPSB0aGlzLmxhYmVsZXIuR2V0RXhjZXB0aW9uTGFiZWxNb2RlbChlLm5hbWUpO1xuICAgICAgICAgICAgdmFyIGxlID0gbmV3IEVudGl0eU9iamVjdChlLCBleGNtb2RlbCwgdGhpcy5tb2RlbHN0YXRlKTtcbiAgICAgICAgICAgIHZhciBleGNsYWJlbCA9IHRoaXMubGFiZWxlci5HZXRFeGNlcHRpb25MYWJlbChlLm5hbWUpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IHZhbHVlc18xLlZhbHVlKGxlLCBleGNsYWJlbCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJldHVybmxhYmVsbW9kZWwgPSB0aGlzLmxhYmVsZXIuUmV0dXJuTGFiZWxlcjtcbiAgICAgICAgdmFyIHJldHVybmxhYmVsID0gcmV0dXJubGFiZWxtb2RlbC5MYWJlbGVyLkxhYmVsKG1vZGVsc3RhdGUpO1xuICAgICAgICB2YXIgbGFiZWxlZHZhbHVlID0gcmVsYWJlbChyZXN1bHQsIHJldHVybmxhYmVsbW9kZWwuVmFsdWVMYWJlbGVyLCBtb2RlbHN0YXRlKTtcbiAgICAgICAgbW9uaXRvci5wb2xpY3kuUG9wTW9kZWxTdGF0ZSgpO1xuICAgICAgICByZXR1cm4gbmV3IHZhbHVlc18xLlZhbHVlKGxhYmVsZWR2YWx1ZSwgcmV0dXJubGFiZWwpO1xuICAgIH07XG4gICAgLy8gLS0tXG4gICAgRW50aXR5RnVuY3Rpb24ucHJvdG90eXBlLkNvbnN0cnVjdCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgIHZhciBtb2RlbHN0YXRlID0gbmV3IHBvbGljeV8xLk1vZGVsU3RhdGUodGhpcy5tb2RlbHN0YXRlKTtcbiAgICAgICAgbW9uaXRvci5wb2xpY3kuUHVzaE1vZGVsU3RhdGUobW9kZWxzdGF0ZSk7XG4gICAgICAgIHZhciBhcmdzdW5sYWJlbG1vZGVscyA9IHRoaXMubGFiZWxlci5Bcmd1bWVudHNVbmxhYmVsZXI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyssIGorKykge1xuICAgICAgICAgICAgd2hpbGUgKCFhcmdzdW5sYWJlbG1vZGVscy5HZXRBcmd1bWVudFVubGFiZWxlcihqKS5Nb2RlbEZvcihhcmdzW2ldKSkge1xuICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFyZ3NbaV0gPSB1bmxhYmVsVmFsdWUoYXJnc1tpXSwgYXJnc3VubGFiZWxtb2RlbHMuR2V0QXJndW1lbnRVbmxhYmVsZXIoaiksIG1vZGVsc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHJpbmdBcmdzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChzdHJpbmdBcmdzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzdHJpbmdBcmdzID0gXCJhcmdzW1wiICsgaSArIFwiXVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nQXJncyArPSBcIiwgYXJnc1tcIiArIGkgKyBcIl1cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZXZhbChcInJlc3VsdCA9IG5ldyB0aGlzLmhvc3QoXCIgKyBzdHJpbmdBcmdzICsgXCIpO1wiKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbW9uaXRvci50cnlSZXRocm93KGUsIHRydWUpO1xuICAgICAgICAgICAgdmFyIGV4Y21vZGVsID0gdGhpcy5sYWJlbGVyLkdldEV4Y2VwdGlvbkxhYmVsTW9kZWwoZS5uYW1lKTtcbiAgICAgICAgICAgIHZhciBsZSA9IG5ldyBFbnRpdHlPYmplY3QoZSwgZXhjbW9kZWwsIHRoaXMubW9kZWxzdGF0ZSk7XG4gICAgICAgICAgICB2YXIgZXhjbGFiZWwgPSB0aGlzLmxhYmVsZXIuR2V0RXhjZXB0aW9uTGFiZWwoZS5uYW1lKTtcbiAgICAgICAgICAgIHRocm93IG5ldyB2YWx1ZXNfMS5WYWx1ZShsZSwgZXhjbGFiZWwpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXR1cm5sYWJlbG1vZGVsID0gdGhpcy5sYWJlbGVyLlJldHVybkxhYmVsZXI7XG4gICAgICAgIHZhciByZXR1cm5sYWJlbCA9IHJldHVybmxhYmVsbW9kZWwuTGFiZWxlci5MYWJlbChtb2RlbHN0YXRlKTtcbiAgICAgICAgdmFyIGxhYmVsZWR2YWx1ZSA9IHJlbGFiZWwocmVzdWx0LCByZXR1cm5sYWJlbG1vZGVsLlZhbHVlTGFiZWxlciwgbW9kZWxzdGF0ZSk7XG4gICAgICAgIG1vbml0b3IucG9saWN5LlBvcE1vZGVsU3RhdGUoKTtcbiAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZShsYWJlbGVkdmFsdWUsIHJldHVybmxhYmVsKTtcbiAgICB9O1xuICAgIHJldHVybiBFbnRpdHlGdW5jdGlvbjtcbn0oRW50aXR5T2JqZWN0KSk7XG5leHBvcnRzLkVudGl0eUZ1bmN0aW9uID0gRW50aXR5RnVuY3Rpb247XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gLS0tIHJlbGFiZWxQcm9wZXJ0eURlc2NyaXB0b3IgOjogTmF0aXZlVmFsdWUgLT4gRW50aXR5T2JqZWN0XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gcmVsYWJlbFByb3BlcnR5RGVzY3JpcHRvcihkZXNjLCBkZXNjcmlwdG9yTGFiZWxlciwgbW9kZWxzdGF0ZSkge1xuICAgIHZhciBlXzIsIF9hO1xuICAgIHZhciBqc2ZkZXNjID0ge1xuICAgICAgICBsYWJlbDogZGVzY3JpcHRvckxhYmVsZXIuTGFiZWxlci5MYWJlbChtb2RlbHN0YXRlKVxuICAgIH07XG4gICAgdmFyIGJvb2xQcm9wZXJ0aWVzID0gWydjb25maWd1cmFibGUnLCAnZW51bWVyYWJsZScsICd3cml0YWJsZSddO1xuICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIGJvb2xQcm9wZXJ0aWVzXzEgPSBfX3ZhbHVlcyhib29sUHJvcGVydGllcyksIGJvb2xQcm9wZXJ0aWVzXzFfMSA9IGJvb2xQcm9wZXJ0aWVzXzEubmV4dCgpOyAhYm9vbFByb3BlcnRpZXNfMV8xLmRvbmU7IGJvb2xQcm9wZXJ0aWVzXzFfMSA9IGJvb2xQcm9wZXJ0aWVzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gYm9vbFByb3BlcnRpZXNfMV8xLnZhbHVlO1xuICAgICAgICAgICAgaWYgKGRlc2Nba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAganNmZGVzY1trZXldID0gZGVzY1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoYm9vbFByb3BlcnRpZXNfMV8xICYmICFib29sUHJvcGVydGllc18xXzEuZG9uZSAmJiAoX2EgPSBib29sUHJvcGVydGllc18xLnJldHVybikpIF9hLmNhbGwoYm9vbFByb3BlcnRpZXNfMSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxuICAgIH1cbiAgICBpZiAoZWNtYV8xLklzQWNjZXNzb3JEZXNjcmlwdG9yKGRlc2MpKSB7XG4gICAgICAgIGlmIChkZXNjLmdldCkge1xuICAgICAgICAgICAgdmFyIEdldF8xID0gbmV3IEVudGl0eUZ1bmN0aW9uKGRlc2MuZ2V0LCBkZXNjcmlwdG9yTGFiZWxlci5HZXR0ZXJMYWJlbGVyLCBtb2RlbHN0YXRlKTtcbiAgICAgICAgICAgIGpzZmRlc2MuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gR2V0XzEuQ2FsbChuZXcgdmFsdWVzXzEuVmFsdWUodGhpcywgYm90KSwgW10pOyB9O1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAganNmZGVzYy5nZXQuYWN0dWFsRnVuY3Rpb24gPSBHZXRfMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgICAgICAgIHZhciBTZXRfMSA9IG5ldyBFbnRpdHlGdW5jdGlvbihkZXNjLnNldCwgZGVzY3JpcHRvckxhYmVsZXIuU2V0dGVyTGFiZWxlciwgbW9kZWxzdGF0ZSk7XG4gICAgICAgICAgICBqc2ZkZXNjLnNldCA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBTZXRfMS5DYWxsKG5ldyB2YWx1ZXNfMS5WYWx1ZSh0aGlzLCBib3QpLCBbdl0pOyB9O1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAganNmZGVzYy5zZXQuYWN0dWFsRnVuY3Rpb24gPSBTZXRfMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChlY21hXzEuSXNEYXRhRGVzY3JpcHRvcihkZXNjKSkge1xuICAgICAgICBqc2ZkZXNjLnZhbHVlID0gcmVsYWJlbChkZXNjLnZhbHVlLCBkZXNjcmlwdG9yTGFiZWxlci5WYWx1ZUxhYmVsZXIsIG1vZGVsc3RhdGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbW9uaXRvci5UaHJvdyhtb25pdG9yLm1vZHVsZXMuZXJyb3IuRXJyb3JPYmplY3QsICdFbnRpdHkucmVsYWJlbFByb3BlcnR5RGVzY3JpcHRvcjogZ290IHNvbWV0aGluZyB0aGF0IGlzIG5vdCBhIGRlc2NyaXB0b3IhJywgYm90KTtcbiAgICB9XG4gICAgcmV0dXJuIGpzZmRlc2M7XG59XG5leHBvcnRzLnJlbGFiZWxQcm9wZXJ0eURlc2NyaXB0b3IgPSByZWxhYmVsUHJvcGVydHlEZXNjcmlwdG9yO1xuLy8gLS0tXG5mdW5jdGlvbiBNa1ZhbHVlKHZhbHVlLCB2YWx1ZUxhYmVsZXIsIG1vZGVsc3RhdGUpIHtcbiAgICB2YXIgbGFiZWwgPSB2YWx1ZUxhYmVsZXIuTGFiZWxlci5MYWJlbChtb2RlbHN0YXRlKTtcbiAgICB2YXIgbGFiZWxlZHZhbHVlID0gcmVsYWJlbCh2YWx1ZSwgdmFsdWVMYWJlbGVyLlZhbHVlTGFiZWxlciwgbW9kZWxzdGF0ZSk7XG4gICAgcmV0dXJuIG5ldyB2YWx1ZXNfMS5WYWx1ZShsYWJlbGVkdmFsdWUsIGxhYmVsKTtcbn1cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAtLS0gcmVsYWJlbCA6OiBFbnRpdHlPYmplY3QgLT4gUG9saWN5IC0+IE5hdGl2ZVZhbHVlIC0+IEVudGl0eU9iamVjdFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFdlIGRvbid0IHdhbnQgdG8gcmV0dXJuIGEgdmFsdWUsIHNpbmNlIHJlbGFiZWwgaXMgdXNlZCBpbiwgZS5nLiwgZGVzY3JpcHRvcnNcbmZ1bmN0aW9uIHJlbGFiZWwodmFsdWUsIGxhYmVsZXIsIG1vZGVsc3RhdGUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fFxuICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8XG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChtb25pdG9yLmVudGl0eW1hcC5oYXModmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBtb25pdG9yLmVudGl0eW1hcC5nZXQodmFsdWUpO1xuICAgIH1cbiAgICB2YXIgcmVzO1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgIHJlcyA9IG5ldyBFbnRpdHlGdW5jdGlvbih2YWx1ZSwgbGFiZWxlciwgbW9kZWxzdGF0ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXMgPSBuZXcgRW50aXR5T2JqZWN0KHZhbHVlLCBsYWJlbGVyLCBtb2RlbHN0YXRlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgbW9uaXRvci5lbnRpdHltYXAuc2V0KHZhbHVlLCByZXMpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBtb25pdG9yLndhcm4oJ0Nhbm5vdCBtYXAgJywgdmFsdWUudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5leHBvcnRzLnJlbGFiZWwgPSByZWxhYmVsO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIC0tLSB1bmxhYmVsUHJvcGVydHlEZXNjcmlwdG9yIDo6IEVudGl0eU9iamVjdCAtPiBOYXRpdmVWYWx1ZVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIHVubGFiZWxQcm9wZXJ0eURlc2NyaXB0b3IoanNmbG93ZGVzYywgdW5sYWJlbG1vZGVsLCBtb2RlbHN0YXRlKSB7XG4gICAgdmFyIGVfMywgX2E7XG4gICAgdmFyIGJvb2xQcm9wZXJ0aWVzID0gWydjb25maWd1cmFibGUnLCAnZW51bWVyYWJsZScsICd3cml0YWJsZSddO1xuICAgIHZhciBkZXNjID0ge307XG4gICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgYm9vbFByb3BlcnRpZXNfMiA9IF9fdmFsdWVzKGJvb2xQcm9wZXJ0aWVzKSwgYm9vbFByb3BlcnRpZXNfMl8xID0gYm9vbFByb3BlcnRpZXNfMi5uZXh0KCk7ICFib29sUHJvcGVydGllc18yXzEuZG9uZTsgYm9vbFByb3BlcnRpZXNfMl8xID0gYm9vbFByb3BlcnRpZXNfMi5uZXh0KCkpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBib29sUHJvcGVydGllc18yXzEudmFsdWU7XG4gICAgICAgICAgICBpZiAoanNmbG93ZGVzY1trZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBkZXNjW2tleV0gPSBqc2Zsb3dkZXNjW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVfM18xKSB7IGVfMyA9IHsgZXJyb3I6IGVfM18xIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChib29sUHJvcGVydGllc18yXzEgJiYgIWJvb2xQcm9wZXJ0aWVzXzJfMS5kb25lICYmIChfYSA9IGJvb2xQcm9wZXJ0aWVzXzIucmV0dXJuKSkgX2EuY2FsbChib29sUHJvcGVydGllc18yKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMykgdGhyb3cgZV8zLmVycm9yOyB9XG4gICAgfVxuICAgIGlmIChlY21hXzEuSXNBY2Nlc3NvckRlc2NyaXB0b3IoanNmbG93ZGVzYykpIHtcbiAgICAgICAgaWYgKGpzZmxvd2Rlc2MuZ2V0KSB7XG4gICAgICAgICAgICBkZXNjLmdldCA9IHVubGFiZWwoanNmbG93ZGVzYy5nZXQsIHVubGFiZWxtb2RlbC5HZXR0ZXJVbmxhYmVsZXIsIG1vZGVsc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChqc2Zsb3dkZXNjLnNldCkge1xuICAgICAgICAgICAgZGVzYy5zZXQgPSB1bmxhYmVsKGpzZmxvd2Rlc2Muc2V0LCB1bmxhYmVsbW9kZWwuU2V0dGVyVW5sYWJlbGVyLCBtb2RlbHN0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChlY21hXzEuSXNEYXRhRGVzY3JpcHRvcihqc2Zsb3dkZXNjKSkge1xuICAgICAgICB2YXIgdmFsdWVVbmxhYmVsZXIgPSBkZXNjLnZhbHVlID0gdW5sYWJlbChqc2Zsb3dkZXNjLnZhbHVlLCB1bmxhYmVsbW9kZWwuVmFsdWVVbmxhYmVsZXIsIG1vZGVsc3RhdGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbW9uaXRvci5UaHJvdyhtb25pdG9yLm1vZHVsZXMuZXJyb3IuRXJyb3JPYmplY3QsICdFbnRpdHkudW5sYWJlbFByb3BlcnR5RGVzY3JpcHRvcjogZ290IHNvbWV0aGluZyB0aGF0IGlzIG5vdCBhIGRlc2NyaXB0b3IhJywgYm90KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc2M7XG59XG5leHBvcnRzLnVubGFiZWxQcm9wZXJ0eURlc2NyaXB0b3IgPSB1bmxhYmVsUHJvcGVydHlEZXNjcmlwdG9yO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIC0tLSB1bmxhYmVsIDo6IEVudGl0eU9iamVjdCAtPiBQb2xpY3kgLT4gTmF0aXZlVmFsdWVcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBUT0RPOiBob3cgdG8gaGFuZGxlIG5vbi1zdGFuZGFyZCBpbnRlcmFjdGlvbnMgKE9iamVjdC5YLCBSZWZsZWN0LlgsIF9fcHJvdG90X18sIGluc3RhbmNlb2YpXG5mdW5jdGlvbiBoYW5kbGVyKGpzZmxvd29iamVjdCwgYWJzdHJhY3RuYW1lKSB7XG4gICAgaWYgKGFic3RyYWN0bmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG1vbml0b3IuZmF0YWwoJ2V4ZWMuanMsIGhhbmRsZXIsIHVuZGVmaW5lZCBhYnN0cmFjdCBuYW1lJyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYWJzdHJhY3RuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICBtb25pdG9yLmZhdGFsKCd1bmxhYmVsIGhhbmRsZXIsIGFic3RyYWN0IG5hbWUgaXMgbm90IGEgc3RyaW5nIGJ1dCcsIGFic3RyYWN0bmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIC8vIC0tLVxuICAgICAgICAvLyBPYmplY3QuZ2V0UHJvdG90eXBlT2YoKSwgUmVmbGVjdC5nZXRQcm90b3R5cGVPZigpLCBfX3Byb3RvX18sIE9iamVjdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZigpLCBpbnN0YW5jZW9mXG4gICAgICAgIGdldFByb3RvdHlwZU9mOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgICAgICB2YXIgbW9kZWxzdGF0ZSA9IG1vbml0b3IucG9saWN5LkN1cnJlbnRNb2RlbFN0YXRlO1xuICAgICAgICAgICAgdmFyIHVubGFiZWxlciA9IG1vZGVsc3RhdGUuR2V0TW9kZWwoYWJzdHJhY3RuYW1lKTtcbiAgICAgICAgICAgIHZhciBwcm90b3R5cGVVbmxhYmVsZXIgPSB1bmxhYmVsZXIuUHJvdG90eXBlVW5sYWJlbGVyO1xuICAgICAgICAgICAgdmFyIHByb3RvdHlwZSA9IHByb3RvdHlwZVVubGFiZWxlci5VbmxhYmVsZXIuVW5sYWJlbChqc2Zsb3dvYmplY3QuUHJvdG90eXBlLCBtb2RlbHN0YXRlKTtcbiAgICAgICAgICAgIHZhciBkZXNjTGFiZWxlciA9IHByb3RvdHlwZVVubGFiZWxlci5SZWFkVW5sYWJlbGVyO1xuICAgICAgICAgICAgdmFyIGpzcHJvdG90eXBlID0gdW5sYWJlbChwcm90b3R5cGUsIGRlc2NMYWJlbGVyLlZhbHVlVW5sYWJlbGVyLCBtb2RlbHN0YXRlKTtcbiAgICAgICAgICAgIHJldHVybiBqc3Byb3RvdHlwZTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gLS0tXG4gICAgICAgIC8vIE9iamVjdC5zZXRQcm90b3R5cGVPZigpLCBSZWZsZWN0LnNldFByb3RvdHlwZU9mKClcbiAgICAgICAgc2V0UHJvdG90eXBlT2Y6IGZ1bmN0aW9uICh0YXJnZXQsIHByb3RvdHlwZSkge1xuICAgICAgICAgICAgbW9uaXRvci5UaHJvdyhtb25pdG9yLm1vZHVsZXMuZXJyb3IuRXJyb3JPYmplY3QsICdQcm94eS5zZXRQcm90b3R5cGVPZjogc2V0UHJvdG90eXBlT2YgaXMgRVM2IHN0YW5kYXJkLicsIGJvdCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIC0tLVxuICAgICAgICAvLyBPYmplY3QuaXNFeHRlbnNpYmxlKCksIFJlZmxlY3QuaXNFeHRlbnNpYmxlKCkgXG4gICAgICAgIGlzRXh0ZW5zaWJsZTogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgICAgdmFyIG1vZGVsc3RhdGUgPSBtb25pdG9yLnBvbGljeS5DdXJyZW50TW9kZWxTdGF0ZTtcbiAgICAgICAgICAgIHZhciB1bmxhYmVsZXIgPSBtb2RlbHN0YXRlLkdldE1vZGVsKGFic3RyYWN0bmFtZSk7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0VmFsdWUgPSBuZXcgdmFsdWVzXzEuVmFsdWUoanNmbG93b2JqZWN0LCBib3QpO1xuICAgICAgICAgICAgdmFyIGlzRXh0ZW5zaWJsZSA9IG1vbml0b3IuaW5zdGFuY2VzLk9iamVjdENvbnN0cnVjdG9yLnByb3BlcnRpZXMuaXNFeHRlbnNpYmxlLkNhbGwoanNmbG93b2JqZWN0LCBbdGFyZ2V0VmFsdWVdKTtcbiAgICAgICAgICAgIHZhciBqc0lzRXh0ZW5zaWJsZSA9IHVubGFiZWxlci5VbmxhYmVsZXIuVW5sYWJlbChpc0V4dGVuc2libGUsIG1vZGVsc3RhdGUpO1xuICAgICAgICAgICAgcmV0dXJuIGpzSXNFeHRlbnNpYmxlO1xuICAgICAgICB9LFxuICAgICAgICAvLyAtLS1cbiAgICAgICAgLy8gT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKCksIFJlZmxlY3QucHJldmVudEV4dGVuc2lvbnMoKVxuICAgICAgICBwcmV2ZW50RXh0ZW5zaW9uczogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgICAgdmFyIG1vZGVsc3RhdGUgPSBtb25pdG9yLnBvbGljeS5DdXJyZW50TW9kZWxTdGF0ZTtcbiAgICAgICAgICAgIHZhciBtb2RlbCA9IG1vZGVsc3RhdGUuR2V0TW9kZWwoYWJzdHJhY3RuYW1lKTtcbiAgICAgICAgICAgIC8vIFRPRE86IHVubGFiZWwgbW9kZWwgaGVyZTsgd3JpdGUgY29udGV4dFxuICAgICAgICAgICAgdmFyIHRhcmdldFZhbHVlID0gbmV3IHZhbHVlc18xLlZhbHVlKGpzZmxvd29iamVjdCwgYm90KTtcbiAgICAgICAgICAgIG1vbml0b3IuaW5zdGFuY2VzLk9iamVjdENvbnN0cnVjdG9yLnByb3BlcnRpZXMucHJldmVudEV4dGVuc2lvbnMuQ2FsbChqc2Zsb3dvYmplY3QsIFt0YXJnZXRWYWx1ZV0pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIC0tLVxuICAgICAgICAvLyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKCksIFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKClcbiAgICAgICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiBmdW5jdGlvbiAodGFyZ2V0LCBwcm9wKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgICAgICAgbW9uaXRvci53YXJuKFwiaGFuZGxlci5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsIGZvcndhcmRpbmcgXCIgKyBwcm9wLnRvU3RyaW5nKCkgKyBcIiB0byBwcm90b3R5cGVcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5fX3Byb3RvX19bcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbW9kZWxzdGF0ZSA9IG1vbml0b3IucG9saWN5LkN1cnJlbnRNb2RlbFN0YXRlO1xuICAgICAgICAgICAgdmFyIHVubGFiZWxlciA9IG1vZGVsc3RhdGUuR2V0TW9kZWwoYWJzdHJhY3RuYW1lKTtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eVVubGFiZWxlciA9IHVubGFiZWxlci5HZXRQcm9wZXJ0eVVubGFiZWxlcihwcm9wKTtcbiAgICAgICAgICAgIHZhciBsYWJlbGVkUmVzdWx0ID0ganNmbG93b2JqZWN0LkdldE93blByb3BlcnR5KG5ldyB2YWx1ZXNfMS5WYWx1ZShwcm9wLCBib3QpKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBwcm9wZXJ0eVVubGFiZWxlci5VbmxhYmVsZXIuVW5sYWJlbChsYWJlbGVkUmVzdWx0LCBtb2RlbHN0YXRlKTtcbiAgICAgICAgICAgIHZhciBqc3Jlc3VsdCA9IHVubGFiZWxQcm9wZXJ0eURlc2NyaXB0b3IocmVzdWx0LCBwcm9wZXJ0eVVubGFiZWxlci5SZWFkVW5sYWJlbGVyLCBtb2RlbHN0YXRlKTtcbiAgICAgICAgICAgIHJldHVybiBqc3Jlc3VsdDtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gLS0tXG4gICAgICAgIC8vIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSgpXG4gICAgICAgIGRlZmluZVByb3BlcnR5OiBmdW5jdGlvbiAodGFyZ2V0LCBwcm9wLCBqc2Rlc2MpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdoYW5kbGVyLmRlZmluZVByb3BlcnR5LCBkZWZpbmluZyBzeW1ib2wgcHJvcGVydGllcyBub3Qgc3VwcG9ydGVkICcgKyBwcm9wLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1vZGVsc3RhdGUgPSBtb25pdG9yLnBvbGljeS5DdXJyZW50TW9kZWxTdGF0ZTtcbiAgICAgICAgICAgIHZhciB1bmxhYmVsZXIgPSBtb2RlbHN0YXRlLkdldE1vZGVsKGFic3RyYWN0bmFtZSk7XG4gICAgICAgICAgICB2YXIgcHJvcGVydHlVbmxhYmVsZXIgPSB1bmxhYmVsZXIuR2V0UHJvcGVydHlVbmxhYmVsZXIocHJvcCk7XG4gICAgICAgICAgICAvLyBUT0RPOiB3ZSBzaG91bGQgZ2V0IGEgd3JpdGUgY29udGV4dCBmcm9tIHRoZSB1bmxhYmVsZXIsIG9yIHRoZSBwcm9wZXJ0eVVubGFiZWxlclxuICAgICAgICAgICAgdmFyIGNvbnRleHRMYWJlbCA9IGJvdDtcbiAgICAgICAgICAgIHZhciBkZXNjID0gcmVsYWJlbFByb3BlcnR5RGVzY3JpcHRvcihqc2Rlc2MsIHByb3BlcnR5VW5sYWJlbGVyLldyaXRlTGFiZWxlciwgbW9kZWxzdGF0ZSk7XG4gICAgICAgICAgICBtb25pdG9yLmNvbnRleHQucHVzaFBDKGNvbnRleHRMYWJlbCk7XG4gICAgICAgICAgICB2YXIgeCA9IGpzZmxvd29iamVjdC5EZWZpbmVPd25Qcm9wZXJ0eShuZXcgdmFsdWVzXzEuVmFsdWUocHJvcCwgYm90KSwgZGVzYywgdHJ1ZSk7XG4gICAgICAgICAgICBtb25pdG9yLmNvbnRleHQucG9wUEMoKTtcbiAgICAgICAgICAgIC8vIFRPRE86IHNob3VsZCBzaGFyZSBtb2RlbCB3aXRoIHNldFxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIC0tLVxuICAgICAgICAvLyB0aGUgaW4gb3BlcmF0b3JcbiAgICAgICAgaGFzOiBmdW5jdGlvbiAodGFyZ2V0LCBwcm9wKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogc2hvdWxkIG5ldmVyIGdldCBzeW1ib2xzP1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2hhbmRsZXIuaGFzLCAgc3ltYm9sIHByb3BlcnRpZXMgbm90IHN1cHBvcnRlZCAnICsgcHJvcC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtb2RlbHN0YXRlID0gbW9uaXRvci5wb2xpY3kuQ3VycmVudE1vZGVsU3RhdGU7XG4gICAgICAgICAgICB2YXIgdW5sYWJlbGVyID0gbW9kZWxzdGF0ZS5HZXRNb2RlbChhYnN0cmFjdG5hbWUpO1xuICAgICAgICAgICAgdmFyIHByb3BlcnR5VW5sYWJlbGVyID0gdW5sYWJlbGVyLkdldFByb3BlcnR5VW5sYWJlbGVyKHByb3ApO1xuICAgICAgICAgICAgLy8gVE9ETzogd2hlcmUgc2hvdWxkIHdlIGdldCB0aGUgbGFiZWwgZm9yIHRoZSBwcm9wPyBhbmQgd2hlcmUgc2hvdWxkIHdlIHN0b3JlIHRoZSBsYWJlbCBmb3IgdGhlIGluP1xuICAgICAgICAgICAgLy8gbXVzdCBiZSBvbiB0aGUgb2JqZWN0XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ganNmbG93b2JqZWN0Lkhhc1Byb3BlcnR5KG5ldyB2YWx1ZXNfMS5WYWx1ZShwcm9wLCBib3QpKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIC0tLVxuICAgICAgICAvL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgICAgICAgbW9uaXRvci53YXJuKFwiaGFuZGxlci5nZXQsIGZvcndhcmRpbmcgXCIgKyBwcm9wLnRvU3RyaW5nKCkgKyBcIiB0byBwcm90b3R5cGVcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5fX3Byb3RvX19bcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbW9kZWxzdGF0ZSA9IG1vbml0b3IucG9saWN5LkN1cnJlbnRNb2RlbFN0YXRlO1xuICAgICAgICAgICAgdmFyIHVubGFiZWxlciA9IG1vZGVsc3RhdGUuR2V0TW9kZWwoYWJzdHJhY3RuYW1lKTtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eVVubGFiZWxlciA9IHVubGFiZWxlci5HZXRQcm9wZXJ0eVVubGFiZWxlcihwcm9wKTtcbiAgICAgICAgICAgIHZhciBkZXNjVW5sYWJlbGVyID0gcHJvcGVydHlVbmxhYmVsZXIuUmVhZFVubGFiZWxlcjtcbiAgICAgICAgICAgIHZhciBqc2ZyZXN1bHQgPSBqc2Zsb3dvYmplY3QuR2V0KG5ldyB2YWx1ZXNfMS5WYWx1ZShwcm9wLCBib3QpKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBkZXNjVW5sYWJlbGVyLlVubGFiZWxlci5VbmxhYmVsKGpzZnJlc3VsdCwgbW9kZWxzdGF0ZSk7XG4gICAgICAgICAgICByZXR1cm4gdW5sYWJlbChyZXN1bHQsIGRlc2NVbmxhYmVsZXIuVmFsdWVVbmxhYmVsZXIsIG1vZGVsc3RhdGUpO1xuICAgICAgICB9LFxuICAgICAgICAvLyAtLVxuICAgICAgICAvLyBcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodGFyZ2V0LCBwcm9wLCB2YWx1ZSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdoYW5kbGVyLnNldCwgc2V0dGluZyBzeW1ib2wgcHJvcGVydGllcyBub3Qgc3VwcG9ydGVkICcgKyBwcm9wLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1vZGVsc3RhdGUgPSBtb25pdG9yLnBvbGljeS5DdXJyZW50TW9kZWxTdGF0ZTtcbiAgICAgICAgICAgIHZhciB1bmxhYmVsZXIgPSBtb2RlbHN0YXRlLkdldE1vZGVsKGFic3RyYWN0bmFtZSk7XG4gICAgICAgICAgICB2YXIgcHJvcGVydHlVbmxhYmVsZXIgPSB1bmxhYmVsZXIuR2V0UHJvcGVydHlVbmxhYmVsZXIocHJvcCk7XG4gICAgICAgICAgICB2YXIgZGVzY0xhYmVsZXIgPSBwcm9wZXJ0eVVubGFiZWxlci5Xcml0ZUxhYmVsZXI7XG4gICAgICAgICAgICB2YXIganNmdmFsdWUgPSByZWxhYmVsKHZhbHVlLCBkZXNjTGFiZWxlci5WYWx1ZUxhYmVsZXIsIG1vZGVsc3RhdGUpO1xuICAgICAgICAgICAgdmFyIHZhbHVlTGFiZWwgPSBkZXNjTGFiZWxlci5WYWx1ZUxhYmVsZXIuTGFiZWxlci5MYWJlbChtb2RlbHN0YXRlKTtcbiAgICAgICAgICAgIC8vIFRPRE86IHdlIHNob3VsZCByZS1hZGQgY29udGV4dCBhdCBzb21lIHBvaW50LlxuICAgICAgICAgICAgdmFyIGNvbnRleHRMYWJlbCA9IGJvdDtcbiAgICAgICAgICAgIG1vbml0b3IuY29udGV4dC5wdXNoUEMoY29udGV4dExhYmVsKTtcbiAgICAgICAgICAgIGpzZmxvd29iamVjdC5QdXQobmV3IHZhbHVlc18xLlZhbHVlKHByb3AsIGJvdCksIG5ldyB2YWx1ZXNfMS5WYWx1ZShqc2Z2YWx1ZSwgdmFsdWVMYWJlbCkpO1xuICAgICAgICAgICAgbW9uaXRvci5jb250ZXh0LnBvcFBDKCk7XG4gICAgICAgICAgICAvLyBOT1RFOiBlbmNvZGVzIHRoYXQgc2V0IGFsd2F5cyB3b3Jrcy5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICAvLyAtLVxuICAgICAgICAvLyBUT0RPOiBsYWNrcyBsYWJlbCBtb2RlbCBjb25uZWN0aW9uXG4gICAgICAgIGRlbGV0ZVByb3BlcnR5OiBmdW5jdGlvbiAodGFyZ2V0LCBwcm9wKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaGFuZGxlci5kZWxldGVQcm9wZXJ0eSwgZGVsZXRpbmcgc3ltYm9sIHByb3BlcnRpZXMgbm90IHN1cHBvcnRlZCAnICsgcHJvcC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBqc2Zsb3dvYmplY3QuRGVsZXRlKG5ldyB2YWx1ZXNfMS5WYWx1ZShwcm9wLCBib3QpKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIC0tXG4gICAgICAgIC8vIFRPRE86IHVuZmlubmlzaGVkIVxuICAgICAgICBvd25LZXlzOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgICAgICB2YXIga2V5cyA9IG1vbml0b3IuaW5zdGFuY2VzLk9iamVjdENvbnN0cnVjdG9yLnByb3BlcnRpZXMuZ2V0T3duUHJvcGVydHlOYW1lcy5DYWxsKGpzZmxvd29iamVjdCwgW25ldyB2YWx1ZXNfMS5WYWx1ZShqc2Zsb3dvYmplY3QsIGJvdCldKTtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpOyAvL3VubGFiZWwoa2V5cyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIC0tXG4gICAgICAgIC8vXG4gICAgICAgIGFwcGx5OiBmdW5jdGlvbiAodGFyZ2V0LCB0aGlzQXJnLCBhcmdzKSB7XG4gICAgICAgICAgICB2YXIgbW9kZWxzdGF0ZSA9IG1vbml0b3IucG9saWN5LkN1cnJlbnRNb2RlbFN0YXRlO1xuICAgICAgICAgICAgaWYgKGFic3RyYWN0bmFtZVswXSA9PT0gJ0AnIHx8IG1vZGVsc3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIGV2ZW50IGxpc3RlbmVyIG1vZGVsIGluZGljYXRlZCBieSBAIFxuICAgICAgICAgICAgICAgIC8vIG9yIGV4ZWN1dGlvbiBpbiB0aGUgZW1wdHkgbW9kZWwgc3RhdGUgc3RhY2sgaW5pZGljYXRpbmcgY2FsbCBpbml0aWFsdGVkIGZyb20gbGlicmFyeVxuICAgICAgICAgICAgICAgIC8vIHRoZSBhc3N1bXB0aW9uIGlzIHRoYXQgZXZlbnQgbGlzdGVuZXJzIGFyZSBvbmx5IGNhbGxlZFxuICAgICAgICAgICAgICAgIG1vZGVsc3RhdGUgPSBtb25pdG9yLnBvbGljeS5ldmVudG1vZGVsc3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUT0RPOiBDYXN0IC0gc2hvdWxkIGFkZCBjaGVjayFcbiAgICAgICAgICAgIHZhciB1bmxhYmVsZXIgPSBtb2RlbHN0YXRlLkdldE1vZGVsKGFic3RyYWN0bmFtZSk7XG4gICAgICAgICAgICB2YXIgbGFiZWxlZFRoaXMgPSBNa1ZhbHVlKHRoaXNBcmcsIHVubGFiZWxlci5TZWxmTGFiZWxlciwgbW9kZWxzdGF0ZSk7XG4gICAgICAgICAgICB2YXIgbGFiZWxlZEFyZ3MgPSBbXTtcbiAgICAgICAgICAgIHZhciBhcmdzbGFiZWxtb2RlbHMgPSB1bmxhYmVsZXIuQXJndW1lbnRzTGFiZWxlcjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyssIGorKykge1xuICAgICAgICAgICAgICAgIHdoaWxlICghYXJnc2xhYmVsbW9kZWxzLkdldExhYmVsZXIoaikuTW9kZWxGb3IoYXJnc1tpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYWJlbGVkQXJnc1tpXSA9IE1rVmFsdWUoYXJnc1tpXSwgYXJnc2xhYmVsbW9kZWxzLkdldExhYmVsZXIoaiksIG1vZGVsc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGpzZmxvd29iamVjdC5DYWxsKGxhYmVsZWRUaGlzLCBsYWJlbGVkQXJncyk7XG4gICAgICAgICAgICByZXR1cm4gdW5sYWJlbFZhbHVlKHJlc3VsdCwgdW5sYWJlbGVyLlJldHVyblVubGFiZWxlciwgbW9kZWxzdGF0ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIC0tLVxuICAgICAgICAvL1xuICAgICAgICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uICh0YXJnZXQsIGFyZ3MsIHJlY2VpdmVyKSB7XG4gICAgICAgICAgICB2YXIgbW9kZWxzdGF0ZSA9IG1vbml0b3IucG9saWN5LkN1cnJlbnRNb2RlbFN0YXRlO1xuICAgICAgICAgICAgdmFyIHVubGFiZWxlciA9IG1vZGVsc3RhdGUuR2V0TW9kZWwoYWJzdHJhY3RuYW1lKTtcbiAgICAgICAgICAgIHZhciBsYWJlbGVkQXJncyA9IFtdO1xuICAgICAgICAgICAgdmFyIGFyZ3NsYWJlbG1vZGVscyA9IHVubGFiZWxlci5Bcmd1bWVudHNMYWJlbGVyO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKywgaisrKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCFhcmdzbGFiZWxtb2RlbHMuR2V0TGFiZWxlcihqKS5Nb2RlbEZvcihhcmdzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhYmVsZWRBcmdzW2ldID0gTWtWYWx1ZShhcmdzW2ldLCBhcmdzbGFiZWxtb2RlbHMuR2V0TGFiZWxlcihqKSwgbW9kZWxzdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ganNmbG93b2JqZWN0LkNvbnN0cnVjdChsYWJlbGVkQXJncyk7XG4gICAgICAgICAgICByZXR1cm4gdW5sYWJlbFZhbHVlKHJlc3VsdCwgdW5sYWJlbGVyLlJldHVyblVubGFiZWxlciwgbW9kZWxzdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuLy8gLS0tXG5mdW5jdGlvbiB1bmxhYmVsVmFsdWUobGFiZWxlZFZhbHVlLCB2YWx1ZVVubGFiZWxlciwgbW9kZWxzdGF0ZSkge1xuICAgIHZhciB2YWx1ZSA9IHZhbHVlVW5sYWJlbGVyLlVubGFiZWxlci5VbmxhYmVsKGxhYmVsZWRWYWx1ZSwgbW9kZWxzdGF0ZSk7XG4gICAgdmFyIGpzdmFsdWUgPSB1bmxhYmVsKHZhbHVlLCB2YWx1ZVVubGFiZWxlci5BYnN0cmFjdE5hbWUsIG1vZGVsc3RhdGUpO1xuICAgIHJldHVybiBqc3ZhbHVlO1xufVxuLy8gLS0tXG4vLyB1bmxhYmVsXG4vLyAtLS0gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gdW5sYWJlbCh2YWx1ZSwgYWJzdHJhY3RuYW1lLCBtb2RlbHN0YXRlKSB7XG4gICAgdmFyIGVfNCwgX2E7XG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgdmFsVHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICBpZiAodmFsVHlwZSA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgdmFsVHlwZSA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgdmFsVHlwZSA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgIHZhbFR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgLy8gQmlGbywgRW50aXR5RnVuY3Rpb24sIEVudGl0eU9iamVjdCwgYWxsIFByb3RvdHlwZXMgYW5kIENvbnN0cnVjdG9yc1xuICAgIGlmICh2YWx1ZS5ob3N0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmhvc3Q7XG4gICAgfVxuICAgIC8vIHRvIGJlIGNhbGxhYmxlLCB0aGUgcHJveGllZCBvYmplY3QgbXVzdCBiZSBhIGZ1bmN0aW9uXG4gICAgLy8gdGh1cywgd2UgY29weSB0aGUgcHJvcGVydGllcyB0byBhIGZ1bmN0aW9uXG4gICAgLy8gdGhvc2UgcHJvcGVydGllcyBhcmUgbm90IHVzZWQsIGJ1dCB0aGV5IG11c3QgYmUgcHJlc2VudC5cbiAgICAvLyB0aGUgaGFuZGxlciBpbnRlcmFjdHMgd2l0aCB0aGUgb3JpZ2luYWwgb2JqZWN0IFxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uT2JqZWN0XzEuRnVuY3Rpb25PYmplY3QpIHtcbiAgICAgICAgdmFyIGZ1biA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXMoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUucHJvcGVydGllcykpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgIC8vIFdlIGNhbm5vdCBjb3B5IHRoZSBhcmd1bWVudHMsIHNpbmNlIGl0cyBub3Qgd3JpdGFibGUgb3IgY29uZmlndXJhYmxlIG9uIGZ1bmN0aW9uIG9iamVjdHNcbiAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSAnYXJndW1lbnRzJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBndWFyYW50ZWVkIHRvIGJlIHByZXNlbnRcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLnByb3BlcnRpZXMsIGtleSk7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmdW4sIGtleSwgZGVzYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzRfMSkgeyBlXzQgPSB7IGVycm9yOiBlXzRfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNCkgdGhyb3cgZV80LmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eShmdW4sIGhhbmRsZXIodmFsdWUsIGFic3RyYWN0bmFtZSkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb3h5KHZhbHVlLnByb3BlcnRpZXMsIGhhbmRsZXIodmFsdWUsIGFic3RyYWN0bmFtZSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW50aXR5LmpzLm1hcCIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG1vbml0b3JfMSA9IHJlcXVpcmUoXCIuLi9tb25pdG9yXCIpO1xudmFyIFdyYXBwZXJNb25pdG9yQmFzZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoV3JhcHBlck1vbml0b3JCYXNlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFdyYXBwZXJNb25pdG9yQmFzZShnbG9iYWwsIHByaW50LCBsb2csIHdhcm4sIGVycm9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGdsb2JhbCwgcHJpbnQsIGxvZywgd2FybiwgZXJyb3IpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmVudGl0eW1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgV3JhcHBlck1vbml0b3JCYXNlLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKGdsb2JhbCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBnbG9iYWwpO1xuICAgICAgICAvKlxuICAgICAgICB0aGlzLmVudGl0eW1hcC5zZXQoXG4gICAgICAgICAgdGhpcy5pbnN0YW5jZXMuT2JqZWN0UHJvdG90eXBlLmhvc3QsXG4gICAgICAgICAgdGhpcy5pbnN0YW5jZXMuT2JqZWN0UHJvdG90eXBlXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuZW50aXR5bWFwLnNldChcbiAgICAgICAgICB0aGlzLmluc3RhbmNlcy5GdW5jdGlvblByb3RvdHlwZS5ob3N0LFxuICAgICAgICAgIHRoaXMuaW5zdGFuY2VzLkZ1bmN0aW9uUHJvdG90eXBlXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuZW50aXR5bWFwLnNldChcbiAgICAgICAgICB0aGlzLmluc3RhbmNlcy5BcnJheVByb3RvdHlwZS5ob3N0LFxuICAgICAgICAgIHRoaXMuaW5zdGFuY2VzLkFycmF5UHJvdG90eXBlXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuZW50aXR5bWFwLnNldChcbiAgICAgICAgICB0aGlzLmluc3RhbmNlcy5TdHJpbmdQcm90b3R5cGUuaG9zdCxcbiAgICAgICAgICB0aGlzLmluc3RhbmNlcy5TdHJpbmdQcm90b3R5cGVcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5lbnRpdHltYXAuc2V0KFxuICAgICAgICAgIHRoaXMuaW5zdGFuY2VzLkJvb2xlYW5Qcm90b3R5cGUuaG9zdCxcbiAgICAgICAgICB0aGlzLmluc3RhbmNlcy5Cb29sZWFuUHJvdG90eXBlXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuZW50aXR5bWFwLnNldChcbiAgICAgICAgICB0aGlzLmluc3RhbmNlcy5OdW1iZXJQcm90b3R5cGUuaG9zdCxcbiAgICAgICAgICB0aGlzLmluc3RhbmNlcy5OdW1iZXJQcm90b3R5cGVcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5lbnRpdHltYXAuc2V0KFxuICAgICAgICAgIHRoaXMuaW5zdGFuY2VzLkRhdGVQcm90b3R5cGUuaG9zdCxcbiAgICAgICAgICB0aGlzLmluc3RhbmNlcy5EYXRlUHJvdG90eXBlXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuZW50aXR5bWFwLnNldChcbiAgICAgICAgICB0aGlzLmluc3RhbmNlcy5SZWdFeHBQcm90b3R5cGUuaG9zdCxcbiAgICAgICAgICB0aGlzLmluc3RhbmNlcy5SZWdFeHBQcm90b3R5cGVcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5lbnRpdHltYXAuc2V0KFxuICAgICAgICAgIHRoaXMuaW5zdGFuY2VzLkVycm9yUHJvdG90eXBlLmhvc3QsXG4gICAgICAgICAgdGhpcy5pbnN0YW5jZXMuRXJyb3JQcm90b3R5cGVcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5lbnRpdHltYXAuc2V0KFxuICAgICAgICAgIHRoaXMuaW5zdGFuY2VzLkZ1bmN0aW9uUHJvdG90eXBlLmhvc3QsXG4gICAgICAgICAgdGhpcy5pbnN0YW5jZXMuRnVuY3Rpb25Qcm90b3R5cGVcbiAgICAgICAgKTtcbiAgICAgICAgKi9cbiAgICB9O1xuICAgIHJldHVybiBXcmFwcGVyTW9uaXRvckJhc2U7XG59KG1vbml0b3JfMS5Nb25pdG9yQmFzZSkpO1xuZXhwb3J0cy5XcmFwcGVyTW9uaXRvckJhc2UgPSBXcmFwcGVyTW9uaXRvckJhc2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb25pdG9yLmpzLm1hcCIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24gKG8pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0sIGkgPSAwO1xuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICAgIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBsYWJlbF8xID0gcmVxdWlyZShcIi4uL2xhYmVsXCIpO1xudmFyIGJvdCA9IGxhYmVsXzEuTGFiZWwuYm90O1xudmFyIGZ1bGxfYWNjZXNzX3BhdGggPSB0cnVlO1xuLy8gLS0tXG5mdW5jdGlvbiBoYXNfb3duX3Byb3BlcnR5KG9iaiwgcHJvcCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cbmV4cG9ydHMuaGFzX293bl9wcm9wZXJ0eSA9IGhhc19vd25fcHJvcGVydHk7XG4vLyAtLS1cbnZhciBTZWN1cml0eVBvbGljeSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZWN1cml0eVBvbGljeShwb2xpY3kpIHtcbiAgICAgICAgLy8gbW9kZWwgc3RhdGUgc3RhY2sgLSBzb21ldGltZXMganNmbG93IGNhdXNlcyB1bmxhYmVsaW5nIHdpdGhvdXQgY2FsbGluZyBhIGxhYmVsZWQgIGV4cG9ydCBmdW5jdGlvblxuICAgICAgICAvLyBlLmcuLCB0aGlzIG9jY3VycyBpZiBjaGVja2luZyBpbnN0YW5jZW9mIG9uIGEgd3JhcHBlZCBqc2Zsb3cgb2JqZWN0XG4gICAgICAgIC8vIGZvciBub3cgd2UgbGV0IHRob3NlIHNwaWxsIGludG8gYSB0b3AtbGV2ZWwgbW9kZWwtc3RhdGVcbiAgICAgICAgdGhpcy5sYWJlbG1vZGVsbWFwID0ge307XG4gICAgICAgIHRoaXMudW5sYWJlbG1vZGVsbWFwID0ge307XG4gICAgICAgIHRoaXMubW9kZWxzdGF0ZXN0YWNrID0gW25ldyBUb3BsZXZlbE1vZGVsU3RhdGUobnVsbCldO1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHBvbGljeS5sYWJlbG1vZGVscykge1xuICAgICAgICAgICAgdGhpcy5sYWJlbG1vZGVsbWFwW25hbWVdID0gVHJhbmZvcm1lckZhY3RvcnkuTWFrZU9iamVjdExhYmVsZXIocG9saWN5LmxhYmVsbW9kZWxzW25hbWVdLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHBvbGljeS51bmxhYmVsbW9kZWxzKSB7XG4gICAgICAgICAgICB0aGlzLnVubGFiZWxtb2RlbG1hcFtuYW1lXSA9IFRyYW5mb3JtZXJGYWN0b3J5Lk1ha2VPYmplY3RVbmxhYmVsZXIocG9saWN5LnVubGFiZWxtb2RlbHNbbmFtZV0sIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2xvYmFsID0gbmV3IE9iamVjdExhYmVsZXIocG9saWN5Lmdsb2JhbCwgXCJnbG9iYWxcIik7XG4gICAgICAgIHRoaXMucGF0aG1vZGVsbWFwID0ge307XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gcG9saWN5LnBhdGhtb2RlbHMpIHtcbiAgICAgICAgICAgIHRoaXMucGF0aG1vZGVsbWFwW25hbWVdID0gcG9saWN5LnBhdGhtb2RlbHNbbmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gbW9kZWwgc3RhdGVzXG4gICAgICAgIHRoaXMuZ2xvYmFsbW9kZWxzdGF0ZSA9IG5ldyBNb2RlbFN0YXRlKG51bGwpO1xuICAgICAgICAvLyBldmVudCBtb2RlbCBzdGF0ZVxuICAgICAgICB0aGlzLmV2ZW50bW9kZWxzdGF0ZSA9IG5ldyBNb2RlbFN0YXRlKG51bGwpO1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHBvbGljeS5ldmVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRtb2RlbHN0YXRlLlNldE1vZGVsKG5hbWUsIFRyYW5mb3JtZXJGYWN0b3J5Lk1ha2VPYmplY3RVbmxhYmVsZXIocG9saWN5LmV2ZW50c1tuYW1lXSwgbmFtZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIC0tLSBcbiAgICAvLyBtb2RlbCBzdGF0ZSBzdGFjayBoYW5kbGluZ1xuICAgIFNlY3VyaXR5UG9saWN5LnByb3RvdHlwZS5QdXNoTW9kZWxTdGF0ZSA9IGZ1bmN0aW9uIChtb2RlbHN0YXRlKSB7XG4gICAgICAgIHRoaXMubW9kZWxzdGF0ZXN0YWNrLnVuc2hpZnQobW9kZWxzdGF0ZSk7XG4gICAgfTtcbiAgICBTZWN1cml0eVBvbGljeS5wcm90b3R5cGUuUG9wTW9kZWxTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubW9kZWxzdGF0ZXN0YWNrLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgbW9uaXRvci5mYXRhbChcIlRyeWluZyB0byBwb3AgdG9wbGV2ZWwgbW9kZWxzdGF0ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbHN0YXRlc3RhY2suc2hpZnQoKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZWN1cml0eVBvbGljeS5wcm90b3R5cGUsIFwiQ3VycmVudE1vZGVsU3RhdGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1vZGVsc3RhdGVzdGFja1swXTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLy8gLS0tXG4gICAgLy8gZXhwb3J0IGNsYXNzIG5hbWUgdG8gbW9kZWxzXG4gICAgU2VjdXJpdHlQb2xpY3kucHJvdG90eXBlLkdldExhYmVsZXIgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBpZiAoIXRoaXMubGFiZWxtb2RlbG1hcFtuYW1lXSkge1xuICAgICAgICAgICAgbW9uaXRvci5mYXRhbCgnTm8gbGFiZWwgbW9kZWwgZm9yICcgKyBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5sYWJlbG1vZGVsbWFwW25hbWVdO1xuICAgIH07XG4gICAgU2VjdXJpdHlQb2xpY3kucHJvdG90eXBlLkdldFVubGFiZWxlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGlmICghdGhpcy51bmxhYmVsbW9kZWxtYXBbbmFtZV0pIHtcbiAgICAgICAgICAgIG1vbml0b3IuZmF0YWwoJ05vIHVubGFiZWwgbW9kZWwgZm9yICcgKyBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy51bmxhYmVsbW9kZWxtYXBbbmFtZV07XG4gICAgfTtcbiAgICByZXR1cm4gU2VjdXJpdHlQb2xpY3k7XG59KCkpO1xuZXhwb3J0cy5TZWN1cml0eVBvbGljeSA9IFNlY3VyaXR5UG9saWN5O1xuLy8gLS0tXG52YXIgVHJhbmZvcm1lckZhY3RvcnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVHJhbmZvcm1lckZhY3RvcnkoKSB7XG4gICAgfVxuICAgIFRyYW5mb3JtZXJGYWN0b3J5Lk1ha2VPYmplY3RMYWJlbGVyID0gZnVuY3Rpb24gKG1vZGVsLCBwYXRoKSB7XG4gICAgICAgIGlmIChtb2RlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVua25vd25MYWJlbGVyKHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAobW9kZWwua2luZCkge1xuICAgICAgICAgICAgY2FzZSAnT2JqZWN0TGFiZWxNb2RlbCc6IHJldHVybiBuZXcgT2JqZWN0TGFiZWxlcihtb2RlbCwgcGF0aCk7XG4gICAgICAgICAgICBjYXNlICdGdW5jdGlvbkxhYmVsTW9kZWwnOiByZXR1cm4gbmV3IEZ1bmN0aW9uTGFiZWxlcihtb2RlbCwgcGF0aCk7XG4gICAgICAgICAgICBjYXNlICdBcnJheUxhYmVsTW9kZWwnOiByZXR1cm4gbmV3IEFycmF5TGFiZWxlcihtb2RlbCwgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmFtZWRMYWJlbE1vZGVsKG1vZGVsKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1vbml0b3IucG9saWN5LkdldExhYmVsZXIobW9kZWwubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vbml0b3IuZmF0YWwoJ1Vua25vd24gbGFiZWwgbW9kZWwgdHlwZSAnICsgbW9kZWwua2luZCk7XG4gICAgfTtcbiAgICBUcmFuZm9ybWVyRmFjdG9yeS5NYWtlT2JqZWN0VW5sYWJlbGVyID0gZnVuY3Rpb24gKG1vZGVsLCBwYXRoKSB7XG4gICAgICAgIGlmIChtb2RlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVua25vd25VbmxhYmVsZXIocGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChtb2RlbC5raW5kKSB7XG4gICAgICAgICAgICBjYXNlICdPYmplY3RVbmxhYmVsTW9kZWwnOiByZXR1cm4gbmV3IE9iamVjdFVubGFiZWxlcihtb2RlbCwgcGF0aCk7XG4gICAgICAgICAgICBjYXNlICdGdW5jdGlvblVubGFiZWxNb2RlbCc6IHJldHVybiBuZXcgRnVuY3Rpb25VbmxhYmVsZXIobW9kZWwsIHBhdGgpO1xuICAgICAgICAgICAgY2FzZSAnQXJyYXlVbmxhYmVsTW9kZWwnOiByZXR1cm4gbmV3IEFycmF5VW5sYWJlbGVyKG1vZGVsLCBwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOYW1lZFVubGFiZWxNb2RlbChtb2RlbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBtb25pdG9yLnBvbGljeS5HZXRVbmxhYmVsZXIobW9kZWwubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vbml0b3IuZmF0YWwoJ1Vua25vd24gdW5sYWJlbCBtb2RlbCB0eXBlICcgKyBtb2RlbC5raW5kKTtcbiAgICB9O1xuICAgIHJldHVybiBUcmFuZm9ybWVyRmFjdG9yeTtcbn0oKSk7XG5leHBvcnRzLlRyYW5mb3JtZXJGYWN0b3J5ID0gVHJhbmZvcm1lckZhY3Rvcnk7XG4vLyAtLS0gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIE1vZGVsU3RhdGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTW9kZWxTdGF0ZShwYXJlbnQpIHtcbiAgICAgICAgdGhpcy5sYWJlbFN0YXRlID0ge307XG4gICAgICAgIHRoaXMubW9kZWxTdGF0ZSA9IHt9O1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB9XG4gICAgLyogZXhwZWN0c1xuICAgICAqIGxhYmVsIGRlc2NyaXB0aW9uIChzdHJpbmcsIFtzdHJpbmddKVxuICAgICAqIGlmIGJlZ2lubmluZyB3aXRoIEAgdGhlbiBsYWJlbCB2YXJpYWJsZVxuICAgICAqIGVsc2UgbGFiZWwgc3RyaW5nXG4gICAgICpcbiAgICAgKiByZXR1cm5zIGx1YiBvZiBkZXNjcmlwdGlvbnNcbiAgICAgKi9cbiAgICBNb2RlbFN0YXRlLnByb3RvdHlwZS5sYWJlbCA9IGZ1bmN0aW9uIChsYWJlbG1vZGVscykge1xuICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgaWYgKGxhYmVsbW9kZWxzID09PSB1bmRlZmluZWQgfHwgbGFiZWxtb2RlbHMgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBib3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBsYWJlbG1vZGVscyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGxhYmVsbW9kZWxzID0gW2xhYmVsbW9kZWxzXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGFiZWwgPSBuZXcgbGFiZWxfMS5MYWJlbCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgbGFiZWxtb2RlbHNfMSA9IF9fdmFsdWVzKGxhYmVsbW9kZWxzKSwgbGFiZWxtb2RlbHNfMV8xID0gbGFiZWxtb2RlbHNfMS5uZXh0KCk7ICFsYWJlbG1vZGVsc18xXzEuZG9uZTsgbGFiZWxtb2RlbHNfMV8xID0gbGFiZWxtb2RlbHNfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFiZWxtb2RlbCA9IGxhYmVsbW9kZWxzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAobGFiZWxtb2RlbFswXSA9PT0gJ0AnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLmx1Yih0aGlzLmdldChsYWJlbG1vZGVsKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsYWJlbC5sdWIobmV3IGxhYmVsXzEuTGFiZWwobGFiZWxtb2RlbCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhYmVsbW9kZWxzXzFfMSAmJiAhbGFiZWxtb2RlbHNfMV8xLmRvbmUgJiYgKF9hID0gbGFiZWxtb2RlbHNfMS5yZXR1cm4pKSBfYS5jYWxsKGxhYmVsbW9kZWxzXzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYWJlbDtcbiAgICB9O1xuICAgIC8vIC0tLVxuICAgIC8vIGxhYmVsIHZhciBoYW5kbGluZ1xuICAgIE1vZGVsU3RhdGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChsYWJlbHZhcikge1xuICAgICAgICBpZiAobGFiZWx2YXIgaW4gdGhpcy5sYWJlbFN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYWJlbFN0YXRlW2xhYmVsdmFyXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5nZXQobGFiZWx2YXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb25pdG9yLmZhdGFsKFwiTW9kZWxTdGF0ZTogbGFiZWwgdmFyaWFibGUgXCIgKyBsYWJlbHZhciArIFwiIG5vdCBmb3VuZFwiKTtcbiAgICB9O1xuICAgIE1vZGVsU3RhdGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChsYWJlbHZhciwgbGFiZWwpIHtcbiAgICAgICAgdGhpcy5sYWJlbFN0YXRlW2xhYmVsdmFyXSA9IGxhYmVsO1xuICAgIH07XG4gICAgLy8gYWJzdHJhY3QgbmFtZSBtYXBwaW5nOyBzaG91bGQgbm90IHRyYXZlcnNlIG1vZGVsIHN0YXRlIGhpZXJhcmNoeVxuICAgIE1vZGVsU3RhdGUucHJvdG90eXBlLkdldE1vZGVsID0gZnVuY3Rpb24gKGFic3RyYWN0bmFtZSkge1xuICAgICAgICBpZiAodHlwZW9mIGFic3RyYWN0bmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG1vbml0b3IuZmF0YWwoJ0dldE1vZGVsIGFic3RyYWN0IG5hbWUgaXMgbm90IGEgc3RyaW5nIGJ1dCcsIGFic3RyYWN0bmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYXNfb3duX3Byb3BlcnR5KHRoaXMubGFiZWxTdGF0ZSwgYWJzdHJhY3RuYW1lKSkge1xuICAgICAgICAgICAgbW9uaXRvci53YXJuKCdubyB1bmxhYmVsIG1vZGVsIGZvcicsIGFic3RyYWN0bmFtZSk7XG4gICAgICAgICAgICB0aGlzLm1vZGVsU3RhdGVbYWJzdHJhY3RuYW1lXSA9IG5ldyBVbmtub3duVW5sYWJlbGVyKGFic3RyYWN0bmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWxTdGF0ZVthYnN0cmFjdG5hbWVdO1xuICAgIH07XG4gICAgTW9kZWxTdGF0ZS5wcm90b3R5cGUuU2V0TW9kZWwgPSBmdW5jdGlvbiAoYWJzdHJhY3RuYW1lLCBtb2RlbCkge1xuICAgICAgICBpZiAodHlwZW9mIGFic3RyYWN0bmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG1vbml0b3IuZmF0YWwoJ1NldE1vZGVsIGFic3RyYWN0IG5hbWUgaXMgbm90IGEgc3RyaW5nIGJ1dCcsIGFic3RyYWN0bmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2RlbFN0YXRlW2Fic3RyYWN0bmFtZV0gPSBtb2RlbDtcbiAgICB9O1xuICAgIHJldHVybiBNb2RlbFN0YXRlO1xufSgpKTtcbmV4cG9ydHMuTW9kZWxTdGF0ZSA9IE1vZGVsU3RhdGU7XG4vLyAtLS0gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIFRvcGxldmVsTW9kZWxTdGF0ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVG9wbGV2ZWxNb2RlbFN0YXRlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRvcGxldmVsTW9kZWxTdGF0ZShwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHBhcmVudCkgfHwgdGhpcztcbiAgICB9XG4gICAgVG9wbGV2ZWxNb2RlbFN0YXRlLnByb3RvdHlwZS5sYWJlbCA9IGZ1bmN0aW9uIChsYWJlbG1vZGVscykge1xuICAgICAgICBtb25pdG9yLndhcm4oJ1RvcGxldmVsTW9kZWxTdGF0ZSwgb3V0LW9mLWNvbnRleHQgbGFiZWwgb2YnLCBsYWJlbG1vZGVscywgJ3RyaWdnZXJlZCcpO1xuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5sYWJlbC5jYWxsKHRoaXMsIGxhYmVsbW9kZWxzKTtcbiAgICB9O1xuICAgIFRvcGxldmVsTW9kZWxTdGF0ZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGxhYmVsdmFyKSB7XG4gICAgICAgIG1vbml0b3Iud2FybignVG9wbGV2ZWxNb2RlbFN0YXRlLCBvdXQtb2YtY29udGV4dCBnZXQgb2YnLCBsYWJlbHZhciwgJ3RyaWdnZXJlZCcpO1xuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5nZXQuY2FsbCh0aGlzLCBsYWJlbHZhcik7XG4gICAgfTtcbiAgICBUb3BsZXZlbE1vZGVsU3RhdGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChsYWJlbHZhciwgbGFiZWwpIHtcbiAgICAgICAgbW9uaXRvci53YXJuKCdUb3BsZXZlbE1vZGVsU3RhdGUsIG91dC1vZi1jb250ZXh0IHNldCBvZicsIGxhYmVsdmFyLCAndHJpZ2dlcmVkJyk7XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnNldC5jYWxsKHRoaXMsIGxhYmVsdmFyLCBsYWJlbCk7XG4gICAgfTtcbiAgICBUb3BsZXZlbE1vZGVsU3RhdGUucHJvdG90eXBlLkdldE1vZGVsID0gZnVuY3Rpb24gKGFic3RyYWN0bmFtZSkge1xuICAgICAgICBtb25pdG9yLndhcm4oJ1RvcGxldmVsTW9kZWxTdGF0ZSwgb3V0LW9mLWNvbnRleHQgR2V0TW9kZWwgb2YnLCBhYnN0cmFjdG5hbWUsICd0cmlnZ2VyZWQnKTtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuR2V0TW9kZWwuY2FsbCh0aGlzLCBhYnN0cmFjdG5hbWUpO1xuICAgIH07XG4gICAgVG9wbGV2ZWxNb2RlbFN0YXRlLnByb3RvdHlwZS5TZXRNb2RlbCA9IGZ1bmN0aW9uIChhYnN0cmFjdG5hbWUsIG1vZGVsKSB7XG4gICAgICAgIG1vbml0b3Iud2FybignVG9wbGV2ZWxNb2RlbFN0YXRlLCBvdXQtb2YtY29udGV4dCBTZXRNb2RlbCBvZicsIGFic3RyYWN0bmFtZSwgJ3RyaWdnZXJlZCcpO1xuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5TZXRNb2RlbC5jYWxsKHRoaXMsIGFic3RyYWN0bmFtZSwgbW9kZWwpO1xuICAgIH07XG4gICAgcmV0dXJuIFRvcGxldmVsTW9kZWxTdGF0ZTtcbn0oTW9kZWxTdGF0ZSkpO1xuZXhwb3J0cy5Ub3BsZXZlbE1vZGVsU3RhdGUgPSBUb3BsZXZlbE1vZGVsU3RhdGU7XG5mdW5jdGlvbiBpc09iamVjdExhYmVsTW9kZWwobW9kZWwpIHtcbiAgICByZXR1cm4gbW9kZWwua2luZCA9PT0gJ09iamVjdExhYmVsTW9kZWwnO1xufVxuZXhwb3J0cy5pc09iamVjdExhYmVsTW9kZWwgPSBpc09iamVjdExhYmVsTW9kZWw7XG5mdW5jdGlvbiBpc09iamVjdFVubGFiZWxNb2RlbChtb2RlbCkge1xuICAgIHJldHVybiBtb2RlbC5raW5kID09PSAnT2JqZWN0VW5sYWJlbE1vZGVsJztcbn1cbmV4cG9ydHMuaXNPYmplY3RVbmxhYmVsTW9kZWwgPSBpc09iamVjdFVubGFiZWxNb2RlbDtcbmZ1bmN0aW9uIGlzTmFtZWRMYWJlbE1vZGVsKG1vZGVsKSB7XG4gICAgcmV0dXJuIG1vZGVsLmtpbmQgPT09ICdOYW1lZExhYmVsTW9kZWwnO1xufVxuZXhwb3J0cy5pc05hbWVkTGFiZWxNb2RlbCA9IGlzTmFtZWRMYWJlbE1vZGVsO1xuZnVuY3Rpb24gaXNOYW1lZFVubGFiZWxNb2RlbChtb2RlbCkge1xuICAgIHJldHVybiBtb2RlbC5raW5kID09PSAnTmFtZWRVbmxhYmVsTW9kZWwnO1xufVxuZXhwb3J0cy5pc05hbWVkVW5sYWJlbE1vZGVsID0gaXNOYW1lZFVubGFiZWxNb2RlbDtcbi8vIC0tLSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBMYWJlbGVyc1xudmFyIFByaW1pdGl2ZUxhYmVsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUHJpbWl0aXZlTGFiZWxlcihsYWJlbG1vZGVsKSB7XG4gICAgICAgIHRoaXMubGFiZWxtb2RlbCA9IGxhYmVsbW9kZWw7XG4gICAgfVxuICAgIFByaW1pdGl2ZUxhYmVsZXIucHJvdG90eXBlLkxhYmVsID0gZnVuY3Rpb24gKG1vZGVsc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIG1vZGVsc3RhdGUubGFiZWwodGhpcy5sYWJlbG1vZGVsKTtcbiAgICB9O1xuICAgIFByaW1pdGl2ZUxhYmVsZXIucHJvdG90eXBlLkV4dHJhY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhYmVsbW9kZWw7XG4gICAgfTtcbiAgICByZXR1cm4gUHJpbWl0aXZlTGFiZWxlcjtcbn0oKSk7XG5leHBvcnRzLlByaW1pdGl2ZUxhYmVsZXIgPSBQcmltaXRpdmVMYWJlbGVyO1xuLy8gLS0tIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBWYWx1ZUxhYmVsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVmFsdWVMYWJlbGVyKGxhYmVsbW9kZWwsIHBhdGgpIHtcbiAgICAgICAgaWYgKGxhYmVsbW9kZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbW9uaXRvci53YXJuKCd1bmRlZmluZWQgdmFsdWUgbGFiZWwgbW9kZWwgZm9yJywgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYWJlbG1vZGVsID0gbGFiZWxtb2RlbCB8fCB7IGxhYmVsOiB1bmRlZmluZWQsIG1vZGVsOiB1bmRlZmluZWQgfTtcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZhbHVlTGFiZWxlci5wcm90b3R5cGUsIFwiTGFiZWxlclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubGFiZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubGFiZWwgPSBuZXcgUHJpbWl0aXZlTGFiZWxlcih0aGlzLmxhYmVsbW9kZWwubGFiZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFiZWw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWYWx1ZUxhYmVsZXIucHJvdG90eXBlLCBcIlZhbHVlTGFiZWxlclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBUcmFuZm9ybWVyRmFjdG9yeS5NYWtlT2JqZWN0TGFiZWxlcih0aGlzLmxhYmVsbW9kZWwubW9kZWwsIHRoaXMucGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIFZhbHVlTGFiZWxlcjtcbn0oKSk7XG5leHBvcnRzLlZhbHVlTGFiZWxlciA9IFZhbHVlTGFiZWxlcjtcbi8vIC0tLSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgQXJndW1lbnRMYWJlbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBcmd1bWVudExhYmVsZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXJndW1lbnRMYWJlbGVyKGxhYmVsbW9kZWwsIHBhdGgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGxhYmVsbW9kZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbW9uaXRvci53YXJuKCd1bmRlZmluZWQgYXJndW1lbnQgbGFiZWwgbW9kZWwgZm9yJywgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBsYWJlbG1vZGVsLCBwYXRoKSB8fCB0aGlzO1xuICAgICAgICAvLyBAdHMtaWdub3JlIGluaXRpYWxpemVkIGJ5IHN1cGVyIGNhbGxcbiAgICAgICAgX3RoaXMub3B0aW9uYWwgPSBfdGhpcy5sYWJlbG1vZGVsLm9wdGlvbmFsO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEFyZ3VtZW50TGFiZWxlci5wcm90b3R5cGUuTW9kZWxGb3IgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMubGFiZWxtb2RlbC5vcHRpb25hbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSB0aGlzLmxhYmVsbW9kZWwub3B0aW9uYWw7XG4gICAgfTtcbiAgICByZXR1cm4gQXJndW1lbnRMYWJlbGVyO1xufShWYWx1ZUxhYmVsZXIpKTtcbmV4cG9ydHMuQXJndW1lbnRMYWJlbGVyID0gQXJndW1lbnRMYWJlbGVyO1xuLy8gLS0tXG52YXIgQXJndW1lbnRzTGFiZWxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBcmd1bWVudHNMYWJlbGVyKGxhYmVsbW9kZWwsIHBhdGgpIHtcbiAgICAgICAgaWYgKGxhYmVsbW9kZWwgIT09IHVuZGVmaW5lZCAmJiAhKGxhYmVsbW9kZWwgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgICAgIG1vbml0b3IuZmF0YWwoJ0FyZ3VtZW50c0xhYmVsTW9kZWwsIGV4cGVjdGVkIHVuZGVmaW5lZCBvciBhcnJheSwgZm9yJywgcGF0aCwgJ2J1dCBnb3QnLCBsYWJlbG1vZGVsKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhYmVsbW9kZWwgPSBsYWJlbG1vZGVsIHx8IFtdO1xuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICB0aGlzLmFyZ3NsYWJlbG1vZGVscyA9IFtdO1xuICAgIH1cbiAgICBBcmd1bWVudHNMYWJlbGVyLnByb3RvdHlwZS5HZXRMYWJlbGVyID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgaWYgKCFoYXNfb3duX3Byb3BlcnR5KHRoaXMuYXJnc2xhYmVsbW9kZWxzLCBpKSkge1xuICAgICAgICAgICAgdGhpcy5hcmdzbGFiZWxtb2RlbHNbaV0gPSBuZXcgQXJndW1lbnRMYWJlbGVyKHRoaXMubGFiZWxtb2RlbFtpXSwgdGhpcy5wYXRoICsgXCJbXCIgKyBpICsgXCJdXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFyZ3NsYWJlbG1vZGVsc1tpXTtcbiAgICB9O1xuICAgIHJldHVybiBBcmd1bWVudHNMYWJlbGVyO1xufSgpKTtcbmV4cG9ydHMuQXJndW1lbnRzTGFiZWxlciA9IEFyZ3VtZW50c0xhYmVsZXI7XG4vLyAtLS0gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIERlc2NyaXB0b3JMYWJlbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlc2NyaXB0b3JMYWJlbGVyKGxhYmVsbW9kZWwsIHBhdGgpIHtcbiAgICAgICAgdGhpcy5sYWJlbG1vZGVsID0gbGFiZWxtb2RlbCB8fCB7fTtcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlc2NyaXB0b3JMYWJlbGVyLnByb3RvdHlwZSwgXCJMYWJlbGVyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5sYWJlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYWJlbCA9IG5ldyBQcmltaXRpdmVMYWJlbGVyKHRoaXMubGFiZWxtb2RlbC5sYWJlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYWJlbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlc2NyaXB0b3JMYWJlbGVyLnByb3RvdHlwZSwgXCJWYWx1ZUxhYmVsZXJcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gVHJhbmZvcm1lckZhY3RvcnkuTWFrZU9iamVjdExhYmVsZXIodGhpcy5sYWJlbG1vZGVsLnZhbHVlLCB0aGlzLnBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZXNjcmlwdG9yTGFiZWxlci5wcm90b3R5cGUsIFwiR2V0dGVyTGFiZWxlclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0dGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldHRlciA9IG5ldyBGdW5jdGlvbkxhYmVsZXIodGhpcy5sYWJlbG1vZGVsLmdldHRlciwgdGhpcy5wYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldHRlcjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlc2NyaXB0b3JMYWJlbGVyLnByb3RvdHlwZSwgXCJTZXR0ZXJMYWJlbGVyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGVyID0gbmV3IEZ1bmN0aW9uTGFiZWxlcih0aGlzLmxhYmVsbW9kZWwuc2V0dGVyLCB0aGlzLnBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGVyO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gRGVzY3JpcHRvckxhYmVsZXI7XG59KCkpO1xuZXhwb3J0cy5EZXNjcmlwdG9yTGFiZWxlciA9IERlc2NyaXB0b3JMYWJlbGVyO1xuLy8gLS0tXG52YXIgRGVzY3JpcHRvclVubGFiZWxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZXNjcmlwdG9yVW5sYWJlbGVyKHVubGFiZWxtb2RlbCwgcGF0aCkge1xuICAgICAgICB0aGlzLnVubGFiZWxtb2RlbCA9IHVubGFiZWxtb2RlbCB8fCB7fTtcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlc2NyaXB0b3JVbmxhYmVsZXIucHJvdG90eXBlLCBcIlVubGFiZWxlclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubGFiZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubGFiZWwgPSBuZXcgUHJpbWl0aXZlVW5sYWJlbGVyKHRoaXMudW5sYWJlbG1vZGVsLmxhYmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxhYmVsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVzY3JpcHRvclVubGFiZWxlci5wcm90b3R5cGUsIFwiVmFsdWVVbmxhYmVsZXJcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy51bmxhYmVsbW9kZWwudmFsdWUgfHwgdGhpcy5wYXRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZXNjcmlwdG9yVW5sYWJlbGVyLnByb3RvdHlwZSwgXCJHZXR0ZXJVbmxhYmVsZXJcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdldHRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXR0ZXIgPSB0aGlzLnVubGFiZWxtb2RlbC5nZXR0ZXIgfHwgdGhpcy5wYXRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0dGVyO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVzY3JpcHRvclVubGFiZWxlci5wcm90b3R5cGUsIFwiU2V0dGVyVW5sYWJlbGVyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGVyID0gdGhpcy51bmxhYmVsbW9kZWwuc2V0dGVyIHx8IHRoaXMucGF0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldHRlcjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIERlc2NyaXB0b3JVbmxhYmVsZXI7XG59KCkpO1xuZXhwb3J0cy5EZXNjcmlwdG9yVW5sYWJlbGVyID0gRGVzY3JpcHRvclVubGFiZWxlcjtcbi8vIC0tLVxudmFyIFByb3BlcnR5TGFiZWxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQcm9wZXJ0eUxhYmVsZXIobGFiZWxtb2RlbCwgcGF0aCkge1xuICAgICAgICBpZiAobGFiZWxtb2RlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBzZWxlY3RlZCBwYXRoIGJhc2VkXG4gICAgICAgICAgICAvLyBsZXQgbGFiZWwgPSBtb25pdG9yLnBvbGljeS5wYXRobW9kZWxtYXBbcGF0aF07XG4gICAgICAgICAgICB2YXIgbGFiZWwgPSBwYXRoLnJlcGxhY2UoL1xcLnByb3RvdHlwZS9nLCAnJyk7XG4gICAgICAgICAgICBpZiAobGFiZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG1vbml0b3Iud2FybihcImF1dG9sYWJlbGluZyBcXFwiXCIgKyBwYXRoICsgXCJcXFwiIDogXFxcIlwiICsgbGFiZWwgKyBcIlxcXCJcIik7XG4gICAgICAgICAgICAgICAgbGFiZWxtb2RlbCA9IHsgbGFiZWw6IGxhYmVsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb25pdG9yLndhcm4oJ3VuZGVmaW5lZCBwcm9wZXJ0eSBsYWJlbCBtb2RlbCBmb3InLCBwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhYmVsbW9kZWwgPSBsYWJlbG1vZGVsIHx8IHt9O1xuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJvcGVydHlMYWJlbGVyLnByb3RvdHlwZSwgXCJMYWJlbGVyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5sYWJlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYWJlbCA9IG5ldyBQcmltaXRpdmVMYWJlbGVyKHRoaXMubGFiZWxtb2RlbC5sYWJlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYWJlbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFByb3BlcnR5TGFiZWxlci5wcm90b3R5cGUsIFwiUmVhZExhYmVsZXJcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVhZCA9IG5ldyBEZXNjcmlwdG9yTGFiZWxlcih0aGlzLmxhYmVsbW9kZWwucmVhZCwgdGhpcy5wYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQcm9wZXJ0eUxhYmVsZXIucHJvdG90eXBlLCBcIldyaXRlVW5sYWJlbGVyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy53cml0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZSA9IG5ldyBEZXNjcmlwdG9yVW5sYWJlbGVyKHRoaXMubGFiZWxtb2RlbC53cml0ZSwgdGhpcy5wYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLndyaXRlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gUHJvcGVydHlMYWJlbGVyO1xufSgpKTtcbmV4cG9ydHMuUHJvcGVydHlMYWJlbGVyID0gUHJvcGVydHlMYWJlbGVyO1xuLy8gLS0tIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBPYmplY3RMYWJlbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9iamVjdExhYmVsZXIobGFiZWxtb2RlbCwgcGF0aCkge1xuICAgICAgICBpZiAobGFiZWxtb2RlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBtb25pdG9yLndhcm4oJ3VuZGVmaW5lZCBvYmplY3QgbGFiZWwgbW9kZWwgZm9yJywgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYWJlbG1vZGVsID0gbGFiZWxtb2RlbCB8fCB7IGtpbmQ6ICdPYmplY3RMYWJlbE1vZGVsJyB9O1xuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7fTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdExhYmVsZXIucHJvdG90eXBlLCBcIlByb3RvdHlwZUxhYmVsZXJcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3RvdHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm90b3R5cGUgPSBuZXcgUHJvcGVydHlMYWJlbGVyKHRoaXMubGFiZWxtb2RlbC5wcm90b3R5cGUsIHRoaXMucGF0aCArICcucHJvdG90eXBlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm90b3R5cGU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdExhYmVsZXIucHJvdG90eXBlLkdldFByb3BlcnR5TGFiZWxlciA9IGZ1bmN0aW9uIChwcm9wZXJ0eW5hbWUpIHtcbiAgICAgICAgaWYgKCFoYXNfb3duX3Byb3BlcnR5KHRoaXMucHJvcGVydGllcywgcHJvcGVydHluYW1lKSkge1xuICAgICAgICAgICAgdmFyIHByb3BlcnR5TW9kZWwgPSB0aGlzLmxhYmVsbW9kZWwucHJvcGVydGllcyAmJiB0aGlzLmxhYmVsbW9kZWwucHJvcGVydGllc1twcm9wZXJ0eW5hbWVdO1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzW3Byb3BlcnR5bmFtZV0gPSBuZXcgUHJvcGVydHlMYWJlbGVyKHByb3BlcnR5TW9kZWwsIHRoaXMucGF0aCArICcuJyArIHByb3BlcnR5bmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcGVydGllc1twcm9wZXJ0eW5hbWVdO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdExhYmVsZXIucHJvdG90eXBlLCBcIkxhYmVsZXJcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxhYmVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhYmVsID0gbmV3IFByaW1pdGl2ZUxhYmVsZXIodGhpcy5sYWJlbG1vZGVsLmxhYmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxhYmVsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0TGFiZWxlcjtcbn0oKSk7XG5leHBvcnRzLk9iamVjdExhYmVsZXIgPSBPYmplY3RMYWJlbGVyO1xuLy8gLS0tIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFRPRE86IGVmZmVjdHNcbnZhciBGdW5jdGlvbkxhYmVsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZ1bmN0aW9uTGFiZWxlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGdW5jdGlvbkxhYmVsZXIobGFiZWxtb2RlbCwgcGF0aCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAobGFiZWxtb2RlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBtb25pdG9yLndhcm4oJ3VuZGVmaW5lZCBleHBvcnQgZnVuY3Rpb24gbGFiZWwgbW9kZWwgZm9yJywgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQHRzLWlnbm9yZSBpbml0aWFsaXplZCBieSBzdXBlciBjYWxsXG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbGFiZWxtb2RlbCwgcGF0aCkgfHwgdGhpcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnVuY3Rpb25MYWJlbGVyLnByb3RvdHlwZSwgXCJBcmd1bWVudHNVbmxhYmVsZXJcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFyZ3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXJncyA9IG5ldyBBcmd1bWVudHNVbmxhYmVsZXIodGhpcy5sYWJlbG1vZGVsLmFyZ3MsIHRoaXMucGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcmdzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnVuY3Rpb25MYWJlbGVyLnByb3RvdHlwZSwgXCJTZWxmVW5sYWJlbGVyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZWxmID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZnVsbF9hY2Nlc3NfcGF0aClcbiAgICAgICAgICAgICAgICAgICAgbW9uaXRvci5sb2codGhpcy5wYXRoICsgJ1tDYWxsXScpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZiA9IG5ldyBWYWx1ZVVubGFiZWxlcih0aGlzLmxhYmVsbW9kZWwuc2VsZiwgdGhpcy5wYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbGY7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGdW5jdGlvbkxhYmVsZXIucHJvdG90eXBlLCBcIlJldHVybkxhYmVsZXJcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZ1bGxfYWNjZXNzX3BhdGgpXG4gICAgICAgICAgICAgICAgICAgIG1vbml0b3IubG9nKHRoaXMucGF0aCArICdbUmV0dXJuVmFsdWVdJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXQgPSBuZXcgVmFsdWVMYWJlbGVyKHRoaXMubGFiZWxtb2RlbC5yZXQsIHRoaXMucGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8vIFRPRE86IElzc3VlICMzNSwgaHR0cHM6Ly9iaXRidWNrZXQub3JnL2NoYWxtZXJzbGJzL2pzZmxvdy9pc3N1ZXMvMzUvc3VwcG9ydC1mb3ItZXhjZXB0aW9uc1xuICAgIEZ1bmN0aW9uTGFiZWxlci5wcm90b3R5cGUuR2V0RXhjZXB0aW9uTGFiZWxNb2RlbCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgVW5rbm93bkxhYmVsZXIobmFtZSk7XG4gICAgfTtcbiAgICAvLyBUT0RPOiBJc3N1ZSAjMzUsIGh0dHBzOi8vYml0YnVja2V0Lm9yZy9jaGFsbWVyc2xicy9qc2Zsb3cvaXNzdWVzLzM1L3N1cHBvcnQtZm9yLWV4Y2VwdGlvbnNcbiAgICBGdW5jdGlvbkxhYmVsZXIucHJvdG90eXBlLkdldEV4Y2VwdGlvbkxhYmVsID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGJvdDtcbiAgICB9O1xuICAgIHJldHVybiBGdW5jdGlvbkxhYmVsZXI7XG59KE9iamVjdExhYmVsZXIpKTtcbmV4cG9ydHMuRnVuY3Rpb25MYWJlbGVyID0gRnVuY3Rpb25MYWJlbGVyO1xuLy8gLS0tIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFRPRE86IGFycmF5cyBzaG91bGQgZmFsbCBiYWNrIG9uIG9iamVjdHNcbnZhciBBcnJheUxhYmVsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFycmF5TGFiZWxlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBcnJheUxhYmVsZXIobGFiZWxtb2RlbCwgcGF0aCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAobGFiZWxtb2RlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBtb25pdG9yLndhcm4oJ3VuZGVmaW5lZCBhcnJheSBsYWJlbCBtb2RlbCBmb3InLCBwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBAdHMtaWdub3JlIGluaXRpYWxpemVkIGJ5IHN1cGVyIGNhbGxcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBsYWJlbG1vZGVsLCBwYXRoKSB8fCB0aGlzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEFycmF5TGFiZWxlci5wcm90b3R5cGUuR2V0UHJvcGVydHlMYWJlbE1vZGVsID0gZnVuY3Rpb24gKHByb3BlcnR5bmFtZSkge1xuICAgICAgICBpZiAodGhpcy5lbGVtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IGNyZWF0ZSB0aGUgcmlnaHQgdHlwZVxuICAgICAgICAgICAgdGhpcy5lbGVtZW50ID0gbmV3IFByb3BlcnR5TGFiZWxlcih0aGlzLmxhYmVsbW9kZWwuZWxlbWVudCwgdGhpcy5wYXRoICsgJy4nICsgcHJvcGVydHluYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50O1xuICAgIH07XG4gICAgcmV0dXJuIEFycmF5TGFiZWxlcjtcbn0oT2JqZWN0TGFiZWxlcikpO1xuZXhwb3J0cy5BcnJheUxhYmVsZXIgPSBBcnJheUxhYmVsZXI7XG4vLyAtLS0gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gTWVyZ2UgYmV0d2VlbiBhbGwgb3RoZXIgbW9kZWxzLiBUT0RPOiBBZGQgZXhwb3J0IGZ1bmN0aW9uIGFuZCBjb25zdHJ1Y3RvciBzdXBwb3J0LlxudmFyIFVua25vd25MYWJlbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFVua25vd25MYWJlbGVyKHBhdGgpIHtcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0ge307XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVbmtub3duTGFiZWxlci5wcm90b3R5cGUsIFwiUHJvdG90eXBlTGFiZWxlclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvdG90eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3RvdHlwZSA9IG5ldyBQcm9wZXJ0eUxhYmVsZXIodW5kZWZpbmVkLCB0aGlzLnBhdGggKyAnLnByb3RvdHlwZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdG90eXBlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBVbmtub3duTGFiZWxlci5wcm90b3R5cGUuR2V0UHJvcGVydHlMYWJlbGVyID0gZnVuY3Rpb24gKHByb3BlcnR5bmFtZSkge1xuICAgICAgICBpZiAoIWhhc19vd25fcHJvcGVydHkodGhpcy5wcm9wZXJ0aWVzLCBwcm9wZXJ0eW5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXNbcHJvcGVydHluYW1lXSA9IG5ldyBQcm9wZXJ0eUxhYmVsZXIodW5kZWZpbmVkLCB0aGlzLnBhdGggKyAnLicgKyBwcm9wZXJ0eW5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXNbcHJvcGVydHluYW1lXTtcbiAgICB9O1xuICAgIFVua25vd25MYWJlbGVyLnByb3RvdHlwZS5HZXRTdHJ1Y3RMYWJlbCA9IGZ1bmN0aW9uIChtb2RlbHN0YXRlKSB7XG4gICAgICAgIHJldHVybiBib3Q7XG4gICAgfTtcbiAgICAvLyBleGNlcHRpb24gc3VwcG9ydFxuICAgIC8vIFRPRE86IElzc3VlICMzNSwgaHR0cHM6Ly9iaXRidWNrZXQub3JnL2NoYWxtZXJzbGJzL2pzZmxvdy9pc3N1ZXMvMzUvc3VwcG9ydC1mb3ItZXhjZXB0aW9uc1xuICAgIFVua25vd25MYWJlbGVyLnByb3RvdHlwZS5HZXRFeGNlcHRpb25MYWJlbE1vZGVsID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVbmtub3duTGFiZWxlcihuYW1lKTtcbiAgICB9O1xuICAgIC8vIFRPRE86IElzc3VlICMzNSwgaHR0cHM6Ly9iaXRidWNrZXQub3JnL2NoYWxtZXJzbGJzL2pzZmxvdy9pc3N1ZXMvMzUvc3VwcG9ydC1mb3ItZXhjZXB0aW9uc1xuICAgIFVua25vd25MYWJlbGVyLnByb3RvdHlwZS5HZXRFeGNlcHRpb25MYWJlbCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBib3Q7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVW5rbm93bkxhYmVsZXIucHJvdG90eXBlLCBcIkFyZ3VtZW50c1VubGFiZWxlclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXJncyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZ1bGxfYWNjZXNzX3BhdGgpXG4gICAgICAgICAgICAgICAgICAgIG1vbml0b3IubG9nKHRoaXMucGF0aCArICdbYXJnc10nKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFyZ3MgPSBuZXcgQXJndW1lbnRzVW5sYWJlbGVyKHVuZGVmaW5lZCwgdGhpcy5wYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFyZ3M7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVbmtub3duTGFiZWxlci5wcm90b3R5cGUsIFwiU2VsZlVubGFiZWxlclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZ1bGxfYWNjZXNzX3BhdGgpXG4gICAgICAgICAgICAgICAgICAgIG1vbml0b3IubG9nKHRoaXMucGF0aCArICdbdGhpc10nKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGYgPSBuZXcgVmFsdWVVbmxhYmVsZXIodW5kZWZpbmVkLCB0aGlzLnBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFVua25vd25MYWJlbGVyLnByb3RvdHlwZSwgXCJSZXR1cm5MYWJlbGVyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChmdWxsX2FjY2Vzc19wYXRoKVxuICAgICAgICAgICAgICAgICAgICBtb25pdG9yLmxvZyh0aGlzLnBhdGggKyAnW3JldF0nKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJldCA9IG5ldyBWYWx1ZUxhYmVsZXIodW5kZWZpbmVkLCB0aGlzLnBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmV0O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVW5rbm93bkxhYmVsZXIucHJvdG90eXBlLCBcIkVmZmVjdHNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFVua25vd25MYWJlbGVyLnByb3RvdHlwZSwgXCJMYWJlbGVyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5sYWJlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYWJlbCA9IG5ldyBQcmltaXRpdmVMYWJlbGVyKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYWJlbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFVua25vd25MYWJlbGVyLnByb3RvdHlwZSwgXCJSZWFkTGFiZWxlclwiLCB7XG4gICAgICAgIC8vIGZvciByZWFkaW5nXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkID0gbmV3IERlc2NyaXB0b3JMYWJlbGVyKHVuZGVmaW5lZCwgdGhpcy5wYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVbmtub3duTGFiZWxlci5wcm90b3R5cGUsIFwiV3JpdGVVbmxhYmVsZXJcIiwge1xuICAgICAgICAvLyBmb3Igd3JpdGluZ1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLndyaXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlID0gbmV3IERlc2NyaXB0b3JVbmxhYmVsZXIodW5kZWZpbmVkLCB0aGlzLnBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMud3JpdGU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBVbmtub3duTGFiZWxlcjtcbn0oKSk7XG5leHBvcnRzLlVua25vd25MYWJlbGVyID0gVW5rbm93bkxhYmVsZXI7XG4vLyAtLS0gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHVubGFiZWwgbW9kZWxzXG52YXIgUHJpbWl0aXZlVW5sYWJlbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFByaW1pdGl2ZVVubGFiZWxlcihsYWJlbHZhcikge1xuICAgICAgICB0aGlzLnZhcmlhYmxlID0gbGFiZWx2YXI7XG4gICAgICAgIGlmIChsYWJlbHZhciAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBsYWJlbHZhciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG1vbml0b3IuZmF0YWwoJ1ByaW1pdGl2ZVVubGFiZWxNb2RlbCwgZXhwZWN0aW5nIGxhYmVsIHZhcmlhYmxlLCBnb3QnLCBsYWJlbHZhcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyogZXhwZWN0c1xuICAgICAqICBWYWx1ZVxuICAgICAqL1xuICAgIFByaW1pdGl2ZVVubGFiZWxlci5wcm90b3R5cGUuVW5sYWJlbCA9IGZ1bmN0aW9uICh2YWx1ZSwgbW9kZWxzdGF0ZSkge1xuICAgICAgICBpZiAodGhpcy52YXJpYWJsZSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG1vZGVsc3RhdGUuc2V0KHRoaXMudmFyaWFibGUsIHZhbHVlLmxhYmVsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWUudmFsdWU7XG4gICAgfTtcbiAgICByZXR1cm4gUHJpbWl0aXZlVW5sYWJlbGVyO1xufSgpKTtcbmV4cG9ydHMuUHJpbWl0aXZlVW5sYWJlbGVyID0gUHJpbWl0aXZlVW5sYWJlbGVyO1xuLy8gLS0tIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgVmFsdWVVbmxhYmVsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVmFsdWVVbmxhYmVsZXIodW5sYWJlbG1vZGVsLCBwYXRoKSB7XG4gICAgICAgIGlmICh1bmxhYmVsbW9kZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbW9uaXRvci53YXJuKCd1bmRlZmluZWQgdmFsdWUgdW5sYWJlbCBtb2RlbCBmb3InLCBwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVubGFiZWxtb2RlbCA9IHVubGFiZWxtb2RlbCB8fCB7fTtcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZhbHVlVW5sYWJlbGVyLnByb3RvdHlwZSwgXCJVbmxhYmVsZXJcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnVubGFiZWxlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bmxhYmVsZXIgPSBuZXcgUHJpbWl0aXZlVW5sYWJlbGVyKHRoaXMudW5sYWJlbG1vZGVsLmxhYmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVubGFiZWxlcjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZhbHVlVW5sYWJlbGVyLnByb3RvdHlwZSwgXCJBYnN0cmFjdE5hbWVcIiwge1xuICAgICAgICAvLyB1bmRlZmluZWQgb3IgYWJzdHJhY3QgbmFtZVxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFic3RyYWN0bmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hYnN0cmFjdG5hbWUgPSB0aGlzLnVubGFiZWxtb2RlbC5tb2RlbCB8fCB0aGlzLnBhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hYnN0cmFjdG5hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBWYWx1ZVVubGFiZWxlcjtcbn0oKSk7XG5leHBvcnRzLlZhbHVlVW5sYWJlbGVyID0gVmFsdWVVbmxhYmVsZXI7XG4vLyAtLS0gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBBcmd1bWVudFVubGFiZWxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXJndW1lbnRVbmxhYmVsZXIsIF9zdXBlcik7XG4gICAgLy8gLS0tXG4gICAgZnVuY3Rpb24gQXJndW1lbnRVbmxhYmVsZXIodW5sYWJlbG1vZGVsLCBwYXRoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh1bmxhYmVsbW9kZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbW9uaXRvci53YXJuKCd1bmRlZmluZWQgYXJndW1lbnQgdW5sYWJlbCBtb2RlbCBmb3InLCBwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHVubGFiZWxtb2RlbCwgcGF0aCkgfHwgdGhpcztcbiAgICAgICAgLy8gQHRzLWlnbm9yZSBpbml0aWFsaXplZCBieSBzdXBlciBjYWxsXG4gICAgICAgIF90aGlzLm9wdGlvbmFsID0gX3RoaXMudW5sYWJlbG1vZGVsLm9wdGlvbmFsO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8vIC0tLVxuICAgIEFyZ3VtZW50VW5sYWJlbGVyLnByb3RvdHlwZS5Nb2RlbEZvciA9IGZ1bmN0aW9uIChsYWJlbGVkdmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uYWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0eXBlb2YgbGFiZWxlZHZhbHVlLnZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlICd1bmRlZmluZWQnOiByZXR1cm4gdGhpcy5vcHRpb25hbCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgICAgICBjYXNlICdib29sZWFuJzogcmV0dXJuIHRoaXMub3B0aW9uYWwgPT09ICdib29sZWFuJztcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6IHJldHVybiB0aGlzLm9wdGlvbmFsID09PSAnbnVtYmVyJztcbiAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6IHJldHVybiB0aGlzLm9wdGlvbmFsID09PSAnc3RyaW5nJztcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFiZWxlZHZhbHVlLnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbmFsID09PSAnbnVsbCc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbGFiZWxlZHZhbHVlLnZhbHVlIG11c3QgYSBKU0Zsb3cgb2JqZWN0IC0gdXNlIHRoZSBDbGFzcyBwcm9wZXJ0eVxuICAgICAgICBzd2l0Y2ggKGxhYmVsZWR2YWx1ZS52YWx1ZS5DbGFzcykge1xuICAgICAgICAgICAgY2FzZSAnT2JqZWN0JzogcmV0dXJuIHRoaXMub3B0aW9uYWwgPT09ICdvYmplY3QnO1xuICAgICAgICAgICAgY2FzZSAnRnVuY3Rpb24nOiByZXR1cm4gdGhpcy5vcHRpb25hbCA9PT0gJ2V4cG9ydCBmdW5jdGlvbic7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vbml0b3IuZmF0YWwoXCJBcmd1bWVudFVubGFiZWxNb2RlbDpNb2RlbEZvcjogZG9uJ3Qga25vdyBob3cgdG8gaGFuZGxlXCIsIGxhYmVsZWR2YWx1ZS52YWx1ZSk7XG4gICAgfTtcbiAgICByZXR1cm4gQXJndW1lbnRVbmxhYmVsZXI7XG59KFZhbHVlVW5sYWJlbGVyKSk7XG5leHBvcnRzLkFyZ3VtZW50VW5sYWJlbGVyID0gQXJndW1lbnRVbmxhYmVsZXI7XG4vLyAtLS0gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBBcmd1bWVudHNVbmxhYmVsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXJndW1lbnRzVW5sYWJlbGVyKHVubGFiZWxtb2RlbCwgcGF0aCkge1xuICAgICAgICBpZiAodW5sYWJlbG1vZGVsICE9PSB1bmRlZmluZWQgJiYgISh1bmxhYmVsbW9kZWwgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgICAgIG1vbml0b3IuZmF0YWwoJ0FyZ3VtZW50c1VubGFiZWxNb2RlbCwgZXhwZWN0aW5nIHVuZGVmaW5lZCBvciBhcnJheSwgZ290JywgdW5sYWJlbG1vZGVsKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVubGFiZWxtb2RlbCA9IHVubGFiZWxtb2RlbCB8fCBbXTtcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5hcmdzID0gW107XG4gICAgfVxuICAgIEFyZ3VtZW50c1VubGFiZWxlci5wcm90b3R5cGUuR2V0QXJndW1lbnRVbmxhYmVsZXIgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICBpZiAoIWhhc19vd25fcHJvcGVydHkodGhpcy5hcmdzLCBpKSkge1xuICAgICAgICAgICAgdGhpcy5hcmdzW2ldID0gbmV3IEFyZ3VtZW50VW5sYWJlbGVyKHRoaXMudW5sYWJlbG1vZGVsW2ldLCB0aGlzLnBhdGggKyBcIltcIiArIGkgKyBcIl1cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYXJnc1tpXTtcbiAgICB9O1xuICAgIHJldHVybiBBcmd1bWVudHNVbmxhYmVsZXI7XG59KCkpO1xuZXhwb3J0cy5Bcmd1bWVudHNVbmxhYmVsZXIgPSBBcmd1bWVudHNVbmxhYmVsZXI7XG4vLyAtLS0gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBQcm9wZXJ0eVVubGFiZWxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQcm9wZXJ0eVVubGFiZWxlcih1bmxhYmVsbW9kZWwsIHBhdGgpIHtcbiAgICAgICAgaWYgKHVubGFiZWxtb2RlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBtb25pdG9yLndhcm4oJ3VuZGVmaW5lZCBwcm9wZXJ0eSB1bmxhYmVsIG1vZGVsIGZvcicsIHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudW5sYWJlbG1vZGVsID0gdW5sYWJlbG1vZGVsIHx8IHt9O1xuICAgICAgICB0aGlzLm5hbWUgPSBwYXRoO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJvcGVydHlVbmxhYmVsZXIucHJvdG90eXBlLCBcIlVubGFiZWxlclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubGFiZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubGFiZWwgPSBuZXcgUHJpbWl0aXZlVW5sYWJlbGVyKHRoaXMudW5sYWJlbG1vZGVsLmxhYmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxhYmVsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJvcGVydHlVbmxhYmVsZXIucHJvdG90eXBlLCBcIlJlYWRVbmxhYmVsZXJcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVhZCA9IG5ldyBEZXNjcmlwdG9yVW5sYWJlbGVyKHRoaXMudW5sYWJlbG1vZGVsLnJlYWQsIHRoaXMubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJvcGVydHlVbmxhYmVsZXIucHJvdG90eXBlLCBcIldyaXRlTGFiZWxlclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMud3JpdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGUgPSBuZXcgRGVzY3JpcHRvckxhYmVsZXIodGhpcy51bmxhYmVsbW9kZWwud3JpdGUsIHRoaXMubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53cml0ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIFByb3BlcnR5VW5sYWJlbGVyO1xufSgpKTtcbmV4cG9ydHMuUHJvcGVydHlVbmxhYmVsZXIgPSBQcm9wZXJ0eVVubGFiZWxlcjtcbi8vIC0tLSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVE9ETzogaGFuZGxpbmcgb2Ygc3RydWN0LCBpc0V4c3RlbnNpYmxlIGFuZCBvdGhlciB0cmFwc1xudmFyIE9iamVjdFVubGFiZWxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPYmplY3RVbmxhYmVsZXIodW5sYWJlbG1vZGVsLCBwYXRoKSB7XG4gICAgICAgIGlmICh1bmxhYmVsbW9kZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbW9uaXRvci53YXJuKCd1bmRlZmluZWQgb2JqZWN0IHVubGFiZWwgbW9kZWwgZm9yJywgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51bmxhYmVsbW9kZWwgPSB1bmxhYmVsbW9kZWwgfHwgeyBraW5kOiAnT2JqZWN0VW5sYWJlbE1vZGVsJyB9O1xuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7fTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdFVubGFiZWxlci5wcm90b3R5cGUsIFwiVW5sYWJlbGVyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5sYWJlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYWJlbCA9IG5ldyBQcmltaXRpdmVVbmxhYmVsZXIodGhpcy51bmxhYmVsbW9kZWwubGFiZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFiZWw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3RVbmxhYmVsZXIucHJvdG90eXBlLCBcIlByb3RvdHlwZVVubGFiZWxlclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvdG90eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3RvdHlwZSA9IG5ldyBQcm9wZXJ0eVVubGFiZWxlcih0aGlzLnVubGFiZWxtb2RlbC5wcm90b3R5cGUsIHRoaXMucGF0aCArICcucHJvdG90eXBlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm90b3R5cGU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdFVubGFiZWxlci5wcm90b3R5cGUuR2V0UHJvcGVydHlVbmxhYmVsZXIgPSBmdW5jdGlvbiAocHJvcGVydHluYW1lKSB7XG4gICAgICAgIGlmICghaGFzX293bl9wcm9wZXJ0eSh0aGlzLnByb3BlcnRpZXMsIHByb3BlcnR5bmFtZSkpIHtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eVVubGFiZWxNb2RlbCA9IHRoaXMudW5sYWJlbG1vZGVsLnByb3BlcnRpZXMgJiYgdGhpcy51bmxhYmVsbW9kZWwucHJvcGVydGllc1twcm9wZXJ0eW5hbWVdO1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzW3Byb3BlcnR5bmFtZV0gPSBuZXcgUHJvcGVydHlVbmxhYmVsZXIocHJvcGVydHlVbmxhYmVsTW9kZWwsIHRoaXMucGF0aCArICcuJyArIHByb3BlcnR5bmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcGVydGllc1twcm9wZXJ0eW5hbWVdO1xuICAgIH07XG4gICAgcmV0dXJuIE9iamVjdFVubGFiZWxlcjtcbn0oKSk7XG5leHBvcnRzLk9iamVjdFVubGFiZWxlciA9IE9iamVjdFVubGFiZWxlcjtcbi8vIC0tLSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIEZ1bmN0aW9uVW5sYWJlbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGdW5jdGlvblVubGFiZWxlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGdW5jdGlvblVubGFiZWxlcih1bmxhYmVsbW9kZWwsIHBhdGgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHVubGFiZWxtb2RlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBtb25pdG9yLndhcm4oJ3VuZGVmaW5lZCBleHBvcnQgZnVuY3Rpb24gdW5sYWJlbCBtb2RlbCBmb3InLCBwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBAdHMtaWdub3JlIGluaXRpYWxpemVkIGJ5IHN1cGVyIGNhbGxcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB1bmxhYmVsbW9kZWwsIHBhdGgpIHx8IHRoaXM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1bmN0aW9uVW5sYWJlbGVyLnByb3RvdHlwZSwgXCJBcmd1bWVudHNMYWJlbGVyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hcmdzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFyZ3MgPSBuZXcgQXJndW1lbnRzTGFiZWxlcih0aGlzLnVubGFiZWxtb2RlbC5hcmdzLCB0aGlzLnBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXJncztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1bmN0aW9uVW5sYWJlbGVyLnByb3RvdHlwZSwgXCJTZWxmTGFiZWxlclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZ1bGxfYWNjZXNzX3BhdGgpXG4gICAgICAgICAgICAgICAgICAgIG1vbml0b3IubG9nKHRoaXMucGF0aCArICdbQ2FsbF0nKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGYgPSBuZXcgVmFsdWVMYWJlbGVyKHRoaXMudW5sYWJlbG1vZGVsLnNlbGYsIHRoaXMucGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWxmO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnVuY3Rpb25VbmxhYmVsZXIucHJvdG90eXBlLCBcIlJldHVyblVubGFiZWxlclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucmV0ID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChmdWxsX2FjY2Vzc19wYXRoKVxuICAgICAgICAgICAgICAgICAgICBtb25pdG9yLmxvZyh0aGlzLnBhdGggKyAnW1JldHVyblZhbHVlXScpO1xuICAgICAgICAgICAgICAgIHRoaXMucmV0ID0gbmV3IFZhbHVlVW5sYWJlbGVyKHRoaXMudW5sYWJlbG1vZGVsLnJldCwgdGhpcy5wYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJldDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIEZ1bmN0aW9uVW5sYWJlbGVyO1xufShPYmplY3RVbmxhYmVsZXIpKTtcbmV4cG9ydHMuRnVuY3Rpb25VbmxhYmVsZXIgPSBGdW5jdGlvblVubGFiZWxlcjtcbi8vIC0tLVxuLy8gVE9ETzogVGhpcyBhcnJheSBsYWJlbCBtb2RlbCBkb2VzIG5vdCB0YWtlIGludG8gYWNjb3VudCB0aGF0IGFycmF5cyBhcmUgb2JqZWN0cy5cbi8vICAgIFNob3VsZCBpbmhlcml0IE9iamVjdFVubGFiZWxNb2RlbCBpbiB0aGUgc2FtZSB3aGF5IEZ1bmN0aW9uVW5sYWJlbE1vZGVsIGRvZXM/XG4vLyBUT0RPOiB1bmxhYmVsaW5nIG9mIHRoZSBzdHJ1Y3QgbGFiZWxcbi8vIC0tLVxudmFyIEFycmF5VW5sYWJlbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBcnJheVVubGFiZWxlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBcnJheVVubGFiZWxlcih1bmxhYmVsbW9kZWwsIHBhdGgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHVubGFiZWxtb2RlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBtb25pdG9yLndhcm4oJ3VuZGVmaW5lZCBhcnJheSB1bmxhYmVsIG1vZGVsIGZvcicsIHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEB0cy1pZ25vcmUgaW5pdGlhbGl6ZWQgYnkgc3VwZXIgY2FsbFxuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHVubGFiZWxtb2RlbCwgcGF0aCkgfHwgdGhpcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBcnJheVVubGFiZWxlci5wcm90b3R5cGUuR2V0UHJvcGVydHlVbmxhYmVsZXIgPSBmdW5jdGlvbiAocHJvcGVydHluYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50ID0gbmV3IFByb3BlcnR5VW5sYWJlbGVyKHRoaXMudW5sYWJlbG1vZGVsLmVsZW1lbnQsIHRoaXMucGF0aCArICcuJyArIHByb3BlcnR5bmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudDtcbiAgICB9O1xuICAgIHJldHVybiBBcnJheVVubGFiZWxlcjtcbn0oT2JqZWN0VW5sYWJlbGVyKSk7XG5leHBvcnRzLkFycmF5VW5sYWJlbGVyID0gQXJyYXlVbmxhYmVsZXI7XG4vLyAtLS0gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFRPRE86IE9iamVjdCB8IEZ1bmN0aW9uIHwgKFRPRE8pIEFycmF5IC4uLlxudmFyIFVua25vd25VbmxhYmVsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVW5rbm93blVubGFiZWxlcihwYXRoKSB7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHt9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVW5rbm93blVubGFiZWxlci5wcm90b3R5cGUsIFwiUHJvdG90eXBlVW5sYWJlbGVyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm90b3R5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvdG90eXBlID0gbmV3IFByb3BlcnR5VW5sYWJlbGVyKHVuZGVmaW5lZCwgdGhpcy5wYXRoICsgJy5wcm90b3R5cGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3RvdHlwZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgVW5rbm93blVubGFiZWxlci5wcm90b3R5cGUuR2V0UHJvcGVydHlVbmxhYmVsZXIgPSBmdW5jdGlvbiAocHJvcGVydHluYW1lKSB7XG4gICAgICAgIGlmICghaGFzX293bl9wcm9wZXJ0eSh0aGlzLnByb3BlcnRpZXMsIHByb3BlcnR5bmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllc1twcm9wZXJ0eW5hbWVdID0gbmV3IFByb3BlcnR5VW5sYWJlbGVyKHVuZGVmaW5lZCwgdGhpcy5wYXRoICsgJy4nICsgcHJvcGVydHluYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzW3Byb3BlcnR5bmFtZV07XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVW5rbm93blVubGFiZWxlci5wcm90b3R5cGUsIFwiQXJndW1lbnRzTGFiZWxlclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXJncyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZ1bGxfYWNjZXNzX3BhdGgpXG4gICAgICAgICAgICAgICAgICAgIG1vbml0b3IubG9nKHRoaXMucGF0aCArICdbYXJnc10nKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFyZ3MgPSBuZXcgQXJndW1lbnRzTGFiZWxlcih1bmRlZmluZWQsIHRoaXMucGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcmdzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVW5rbm93blVubGFiZWxlci5wcm90b3R5cGUsIFwiU2VsZkxhYmVsZXJcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlbGYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChmdWxsX2FjY2Vzc19wYXRoKVxuICAgICAgICAgICAgICAgICAgICBtb25pdG9yLmxvZyh0aGlzLnBhdGggKyAnW3NlbGZdJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxmID0gbmV3IFZhbHVlTGFiZWxlcih1bmRlZmluZWQsIHRoaXMucGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWxmO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVW5rbm93blVubGFiZWxlci5wcm90b3R5cGUsIFwiUmV0dXJuVW5sYWJlbGVyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChmdWxsX2FjY2Vzc19wYXRoKVxuICAgICAgICAgICAgICAgICAgICBtb25pdG9yLmxvZyh0aGlzLnBhdGggKyAnW3JldF0nKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJldCA9IG5ldyBWYWx1ZVVubGFiZWxlcih1bmRlZmluZWQsIHRoaXMucGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVbmtub3duVW5sYWJlbGVyLnByb3RvdHlwZSwgXCJVbmxhYmVsZXJcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gbmV3IFByaW1pdGl2ZVVubGFiZWxlcih1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVbmtub3duVW5sYWJlbGVyLnByb3RvdHlwZSwgXCJSZWFkVW5sYWJlbGVyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlYWQgPSBuZXcgRGVzY3JpcHRvclVubGFiZWxlcih1bmRlZmluZWQsIHRoaXMucGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVW5rbm93blVubGFiZWxlci5wcm90b3R5cGUsIFwiV3JpdGVMYWJlbGVyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy53cml0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZSA9IG5ldyBEZXNjcmlwdG9yTGFiZWxlcih1bmRlZmluZWQsIHRoaXMucGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53cml0ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIFVua25vd25VbmxhYmVsZXI7XG59KCkpO1xuZXhwb3J0cy5Vbmtub3duVW5sYWJlbGVyID0gVW5rbm93blVubGFiZWxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvbGljeS5qcy5tYXAiLCIvKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGxhYmVsXzEgPSByZXF1aXJlKFwiLi9sYWJlbFwiKTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gSW5Db250ZXh0KGwsIGYpIHtcbiAgICBtb25pdG9yLmNvbnRleHQucHVzaFBDKGwpO1xuICAgIHZhciByZXMgPSBmKCk7XG4gICAgbW9uaXRvci5jb250ZXh0LnBvcFBDKCk7XG4gICAgaWYgKHJlcyBpbnN0YW5jZW9mIFZhbHVlKSB7XG4gICAgICAgIHJlcy5yYWlzZShsKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVmFsdWUgLSBsYWJlbGVkIHZhbHVlc1xudmFyIFZhbHVlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZhbHVlKHZhbHVlLCBsYWJlbCkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgVmFsdWUucHJvdG90eXBlLnJhaXNlID0gZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgdGhpcy5sYWJlbCA9IGxhYmVsXzEubHViKHRoaXMubGFiZWwsIGwpO1xuICAgIH07XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgVmFsdWUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFZhbHVlKHRoaXMudmFsdWUsIHRoaXMubGFiZWwpO1xuICAgIH07XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgVmFsdWUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMudmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gXCInXCIgKyB0aGlzLnZhbHVlICsgXCInX1wiICsgdGhpcy5sYWJlbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlICsgXCJfXCIgKyB0aGlzLmxhYmVsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBFY21hXG4gICAgVmFsdWUucHJvdG90eXBlLkdldE93blByb3BlcnR5ID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgcmV0dXJuIEluQ29udGV4dCh0aGlzLmxhYmVsLCBmdW5jdGlvbiAoKSB7IHJldHVybiB2YWx1ZS5HZXRPd25Qcm9wZXJ0eShzKTsgfSk7XG4gICAgfTtcbiAgICBWYWx1ZS5wcm90b3R5cGUuR2V0UHJvcGVydHkgPSBmdW5jdGlvbiAocykge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICByZXR1cm4gSW5Db250ZXh0KHRoaXMubGFiZWwsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbHVlLkdldFByb3BlcnR5KHMpOyB9KTtcbiAgICB9O1xuICAgIFZhbHVlLnByb3RvdHlwZS5HZXQgPSBmdW5jdGlvbiAocykge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICByZXR1cm4gSW5Db250ZXh0KHRoaXMubGFiZWwsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbHVlLkdldChzKTsgfSk7XG4gICAgfTtcbiAgICBWYWx1ZS5wcm90b3R5cGUuQ2FuUHV0ID0gZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgcmV0dXJuIEluQ29udGV4dCh0aGlzLmxhYmVsLCBmdW5jdGlvbiAoKSB7IHJldHVybiB2YWx1ZS5DYW5QdXQocCk7IH0pO1xuICAgIH07XG4gICAgVmFsdWUucHJvdG90eXBlLlB1dCA9IGZ1bmN0aW9uIChzLCB2LCBUaHJvdykge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICByZXR1cm4gSW5Db250ZXh0KHRoaXMubGFiZWwsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbHVlLlB1dChzLCB2KTsgfSk7XG4gICAgfTtcbiAgICBWYWx1ZS5wcm90b3R5cGUuSGFzUHJvcGVydHkgPSBmdW5jdGlvbiAocykge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICByZXR1cm4gSW5Db250ZXh0KHRoaXMubGFiZWwsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbHVlLkhhc1Byb3BlcnR5KHMpOyB9KTtcbiAgICB9O1xuICAgIFZhbHVlLnByb3RvdHlwZS5EZWxldGUgPSBmdW5jdGlvbiAocywgVGhyb3cpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgcmV0dXJuIEluQ29udGV4dCh0aGlzLmxhYmVsLCBmdW5jdGlvbiAoKSB7IHJldHVybiB2YWx1ZS5EZWxldGUocywgVGhyb3cpOyB9KTtcbiAgICB9O1xuICAgIFZhbHVlLnByb3RvdHlwZS5EZWZhdWx0VmFsdWUgPSBmdW5jdGlvbiAoaGludCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICByZXR1cm4gSW5Db250ZXh0KHRoaXMubGFiZWwsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbHVlLkRlZmF1bHRWYWx1ZShoaW50KTsgfSk7XG4gICAgfTtcbiAgICBWYWx1ZS5wcm90b3R5cGUuRGVmaW5lT3duUHJvcGVydHkgPSBmdW5jdGlvbiAocywgZGVzYywgVGhyb3cpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgcmV0dXJuIEluQ29udGV4dCh0aGlzLmxhYmVsLCBmdW5jdGlvbiAoKSB7IHJldHVybiB2YWx1ZS5EZWZpbmVPd25Qcm9wZXJ0eShzLCBkZXNjLCBUaHJvdyk7IH0pO1xuICAgIH07XG4gICAgLy8gLS0tXG4gICAgLy8gRnVuY3Rpb25cbiAgICBWYWx1ZS5wcm90b3R5cGUuSGFzSW5zdGFuY2UgPSBmdW5jdGlvbiAoVikge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICByZXR1cm4gSW5Db250ZXh0KHRoaXMubGFiZWwsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbHVlLkhhc0luc3RhbmNlKFYpOyB9KTtcbiAgICB9O1xuICAgIFZhbHVlLnByb3RvdHlwZS5DYWxsID0gZnVuY3Rpb24gKHRoaXNBcmcsIGFyZ3MpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgcmV0dXJuIEluQ29udGV4dCh0aGlzLmxhYmVsLCBmdW5jdGlvbiAoKSB7IHJldHVybiB2YWx1ZS5DYWxsKHRoaXNBcmcsIGFyZ3MpOyB9KTtcbiAgICB9O1xuICAgIFZhbHVlLnByb3RvdHlwZS5Db25zdHJ1Y3QgPSBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICByZXR1cm4gSW5Db250ZXh0KHRoaXMubGFiZWwsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbHVlLkNvbnN0cnVjdChhcmdzKTsgfSk7XG4gICAgfTtcbiAgICAvLyAtLS1cbiAgICAvLyBPYmplY3RFbnZpcm9ubWVudFJlY29yZCwgRGVjbGFyYXRpdmVFbnZpcm9ubWVudFJlY29yZFxuICAgIFZhbHVlLnByb3RvdHlwZS5IYXNCaW5kaW5nID0gZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgcmV0dXJuIEluQ29udGV4dCh0aGlzLmxhYmVsLCBmdW5jdGlvbiAoKSB7IHJldHVybiB2YWx1ZS5IYXNCaW5kaW5nKHApOyB9KTtcbiAgICB9O1xuICAgIFZhbHVlLnByb3RvdHlwZS5DcmVhdGVNdXRhYmxlQmluZGluZyA9IGZ1bmN0aW9uIChwLCBkKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgIHJldHVybiBJbkNvbnRleHQodGhpcy5sYWJlbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsdWUuQ3JlYXRlTXV0YWJsZUJpbmRpbmcocCwgZCk7IH0pO1xuICAgIH07XG4gICAgVmFsdWUucHJvdG90eXBlLkdldEJpbmRpbmdWYWx1ZSA9IGZ1bmN0aW9uIChwLCBzKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgIHJldHVybiBJbkNvbnRleHQodGhpcy5sYWJlbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsdWUuR2V0QmluZGluZ1ZhbHVlKHAsIHMpOyB9KTtcbiAgICB9O1xuICAgIFZhbHVlLnByb3RvdHlwZS5TZXRNdXRhYmxlQmluZGluZyA9IGZ1bmN0aW9uIChwLCB2LCBzKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgIHJldHVybiBJbkNvbnRleHQodGhpcy5sYWJlbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsdWUuU2V0TXV0YWJsZUJpbmRpbmcocCwgdiwgcyk7IH0pO1xuICAgIH07XG4gICAgVmFsdWUucHJvdG90eXBlLkRlbGV0ZUJpbmRpbmcgPSBmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICByZXR1cm4gSW5Db250ZXh0KHRoaXMubGFiZWwsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbHVlLkRlbGV0ZUJpbmRpbmcocCk7IH0pO1xuICAgIH07XG4gICAgVmFsdWUucHJvdG90eXBlLkltcGxpY2l0VGhpc1ZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICByZXR1cm4gSW5Db250ZXh0KHRoaXMubGFiZWwsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbHVlLkltcGxpY2l0VGhpc1ZhbHVlKCk7IH0pO1xuICAgIH07XG4gICAgLy8gRGVjbGFyYXRpdmVFbnZpcm9ubWVudFJlY29yZFxuICAgIFZhbHVlLnByb3RvdHlwZS5DcmVhdGVJbW11dGFibGVCaW5kaW5nID0gZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgcmV0dXJuIEluQ29udGV4dCh0aGlzLmxhYmVsLCBmdW5jdGlvbiAoKSB7IHJldHVybiB2YWx1ZS5DcmVhdGVJbW11dGFibGVCaW5kaW5nKHApOyB9KTtcbiAgICB9O1xuICAgIFZhbHVlLnByb3RvdHlwZS5Jbml0aWFsaXplSW1tdXRhYmxlQmluZGluZyA9IGZ1bmN0aW9uIChwLCB2KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgIHJldHVybiBJbkNvbnRleHQodGhpcy5sYWJlbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsdWUuSW5pdGlhbGl6ZUltbXV0YWJsZUJpbmRpbmcocCwgdik7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFZhbHVlO1xufSgpKTtcbmV4cG9ydHMuVmFsdWUgPSBWYWx1ZTtcbmZ1bmN0aW9uIGlzRGVmaW5lZFByaW1pdGl2ZVZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZS52YWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8IHR5cGVvZiB2YWx1ZS52YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlLnZhbHVlID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNEZWZpbmVkUHJpbWl0aXZlVmFsdWUgPSBpc0RlZmluZWRQcmltaXRpdmVWYWx1ZTtcbnZhciBSZWZlcmVuY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVmZXJlbmNlKGJhc2UsIHByb3BlcnR5TmFtZSkge1xuICAgICAgICB0aGlzLmJhc2UgPSBiYXNlO1xuICAgICAgICB0aGlzLnByb3BlcnR5TmFtZSA9IHByb3BlcnR5TmFtZTtcbiAgICB9XG4gICAgUmVmZXJlbmNlLnByb3RvdHlwZS5HZXRCYXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYXNlO1xuICAgIH07XG4gICAgUmVmZXJlbmNlLnByb3RvdHlwZS5HZXRSZWZlcmVuY2VkTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcGVydHlOYW1lO1xuICAgIH07XG4gICAgUmVmZXJlbmNlLnByb3RvdHlwZS5IYXNQcmltaXRpdmVCYXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgeCA9IHR5cGVvZiB0aGlzLmJhc2UudmFsdWU7XG4gICAgICAgIHJldHVybiAoeCA9PT0gJ2Jvb2xlYW4nIHx8IHggPT09ICdzdHJpbmcnIHx8IHggPT09ICdudW1iZXInKTtcbiAgICB9O1xuICAgIFJlZmVyZW5jZS5wcm90b3R5cGUuSXNQcm9wZXJ0eVJlZmVyZW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmJhc2UudmFsdWUuQ2xhc3MgIT09IHVuZGVmaW5lZCB8fCB0aGlzLkhhc1ByaW1pdGl2ZUJhc2UoKSk7XG4gICAgfTtcbiAgICBSZWZlcmVuY2UucHJvdG90eXBlLklzVW5yZXNvbHZhYmxlUmVmZXJlbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuYmFzZS52YWx1ZSA9PT0gdW5kZWZpbmVkKTtcbiAgICB9O1xuICAgIFJlZmVyZW5jZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoJ0AoJyArIHRoaXMuYmFzZSArICcsJyArIHRoaXMucHJvcGVydHlOYW1lICsgJyknKTtcbiAgICB9O1xuICAgIHJldHVybiBSZWZlcmVuY2U7XG59KCkpO1xuZXhwb3J0cy5SZWZlcmVuY2UgPSBSZWZlcmVuY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12YWx1ZXMuanMubWFwIiwiLy8gLmRpcm5hbWUsIC5iYXNlbmFtZSwgYW5kIC5leHRuYW1lIG1ldGhvZHMgYXJlIGV4dHJhY3RlZCBmcm9tIE5vZGUuanMgdjguMTEuMSxcbi8vIGJhY2twb3J0ZWQgYW5kIHRyYW5zcGxpdGVkIHdpdGggQmFiZWwsIHdpdGggYmFja3dhcmRzLWNvbXBhdCBmaXhlc1xuXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gcmVzb2x2ZXMgLiBhbmQgLi4gZWxlbWVudHMgaW4gYSBwYXRoIGFycmF5IHdpdGggZGlyZWN0b3J5IG5hbWVzIHRoZXJlXG4vLyBtdXN0IGJlIG5vIHNsYXNoZXMsIGVtcHR5IGVsZW1lbnRzLCBvciBkZXZpY2UgbmFtZXMgKGM6XFwpIGluIHRoZSBhcnJheVxuLy8gKHNvIGFsc28gbm8gbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcyAtIGl0IGRvZXMgbm90IGRpc3Rpbmd1aXNoXG4vLyByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgcGF0aHMpXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheShwYXJ0cywgYWxsb3dBYm92ZVJvb3QpIHtcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGxhc3QgPSBwYXJ0c1tpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoYWxsb3dBYm92ZVJvb3QpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHBhcnRzLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG4vLyBwYXRoLnJlc29sdmUoW2Zyb20gLi4uXSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlc29sdmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc29sdmVkUGF0aCA9ICcnLFxuICAgICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAtMSAmJiAhcmVzb2x2ZWRBYnNvbHV0ZTsgaS0tKSB7XG4gICAgdmFyIHBhdGggPSAoaSA+PSAwKSA/IGFyZ3VtZW50c1tpXSA6IHByb2Nlc3MuY3dkKCk7XG5cbiAgICAvLyBTa2lwIGVtcHR5IGFuZCBpbnZhbGlkIGVudHJpZXNcbiAgICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5yZXNvbHZlIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH0gZWxzZSBpZiAoIXBhdGgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJlc29sdmVkUGF0aCA9IHBhdGggKyAnLycgKyByZXNvbHZlZFBhdGg7XG4gICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IHBhdGguY2hhckF0KDApID09PSAnLyc7XG4gIH1cblxuICAvLyBBdCB0aGlzIHBvaW50IHRoZSBwYXRoIHNob3VsZCBiZSByZXNvbHZlZCB0byBhIGZ1bGwgYWJzb2x1dGUgcGF0aCwgYnV0XG4gIC8vIGhhbmRsZSByZWxhdGl2ZSBwYXRocyB0byBiZSBzYWZlIChtaWdodCBoYXBwZW4gd2hlbiBwcm9jZXNzLmN3ZCgpIGZhaWxzKVxuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICByZXNvbHZlZFBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocmVzb2x2ZWRQYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIXJlc29sdmVkQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICByZXR1cm4gKChyZXNvbHZlZEFic29sdXRlID8gJy8nIDogJycpICsgcmVzb2x2ZWRQYXRoKSB8fCAnLic7XG59O1xuXG4vLyBwYXRoLm5vcm1hbGl6ZShwYXRoKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5ub3JtYWxpemUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciBpc0Fic29sdXRlID0gZXhwb3J0cy5pc0Fic29sdXRlKHBhdGgpLFxuICAgICAgdHJhaWxpbmdTbGFzaCA9IHN1YnN0cihwYXRoLCAtMSkgPT09ICcvJztcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihwYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIWlzQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICBpZiAoIXBhdGggJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBwYXRoID0gJy4nO1xuICB9XG4gIGlmIChwYXRoICYmIHRyYWlsaW5nU2xhc2gpIHtcbiAgICBwYXRoICs9ICcvJztcbiAgfVxuXG4gIHJldHVybiAoaXNBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHBhdGg7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmlzQWJzb2x1dGUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5qb2luID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYXRocyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gIHJldHVybiBleHBvcnRzLm5vcm1hbGl6ZShmaWx0ZXIocGF0aHMsIGZ1bmN0aW9uKHAsIGluZGV4KSB7XG4gICAgaWYgKHR5cGVvZiBwICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGguam9pbiBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH0pLmpvaW4oJy8nKSk7XG59O1xuXG5cbi8vIHBhdGgucmVsYXRpdmUoZnJvbSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlbGF0aXZlID0gZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgZnJvbSA9IGV4cG9ydHMucmVzb2x2ZShmcm9tKS5zdWJzdHIoMSk7XG4gIHRvID0gZXhwb3J0cy5yZXNvbHZlKHRvKS5zdWJzdHIoMSk7XG5cbiAgZnVuY3Rpb24gdHJpbShhcnIpIHtcbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIGZvciAoOyBzdGFydCA8IGFyci5sZW5ndGg7IHN0YXJ0KyspIHtcbiAgICAgIGlmIChhcnJbc3RhcnRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIGVuZCA9IGFyci5sZW5ndGggLSAxO1xuICAgIGZvciAoOyBlbmQgPj0gMDsgZW5kLS0pIHtcbiAgICAgIGlmIChhcnJbZW5kXSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA+IGVuZCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiBhcnIuc2xpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0ICsgMSk7XG4gIH1cblxuICB2YXIgZnJvbVBhcnRzID0gdHJpbShmcm9tLnNwbGl0KCcvJykpO1xuICB2YXIgdG9QYXJ0cyA9IHRyaW0odG8uc3BsaXQoJy8nKSk7XG5cbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGZyb21QYXJ0cy5sZW5ndGgsIHRvUGFydHMubGVuZ3RoKTtcbiAgdmFyIHNhbWVQYXJ0c0xlbmd0aCA9IGxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChmcm9tUGFydHNbaV0gIT09IHRvUGFydHNbaV0pIHtcbiAgICAgIHNhbWVQYXJ0c0xlbmd0aCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgb3V0cHV0UGFydHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IHNhbWVQYXJ0c0xlbmd0aDsgaSA8IGZyb21QYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIG91dHB1dFBhcnRzLnB1c2goJy4uJyk7XG4gIH1cblxuICBvdXRwdXRQYXJ0cyA9IG91dHB1dFBhcnRzLmNvbmNhdCh0b1BhcnRzLnNsaWNlKHNhbWVQYXJ0c0xlbmd0aCkpO1xuXG4gIHJldHVybiBvdXRwdXRQYXJ0cy5qb2luKCcvJyk7XG59O1xuXG5leHBvcnRzLnNlcCA9ICcvJztcbmV4cG9ydHMuZGVsaW1pdGVyID0gJzonO1xuXG5leHBvcnRzLmRpcm5hbWUgPSBmdW5jdGlvbiAocGF0aCkge1xuICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSBwYXRoID0gcGF0aCArICcnO1xuICBpZiAocGF0aC5sZW5ndGggPT09IDApIHJldHVybiAnLic7XG4gIHZhciBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KDApO1xuICB2YXIgaGFzUm9vdCA9IGNvZGUgPT09IDQ3IC8qLyovO1xuICB2YXIgZW5kID0gLTE7XG4gIHZhciBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICBmb3IgKHZhciBpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDE7IC0taSkge1xuICAgIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGUgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgZW5kID0gaTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yXG4gICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoZW5kID09PSAtMSkgcmV0dXJuIGhhc1Jvb3QgPyAnLycgOiAnLic7XG4gIGlmIChoYXNSb290ICYmIGVuZCA9PT0gMSkge1xuICAgIC8vIHJldHVybiAnLy8nO1xuICAgIC8vIEJhY2t3YXJkcy1jb21wYXQgZml4OlxuICAgIHJldHVybiAnLyc7XG4gIH1cbiAgcmV0dXJuIHBhdGguc2xpY2UoMCwgZW5kKTtcbn07XG5cbmZ1bmN0aW9uIGJhc2VuYW1lKHBhdGgpIHtcbiAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykgcGF0aCA9IHBhdGggKyAnJztcblxuICB2YXIgc3RhcnQgPSAwO1xuICB2YXIgZW5kID0gLTE7XG4gIHZhciBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICB2YXIgaTtcblxuICBmb3IgKGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgaWYgKHBhdGguY2hhckNvZGVBdChpKSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcbiAgICAgICAgLy8gc2VwYXJhdG9ycyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHN0b3Agbm93XG4gICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyXG4gICAgICAvLyBwYXRoIGNvbXBvbmVudFxuICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICBlbmQgPSBpICsgMTtcbiAgICB9XG4gIH1cblxuICBpZiAoZW5kID09PSAtMSkgcmV0dXJuICcnO1xuICByZXR1cm4gcGF0aC5zbGljZShzdGFydCwgZW5kKTtcbn1cblxuLy8gVXNlcyBhIG1peGVkIGFwcHJvYWNoIGZvciBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSwgYXMgZXh0IGJlaGF2aW9yIGNoYW5nZWRcbi8vIGluIG5ldyBOb2RlLmpzIHZlcnNpb25zLCBzbyBvbmx5IGJhc2VuYW1lKCkgYWJvdmUgaXMgYmFja3BvcnRlZCBoZXJlXG5leHBvcnRzLmJhc2VuYW1lID0gZnVuY3Rpb24gKHBhdGgsIGV4dCkge1xuICB2YXIgZiA9IGJhc2VuYW1lKHBhdGgpO1xuICBpZiAoZXh0ICYmIGYuc3Vic3RyKC0xICogZXh0Lmxlbmd0aCkgPT09IGV4dCkge1xuICAgIGYgPSBmLnN1YnN0cigwLCBmLmxlbmd0aCAtIGV4dC5sZW5ndGgpO1xuICB9XG4gIHJldHVybiBmO1xufTtcblxuZXhwb3J0cy5leHRuYW1lID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykgcGF0aCA9IHBhdGggKyAnJztcbiAgdmFyIHN0YXJ0RG90ID0gLTE7XG4gIHZhciBzdGFydFBhcnQgPSAwO1xuICB2YXIgZW5kID0gLTE7XG4gIHZhciBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICAvLyBUcmFjayB0aGUgc3RhdGUgb2YgY2hhcmFjdGVycyAoaWYgYW55KSB3ZSBzZWUgYmVmb3JlIG91ciBmaXJzdCBkb3QgYW5kXG4gIC8vIGFmdGVyIGFueSBwYXRoIHNlcGFyYXRvciB3ZSBmaW5kXG4gIHZhciBwcmVEb3RTdGF0ZSA9IDA7XG4gIGZvciAodmFyIGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgdmFyIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGUgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoXG4gICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgIHN0YXJ0UGFydCA9IGkgKyAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyXG4gICAgICAvLyBleHRlbnNpb25cbiAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgZW5kID0gaSArIDE7XG4gICAgfVxuICAgIGlmIChjb2RlID09PSA0NiAvKi4qLykge1xuICAgICAgICAvLyBJZiB0aGlzIGlzIG91ciBmaXJzdCBkb3QsIG1hcmsgaXQgYXMgdGhlIHN0YXJ0IG9mIG91ciBleHRlbnNpb25cbiAgICAgICAgaWYgKHN0YXJ0RG90ID09PSAtMSlcbiAgICAgICAgICBzdGFydERvdCA9IGk7XG4gICAgICAgIGVsc2UgaWYgKHByZURvdFN0YXRlICE9PSAxKVxuICAgICAgICAgIHByZURvdFN0YXRlID0gMTtcbiAgICB9IGVsc2UgaWYgKHN0YXJ0RG90ICE9PSAtMSkge1xuICAgICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBhbmQgbm9uLXBhdGggc2VwYXJhdG9yIGJlZm9yZSBvdXIgZG90LCBzbyB3ZSBzaG91bGRcbiAgICAgIC8vIGhhdmUgYSBnb29kIGNoYW5jZSBhdCBoYXZpbmcgYSBub24tZW1wdHkgZXh0ZW5zaW9uXG4gICAgICBwcmVEb3RTdGF0ZSA9IC0xO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdGFydERvdCA9PT0gLTEgfHwgZW5kID09PSAtMSB8fFxuICAgICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBjaGFyYWN0ZXIgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBkb3RcbiAgICAgIHByZURvdFN0YXRlID09PSAwIHx8XG4gICAgICAvLyBUaGUgKHJpZ2h0LW1vc3QpIHRyaW1tZWQgcGF0aCBjb21wb25lbnQgaXMgZXhhY3RseSAnLi4nXG4gICAgICBwcmVEb3RTdGF0ZSA9PT0gMSAmJiBzdGFydERvdCA9PT0gZW5kIC0gMSAmJiBzdGFydERvdCA9PT0gc3RhcnRQYXJ0ICsgMSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICByZXR1cm4gcGF0aC5zbGljZShzdGFydERvdCwgZW5kKTtcbn07XG5cbmZ1bmN0aW9uIGZpbHRlciAoeHMsIGYpIHtcbiAgICBpZiAoeHMuZmlsdGVyKSByZXR1cm4geHMuZmlsdGVyKGYpO1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmKHhzW2ldLCBpLCB4cykpIHJlcy5wdXNoKHhzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy8gU3RyaW5nLnByb3RvdHlwZS5zdWJzdHIgLSBuZWdhdGl2ZSBpbmRleCBkb24ndCB3b3JrIGluIElFOFxudmFyIHN1YnN0ciA9ICdhYicuc3Vic3RyKC0xKSA9PT0gJ2InXG4gICAgPyBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7IHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pIH1cbiAgICA6IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHtcbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSBzdHIubGVuZ3RoICsgc3RhcnQ7XG4gICAgICAgIHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pO1xuICAgIH1cbjtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iXX0=
